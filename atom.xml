<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ricardo-谁谓河广</title>
  
  <subtitle>谁谓河广</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://ShenZhen2017.github.io/"/>
  <updated>2021-01-02T14:35:57.663Z</updated>
  <id>http://ShenZhen2017.github.io/</id>
  
  <author>
    <name>Ricardo.M.Jiang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ARTS打卡11</title>
    <link href="http://ShenZhen2017.github.io/blog/2020/12/arts-way-eleven.html"/>
    <id>http://ShenZhen2017.github.io/blog/2020/12/arts-way-eleven.html</id>
    <published>2020-12-29T00:52:04.000Z</published>
    <updated>2021-01-02T14:35:57.663Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p><a href="https://medium.com/better-programming/a-new-way-to-pass-data-between-fragments-a5d32acc34e7" target="_blank" rel="noopener">A New Way to Pass Data Between Fragments</a><br>在Fragment中间传递数据的一种新方法<br>主要通过setFragmentResultListener实现<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewCreated</span><span class="params">(view: <span class="type">View</span>, savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onViewCreated(view, savedInstanceState)</span><br><span class="line">    <span class="comment">// Use the Kotlin extension in the fragment-ktx artifact</span></span><br><span class="line">    setFragmentResultListener(<span class="string">"requestKey"</span>) &#123; key, bundle -&gt;</span><br><span class="line">        <span class="keyword">val</span> result = bundle.getString(<span class="string">"name"</span>)</span><br><span class="line">        <span class="comment">// Do something with the result...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><h3 id="写作技巧总结"><a href="#写作技巧总结" class="headerlink" title="写作技巧总结"></a>写作技巧总结</h3><p>1、写文档是第一步，因为你告诉别人怎么去理解你写的东西，所以如果你想开始写作，最简单就是从写文档开始，把你的东西介绍明白了，就是一个好的开始。</p><p>2、写源码分析是第二步，那就是学习和分享如何去理解别人的东西，这个过程可以让自己在学习的过程中有所总结，并且介绍别人的内容就是一种抽象能力的进步。</p><p>3、写问题解决和应用思想是第三步，告诉别人如何去理解别人的思想，这就需要作者对要介绍的内容有自己的理解，才能够把内容变成更好理解的接地气的文字内容。</p><p>其实介绍了这么多写作内容，就是想告诉大家:“大前端是一种思想，就是让你已有的能力可以运用更广泛，而写作是帮助你把能力抽象化的一个过程。”</p><h3 id="lineSpaceExtra在部分低版本机型最后一行会有空行的解决办法"><a href="#lineSpaceExtra在部分低版本机型最后一行会有空行的解决办法" class="headerlink" title="lineSpaceExtra在部分低版本机型最后一行会有空行的解决办法"></a>lineSpaceExtra在部分低版本机型最后一行会有空行的解决办法</h3><p>因为lineHeight在许多机型上有适配问题，因此我们常常用lineSpaceExtra替代<br>但是lineSpaceExtra在部分低版本手机上也会有问题<br>详情可见：<a href="https://blog.csdn.net/etwge/article/details/72818859" target="_blank" rel="noopener">https://blog.csdn.net/etwge/article/details/72818859</a></p><h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Algorithm&quot;&gt;&lt;a href=&quot;#Algorithm&quot; class=&quot;headerlink&quot; title=&quot;Algorithm&quot;&gt;&lt;/a&gt;Algorithm&lt;/h2&gt;&lt;h2 id=&quot;Review&quot;&gt;&lt;a href=&quot;#Review&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="ARTS" scheme="http://ShenZhen2017.github.io/tags/ARTS/"/>
    
  </entry>
  
  <entry>
    <title>手写协程之手写Lua协程</title>
    <link href="http://ShenZhen2017.github.io/blog/2020/12/hand-lua-curountine.html"/>
    <id>http://ShenZhen2017.github.io/blog/2020/12/hand-lua-curountine.html</id>
    <published>2020-12-27T14:34:36.000Z</published>
    <updated>2020-12-27T14:35:36.106Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="android" scheme="http://ShenZhen2017.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>ARTS打卡10</title>
    <link href="http://ShenZhen2017.github.io/blog/2020/12/arts-way-ten.html"/>
    <id>http://ShenZhen2017.github.io/blog/2020/12/arts-way-ten.html</id>
    <published>2020-12-26T13:02:19.000Z</published>
    <updated>2020-12-27T12:42:54.879Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><blockquote><p><a href="https://leetcode-cn.com/contest/weekly-contest-221/problems/determine-if-string-halves-are-alike/" target="_blank" rel="noopener">5637. 判断字符串的两半是否相似</a><br>给你一个偶数长度的字符串 s 。将其拆分成长度相同的两半，前一半为 a ，后一半为 b 。<br>两个字符串 相似 的前提是它们都含有相同数目的元音（’a’，’e’，’i’，’o’，’u’，’A’，’E’，’I’，’O’，’U’）。注意，s 可能同时含有大写和小写字母。<br>如果 a 和 b 相似，返回 true ；否则，返回 false 。</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">halvesAreAlike</span><span class="params">(s: <span class="type">String</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> yuanYinCount(s.substring(<span class="number">0</span>,s.length/<span class="number">2</span>)) == yuanYinCount(s.substring(s.length/<span class="number">2</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">yuanYinCount</span><span class="params">(s:<span class="type">String</span>)</span></span>:<span class="built_in">Int</span>&#123;</span><br><span class="line">        <span class="keyword">val</span> list = mutableListOf&lt;<span class="built_in">Char</span>&gt;(<span class="string">'a'</span>,<span class="string">'e'</span>,<span class="string">'i'</span>,<span class="string">'o'</span>,<span class="string">'u'</span>,<span class="string">'A'</span>,<span class="string">'E'</span>,<span class="string">'I'</span>,<span class="string">'O'</span>,<span class="string">'U'</span>)</span><br><span class="line">        <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">        s.forEach &#123;</span><br><span class="line">            <span class="keyword">if</span> (list.contains(it))&#123;</span><br><span class="line">                count++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p><a href="https://medium.com/@gilgoldzweig/how-to-perfect-android-animations-using-motionlayout-286cfa0f4f13" target="_blank" rel="noopener">https://medium.com/@gilgoldzweig/how-to-perfect-android-animations-using-motionlayout-286cfa0f4f13</a><br>本文主要是讲解了一些MotionLayout的例子与实例</p><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><h3 id="Lottie预览"><a href="#Lottie预览" class="headerlink" title="Lottie预览"></a>Lottie预览</h3><p>lottie图是Airbnb开源的一种动画，不能直观的察看效果，如果出现问题，很难判定到底是资源问题，还是代码问题，因此需要有一个简单的方法来预览lottie图效果<br>我们可以在本机上，使用 Python 搭建一个最简单的 HTTP 服务器。在本地动画 ZIP 包文件的文件夹下，执行下面的命令。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m SimpleHttpServer <span class="number">8099</span></span><br></pre></td></tr></table></figure></p><p>该命令会在本机上搭建一个 HTTP 服务器，监听 8099 端口<br>然后再用lottie官方app打开相应地址即可预览.</p><p>详情可见：<a href="https://toutiao.io/posts/ml787h/preview" target="_blank" rel="noopener">https://toutiao.io/posts/ml787h/preview</a></p><h3 id="9图四条黑边的意义"><a href="#9图四条黑边的意义" class="headerlink" title=".9图四条黑边的意义"></a>.9图四条黑边的意义</h3><p>顶部：在水平拉伸的时候，保持其他位置不动，只在这个点的区域做无限的延伸</p><p>左边：在竖直拉伸的时候，保持其他位置不动，只在这个点的区域做无限的延伸</p><p>底部：在水平拉伸的时候，指定图片里的内容显示的区域</p><p>右边：在竖直拉伸的时候，指定图片里的内容显示的区域</p><p>详情可见:<a href="https://blog.csdn.net/sunbinkang/article/details/77331718" target="_blank" rel="noopener">https://blog.csdn.net/sunbinkang/article/details/77331718</a></p><h3 id="kotlin-fold与reduce使用"><a href="#kotlin-fold与reduce使用" class="headerlink" title="kotlin fold与reduce使用"></a>kotlin fold与reduce使用</h3><h4 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> index: Array&lt;<span class="built_in">Int</span>&gt; = arrayOf(<span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">10</span>, <span class="number">3</span>, <span class="number">11</span>, <span class="number">5</span>, <span class="number">12</span>)</span><br><span class="line">  <span class="keyword">val</span> index2: Array&lt;<span class="built_in">Int</span>&gt; = arrayOf(<span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * reduce函数：累加函数，第一个参数是用来叠加的返回值，第二个参数是本次循环中列表的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">        println(<span class="string">"使用 reduce  求总和"</span>) <span class="comment">//使用 reduce  求总和</span></span><br><span class="line">        println(index.reduce &#123; acc, i -&gt; acc + i &#125;)</span><br><span class="line">        println(<span class="string">"使用 reduce  求积"</span>) <span class="comment">//使用 reduce  求积</span></span><br><span class="line">        println(index2.reduce &#123; acc, i -&gt; acc * i &#125;)  <span class="comment">//acc是累加的返回值，i是当前遍历列表中的值</span></span><br><span class="line"> </span><br><span class="line">    使用 reduce  求总和</span><br><span class="line">    System.<span class="keyword">out</span>: <span class="number">86</span></span><br><span class="line">    使用 reduce  求积</span><br><span class="line">    <span class="number">60</span></span><br></pre></td></tr></table></figure><h4 id="fold"><a href="#fold" class="headerlink" title="fold"></a>fold</h4><p>In kotlin, “fold” is same in Javascript’s reduce. “fold” has initial value</p><p>“reduce” in kotlin, you don’t give initial value<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> colors = listOf(<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>, <span class="string">"black"</span>)</span><br><span class="line"></span><br><span class="line">    println(colors.reduce &#123;</span><br><span class="line">        acc, curr -&gt; <span class="string">"<span class="variable">$acc</span>, <span class="variable">$curr</span>"</span></span><br><span class="line">    &#125;) <span class="comment">// red, blue, green, black</span></span><br><span class="line"></span><br><span class="line">    println(colors.map &#123;it.length&#125;.fold(<span class="number">0</span>) &#123;</span><br><span class="line">            acc, curr -&gt; acc + curr</span><br><span class="line">    &#125;) <span class="comment">// 17</span></span><br></pre></td></tr></table></figure></p><h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p>本周略</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Algorithm&quot;&gt;&lt;a href=&quot;#Algorithm&quot; class=&quot;headerlink&quot; title=&quot;Algorithm&quot;&gt;&lt;/a&gt;Algorithm&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.
      
    
    </summary>
    
    
      <category term="ARTS" scheme="http://ShenZhen2017.github.io/tags/ARTS/"/>
    
  </entry>
  
  <entry>
    <title>利用MotionLayout实现RecyclerView折叠展开动画</title>
    <link href="http://ShenZhen2017.github.io/blog/2020/12/motionlayout-recyclerview-animation.html"/>
    <id>http://ShenZhen2017.github.io/blog/2020/12/motionlayout-recyclerview-animation.html</id>
    <published>2020-12-20T03:53:32.000Z</published>
    <updated>2020-12-20T13:11:31.973Z</updated>
    
    <content type="html"><![CDATA[<p>RecyclerView的展开与折叠是一种常见的动画<br>主要有两种方式可以实现<br><strong>1.通过添加与移除元素</strong><br>notifyInsert,notifyRemoved，这种方式涉及到元素的加减，动画效果不太流畅<br><strong>2.通过给RecyclerView的item添加动画</strong><br>这种情况需要考虑一个item添加动画时，对其他的item的影响。而利用MotionLayout可以方便的实现这一点。    </p><p><strong>先来看看效果</strong><br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog9/p1.gif" alt><br>1.支持流畅的展开折叠<br>2.支持多类型item<br>3.支持只能同时展开一个    </p><p>下面来看下具体实现  </p><h2 id="1-引入MotionLayout库"><a href="#1-引入MotionLayout库" class="headerlink" title="1.引入MotionLayout库"></a>1.引入MotionLayout库</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">dependencies</span> &#123; <span class="attribute">implementation</span> <span class="string">'com.android.support.constraint:constraint-layout:2.0.0-beta2'</span> &#125;</span><br></pre></td></tr></table></figure><h2 id="2-在布局文件中使用"><a href="#2-在布局文件中使用" class="headerlink" title="2.在布局文件中使用"></a>2.在布局文件中使用</h2><p>MotionLayout 想要使用 MotionLayout，只需要在布局文件中作如下声明即可：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;androidx<span class="selector-class">.constraintlayout</span><span class="selector-class">.motion</span><span class="selector-class">.widget</span><span class="selector-class">.MotionLayout</span> xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    xmlns:app=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span><br><span class="line">    xmlns:tools=<span class="string">"http://schemas.android.com/tools"</span></span><br><span class="line">    android:id=<span class="string">"@+id/motionContainer"</span></span><br><span class="line">    android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">    android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">    android:<span class="attribute">background</span>=<span class="string">"@color/white"</span></span><br><span class="line">    app:layoutDescription=<span class="string">"@xml/motion_list_rv_item_scene"</span>&gt;</span><br><span class="line">.....</span><br><span class="line">&lt;/android<span class="selector-class">.support</span><span class="selector-class">.constraint</span><span class="selector-class">.motion</span>.MotionLayout&gt;</span><br></pre></td></tr></table></figure></p><p>由于 MotionLayout 作为 ConstraintLayout 的子类，那么就自然而然地可以像 ConstraintLayout 那样使用去“约束”子视图了，不过这可就有点“大材小用了”，MotionLayout 的用处可远不止这些。我们先来看看 MotionLayout 的构成：<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog9/p1.webp" alt></p><p>由上图可知，MotionLayout 可分为 <view> 和 <helper> 两个部分。<view> 部分可简单理解为一个 ConstraintLayout，至于 <helper> 其实就是我们的“动画层”了。MotionLayout 为我们提供了 layoutDescription 属性，我们需要为它传入一个 MotionScene 包裹的 XML 文件，想要实现动画交互，就必须通过这个“媒介”来连接。</helper></view></helper></view></p><h2 id="MotionScene"><a href="#MotionScene" class="headerlink" title="MotionScene"></a>MotionScene</h2><p>什么是 MotionScene？结合上图 MotionScene 主要由三部分组成：StateSet、ConstraintSet 和 Transition<br>实现RecyclerView展开折叠效果，主要用到了 ConstarintSet 和 Transition     </p><h3 id="首先来看看布局文件"><a href="#首先来看看布局文件" class="headerlink" title="首先来看看布局文件"></a>首先来看看布局文件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.motion.widget.MotionLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/motionContainer"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:background</span>=<span class="string">"@color/white"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layoutDescription</span>=<span class="string">"@xml/motion_list_rv_item_scene"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/box_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:orientation</span>=<span class="string">"vertical"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"86dp"</span>&gt;</span></span><br><span class="line">            ....</span><br><span class="line">            <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">View</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"100dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:background</span>=<span class="string">"@color/blue_magic"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">View</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/view2"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"1dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_below</span>=<span class="string">"@id/box_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">"#eaeaef"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.motion.widget.MotionLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>布局文件很简单，只不过你可能会注意到，我们对 LinearLayout并没有添加任何约束，原因在于：我们会在 MotionScene 中声明 ConstraintSet，里面将包含该 LinearLayout 的“运动”起始点和终点的约束信息。</p><p>当然你也可以在布局文件中对其加以约束，但 MotionScene 中对于控件约束的优先级会高于布局文件中的设定。这里我们通过 layoutDescription 来为 MotionLayout 设置它的 MotionScene 为 motion_list_rv_item_scene，接下来就让我们一睹 MotionScene 的芳容：</p><h3 id="动画文件"><a href="#动画文件" class="headerlink" title="动画文件"></a>动画文件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">MotionScene</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ConstraintSet</span> <span class="attr">android:id</span>=<span class="string">"@+id/start"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Constraint</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@id/box_content"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"0dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"86dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">"parent"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ConstraintSet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ConstraintSet</span> <span class="attr">android:id</span>=<span class="string">"@+id/end"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Constraint</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@id/box_content"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"0dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"186dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">"parent"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ConstraintSet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Transition</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:constraintSetEnd</span>=<span class="string">"@id/end"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:constraintSetStart</span>=<span class="string">"@+id/start"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:duration</span>=<span class="string">"500"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:motionInterpolator</span>=<span class="string">"easeInOut"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Transition</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">MotionScene</span>&gt;</span></span><br></pre></td></tr></table></figure><p>首先，可以发现我们定义了两个 <constraintset>   分别描述了RecyclerView中的item的动画起始位置以及结束位置的约束信息（仅包含少量必要信息，如：width、height、margin以及位置属性等）。<br>显而易见，itemView起始高度为86dp，结束高度186dp.    </constraintset></p><p><strong>那么问题来了，如何让它动起来呢？</strong><br>这就要依靠我们的 <transition> 元素了。     </transition></p><p>事实上，我们都知道，动画都是有开始位置和结束位置的，而 MotionLayout 正是利用这一客观事实，将首尾位置和动画过程分离，两个点位置和距离虽然是固定的，但是它们之间的 Path 是无限的，可以是“一马平川”，也可以是”蜿蜒曲折”的。</p><p>我们只需要为 Transition 设置起始位置和结束位置的 ConstraintSet 并设置动画时间即可，剩下的都交给 MotionLayout 自动去帮我们完成。</p><p>当然你也可以通过 onClick 点击事件来触发动画，绑定目标控件的 id 以及通过 clickAction 属性来设置点击事件的类型。</p><h3 id="OnClick有多种类型"><a href="#OnClick有多种类型" class="headerlink" title="OnClick有多种类型"></a>OnClick有多种类型</h3><ul><li>1.toggle，如果布局当前处于开始状态，请将动画效果切换为结束状态；否则，请将动画效果切换为开始状态。</li><li>2.transitionToStart,为从当前布局到 <transition> 元素的 motion::constraintSetStart 属性指定的布局添加动画效果。</transition></li><li>3.transitionToEnd,为从当前布局到 <transition> 元素的 motion:constraintSetEnd 属性指定的布局添加动画效果。</transition></li></ul><h2 id="只能同时展开一个item实现"><a href="#只能同时展开一个item实现" class="headerlink" title="只能同时展开一个item实现"></a>只能同时展开一个item实现</h2><p>因为我们需要在展开一个item时，折叠其他item,因此不在xml中指定点击事件，去adapter中指定<br>实现展开一个时折叠其他item 我们可以通过MotionLayout的progress判断当前是在start状态还是end状态。   </p><p>下面的代码主要有几点需要注意的<br>1.如果是start状态则展开，否则则折叠<br>2.利用payload局部刷新达到折叠其他itemView的效果。<br>3.在RecyclerView滚动时会复用，所以需要在onBindViewHolder时初始化item的状态，即progress，不然会发生错位现象</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBindViewHolder</span><span class="params">(holder: <span class="type">RecyclerView</span>.<span class="type">ViewHolder</span>, position: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (holder <span class="keyword">is</span> MotionViewHolder) &#123;</span><br><span class="line">            <span class="keyword">val</span> motionBox = holder.itemView.findViewById&lt;MotionLayout&gt;(R.id.motionContainer)</span><br><span class="line">            <span class="keyword">if</span> (expandList[position])&#123;</span><br><span class="line">                motionBox.progress = <span class="number">1.0f</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                motionBox.progress = <span class="number">0f</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            holder.itemView.setOnClickListener &#123;</span><br><span class="line">                expandList.fill(<span class="literal">false</span>)</span><br><span class="line">                <span class="keyword">if</span> (motionBox.progress == <span class="number">1.0f</span>) &#123;</span><br><span class="line">                    motionBox.transitionToStart()</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (motionBox.progress == <span class="number">0.0f</span>) &#123;</span><br><span class="line">                    motionBox.transitionToEnd()</span><br><span class="line">                    expandList[position] = <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until itemCount) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i != position) &#123;</span><br><span class="line">                        notifyItemChanged(i, <span class="string">"collapse"</span>)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBindViewHolder</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        holder: <span class="type">RecyclerView</span>.<span class="type">ViewHolder</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        position: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        payloads: <span class="type">MutableList</span>&lt;<span class="type">Any</span>&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (payloads.isNullOrEmpty()) &#123;</span><br><span class="line">            <span class="keyword">super</span>.onBindViewHolder(holder, position, payloads)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (holder <span class="keyword">is</span> MotionViewHolder) &#123;</span><br><span class="line">                <span class="keyword">val</span> motionBox = holder.itemView.findViewById&lt;MotionLayout&gt;(R.id.motionContainer)</span><br><span class="line">                motionBox.transitionToStart()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过以上步骤，即利用MotionLayout比较简单的实现了RecyclerView的item展开折叠效果<br>1.支持流畅的展开折叠<br>2.支持多类型item<br>3.支持只能同时展开一个    </p><p>MotionLayout还有很多更强大的功能，比如与AppBarLayout联动，与Lottie联动，实现复杂动画等。<br>读者如有兴趣可阅读下方的参考链接，及本文的所有代码</p><h3 id="本文的所有相关代码"><a href="#本文的所有相关代码" class="headerlink" title="本文的所有相关代码"></a>本文的所有相关代码</h3><p><a href="https://github.com/shenzhen2017/MotionLayoutRecyclerView" target="_blank" rel="noopener">MotionLayoutRecyclerView实现</a></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://juejin.cn/post/6844903918598635534" target="_blank" rel="noopener">MotionLayout：打开动画新世界大门 (part I)</a><br><a href="https://juejin.cn/post/6854573206653812743" target="_blank" rel="noopener">Android MotionLayout动画：续写ConstraintLayout新篇章</a>     </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;RecyclerView的展开与折叠是一种常见的动画&lt;br&gt;主要有两种方式可以实现&lt;br&gt;&lt;strong&gt;1.通过添加与移除元素&lt;/strong&gt;&lt;br&gt;notifyInsert,notifyRemoved，这种方式涉及到元素的加减，动画效果不太流畅&lt;br&gt;&lt;strong&gt;
      
    
    </summary>
    
    
      <category term="android" scheme="http://ShenZhen2017.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>ARTS打卡9</title>
    <link href="http://ShenZhen2017.github.io/blog/2020/12/arts-way-nine.html"/>
    <id>http://ShenZhen2017.github.io/blog/2020/12/arts-way-nine.html</id>
    <published>2020-12-14T04:20:45.000Z</published>
    <updated>2020-12-20T06:18:41.593Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><blockquote><p><a href="https://leetcode-cn.com/contest/weekly-contest-220/problems/reformat-phone-number/" target="_blank" rel="noopener">5629. 重新格式化电话号码</a><br>给你一个字符串形式的电话号码 number 。number 由数字、空格 ‘ ‘、和破折号 ‘-‘ 组成。<br>请你按下述方式重新格式化电话号码。<br>首先，删除 所有的空格和破折号。<br>其次，将数组从左到右 每 3 个一组 分块，直到 剩下 4 个或更少数字。剩下的数字将按下述规定再分块：<br>2 个数字：单个含 2 个数字的块。<br>3 个数字：单个含 3 个数字的块。<br>4 个数字：两个分别含 2 个数字的块。<br>最后用破折号将这些块连接起来。注意，重新格式化过程中 不应该 生成仅含 1 个数字的块，并且 最多 生成两个含 2 个数字的块。<br>返回格式化后的电话号码。</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">reformatNumber</span><span class="params">(number: <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">val</span> item = number.trim().replace(<span class="string">" "</span>,<span class="string">""</span>).replace(<span class="string">"-"</span>,<span class="string">""</span>)</span><br><span class="line">        <span class="keyword">val</span> result = StringBuilder()</span><br><span class="line">        <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; item.length)&#123;</span><br><span class="line">            <span class="keyword">if</span> (item.length-i&lt;=<span class="number">4</span>)&#123;</span><br><span class="line">                <span class="keyword">when</span> &#123;</span><br><span class="line">                    item.length-i==<span class="number">4</span> -&gt; result.append(item[i]).append(item[i+<span class="number">1</span>]).append(<span class="string">"-"</span>).append(item[i+<span class="number">2</span>]).append(item[i+<span class="number">3</span>])</span><br><span class="line">                    item.length-i == <span class="number">3</span> -&gt; result.append(item[i]).append(item[i+<span class="number">1</span>]).append(item[i+<span class="number">2</span>])</span><br><span class="line">                    <span class="keyword">else</span> -&gt; result.append(item[i]).append(item[i+<span class="number">1</span>])</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                result.append(item[i]).append(item[i+<span class="number">1</span>]).append(item[i+<span class="number">2</span>]).append(<span class="string">"-"</span>)</span><br><span class="line">                i += <span class="number">3</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.toString()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p><a href="https://thegeekpage.com/wifi-disconnecting-when-vpn-in-enabled/" target="_blank" rel="noopener">https://thegeekpage.com/wifi-disconnecting-when-vpn-in-enabled/</a><br><a href="https://thegeekpage.com/restart-pc-in-clean-boot-mode/" target="_blank" rel="noopener">https://thegeekpage.com/restart-pc-in-clean-boot-mode/</a><br>本文主要是windows10 安装vpn后，一打开vpn,wifi自动关闭<br>最后通过为windows建立干净启动解决问题</p><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><h3 id="ConstraintLayout给几个View添加背景"><a href="#ConstraintLayout给几个View添加背景" class="headerlink" title="ConstraintLayout给几个View添加背景"></a>ConstraintLayout给几个View添加背景</h3><p>考虑这么一个场景，如果一个页面里面有部分 view 需要加个背景，使用Layer引用这几个 view，然后给Layer设置背景就可以了。如果不用Layer，只能另外加个 ViewGroup 包住这几个 View 了，这样会增加 view 的层级，不利于性能。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;android.support.constraint.helper.Layer</span><br><span class="line">        app:<span class="attribute">layout_constraintLeft_toLeftOf</span>=<span class="string">"parent"</span></span><br><span class="line">        app:<span class="attribute">layout_constraintTop_toTopOf</span>=<span class="string">"parent"</span></span><br><span class="line">        android:<span class="attribute">id</span>=<span class="string">"@+id/layer"</span></span><br><span class="line">        android:<span class="attribute">layout_width</span>=<span class="string">"wrap_content"</span></span><br><span class="line">        android:<span class="attribute">layout_height</span>=<span class="string">"wrap_content"</span></span><br><span class="line">        android:<span class="attribute">background</span>=<span class="string">"@drawable/frame"</span></span><br><span class="line">        android:<span class="attribute">padding</span>=<span class="string">"32dp"</span></span><br><span class="line">        app:<span class="attribute">constraint_referenced_ids</span>=<span class="string">"button4,button5,button7,button6,button3,button2"</span> /&gt;</span><br></pre></td></tr></table></figure><p>详情可见：<a href="https://juejin.cn/post/6844903872255754248" target="_blank" rel="noopener">ConstraintLayout 2.0 新特性详解及实战</a></p><h3 id="圆角View与圆角ImageView实现"><a href="#圆角View与圆角ImageView实现" class="headerlink" title="圆角View与圆角ImageView实现"></a>圆角View与圆角ImageView实现</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;androidx.constraintlayout.utils.widget.ImageFilterButton</span><br><span class="line">    android:<span class="attribute">layout_width</span>=<span class="string">"wrap_content"</span></span><br><span class="line">    android:<span class="attribute">layout_height</span>=<span class="string">"wrap_content"</span></span><br><span class="line">    android:<span class="attribute">layout_marginTop</span>=<span class="string">"100dp"</span></span><br><span class="line">    android:<span class="attribute">src</span>=<span class="string">"@mipmap/ic_launcher"</span></span><br><span class="line">    app:<span class="attribute">layout_constraintLeft_toLeftOf</span>=<span class="string">"parent"</span></span><br><span class="line">    app:<span class="attribute">layout_constraintRight_toRightOf</span>=<span class="string">"parent"</span></span><br><span class="line">    app:<span class="attribute">layout_constraintTop_toTopOf</span>=<span class="string">"parent"</span></span><br><span class="line">    app:<span class="attribute">round</span>=<span class="string">"50dp"</span> /&gt;</span><br></pre></td></tr></table></figure><p>可以使用ImageFilterButton与ImageFilterView实现，通过round属性设置</p><p>详情可见：<a href="https://juejin.cn/post/6854573221312725000#heading-5" target="_blank" rel="noopener">ImageFilterView实现圆角</a></p><h3 id="ConstraintLayout-margin设置为负值"><a href="#ConstraintLayout-margin设置为负值" class="headerlink" title="ConstraintLayout margin设置为负值"></a>ConstraintLayout margin设置为负值</h3><p>有ConstraintLayout实践经验的朋友应该知道margin设置负值在ConstraintLayout是没有效果的<br>我们可以通过轻量级的Space来间接实现这种效果。<br>详情可见：<a href="https://juejin.cn/post/6854573221312725000#heading-9" target="_blank" rel="noopener">ConstraintLayout实现maring为负值</a></p><h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p><a href="https://shenzhen2017.github.io/blog/2020/12/motionlayout-recyclerview-animation.html">利用MotionLayout实现RecyclerView折叠展开动画</a><br>结合MotionLayout与RecyclerView，实现展开折叠动画</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Algorithm&quot;&gt;&lt;a href=&quot;#Algorithm&quot; class=&quot;headerlink&quot; title=&quot;Algorithm&quot;&gt;&lt;/a&gt;Algorithm&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.
      
    
    </summary>
    
    
      <category term="ARTS" scheme="http://ShenZhen2017.github.io/tags/ARTS/"/>
    
  </entry>
  
  <entry>
    <title>【译】取代Android的LiveData:StateFlow还是SharedFlow？</title>
    <link href="http://ShenZhen2017.github.io/blog/2020/12/translate-substituing-liveData.html"/>
    <id>http://ShenZhen2017.github.io/blog/2020/12/translate-substituing-liveData.html</id>
    <published>2020-12-13T13:25:27.000Z</published>
    <updated>2020-12-16T16:00:43.376Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>原标题: Substituting Android’s LiveData: StateFlow or SharedFlow?<br>原文地址: <a href="https://proandroiddev.com/should-we-choose-kotlins-stateflow-or-sharedflow-to-substitute-for-android-s-livedata-2d69f2bd6fa5" target="_blank" rel="noopener">Substituting Android’s LiveData: StateFlow or SharedFlow?</a><br>原文作者：Patrick Steiger</p></blockquote><p>Kotlin Coroutines最近推出了两种Flow类型，SharedFlow和StateFlow，Android社区开始考虑使用用这些新类型去替代LiveData的可能性。<br>这样做的两个主要原因是：    </p><ul><li>1.LiveData与UI紧密绑定（没有自然的方式将工作卸载到工作线程）    </li><li>2.LiveData与Android平台紧密绑定。    </li></ul><p>我们可以从这两个事实得出结论，就Clean Architecture而言，尽管LiveData在展示层上运行良好，但它并不能很好地集成到域层中，后者应该独立于平台（意味着一个纯粹的Kotlin / Java模块）；   而且它也不太适合数据层（存储库实现和数据源），因为我们通常应该将数据访问工作分担给工作线程。<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog9/p1.png" alt><br>但是，我们不能仅用纯Flow代替LiveData。使用纯Flow作为LiveData替代品的主要问题是：   </p><ul><li>1.Flow是无状态的（并且不能通过.value访问）。</li><li>2.Flow是声明性的,一个Flow Builder仅描述Flow是什么，并且仅在收集时才具体化。 并且将为每个收集器有效地实例化新的Flow，这意味着将为每个收集器冗余且重复地运行上游昂贵的数据库访问。</li><li>3.Flow本身对Android生命周期一无所知，并且不会在Android生命周期状态发生变化时自动暂停和恢复收集器。</li></ul><blockquote><p>这些不应被视为Flow固有缺陷：这些只是使其无法很好地替代LiveData，而在其他情况下却可能很实用。</p></blockquote><p>对于（3），我们已经可以使用LifecycleCoroutineScope扩展（例如launchWhenStarted）来启动协程以收集我们的flows-这些收集器将自动暂停并与组件的Lifecycle同步恢复。  </p><blockquote><p>注意：在本文中，我们将收集和观察用作同义词概念。 收集是Kotlin Flows（我们收集一个Flow）的首选术语，观察是Android LiveData（我们观察一个LiveData）的首选术语。  </p></blockquote><p>但是关于（1）访问当前状态，（2）对于N&gt; = 1个收集器仅实现一次，而对于0个收集器则消失，我们该如何实现呢？</p><p>现在，SharedFlow和StateFlow为这两个问题提供了解决方案。     </p><h2 id="一个实例"><a href="#一个实例" class="headerlink" title="一个实例"></a>一个实例</h2><p>我们举一个例子。我们的用例正在获取附近的位置。我们假设将Firebase实时数据库与GeoFire库一起使用，该库允许查询附近的位置。   </p><h3 id="使用LiveData端到端"><a href="#使用LiveData端到端" class="headerlink" title="使用LiveData端到端"></a>使用LiveData端到端</h3><p><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog9/p2.png" alt></p><p>让我们首先展示从数据源一直到视图的LiveData用法。<br>数据源负责通过GeoQuery连接到Firebase实时数据库。<br>当我们收到onGeoQueryReady或onGeoQueryError时，将使用自上一个onGeoQueryReady以来输入，退出或移动的位置的总和来更新LiveData值。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Singleton</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NearbyUsersDataSource</span> <span class="meta">@Inject</span> <span class="keyword">constructor</span></span>() &#123;</span><br><span class="line">    <span class="comment">// Ideally, those should be constructor-injected.</span></span><br><span class="line">    <span class="keyword">val</span> geoFire = GeoFire(FirebaseDatabase.getInstance().getReference(<span class="string">"geofire"</span>))</span><br><span class="line">    <span class="keyword">val</span> geoLocation = GeoLocation(<span class="number">0.0</span>, <span class="number">0.0</span>)</span><br><span class="line">    <span class="keyword">val</span> radius = <span class="number">100.0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">val</span> geoQuery = geoFire.queryAtLocation(geoLocation, radius)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Listener for receiving GeoLocations</span></span><br><span class="line">    <span class="keyword">val</span> listener: GeoQueryEventListener = <span class="keyword">object</span> : GeoQueryEventListener &#123;</span><br><span class="line">        <span class="keyword">val</span> map = mutableMapOf&lt;Key, GeoLocation&gt;()</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onKeyEntered</span><span class="params">(key: <span class="type">String</span>, location: <span class="type">GeoLocation</span>)</span></span> &#123;</span><br><span class="line">            map[key] = location</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onKeyExited</span><span class="params">(key: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">            map.remove(key)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onKeyMoved</span><span class="params">(key: <span class="type">String</span>, location: <span class="type">GeoLocation</span>)</span></span> &#123;</span><br><span class="line">            map[key] = location</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onGeoQueryReady</span><span class="params">()</span></span> &#123;</span><br><span class="line">            _locations.value = State.Ready(map.toMap())</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onGeoQueryError</span><span class="params">(e: <span class="type">DatabaseError</span>)</span></span> &#123;</span><br><span class="line">            _locations.value = State.Error(map.toMap(), e.toException())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Listen for changes only while observed</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> _locations = <span class="keyword">object</span> : MutableLiveData&lt;State&gt;() &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActive</span><span class="params">()</span></span> &#123;</span><br><span class="line">            geoQuery.addGeoQueryEventListener(listener)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onInactive</span><span class="params">()</span></span> &#123;</span><br><span class="line">            geoQuery.removeGeoQueryEventListener(listener)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Expose read-only LiveData</span></span><br><span class="line">    <span class="keyword">val</span> locations: LiveData&lt;State&gt; <span class="keyword">by</span> <span class="keyword">this</span>::_locations</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">State</span></span>(<span class="keyword">open</span> <span class="keyword">val</span> value: Map&lt;Key, GeoLocation&gt;) &#123;</span><br><span class="line">        <span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Ready</span></span>(</span><br><span class="line">            <span class="keyword">override</span> <span class="keyword">val</span> value: Map&lt;Key, GeoLocation&gt;</span><br><span class="line">        ) : State(value)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Error</span></span>(</span><br><span class="line">            <span class="keyword">override</span> <span class="keyword">val</span> value: Map&lt;Key, GeoLocation&gt;,</span><br><span class="line">            <span class="keyword">val</span> exception: Exception</span><br><span class="line">        ) : State(value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后，我们的Repository，ViewModel和Activity应该很简单：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Singleton</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NearbyUsersRepository</span> <span class="meta">@Inject</span> <span class="keyword">constructor</span></span>(</span><br><span class="line">    nearbyUsersDataSource: NearbyUsersDataSource</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="keyword">val</span> locations <span class="keyword">get</span>() = nearbyUsersDataSource.locations</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NearbyUsersViewModel</span> <span class="meta">@ViewModelInject</span> <span class="keyword">constructor</span></span>(</span><br><span class="line">    nearbyUsersRepository: NearbyUsersRepository</span><br><span class="line">) : ViewModel() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> locations <span class="keyword">get</span>() = nearbyUsersRepository.locations</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AndroidEntryPoint</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NearbyUsersActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> viewModel: NearbyUsersViewModel <span class="keyword">by</span> viewModels()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        viewModel.locations.observe(<span class="keyword">this</span>) &#123; state: State -&gt;</span><br><span class="line">            <span class="comment">// Update views with the data.   </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在您决定使包含存储库接口的域层（独立于平台）之前，这种尝试可能不错。 同样，一旦需要将工作分担到数据源上的工作线程上，您将发现LiveData没有简单，惯用的方法。</p><h3 id="在数据源和Repository上使用Flow"><a href="#在数据源和Repository上使用Flow" class="headerlink" title="在数据源和Repository上使用Flow"></a>在数据源和Repository上使用Flow</h3><p><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog9/p3.png" alt><br>让我们将数据源转换为使用Flow。 我们有一个Flow生成器callbackFlow，它将回调转换为Flow。<br>收集此Flow后，它将运行传递给Flow构建器的代码块，添加GeoQuery侦听器并到达awaitClose，在该处暂停直到Flow被关闭（即直到没有人收集或因为异常被取消为止).<br>关闭时，它将删除监听器，并且Flow将取消实现。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Singleton</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NearbyUsersDataSource</span> <span class="meta">@Inject</span> <span class="keyword">constructor</span></span>() &#123;</span><br><span class="line">    <span class="comment">// Ideally, those should be constructor-injected.</span></span><br><span class="line">    <span class="keyword">val</span> geoFire = GeoFire(FirebaseDatabase.getInstance().getReference(<span class="string">"geofire"</span>))</span><br><span class="line">    <span class="keyword">val</span> geoLocation = GeoLocation(<span class="number">0.0</span>, <span class="number">0.0</span>)</span><br><span class="line">    <span class="keyword">val</span> radius = <span class="number">100.0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">val</span> geoQuery = geoFire.queryAtLocation(geoLocation, radius)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> GeoQuery.<span class="title">asFlow</span><span class="params">()</span></span> = callbackFlow &#123;</span><br><span class="line">        <span class="keyword">val</span> listener: GeoQueryEventListener = <span class="keyword">object</span> : GeoQueryEventListener &#123;</span><br><span class="line">            <span class="keyword">val</span> map = mutableMapOf&lt;Key, GeoLocation&gt;()</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onKeyEntered</span><span class="params">(key: <span class="type">String</span>, location: <span class="type">GeoLocation</span>)</span></span> &#123;</span><br><span class="line">                map[key] = location</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onKeyExited</span><span class="params">(key: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">                map.remove(key)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onKeyMoved</span><span class="params">(key: <span class="type">String</span>, location: <span class="type">GeoLocation</span>)</span></span> &#123;</span><br><span class="line">                map[key] = location</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onGeoQueryReady</span><span class="params">()</span></span> &#123;</span><br><span class="line">                emit(State.Ready(locations.toMap()))</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onGeoQueryError</span><span class="params">(e: <span class="type">DatabaseError</span>)</span></span> &#123;</span><br><span class="line">                emit(State.Error(map.toMap(), e.toException()))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        addGeoQueryEventListener(listener)</span><br><span class="line">        </span><br><span class="line">        awaitClose &#123; removeGeoQueryEventListener(listener) &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> locations: Flow&lt;State&gt; = geoQuery.asFlow()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">State</span></span>(<span class="keyword">open</span> <span class="keyword">val</span> value: Map&lt;Key, GeoLocation&gt;) &#123;</span><br><span class="line">        <span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Ready</span></span>(</span><br><span class="line">            <span class="keyword">override</span> <span class="keyword">val</span> value: Map&lt;Key, GeoLocation&gt;</span><br><span class="line">        ) : State(value)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Error</span></span>(</span><br><span class="line">            <span class="keyword">override</span> <span class="keyword">val</span> value: Map&lt;Key, GeoLocation&gt;,</span><br><span class="line">            <span class="keyword">val</span> exception: Exception</span><br><span class="line">        ) : State(value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们的Repository和ViewModel不做任何更改，但是我们的Activity现在接收到Flow而不是LiveData，因此它需要进行调整：我们将收集Flow而不是观察LiveData。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AndroidEntryPoint</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NearbyUsersActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> viewModel: NearbyUsersViewModel <span class="keyword">by</span> viewModels()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        lifecycleScope.launchWhenStarted &#123;</span><br><span class="line">            viewModel.locations.collect &#123;</span><br><span class="line">                <span class="comment">// Update views with the data.   </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们使用launchWhenStarted {}来收集Flow，因此协程仅在Activity达到onStart（）生命周期状态时才自动启动，而当它达到onStop（）生命周期状态时将自动暂停。 这类似于LiveData给我们的生命周期自动处理。 </p><blockquote><p>注意：您可以选择在展示层中继续使用LiveData。 在这种情况下，您可以使用Flow <t>.asLiveData扩展函数轻松地在ViewModel中将Flow从Flow转换为LiveData。<br>这个决定将带来后果，我们将继续进行讨论，并且将证明端到端使用SharedFlow和StateFlow更加通用，并且可能更适合您的体系结构。<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog9/p4.png" alt>  </t></p></blockquote><h3 id="在View层中使用Flow有什么问题？"><a href="#在View层中使用Flow有什么问题？" class="headerlink" title="在View层中使用Flow有什么问题？"></a>在View层中使用Flow有什么问题？</h3><p>这种方法的第一个问题是生命周期的处理，LiveData会自动为我们处理。 在上面的示例中，我们通过使用launchWhenStarted {}实现了类似的行为。    </p><p>但是还有另一个问题：由于Flow是声明性的，并且仅在收集时运行（实例化），因此，如果我们有多个收集器，则将为每个收集器运行一个新的Flow，彼此完全独立。<br>根据完成的操作（例如数据库或网络操作），这可能会非常无效。<br>如果我们期望操作只进行一次以确保正确性，则甚至可能导致错误的状态。<br>在我们的实际示例中，我们将为每个收集器添加一个新的GeoQuery监听器-可能不是关键问题，但肯定会浪费内存和CPU周期。   </p><blockquote><p>注意：如果通过在ViewModel中使用Flow <t> .asLiveData（）将存储库流转换为LiveData，则LiveData将成为Flow的唯一收集器，无论展示层中有多少观察者，都将只有一个Flow 集。<br>但是，为了使该架构正常工作，您需要确保自己的所有其他组件都可以从ViewModel访问LiveData，而绝不能直接从存储库访问Flow。<br>这可能是一个挑战，具体取决于应用程序的分离程度：所有需要存储库的组件现在都将依赖Activity实例来获取ViewModel实例，以及这些组件的范围 需要相应地加以限制。</t></p></blockquote><p>无论我们在View层中有多少个收集器，我们都只需要一个GeoQuery监听器。 我们可以通过共享所有收集器之间的流来实现此目的。     </p><h3 id="SharedFlow"><a href="#SharedFlow" class="headerlink" title="SharedFlow"></a>SharedFlow</h3><p>SharedFlow是一种流，它允许在多个收集器之间共享自己，因此对于所有同时收集器，只有一个流有效地运行（实现）。<br>如果定义访问数据库的SharedFlow并且由多个收集器收集，则数据库访问将仅运行一次，并且所得到的数据将共享给所有收集器。    </p><p>StateFlow也可以用于实现相同的行为：它是具有.value（其当前状态）和特定SharedFlow配置（约束）的专用SharedFlow。 稍后我们将讨论这些限制。<br>我们有一个运算符，用于将任何Flow转换为SharedFlow<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Flow<span class="type">&lt;T&gt;</span>.<span class="title">shareIn</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    scope: <span class="type">CoroutineScope</span>, </span></span></span><br><span class="line"><span class="function"><span class="params">    started: <span class="type">SharingStarted</span>, </span></span></span><br><span class="line"><span class="function"><span class="params">    replay: <span class="type">Int</span> = <span class="number">0</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>: SharedFlow&lt;T&gt; (source)</span><br></pre></td></tr></table></figure></p><p>让我们将其应用于我们的数据源。     </p><p>scope是完成实现该流程的所有计算的地方。<br>由于我们的数据源是@Singleton，因此我们可以使用应用程序进程的LifecycleScope，它是一个LifecycleCoroutineScope，它是在进程创建时创建的，仅在进程销毁时才销毁。    </p><p>对于started参数，我们可以使用SharingStarted.WhileSubscribed（），这使Flow仅在订阅者数量从0变为1时才开始共享（实现），并在订阅者数量从1变为0时停止共享。     与我们之前通过在onActive（）回调中添加GeoQuery侦听器并在onInactive（）回调中删除侦听器实现的LiveData行为类似。      我们还可以将其配置为立即启动（立即实现，而不再取消实现）或懒启动（在首次收集时实现，而从未取消实现），但是我们希望它在下游不再收集时停止上游数据库的收集。    </p><blockquote><p>关于术语的注意事项：正如我们将术语“观察者”用于LiveData，将“收集器”用于Flow一样，我们将术语“订阅”用于SharedFlow。</p></blockquote><p>对于replay参数,我们可以设置为1，新订阅者将在订阅时立即获得最后发出的值。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Singleton</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NearbyUsersDataSource</span> <span class="meta">@Inject</span> <span class="keyword">constructor</span></span>() &#123;</span><br><span class="line">    <span class="comment">// Ideally, those should be constructor-injected.</span></span><br><span class="line">    <span class="keyword">val</span> geoFire = GeoFire(FirebaseDatabase.getInstance().getReference(<span class="string">"geofire"</span>))</span><br><span class="line">    <span class="keyword">val</span> geoLocation = GeoLocation(<span class="number">0.0</span>, <span class="number">0.0</span>)</span><br><span class="line">    <span class="keyword">val</span> radius = <span class="number">100.0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">val</span> geoQuery = geoFire.queryAtLocation(geoLocation, radius)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> GeoQuery.<span class="title">asFlow</span><span class="params">()</span></span> = callbackFlow &#123;</span><br><span class="line">        <span class="keyword">val</span> listener: GeoQueryEventListener = <span class="keyword">object</span> : GeoQueryEventListener &#123;</span><br><span class="line">            <span class="keyword">val</span> map = mutableMapOf&lt;Key, GeoLocation&gt;()</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onKeyEntered</span><span class="params">(key: <span class="type">String</span>, location: <span class="type">GeoLocation</span>)</span></span> &#123;</span><br><span class="line">                map[key] = location</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onKeyExited</span><span class="params">(key: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">                map.remove(key)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onKeyMoved</span><span class="params">(key: <span class="type">String</span>, location: <span class="type">GeoLocation</span>)</span></span> &#123;</span><br><span class="line">                map[key] = location</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onGeoQueryReady</span><span class="params">()</span></span> &#123;</span><br><span class="line">                emit(State.Ready(map.toMap())</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onGeoQueryError</span><span class="params">(e: <span class="type">DatabaseError</span>)</span></span> &#123;</span><br><span class="line">                emit(State.Error(map.toMap(), e.toException())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        addGeoQueryEventListener(listener)</span><br><span class="line">        </span><br><span class="line">        awaitClose &#123; removeGeoQueryEventListener(listener) &#125;</span><br><span class="line">    &#125;.shareIn(</span><br><span class="line">         ProcessLifecycleOwner.<span class="keyword">get</span>().lifecycleScope,</span><br><span class="line">         SharingStarted.WhileSubscribed(),</span><br><span class="line">         <span class="number">1</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> locations: Flow&lt;State&gt; = geoQuery.asFlow()</span><br><span class="line">                     </span><br><span class="line">    <span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">State</span></span>(<span class="keyword">open</span> <span class="keyword">val</span> value: Map&lt;Key, GeoLocation&gt;) &#123;</span><br><span class="line">        <span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Ready</span></span>(</span><br><span class="line">            <span class="keyword">override</span> <span class="keyword">val</span> value: Map&lt;Key, GeoLocation&gt;</span><br><span class="line">        ) : State(value)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Error</span></span>(</span><br><span class="line">            <span class="keyword">override</span> <span class="keyword">val</span> value: Map&lt;Key, GeoLocation&gt;,</span><br><span class="line">            <span class="keyword">val</span> exception: Exception</span><br><span class="line">        ) : State(value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>将SharedFlow本身视为Flow收集器可能会有所帮助，它会将上游的冷流变为热流，并在下游的许多收集器之间共享收集的值。 在冷的上游水流和多个下游收集器之间的中间位置有一个人。  </p><p>现在，我们可能会以为Activity不需要调整。<br>错误！ 有一个陷阱：在使用launchWhenStarted {}启动的协程中收集流时，协程将在onStop（）上暂停，并在onStart（）上恢复，但仍将订阅该流。<br>对于MutableSharedFlow <t>，这意味着MutableSharedFlow <t> .subscriptionCount对于暂停的协程不会更改。 为了利用SharingStarted.WhileSubscribed（）的功能，我们实际上需要在onStop（）上退订，然后在onStart（）上再次订阅。 这意味着取消收集协程并重新创建它。</t></t></p><p>让我们为此目的创建一个类：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PublishedApi</span></span><br><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserverImpl</span>&lt;<span class="type">T</span>&gt; </span>(</span><br><span class="line">    lifecycleOwner: LifecycleOwner,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> flow: Flow&lt;T&gt;,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> collector: <span class="keyword">suspend</span> (T) -&gt; <span class="built_in">Unit</span></span><br><span class="line">) : DefaultLifecycleObserver &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> job: Job? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStart</span><span class="params">(owner: <span class="type">LifecycleOwner</span>)</span></span> &#123;</span><br><span class="line">        job = owner.lifecycleScope.launch &#123;</span><br><span class="line">            flow.collect &#123;</span><br><span class="line">                collector(it)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStop</span><span class="params">(owner: <span class="type">LifecycleOwner</span>)</span></span> &#123;</span><br><span class="line">        job?.cancel()</span><br><span class="line">        job = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        lifecycleOwner.lifecycle.addObserver(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T&gt;</span> Flow<span class="type">&lt;T&gt;</span>.<span class="title">observe</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    lifecycleOwner: <span class="type">LifecycleOwner</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">noinline</span> collector: <span class="type">suspend</span> (<span class="type">T</span>) -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> &#123;</span><br><span class="line">    ObserverImpl(lifecycleOwner, <span class="keyword">this</span>, collector)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T&gt;</span> Flow<span class="type">&lt;T&gt;</span>.<span class="title">observeIn</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    lifecycleOwner: <span class="type">LifecycleOwner</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> &#123;</span><br><span class="line">    ObserverImpl(lifecycleOwner, <span class="keyword">this</span>, &#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在，我们可以调整Activity以使用刚刚创建的.observeIn（LifecycleOwner）扩展功能：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AndroidEntryPoint</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NearbyUsersActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> viewModel: NearbyUsersViewModel <span class="keyword">by</span> viewModels()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        viewModel</span><br><span class="line">            .locations</span><br><span class="line">            .onEach &#123; <span class="comment">/* new locations received */</span> &#125;</span><br><span class="line">            .observeIn(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当LifecycleOwner的生命周期达到CREATED状态（恰好在onStop（）调用之前）时，使用observeIn（LifecycleOwner）创建的收集器协程将被销毁，并且一旦达到STARTED状态（在onStart（）调用之后）将被重新创建。</p><blockquote><p>注意：为什么是CREATED状态？ 不应该是STOPED状态吗？ 乍一看听起来有点违反直觉，但确实很合理。 Lifecycle.State仅具有以下状态：CREATED, DESTROYED, INITIALIZED, RESUMED, STARTED。<br>没有STOPPED和PAUSED状态。 当生命周期达到onPause（）时，它不会返回新状态，而是返回到STARTED状态。 当到达onStop（）时，它返回到CREATED状态。</p></blockquote><p><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog9/p5.png" alt><br>现在，我们有了一个数据源，该数据源一次实现，但将其数据共享给所有订阅者。<br>一旦没有订阅者，它的上游收集将停止，并在第一个订阅者重新出现时重新启动。<br>它不依赖于Android平台，也不与主线程绑定（仅通过应用.flowOn（）运算符即可在其他线程中进行流转换：<br>flowOn（Dispatchers.IO）或.flowOn（Dispatchers.Default） ）。</p><h3 id="但是，如果我最终需要访问Flow的当前状态而不收集它怎么办？"><a href="#但是，如果我最终需要访问Flow的当前状态而不收集它怎么办？" class="headerlink" title="但是，如果我最终需要访问Flow的当前状态而不收集它怎么办？"></a>但是，如果我最终需要访问Flow的当前状态而不收集它怎么办？</h3><p>如果确实需要像使用LiveData一样使用.value访问Flow的状态，则我们可以使用StateFlow，它是一种专用的受限SharedFlow。    </p><p>ShareFlow使用shareIn来实现<br>StateFlow使用stateIn实现</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Flow<span class="type">&lt;T&gt;</span>.<span class="title">stateIn</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    scope: <span class="type">CoroutineScope</span>, </span></span></span><br><span class="line"><span class="function"><span class="params">    started: <span class="type">SharingStarted</span>, </span></span></span><br><span class="line"><span class="function"><span class="params">    initialValue: <span class="type">T</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>: StateFlow&lt;T&gt; (source)</span><br></pre></td></tr></table></figure><p>从方法参数可以看出，sharedIn（）和stateIn（）之间有两个基本区别：</p><p>1.stateIn（）不支持replay自定义。 StateFlow是具有固定replay=1的SharedFlow。 这意味着新订阅者将在订阅后立即获得当前状态。<br>2.stateIn（）需要一个初始值。 这意味着如果您当时没有初始值，则需要使StateFlow <t>类型T为可为空，或使用密封类来表示空的初始值。    </t></p><h3 id="选择哪个，StateFlow或SharedFlow？"><a href="#选择哪个，StateFlow或SharedFlow？" class="headerlink" title="选择哪个，StateFlow或SharedFlow？"></a>选择哪个，StateFlow或SharedFlow？</h3><p>回答此问题的简单方法是尝试回答其他一些问题：   </p><p><strong>“我真的需要在任何给定时间使用myFlow.value访问Flow的当前状态吗？”</strong><br>如果此问题的答案为“否”，则可以考虑使用SharedFlow。 </p><p><strong>“我需要支持发出和收集重复值吗？”</strong><br>如果对这个问题的回答是“是”，则需要SharedFlow。  </p><p><strong>“对于新订户，我是否需要重播超过最新值的内容？”</strong><br>如果对这个问题的回答是“是”，则需要SharedFlow。    </p><p>正如我们所看到的，对于所有内容，StateFlow并不是自动的正确答案。  </p><p>1.它忽略（合并）重复的值，并且这是不可配置的。 有时您不需要忽略重复的值，例如：连接尝试将尝试的结果存储在流中，并且每次失败后都需要重试。   </p><p>2.另外，它需要一个初始值。 由于SharedFlow没有.value，因此不需要使用初始值实例化-收集器将暂停直到第一个值出现，并且没有人会尝试在任何值到达之前访问.value。 如果您没有StateFlow的初始值，则必须将StateFlow类型设为可为null的T？ 并使用null作为初始值（或使用密封类来表示空的初始值）。</p><p>3.另外，您可能需要调整重播值。 SharedFlow可以为新订户重播最后n个值。 StateFlow的固定重播值为1-它仅共享当前状态值</p><p>两者都支持SharingStarted（立刻，懒加载或WhileSubscribed（））配置。我通常使用SharingStarted.WhileSubscribed（）<br>并在Activity onStart（）/ onStop（）时，销毁/重新创建所有收集器，<br>因此，当用户不积极使用该应用程序时，数据源上游收集将停止    </p><p>StateFlow施加在SharedFlow上的约束可能不是最适合您，您可能需要调整行为并选择使用SharedFlow。就个人而言，我很少需要访问myFlow.value，并且享受SharedFlow的灵活性，因此我通常选择SharedFlow。  </p><h3 id="一个使用SharedFlow的实例"><a href="#一个使用SharedFlow的实例" class="headerlink" title="一个使用SharedFlow的实例"></a>一个使用SharedFlow的实例</h3><p>考虑以下围绕Google Billing Client库的包装。我们有一个MutableSharedFlow billingClientStatus，用于存储当前到计费服务的连接状态。<br>我们将其初始值设置为SERVICE_DISCONNECTED。我们收集billingClientStatus，当它不正常时，我们尝试将startConnection（）连接到计费服务。<br>如果连接尝试失败，我们将发出SERVICE_DISCONNECTED。</p><p>在该示例中，如果billingClientStatus是MutableStateFlow而不是MutableSharedFlow，则当其值已经为SERVICE_DISCONNECTED且我们尝试将其设置为相同（连接重试失败）时，它将忽略更新，因此，它将不会尝试重新连接再次。   </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Singleton</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Biller</span> <span class="meta">@Inject</span> <span class="keyword">constructor</span></span>(</span><br><span class="line">    <span class="meta">@ApplicationContext</span> <span class="keyword">private</span> <span class="keyword">val</span> context: Context,</span><br><span class="line">) : PurchasesUpdatedListener, BillingClientStateListener &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> billingClient: BillingClient =</span><br><span class="line">        BillingClient.newBuilder(context)</span><br><span class="line">            .setListener(<span class="keyword">this</span>)</span><br><span class="line">            .enablePendingPurchases()</span><br><span class="line">            .build()</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> billingClientStatus = MutableSharedFlow&lt;<span class="built_in">Int</span>&gt;(</span><br><span class="line">        replay = <span class="number">1</span>,</span><br><span class="line">        onBufferOverflow = BufferOverflow.DROP_OLDEST</span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBillingSetupFinished</span><span class="params">(result: <span class="type">BillingResult</span>)</span></span> &#123;</span><br><span class="line">        billingClientStatus.tryEmit(result.responseCode)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBillingServiceDisconnected</span><span class="params">()</span></span> &#123;</span><br><span class="line">        billingClientStatus.tryEmit(BillingClient.BillingResponseCode.SERVICE_DISCONNECTED)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Suspend until billingClientStatus == BillingClient.BillingResponseCode.OK</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">requireBillingClientSetup</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> =</span><br><span class="line">        withTimeoutOrNull(TIMEOUT_MILLIS) &#123;</span><br><span class="line">            billingClientStatus.first &#123; it == BillingClient.BillingResponseCode.OK &#125;</span><br><span class="line">            <span class="literal">true</span></span><br><span class="line">        &#125; ?: <span class="literal">false</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        billingClientStatus.tryEmit(BillingClient.BillingResponseCode.SERVICE_DISCONNECTED)</span><br><span class="line">        billingClientStatus.observe(ProcessLifecycleOwner.<span class="keyword">get</span>()) &#123;</span><br><span class="line">            <span class="keyword">when</span> (it) &#123;</span><br><span class="line">                BillingClient.BillingResponseCode.OK -&gt; with (billingClient) &#123;</span><br><span class="line">                    updateSkuPrices()</span><br><span class="line">                    handlePurchases()</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">                    delay(RETRY_MILLIS)</span><br><span class="line">                    billingClient.startConnection(<span class="keyword">this</span><span class="symbol">@Biller</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> TIMEOUT_MILLIS = <span class="number">2000L</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> RETRY_MILLIS = <span class="number">3000L</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这种情况下，我们需要使用SharedFlow，它支持发出连续的重复值。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要是关于SharedFlow与StateFlow的一些介绍及使用他们代替LiveData的一些尝试<br>这是在下翻译的第一篇文章，还有很多不足之处，请各位读者结合原文观看，如果有什么总量，欢迎提出指正。    </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;原标题: Substituting Android’s LiveData: StateFlow or Shared
      
    
    </summary>
    
    
      <category term="android" scheme="http://ShenZhen2017.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>android文档之性能优化总结</title>
    <link href="http://ShenZhen2017.github.io/blog/2020/12/android-doc-performace.html"/>
    <id>http://ShenZhen2017.github.io/blog/2020/12/android-doc-performace.html</id>
    <published>2020-12-12T13:44:32.000Z</published>
    <updated>2020-12-22T14:52:40.011Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文地址:<a href="https://developer.android.google.cn/topic/performance" target="_blank" rel="noopener">https://developer.android.google.cn/topic/performance</a></p></blockquote><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>用户对应用具有如下的期望：<br>1.耗电少。<br>2.启动快。<br>3.对用户互动响应迅速。</p><h2 id="Android-Vitals"><a href="#Android-Vitals" class="headerlink" title="Android Vitals"></a>Android Vitals</h2><h3 id="ANR"><a href="#ANR" class="headerlink" title="ANR"></a>ANR</h3><p>如果 Android 应用的界面线程处于阻塞状态的时间过长，会触发“应用无响应”(ANR) 错误<br>出现以下任何情况时，系统都会针对您的应用触发 ANR：</p><ul><li>当您的 Activity 位于前台时，您的应用在 5 秒钟内未响应输入事件或 BroadcastReceiver（如按键或屏幕轻触事件）。</li><li>虽然前台没有 Activity，但您的 BroadcastReceiver 用了相当长的时间仍未执行完毕。</li></ul><p>如果您的应用遇到 ANR 错误，您可以按照本文中的指导来诊断并解决问题。</p><h4 id="诊断-ANR"><a href="#诊断-ANR" class="headerlink" title="诊断 ANR"></a>诊断 ANR</h4><p>诊断 ANR 时需要考虑以下几种常见模式：</p><p>1.应用在主线程上非常缓慢地执行涉及 I/O 的操作。<br>2.应用在主线程上进行长时间的计算。<br>3.主线程在对另一个进程进行同步 binder 调用，而后者需要很长时间才能返回。<br>4.主线程处于阻塞状态，为发生在另一个线程上的长操作等待同步的块。<br>5.主线程在进程中或通过 binder 调用与另一个线程之间发生死锁。主线程不只是在等待长操作执行完毕，而且处于死锁状态</p><p>以下方法可帮助您找出是以上哪种原因造成了 ANR</p><h5 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h5><p>使用 StrictMode 有助于您在开发应用时发现主线程上的意外 I/O 操作。您可以在应用级别或 Activity 级别使用 StrictMode。</p><h5 id="启用后台-ANR-对话框"><a href="#启用后台-ANR-对话框" class="headerlink" title="启用后台 ANR 对话框"></a>启用后台 ANR 对话框</h5><p>只有在设备的开发者选项中启用了显示所有 ANR 时，Android 才会针对花费过长时间处理广播消息的应用显示 ANR 对话框。因此，系统并不会始终向用户显示后台 ANR 对话框，但应用仍可能会遇到性能问题。</p><h5 id="TraceView"><a href="#TraceView" class="headerlink" title="TraceView"></a>TraceView</h5><p>您可以使用 TraceView 在查看用例时获取正在运行的应用的跟踪信息，并找出主线程繁忙的位置。如需了解如何使用 TraceView，请参阅使用 TraceView 和 dmtracedump 分析性能。</p><h5 id="拉取跟踪信息文件"><a href="#拉取跟踪信息文件" class="headerlink" title="拉取跟踪信息文件"></a>拉取跟踪信息文件</h5><p>Android 会在遇到 ANR 时存储跟踪信息。在较低的操作系统版本中，设备上只有一个 /data/anr/traces.txt 文件。在较新的操作系统版本中，有多个 /data/anr/anr_* 文件。您可以使用 Android 调试桥 (ADB) 作为根，从设备或模拟器中获取 ANR 跟踪信息：</p><h4 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h4><h5 id="主线程上执行速度缓慢的代码"><a href="#主线程上执行速度缓慢的代码" class="headerlink" title="主线程上执行速度缓慢的代码"></a>主线程上执行速度缓慢的代码</h5><p>在您的代码中找出应用的主线程忙碌时间超过 5 秒的位置。在您的应用中查找可疑用例并尝试重现 ANR。</p><p>然后通过TraceView来找出</p><h5 id="主线程上的-IO"><a href="#主线程上的-IO" class="headerlink" title="主线程上的 IO"></a>主线程上的 IO</h5><p>在主线程上执行 IO 操作是导致主线程上操作速度缓慢的常见原因，主线程上操作速度缓慢会导致 ANR。建议将所有 IO 操作移至工作线程，如上一部分所示。</p><p>IO 操作示例包括网络和存储操作。如需了解详情，请参阅执行网络操作和保存数据。</p><h5 id="锁争用"><a href="#锁争用" class="headerlink" title="锁争用"></a>锁争用</h5><p>在某些情况下，导致 ANR 的工作并不是直接在应用的主线程上执行。如果某工作线程持有对某项资源的锁，而该资源是主线程完成其工作所必需的，这种情况下就可能会发生 ANR。</p><h3 id="崩溃"><a href="#崩溃" class="headerlink" title="崩溃"></a>崩溃</h3><p>未处理的异常或信号导致的意外退出，会使 Android 应用崩溃。使用 Java 编写的应用会在抛出未处理的异常（由 Throwable 类表示）时崩溃。使用原生代码语言编写的应用，会在执行过程中遇到未处理的信号（如 SIGSEGV）时崩溃。</p><p>当应用崩溃时，Android 会终止应用的进程并显示一个对话框，告知用户应用已停止</p><p>应用并不是只有在前台运行时才会崩溃。任何应用组件，甚至是广播接收器或内容提供程序这类在后台运行的组件，都有可能导致应用崩溃。这些崩溃常常让用户感到困惑，因为他们并没有在使用应用。</p><h4 id="诊断崩溃"><a href="#诊断崩溃" class="headerlink" title="诊断崩溃"></a>诊断崩溃</h4><p>解决崩溃问题可能很困难。但是，如果您能确定崩溃的根本原因，就有很可能能够找到解决方法。</p><h5 id="读取堆栈轨迹"><a href="#读取堆栈轨迹" class="headerlink" title="读取堆栈轨迹"></a>读取堆栈轨迹</h5><p>解决崩溃的第一步是确定它发生的位置。如果您使用的是 Play 管理中心或 logcat 工具的输出，则可使用报告详细信息中提供的堆栈轨迹。如果您没有堆栈轨迹可用，则应通过手动测试应用或联系受影响的用户在本地再现崩溃，并且要在使用 logcat 的情况下再现。</p><h5 id="有关再现崩溃的提示"><a href="#有关再现崩溃的提示" class="headerlink" title="有关再现崩溃的提示"></a>有关再现崩溃的提示</h5><p>再现问题可能无法简单地通过启动模拟器或将设备连接到计算机来实现。开发环境往往具有更多的资源，比如带宽、内存和存储。通过异常类型确定哪项资源不足，或找到 Android 版本、设备类型或应用版本之间的关联。</p><h5 id="内存错误"><a href="#内存错误" class="headerlink" title="内存错误"></a>内存错误</h5><p>如果发生了 OutOfMemoryError 异常，您可以首先创建一个内存容量较低的模拟器。图 2 显示了 AVD 管理器设置，您可以通过这些设置控制设备的内存容量。</p><h2 id="渲染速度缓慢"><a href="#渲染速度缓慢" class="headerlink" title="渲染速度缓慢"></a>渲染速度缓慢</h2><p>界面呈现是指从应用生成帧并将其显示在屏幕上的动作。要确保用户能够流畅地与您的应用互动，您的应用呈现每帧的时间不应超过 16ms，以达到每秒 60 帧的呈现速度（为什么是60fps？）。如果您的应用存在界面呈现缓慢的问题，系统会不得不跳过一些帧，这会导致用户感觉您的应用不流畅。我们将这种情况称为卡顿。</p><h3 id="识别卡顿"><a href="#识别卡顿" class="headerlink" title="识别卡顿"></a>识别卡顿</h3><p>1.目视检查<br>2.Systrace<br>3.自定义性能监控</p><h3 id="常见的卡顿来源"><a href="#常见的卡顿来源" class="headerlink" title="常见的卡顿来源"></a>常见的卡顿来源</h3><h4 id="可滚动列表"><a href="#可滚动列表" class="headerlink" title="可滚动列表"></a>可滚动列表</h4><p>ListView 和 RecyclerView （尤其是后者）常用于最易出现卡顿的复杂滚动列表。它们都包含 Systrace 标记，因此您可以使用 Systrace 来判断它们是不是导致应用出现卡顿的因素。请务必传递命令行参数 -a <your-package-name>，以便让 RecyclerView 中的跟踪部分（以及您添加的所有跟踪标记）显示出来。请遵循系统跟踪信息输出中生成的提醒提供的指导（如果有）。在 Systrace 中，您可以点击 RecyclerView 跟踪部分，以查看关于 RecyclerView 正在执行的工作的说明。</your-package-name></p><h5 id="RecyclerView：notifyDataSetChanged"><a href="#RecyclerView：notifyDataSetChanged" class="headerlink" title="RecyclerView：notifyDataSetChanged"></a>RecyclerView：notifyDataSetChanged</h5><p>如果您在一个帧中看到 RecyclerView 中的每一项都重新绑定（并因此重新布局和重新绘制），请确保您没有调用 notifyDataSetChanged()、setAdapter(Adapter) 或 swapAdapter(Adapter, boolean) 来进行细微更新。这些方法会向系统表明整个列表内容已更改，并会在 Systrace 中显示为 RV FullInvalidate。应改用 SortedList 或 DiffUtil，以便在内容发生更改或添加了内容时生成最少量的更新。</p><h5 id="RecyclerView：嵌套的-RecyclerView"><a href="#RecyclerView：嵌套的-RecyclerView" class="headerlink" title="RecyclerView：嵌套的 RecyclerView"></a>RecyclerView：嵌套的 RecyclerView</h5><p>嵌套 RecyclerView 很常见，对于由水平滚动列表组成的纵向列表（例如 Play 商店主页面上的应用网格），尤其如此。这种方法效果很好，但它也会导致大量来回移动的视图。在首次向下滚动页面时，如果您看到大量内部内容出现扩充，则可能需要检查内部（水平）RecyclerView 之间是否正在共享 RecyclerView.RecycledViewPool。默认情况下，每个 RecyclerView 都将有自己的内容池。然而，在屏幕上同时显示十几个 itemViews 的情况下，如果所有行都显示类型相似的视图，那么当不同的水平列表无法共享 itemViews 时，就会出现问题。</p><h5 id="RecyclerView：膨胀过多-创建过程用时过长"><a href="#RecyclerView：膨胀过多-创建过程用时过长" class="headerlink" title="RecyclerView：膨胀过多/创建过程用时过长"></a>RecyclerView：膨胀过多/创建过程用时过长</h5><p>RecyclerView 中的预取功能会在界面线程处于空闲状态时提前执行工作，因此在大多数情况下应该有助于解决膨胀造成的开销问题。如果您在帧中（而不是标记为 RV 预取的部分中）看到了扩充，请确保您是在版本较新的设备上进行测试（预取功能当前仅在 Android 5.0 API 级别 21 及更高版本上受支持），并且使用的是较新版本的支持库。</p><p>如果您经常在屏幕上出现新内容时看到导致卡顿的扩充问题，请确认您的视图类型数量没有超出所需要的数量。RecyclerView 内容中的视图类型越少，屏幕上出现新的内容类型时需要进行的扩充就越少。如果可能的话，可以在适当情况下合并视图类型 - 如果不同类型之间只有图标、颜色或文本片段不同，您可以在绑定时进行这项更改，从而避免膨胀（同时减少应用占用的内存）。</p><p>如果视图类型看起来合适，请考虑降低膨胀导致的开销。减少不必要的容器和结构视图会有所帮助 – 请考虑使用 ConstraintLayout 构建 itemViews，以便轻松减少结构视图。如果您希望真正进行优化以提升性能，内容的层次结构非常简单，并且您不需要复杂的主题和样式功能，可以考虑自己调用构造函数，但是请注意，通常不值得为此牺牲 XML 的简易性和功能。</p><h5 id="RecyclerView：绑定用时过长"><a href="#RecyclerView：绑定用时过长" class="headerlink" title="RecyclerView：绑定用时过长"></a>RecyclerView：绑定用时过长</h5><p>绑定（即 onBindViewHolder(VH, int)）应该非常简单，并且所有内容（最复杂的内容除外）所需的绑定时间都应远远少于 1 毫秒。它应该只从适配器的内部内容数据获取 POJO 内容，并对 ViewHolder 中的视图调用 setter。如果 RV OnBindView 用时很长，请确认在绑定代码中只执行最少量的工作。</p><p>如果您使用简单的 POJO 对象将数据保存在适配器中，可以使用数据绑定库完全避免在 onBindViewHolder 中写入绑定代码。</p><h5 id="布局性能"><a href="#布局性能" class="headerlink" title="布局性能"></a>布局性能</h5><p>如果 Systrace 表明 Choreographer#doFrame 的布局部分执行的工作过多或者执行工作的频率太高，则意味着您遇到了布局性能问题。应用的布局性能取决于视图层次结构的哪个部分包含会发生改变的布局参数或输入。</p><h2 id="进程和线程概览"><a href="#进程和线程概览" class="headerlink" title="进程和线程概览"></a>进程和线程概览</h2><p>当应用组件启动且该应用未运行任何其他组件时，Android 系统会使用单个执行线程为应用启动新的 Linux 进程。默认情况下，同一应用的所有组件会在相同的进程和线程（称为“主”线程）中运行。如果某个应用组件启动且该应用已存在进程（因为存在该应用的其他组件），则该组件会在此进程内启动并使用相同的执行线程。但是，您可以安排应用中的其他组件在单独的进程中运行，并为任何进程创建额外的线程。</p><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>默认情况下，同一应用的所有组件均在相同的进程中运行，且大多数应用都不应改变这一点。但是，如果您发现需要控制某个组件所属的进程，则可在清单文件中执行此操作。</p><p>各类组件元素（<activity>、<service>、<receiver> 和 <provider>）的清单文件条目均支持 android:process 属性，此属性可指定该组件应在哪个进程中运行。您可以设置此属性，使每个组件均在各自的进程中运行，或者使某些组件共享一个进程，而其他组件则不共享。您也可设置 android:process，以便不同应用的组件在同一进程中运行，但前提是这些应用共享相同的 Linux 用户 ID 并使用相同的证书进行签署。</provider></receiver></service></activity></p><p>此外，<application> 元素还支持 android:process 属性，用来设置适用于所有组件的默认值。</application></p><p>当内存不足，而其他更急于为用户提供服务的进程又需要内存时，Android 可能会决定在某一时刻关闭某个进程。正因如此，系统会销毁在被终止进程中运行的应用组件。当这些组件需再次运行时，系统将为其重启进程。</p><p>决定终止哪个进程时，Android 系统会权衡其对用户的相对重要性。例如，相较于托管可见 Activity 的进程而言，系统更有可能关闭托管屏幕上不再可见的 Activity 的进程。因此，是否终止某个进程的决定取决于该进程中所运行组件的状态。</p><p>如需详细了解进程生命周期及其与应用状态的关系，请参阅进程和应用生命周期。</p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>启动应用时，系统会为该应用创建一个称为“main”（主线程）的执行线程。此线程非常重要，因为其负责将事件分派给相应的界面微件，其中包括绘图事件。此外，应用与 Android 界面工具包组件（来自 android.widget 和 android.view 软件包的组件）也几乎都在该线程中进行交互。因此，主线程有时也称为界面线程。但在一些特殊情况下，应用的主线程可能并非其界面线程，相关详情请参阅线程注解。</p><p>系统不会为每个组件实例创建单独的线程。在同一进程中运行的所有组件均在界面线程中进行实例化，并且对每个组件的系统调用均由该线程进行分派。因此，响应系统回调的方法（例如，报告用户操作的 onKeyDown() 或生命周期回调方法）始终在进程的界面线程中运行。</p><h2 id="缩减应用大小"><a href="#缩减应用大小" class="headerlink" title="缩减应用大小"></a>缩减应用大小</h2><h3 id="使用-Android-Size-Analyzer"><a href="#使用-Android-Size-Analyzer" class="headerlink" title="使用 Android Size Analyzer"></a>使用 Android Size Analyzer</h3><p>您可以使用 Android Studio 中的插件市场下载 Android Size Analyzer 插件，如图 1 所示。要打开插件市场并安装该插件，请按以下步骤操作：</p><p>依次选择 File &gt; Settings（或在 Mac 上，依次选择 Android Studio &gt; Preferences）。<br>选择左侧面板中的 Plugins 部分。<br>点击 Marketplace 标签。<br>搜索“Android Size Analyzer”插件。<br>点击分析器插件的 Install 按钮。</p><h3 id="压缩-PNG-文件"><a href="#压缩-PNG-文件" class="headerlink" title="压缩 PNG 文件"></a>压缩 PNG 文件</h3><p>aapt 工具可以在编译过程中通过无损压缩来优化放置在 res/drawable/ 中的图片资源。例如，aapt 工具可以通过调色板将不需要超过 256 种颜色的真彩色 PNG 转换为 8 位 PNG。这样做会生成质量相同但内存占用量更小的图片。</p><h3 id="使用-WebP-文件格式"><a href="#使用-WebP-文件格式" class="headerlink" title="使用 WebP 文件格式"></a>使用 WebP 文件格式</h3><p>如果以 Android 3.2（API 级别 13）及更高版本为目标，您还可以使用 WebP 文件格式的图片（而不是使用 PNG 或 JPEG 文件）。WebP 格式提供有损压缩（如 JPEG）以及透明度（如 PNG），不过与 JPEG 或 PNG 相比，这种格式可以提供更好的压缩效果。</p><h3 id="使用矢量图形"><a href="#使用矢量图形" class="headerlink" title="使用矢量图形"></a>使用矢量图形</h3><p>您可以使用矢量图形创建与分辨率无关的图标和其他可伸缩媒体。使用这些图形可以极大地减少 APK 占用的空间。 矢量图片在 Android 中以 VectorDrawable 对象的形式表示。借助 VectorDrawable 对象，100 字节的文件可以生成与屏幕大小相同的清晰图片。</p><p>不过，系统渲染每个 VectorDrawable 对象需要花费大量时间，而较大的图片则需要更长的时间才能显示在屏幕上。因此，请考虑仅在显示小图片时使用这些矢量图形。</p><h2 id="内存管理概览"><a href="#内存管理概览" class="headerlink" title="内存管理概览"></a>内存管理概览</h2><p>Android 运行时 (ART) 和 Dalvik 虚拟机使用分页和内存映射来管理内存。这意味着应用修改的任何内存，无论修改的方式是分配新对象还是轻触内存映射的页面，都会一直驻留在 RAM 中，并且无法换出。要从应用中释放内存，只能释放应用保留的对象引用，使内存可供垃圾回收器回收。这种情况有一个例外：对于任何未经修改的内存映射文件（如代码），如果系统想要在其他位置使用其内存，可将其从 RAM 中换出。</p><h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p>ART 或 Dalvik 虚拟机之类的受管内存环境会跟踪每次内存分配。一旦确定程序不再使用某块内存，它就会将该内存重新释放到堆中，无需程序员进行任何干预。这种回收受管内存环境中的未使用内存的机制称为“垃圾回收”。垃圾回收有两个目标：在程序中查找将来无法访问的数据对象，并回收这些对象使用的资源。</p><p>Android 的内存堆是分代的，这意味着它会根据分配对象的预期寿命和大小跟踪不同的分配存储分区。例如，最近分配的对象属于“新生代”。当某个对象保持活动状态达足够长的时间时，可将其提升为较老代，然后是永久代。</p><p>堆的每一代对相应对象可占用的内存量都有其自身的专用上限。每当一代开始填满时，系统便会执行垃圾回收事件以释放内存。垃圾回收的持续时间取决于它回收的是哪一代对象以及每一代有多少个活动对象。</p><p>尽管垃圾回收速度非常快，但仍会影响应用的性能。通常情况下，您无法从代码中控制何时发生垃圾回收事件。系统有一套专门确定何时执行垃圾回收的标准。当条件满足时，系统会停止执行进程并开始垃圾回收。如果在动画或音乐播放等密集型处理循环过程中发生垃圾回收，则可能会增加处理时间，进而可能会导致应用中的代码执行超出建议的 16ms 阈值，无法实现高效、流畅的帧渲染。</p><p>此外，您的代码流执行的各种工作可能迫使垃圾回收事件发生得更频繁或导致其持续时间超过正常范围。 例如，如果您在 Alpha 混合动画的每一帧期间，在 for 循环的最内层分配多个对象，则可能会使内存堆受到大量对象的影响。在这种情况下，垃圾回收器会执行多个垃圾回收事件，并可能降低应用的性能。</p><h3 id="谨慎使用服务"><a href="#谨慎使用服务" class="headerlink" title="谨慎使用服务"></a>谨慎使用服务</h3><p>在不需要某项服务时让其保持运行状态，是 Android 应用可能犯下的最严重的内存管理错误之一。如果您的应用需要某项服务在后台执行工作，请不要让其保持运行状态，除非其需要运行作业。请注意在服务完成任务后使其停止运行。否则，您可能会在无意中导致内存泄漏。</p><p>在您启动某项服务后，系统更倾向于让此服务的进程始终保持运行状态。这种行为会导致服务进程代价十分高昂，因为一旦服务使用了某部分 RAM，那么这部分 RAM 就不再可供其他进程使用。这会减少系统可以在 LRU 缓存中保留的缓存进程数量，从而降低应用切换效率。当内存紧张，并且系统无法维护足够的进程以托管当前运行的所有服务时，这甚至可能导致系统出现抖动。</p><p>您通常应该避免使用持久性服务，因为它们会对可用内存提出持续性的要求。我们建议您采用 JobSchedulerJobScheduler 等替代实现方式。要详细了解如何使用 JobScheduler 调度后台进程，请参阅后台优化。</p><p>如果您必须使用某项服务，则限制此服务的生命周期的最佳方式是使用 IntentService，它会在处理完启动它的 intent 后立即自行结束。有关详情，请参阅在后台服务中运行。</p><h3 id="使用经过优化的数据容器"><a href="#使用经过优化的数据容器" class="headerlink" title="使用经过优化的数据容器"></a>使用经过优化的数据容器</h3><p>编程语言所提供的部分类并未针对移动设备做出优化。例如，常规 HashMap 实现的内存效率可能十分低下，因为每个映射都需要分别对应一个单独的条目对象。</p><p>Android 框架包含几个经过优化的数据容器，包括 SparseArray、SparseBooleanArray 和 LongSparseArray。 例如，SparseArray 类的效率更高，因为它们可以避免系统需要对键（有时还对值）进行自动装箱（这会为每个条目分别再创建 1-2 个对象）。</p><p>如果需要，您可以随时切换到原始数组以获得非常精简的数据结构。</p><h3 id="避免内存抖动"><a href="#避免内存抖动" class="headerlink" title="避免内存抖动"></a>避免内存抖动</h3><p>如前所述，垃圾回收事件通常不会影响应用的性能。不过，如果在短时间内发生许多垃圾回收事件，就可能会快速耗尽帧时间。系统花在垃圾回收上的时间越多，能够花在呈现或流式传输音频等其他任务上的时间就越少。</p><p>通常，“内存抖动”可能会导致出现大量的垃圾回收事件。实际上，内存抖动可以说明在给定时间内出现的已分配临时对象的数量。</p><p>例如，您可以在 for 循环中分配多个临时对象。或者，您也可以在视图的 onDraw() 函数中创建新的 Paint 或 Bitmap 对象。在这两种情况下，应用都会快速创建大量对象。这些操作可以快速消耗新生代 (young generation) 区域中的所有可用内存，从而迫使垃圾回收事件发生。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;原文地址:&lt;a href=&quot;https://developer.android.google.cn/topic/performance&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://developer.androi
      
    
    </summary>
    
    
      <category term="android" scheme="http://ShenZhen2017.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>ARTS打卡8</title>
    <link href="http://ShenZhen2017.github.io/blog/2020/12/arts-way-eight.html"/>
    <id>http://ShenZhen2017.github.io/blog/2020/12/arts-way-eight.html</id>
    <published>2020-12-08T08:05:22.000Z</published>
    <updated>2020-12-16T16:00:43.376Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><blockquote><p><a href="https://leetcode-cn.com/contest/weekly-contest-219/problems/count-of-matches-in-tournament/" target="_blank" rel="noopener">5625. 比赛中的配对次数</a><br>给你一个整数 n ，表示比赛中的队伍数。比赛遵循一种独特的赛制：<br>如果当前队伍数是 偶数 ，那么每支队伍都会与另一支队伍配对。总共进行 n / 2 场比赛，且产生 n / 2 支队伍进入下一轮。<br>如果当前队伍数为 奇数 ，那么将会随机轮空并晋级一支队伍，其余的队伍配对。总共进行 (n - 1) / 2 场比赛，且产生 (n - 1) / 2 + 1 支队伍进入下一轮。<br>返回在比赛中进行的配对次数，直到决出获胜队伍为止。</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">numberOfMatches</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n==<span class="number">0</span>||n==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">if</span> (n%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">            n/<span class="number">2</span>+numberOfMatches(n/<span class="number">2</span>)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            (n-<span class="number">1</span>)/<span class="number">2</span> + numberOfMatches((n-<span class="number">1</span>)/<span class="number">2</span>+<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p><a href="https://developers.google.cn/codelabs/advanced-android-kotlin-training-property-animation#0" target="_blank" rel="noopener">https://developers.google.cn/codelabs/advanced-android-kotlin-training-property-animation#0</a><br>本文主要讲述了android属性动画，是MotionLayout动画的前置知识</p><h2 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h2><h3 id="Git合并多个commit的操作"><a href="#Git合并多个commit的操作" class="headerlink" title="Git合并多个commit的操作"></a>Git合并多个commit的操作</h3><p>当我们需要合并多个提交时，可以使用git rebase -i<br>详情可见：<a href="https://www.jianshu.com/p/964de879904a" target="_blank" rel="noopener">「Git」合并多个 Commit</a></p><h3 id="LineHeight失效问题"><a href="#LineHeight失效问题" class="headerlink" title="LineHeight失效问题"></a>LineHeight失效问题</h3><p>lineHeight的兼容性不好，在很多机型上会失效<br>建议使用lineSpacingExtra替代</p><h3 id="部分机型虚线绘制失效的问题"><a href="#部分机型虚线绘制失效的问题" class="headerlink" title="部分机型虚线绘制失效的问题"></a>部分机型虚线绘制失效的问题</h3><p>直接使用DashEffect会有部分机型失效的问题，可以使用以下方法绘制虚线<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">drawHDashLine</span><span class="params">(canvas: <span class="type">Canvas</span>?, startX: <span class="type">Float</span>, stopX: <span class="type">Float</span>, lineY: <span class="type">Float</span>, paintChineseMindLine: <span class="type">Paint</span>, line: <span class="type">Float</span>, empty: <span class="type">Float</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">var</span> drawPointX = startX</span><br><span class="line">            <span class="keyword">var</span> isLine = <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> (drawPointX &lt; stopX) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isLine == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">val</span> start = drawPointX</span><br><span class="line">                    drawPointX = <span class="keyword">if</span> ((drawPointX + line) &gt;= stopX) stopX <span class="keyword">else</span> drawPointX + line</span><br><span class="line">                    canvas?.drawLine(start, lineY, drawPointX, lineY, paintChineseMindLine)</span><br><span class="line">                    isLine = <span class="number">0</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    drawPointX = <span class="keyword">if</span> ((drawPointX + empty) &gt;= stopX) stopX <span class="keyword">else</span> drawPointX + empty</span><br><span class="line">                    isLine = <span class="number">1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p><h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p>本周主要是翻译：<br>【译】取代Android的LiveData:StateFlow还是SharedFlow？<br>详情可见：<a href="https://shenzhen2017.github.io/blog/2020/12/translate-substituing-liveData.html">https://shenzhen2017.github.io/blog/2020/12/translate-substituing-liveData.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Algorithm&quot;&gt;&lt;a href=&quot;#Algorithm&quot; class=&quot;headerlink&quot; title=&quot;Algorithm&quot;&gt;&lt;/a&gt;Algorithm&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.
      
    
    </summary>
    
    
      <category term="ARTS" scheme="http://ShenZhen2017.github.io/tags/ARTS/"/>
    
  </entry>
  
  <entry>
    <title>【2020年终总结】程序员的三年之痒</title>
    <link href="http://ShenZhen2017.github.io/blog/2020/12/2020-sum-up.html"/>
    <id>http://ShenZhen2017.github.io/blog/2020/12/2020-sum-up.html</id>
    <published>2020-12-06T02:05:32.000Z</published>
    <updated>2020-12-16T16:00:43.376Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对程序员来说，三年是个坎。<br>三年时间，足以让一个刚出校门的年轻人成长为一个真正的打工人。<br>三年时间，可以积累一定的工作经验，拥有一定的技术成长。<br>三年时间，不算太长也不算太短，是一个跳槽的好时机，毕竟有不少工作都是要求3年以上经验。   </p><p>这大概就是程序员三年之痒的来源~   </p><h2 id="2020的收获"><a href="#2020的收获" class="headerlink" title="2020的收获"></a>2020的收获</h2><p>2020是一个神奇的一年，发生了许多大事，但回到个人身上也只是一件一件小事。<br>一件一件小事本没有什么意义，但只要注意积累，重复练习，积少成多，应该也会有一定的价值~<br>下面总结一些2020年的一些小收获   </p><ul><li>完成了第一次跳槽</li><li>掘金升级到了Lv2,阅读量3万+</li><li>拿到了掘金搪瓷杯和卫衣</li><li>有两篇文章被鸿洋大神转载了</li><li>坚持了ARTS打卡</li><li>坚持了每周的总结与下周规划</li></ul><h2 id="2021的展望"><a href="#2021的展望" class="headerlink" title="2021的展望"></a>2021的展望</h2><p>2021,新的一年，新的开始<br>下面列出2021的一些目标与展望        </p><ul><li>掘金升级到LV4</li><li>做一个100以上star的Github开源项目</li><li>读几本计算机原理，计算机网络，数据结构等基础领域的书</li><li>掌握flutter的使用与相关原理</li><li>最后，希望以上都能实现</li></ul><h2 id="一些面试资源"><a href="#一些面试资源" class="headerlink" title="一些面试资源"></a>一些面试资源</h2><p>今年完成了第一次跳槽，积累了一些面试相关的资源，在这里总结一下，希望对读者有用。   </p><h3 id="简历"><a href="#简历" class="headerlink" title="简历"></a>简历</h3><p>首先是简历，一般找一个模板，填写掌握的技能和项目经历即可。<br>github上有一个不错的模板，详情可见：<a href="https://github.com/CyC2018/Markdown-Resume" target="_blank" rel="noopener">https://github.com/CyC2018/Markdown-Resume</a><br>项目clone后，个性Resuem.md即可，然后导出为pdf文件。<br>简历建议长度为2页，太长太短都不好。<br>建议用掌握与熟练掌握取代了解与精通。    </p><h3 id="刷题"><a href="#刷题" class="headerlink" title="刷题"></a>刷题</h3><p>算法题可以说是现在找工作必刷的了。不过根据我面试的经验，算法题总得来说问的还是比较少，还有一些公司是基本不问算法的。<br>当然如果碰到字节，快手这种每轮都问算法的公司，如果因为算法题拿不到offer就很可惜了。<br>算法题就好像高考语文的古诗词默写一样，分不多，但丢了就很可惜了。<br>根据我的经验，大概刷了，掌握100道题就足以应付面试了。<br>当然完全掌握需要重复练习，不是刷了一遍就可以的。<br>这里推荐一下极客时间上覃超的五遍刷题法    </p><h4 id="五遍刷题法"><a href="#五遍刷题法" class="headerlink" title="五遍刷题法"></a>五遍刷题法</h4><p>1.第一遍，直接看解法<br>多解法，比较解法优劣，默写好的解法<br>2.第二遍，打开leetcode，直接开始写<br>多种解法比较，调优<br>3.第三遍，过一天之后，再重复做题<br>4.第四遍，过了一周，再来反复练<br>5.第五遍，面试前一周，恢复性训练      </p><p>极客时间上每周四覃超老师都会直播面试，比较精彩，大家可以去看看。当然也没有必要去买算法课，看一看直播，了解下刷题的思路即可。<br>通过以上方法重复练习，大概刷100题就足以应付面试，如果每天刷3道，大概准备一个月即可    </p><h3 id="题库"><a href="#题库" class="headerlink" title="题库"></a>题库</h3><p>刷题也要注意，不要一题一题刷，比如Leetcode的每日一题<br>建议按知识点分类，这样比较方便重复练习与知识点掌握<br>在知识点刷过一遍后，也可以按照公司分类或者LeetCode热题100刷，一般公司出算法题也是有题库的<br>下面推荐几个题库供大家使用</p><h4 id="按知识点分类"><a href="#按知识点分类" class="headerlink" title="按知识点分类"></a>按知识点分类</h4><p><a href="https://github.com/yuanguangxin/LeetCode" target="_blank" rel="noopener">https://github.com/yuanguangxin/LeetCode</a><br><a href="https://github.com/zhangyixing1007/leetcode" target="_blank" rel="noopener">https://github.com/zhangyixing1007/leetcode</a>     </p><h4 id="按公司分类"><a href="#按公司分类" class="headerlink" title="按公司分类"></a>按公司分类</h4><p><a href="https://github.com/afatcoder/LeetcodeTop" target="_blank" rel="noopener">https://github.com/afatcoder/LeetcodeTop</a>    </p><h4 id="热题100"><a href="#热题100" class="headerlink" title="热题100"></a>热题100</h4><p><a href="https://zhuanlan.zhihu.com/p/84230862" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/84230862</a>    </p><h3 id="一些高质量面经总结"><a href="#一些高质量面经总结" class="headerlink" title="一些高质量面经总结"></a>一些高质量面经总结</h3><p><a href="https://juejin.cn/post/6876968255597051917" target="_blank" rel="noopener">三年经验Android开发面经总结</a><br><a href="https://github.com/Moosphan/Android-Daily-Interview" target="_blank" rel="noopener">Android面试每日一题,内容很多，包罗万象</a><br><a href="https://carlwe.com/2019/12/07/Android%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86%E9%94%A6/" target="_blank" rel="noopener">Android面试题集锦</a><br><a href="https://juejin.cn/post/6844904155153170439" target="_blank" rel="noopener">这些年，我所经历的所有面试｜写给正在求职的 Androider</a>    </p><h2 id="一些学习方法"><a href="#一些学习方法" class="headerlink" title="一些学习方法"></a>一些学习方法</h2><p>如上文所说，坚持是一件很难的事。正因为如此，我们需要通过一些方法来辅助我们。<br>提高放弃的成本，增强坚持下去的成就感，提高最终坚持下去的概率。   </p><h3 id="ARTS打卡"><a href="#ARTS打卡" class="headerlink" title="ARTS打卡"></a>ARTS打卡</h3><p>在开始ARTS打卡之前，先介绍一下什么是ARTS<br>ARTS 源于极客时间《左耳听风》专栏组织的一个学习打卡活动，四个字母对应着四个行动准则：     </p><ul><li>Algorithm：每周至少做一个 leetcode 的算法题</li><li>Review: 阅读并点评一篇英文技术文章</li><li>Tip：学习至少一个技术技巧</li><li>Share：[撰写并]分享一篇有观点和思考的技术文章<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog8/p1.png" alt></li></ul><p>ARTS打卡将坚持拆解成一个一个小任务，当你不太清楚该做什么的时候，当你感觉常常不了了之的时候，可以尝试下ARTS每周打卡。<br>为了提高坚持下去的动力，可以组建一个打卡群，或者发给朋友之类的，提高坚持下去的概率。<br>下面是我每周打卡的一些内容，读者可以参考下<br><a href="https://shenzhen2017.github.io/blog/2020/12/arts-way-seven.html">ARTS打卡7</a><br><a href="https://shenzhen2017.github.io/blog/2020/11/arts-way-six.html">ARTS打卡6</a></p><h3 id="每周总结与下周计划"><a href="#每周总结与下周计划" class="headerlink" title="每周总结与下周计划"></a>每周总结与下周计划</h3><p>为了实现预定的目标，我们需要将任务拆分成一个个小模块，每周制定计划并统计每周的完成率。<br>这样也有利于提高我们坚持下去的概率<br>最初我是在<a href="https://juejin.cn/user/4318537403878167" target="_blank" rel="noopener">jsonchao</a>大神在群里看到的<br>jsonchao大神关于性能优化的系列文章都很优秀，有需要的读者可以关注下         </p><p>jsonchao每周都会在群里发自己的学习计划与完成情况，在他的影响下我也逐渐开始用起了这个学习方法<br>下面给出每周总结与下周计划的示例，用的网站是<a href="http://mubu.com/app" target="_blank" rel="noopener">http://mubu.com/app</a><br><img src="https://raw.githubusercontent.com/shenzhen2017/Goal/master/2020/9%E6%9C%887%E6%97%A5%E8%87%B39%E6%9C%8813%E6%97%A5%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92.png" alt><br><img src="https://raw.githubusercontent.com/shenzhen2017/Goal/master/2020/9%E6%9C%887%E6%97%A5%E8%87%B39%E6%9C%8813%E6%97%A5%E5%AD%A6%E4%B9%A0%E5%AE%8C%E6%88%90%E6%83%85%E5%86%B5.png" alt><br>如果读者觉得有用，也可以尝试下这种方法  </p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>定目标是简单的，但更简单的是没有完成目标。<br>相信大家都有很多类似的体验，年初定好的计划，往往不了了之。<br>达成目标并不是一件简单的事，但我相信我们可以通过坚持做一件件简单的事来达成目标。<br>毕竟，坚持是一件最不简单的事   </p><p>罗老师曾经说过     </p><blockquote><p>“把车停到公司楼下， 我摸了摸，给同事买的几盒炒面依然滚烫。<br>去时的大雪完全停了，我打开天窗，车顶残留的雪落了我一头，能看到很多星星，凉凉的空气好得不像话，喇叭里的音乐也从重金属变成了钢琴曲…<br>突然我就伤感起来了：你只是勤奋工作，努力做好自己，结果很多你的同行就要倒闭了…生命真残酷啊。”<br>——罗永浩</p></blockquote><p>如果我们能够勤奋工作，努力做好自己，相信年底回过头来，会发现这一年有不少收获，会发现自己已经走出了很远。<br>2021,共勉~    </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;对程序员来说，三年是个坎。&lt;br&gt;三年时间，足以让一个刚出校门的年轻人成长为一个真正的打工人。&lt;br&gt;三年时间，可以积累一定的工作经验，拥有
      
    
    </summary>
    
    
      <category term="总结" scheme="http://ShenZhen2017.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>ARTS打卡7</title>
    <link href="http://ShenZhen2017.github.io/blog/2020/12/arts-way-seven.html"/>
    <id>http://ShenZhen2017.github.io/blog/2020/12/arts-way-seven.html</id>
    <published>2020-12-01T13:39:41.000Z</published>
    <updated>2020-12-16T16:00:43.376Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><blockquote><p><a href="https://leetcode-cn.com/contest/weekly-contest-218/problems/goal-parser-interpretation/" target="_blank" rel="noopener">5617. 设计 Goal 解析器</a><br>请你设计一个可以解释字符串 command 的 Goal 解析器 。command 由 “G”、”()” 和/或 “(al)” 按某种顺序组成。Goal 解析器会将 “G” 解释为字符串 “G”、”()” 解释为字符串 “o” ，”(al)” 解释为字符串 “al” 。然后，按原顺序将经解释得到的字符串连接成一个字符串。<br>给你字符串 command ，返回 Goal 解析器 对 command 的解释结果。</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">interpret</span><span class="params">(command: <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">val</span> stack = Stack&lt;<span class="built_in">Char</span>&gt;()</span><br><span class="line">        <span class="keyword">val</span> result = StringBuilder()</span><br><span class="line">        command.forEach &#123;</span><br><span class="line">            <span class="keyword">if</span> (it == <span class="string">'G'</span>)&#123;</span><br><span class="line">                result.append(it)</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                stack.push(it)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (it == <span class="string">')'</span>)&#123;</span><br><span class="line">                <span class="keyword">val</span> item = StringBuilder()</span><br><span class="line">                <span class="keyword">while</span> (stack.isNotEmpty())&#123;</span><br><span class="line">                    item.append(stack.pop())</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (item.toString() == <span class="string">")("</span>)&#123;</span><br><span class="line">                    result.append(<span class="string">"o"</span>)</span><br><span class="line">                &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                    result.append(<span class="string">"al"</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.toString()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p><a href="https://developer.android.google.cn/topic/libraries/view-binding/migration" target="_blank" rel="noopener">https://developer.android.google.cn/topic/libraries/view-binding/migration</a><br>Android Kotlin Extensions 插件最初由 JetBrains 开发,其中Synthetic 视图 : 可以将调用 findViewById 替换为使用 kotlinx.android.synthetic 进行 UI 交互。<br>极大的方便了用户的使用<br>但 Kotlin synthetic 却存在一些弊端:</p><ul><li>污染全局命名空间</li><li>不能暴露可空性信息</li><li>仅支持 Kotlin 代码</li></ul><p>因此android官方将弃用Synthetic视图<br>弃用期随着 Kotlin 1.4.20 的发布正式开始。android-kotlin-extensions 将继续保留至少一年时间，但在 2021 年 9 月或之后的 Kotlin 版本中将被移除<br>详情可见:<a href="https://juejin.cn/post/6902226860080529421" target="_blank" rel="noopener">Kotlin Android Extensions 的未来计划</a></p><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><h3 id="解决TabLayout在平板上无法全屏的问题"><a href="#解决TabLayout在平板上无法全屏的问题" class="headerlink" title="解决TabLayout在平板上无法全屏的问题"></a>解决TabLayout在平板上无法全屏的问题</h3><p>​​具体的参数设置如下：</p><ol><li>宽度一定要设置成 match_parent, 即 android:layout_width=”match_parent”</li><li>tabGravity设置成fill, 即  app:tabGravity=”fill”</li><li>tabMaxWidth设置成 0dp, 即 app:tabMaxWidth=”0dp”</li><li>tabMode设置成fixed, 即 app:tabMode=”fixed”<br>完成以上四步就可以铺满整个屏幕宽度了</li></ol><p>实际测试发现只需要添加tabGravity即可<br>详情可见：<a href="https://blog.csdn.net/qq_29742677/article/details/84339690" target="_blank" rel="noopener">Android TabLayout宽度在平板上未铺满解决方案</a></p><h3 id="PopWindow的版本兼容问题"><a href="#PopWindow的版本兼容问题" class="headerlink" title="PopWindow的版本兼容问题"></a>PopWindow的版本兼容问题</h3><p>popWindow在android7.0以上及之下的表现行为不太一样<br>主流解决方法大概如下：<br>①重写showAsDropDown()，以24为界限，区别对待；<br>②调用show的时候，SDK&gt;24的时用showAtLocation（）替代showAsDropDown()；</p><p>详情可见：<br><a href="https://blog.csdn.net/iblade/article/details/100073141" target="_blank" rel="noopener">PopupWindow显示位置错乱，真正的终极方案。</a><br><a href="https://blog.csdn.net/alwaysGoalong/article/details/80455427" target="_blank" rel="noopener">Android 7.0中PopupWindow设置位置不生效解决方法（亲测可用）</a></p><h3 id="自定义drawable复用问题"><a href="#自定义drawable复用问题" class="headerlink" title="自定义drawable复用问题"></a>自定义drawable复用问题</h3><p>在我们使用一些自定义drawable时，比如圆角矩形时，常常只会是背景颜色与圆角角度不一样<br>而这样就重复需要定义一些drawable文件，而这就会带来类爆炸</p><p>一个解决drawable类爆炸的解决方法是使用GradientDrawable，结合kotlin扩展，可以方便的解决自定义drawable复用的问题<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> View.<span class="title">setRoundRectBg</span><span class="params">(color: <span class="type">Int</span> = Color.WHITE, cornerRadius: <span class="type">Int</span> = <span class="number">15.</span>dp)</span></span> &#123;</span><br><span class="line">    background = GradientDrawable().apply &#123;</span><br><span class="line">        setColor(color)</span><br><span class="line">        setCornerRadius(cornerRadius.toFloat())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>详情可见：<a href="https://mp.weixin.qq.com/s/yJM64wm07S3dqdvMvtaHcA" target="_blank" rel="noopener">无需自定义 View，巧妙利用 xml 属性，避免 drawable 泛滥</a></p><h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p><a href="https://shenzhen2017.github.io/blog/2020/12/2020-sum-up.html">【2020年终总结】程序员的三年之痒</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Algorithm&quot;&gt;&lt;a href=&quot;#Algorithm&quot; class=&quot;headerlink&quot; title=&quot;Algorithm&quot;&gt;&lt;/a&gt;Algorithm&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.
      
    
    </summary>
    
    
      <category term="ARTS" scheme="http://ShenZhen2017.github.io/tags/ARTS/"/>
    
  </entry>
  
  <entry>
    <title>ARTS打卡6</title>
    <link href="http://ShenZhen2017.github.io/blog/2020/11/arts-way-six.html"/>
    <id>http://ShenZhen2017.github.io/blog/2020/11/arts-way-six.html</id>
    <published>2020-11-24T01:54:50.000Z</published>
    <updated>2020-12-16T16:00:43.376Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><blockquote><p><a href="https://leetcode-cn.com/contest/weekly-contest-217/problems/richest-customer-wealth/" target="_blank" rel="noopener">5613. 最富有客户的资产总量</a><br>给你一个 m x n 的整数网格 accounts ，其中 accounts[i][j] 是第 i​​​​​​​​​​​​ 位客户在第 j 家银行托管的资产数量。返回最富有客户所拥有的 资产总量 。<br>客户的 资产总量 就是他们在各家银行托管的资产数量之和。最富有客户就是 资产总量 最大的客户。</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">maximumWealth</span><span class="params">(accounts: <span class="type">Array</span>&lt;<span class="type">IntArray</span>&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> max = <span class="number">0</span></span><br><span class="line">        accounts.forEach &#123;</span><br><span class="line">            max = maxOf(max,it.sum())</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p><a href="https://proandroiddev.com/should-we-choose-kotlins-stateflow-or-sharedflow-to-substitute-for-android-s-livedata-2d69f2bd6fa5" target="_blank" rel="noopener">Substituting Android’s LiveData: StateFlow or SharedFlow?</a><br>本文主要讲述了使用sharedFlow和stateFlow替换liveData的一些尝试</p><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><h3 id="kotin接口支持SAM转换"><a href="#kotin接口支持SAM转换" class="headerlink" title="kotin接口支持SAM转换"></a>kotin接口支持SAM转换</h3><p>什么是SAM转换？可能有的同学还不太了解，这里先科普一下：</p><p>SAM 转换，即 Single Abstract Method Conversions，就是对于只有单个非默认抽象方法接口的转换 —— 对于符合这个条件的接口（称之为 SAM Type ），在 Kotlin 中可以直接用 Lambda 来表示 —— 当然前提是 Lambda 的所表示函数类型能够跟接口的中方法相匹配。</p><p>在Kotlin1.4之前，Kotlin是不支持Kotlin的SAM转换的，可以支持Java SAM转换，官方给出的的解释是：是 Kotlin 本身已经有了函数类型和高阶函数，不需要在去SAM转化。 这个解释开发者并不买账，如果你用过Java Lambda和Fuction Interface。当你切换到Kotlin时，就会很懵逼。看来Kotlin是意识到了这个，或者是看到开发者的反馈，终于支持了。</p><p>在1.4之前，只能传递一个对象，是不支持Kotlin SAM的，而在1.4之后，可以支持Kotlin SAM,但是用法有一丢丢变化。interface需要使用fun关键字声明。使用fun关键字标记接口后，只要将此类接口作为参数，就可以将lambda作为参数传递。</p><p>详情可见：<a href="https://juejin.cn/post/6844904132449402887" target="_blank" rel="noopener">Kotlin1.4-M1发布，终于支持Kotlin interface SAM转换了！</a></p><h3 id="消除Obsever警告"><a href="#消除Obsever警告" class="headerlink" title="消除Obsever警告"></a>消除Obsever警告</h3><p>在升级到kotlin1.4之后，会有警告Live Data: Candidate resolution will be changed soon<br>解决方法：去除引用import androidx.lifecycle.observe即可<br>原因：kotlin1.4之后支持SAM转换，不再需要自定义的扩展，如下所示：<br><figure class="highlight plain"><figcaption><span>inline fun <t> LiveData<t>.observe(</t></t></span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    owner: LifecycleOwner,</span><br><span class="line">    crossinline onChanged: (T) -&gt; Unit</span><br><span class="line">): Observer&lt;T&gt; &#123;</span><br><span class="line">    val wrappedObserver = Observer&lt;T&gt; &#123; t -&gt; onChanged.invoke(t) &#125;</span><br><span class="line">    observe(owner, wrappedObserver)</span><br><span class="line">    return wrappedObserver</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>详情可见：<a href="https://stackoverflow.com/questions/64045082/live-data-candidate-resolution-will-be-changed-soon" target="_blank" rel="noopener">https://stackoverflow.com/questions/64045082/live-data-candidate-resolution-will-be-changed-soon</a></p><h3 id="kotlin委托属性"><a href="#kotlin委托属性" class="headerlink" title="kotlin委托属性"></a>kotlin委托属性</h3><p>从 Kotlin 1.4 开始，一个属性可以把它的 getter 与 setter 委托给另一个属性。这种委托对于顶层和类的属性（成员和扩展）都可用。该委托属性可以为：<br>1.顶层属性<br>2.同一个类的成员或扩展属性<br>3.另一个类的成员或扩展属性</p><p>为将一个属性委托给另一个属性，应在委托名称中使用恰当的 :: 限定符，例如，this::delegate 或 MyClass::delegate<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span>(<span class="keyword">var</span> memberInt: <span class="built_in">Int</span>, <span class="keyword">val</span> anotherClassInstance: ClassWithDelegate) &#123;</span><br><span class="line">    <span class="keyword">var</span> delegatedToMember: <span class="built_in">Int</span> <span class="keyword">by</span> <span class="keyword">this</span>::memberInt</span><br><span class="line">    <span class="keyword">var</span> delegatedToTopLevel: <span class="built_in">Int</span> <span class="keyword">by</span> ::topLevelInt</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">val</span> delegatedToAnotherClass: <span class="built_in">Int</span> <span class="keyword">by</span> anotherClassInstance::anotherClassInt</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> MyClass.extDelegated: <span class="built_in">Int</span> <span class="keyword">by</span> ::topLevelInt</span><br></pre></td></tr></table></figure></p><p>这是很有用的，例如，当想要以一种向后兼容的方式重命名一个属性的时候：引入一个新的属性、 使用 @Deprecated 注解来注解旧的属性、并委托其实现。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> newName: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">   <span class="meta">@Deprecated(<span class="meta-string">"Use 'newName' instead"</span>, ReplaceWith(<span class="meta-string">"newName"</span>)</span>)</span><br><span class="line">   <span class="keyword">var</span> oldName: <span class="built_in">Int</span> <span class="keyword">by</span> <span class="keyword">this</span>::newName</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">val</span> myClass = MyClass()</span><br><span class="line">   <span class="comment">// 通知：'oldName: Int' is deprecated.</span></span><br><span class="line">   <span class="comment">// Use 'newName' instead</span></span><br><span class="line">   myClass.oldName = <span class="number">42</span></span><br><span class="line">   println(myClass.newName) <span class="comment">// 42</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>详情可见：<a href="https://www.kotlincn.net/docs/reference/delegated-properties.html" target="_blank" rel="noopener">kotlin委托属性</a></p><h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p>本周主要总结了kotlin协程的一些基本概念<br><a href="https://shenzhen2017.github.io/blog/2020/11/kotlin-coroutine-start.html">协程初步</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Algorithm&quot;&gt;&lt;a href=&quot;#Algorithm&quot; class=&quot;headerlink&quot; title=&quot;Algorithm&quot;&gt;&lt;/a&gt;Algorithm&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.
      
    
    </summary>
    
    
      <category term="ARTS" scheme="http://ShenZhen2017.github.io/tags/ARTS/"/>
    
  </entry>
  
  <entry>
    <title>协程初步</title>
    <link href="http://ShenZhen2017.github.io/blog/2020/11/kotlin-coroutine-start.html"/>
    <id>http://ShenZhen2017.github.io/blog/2020/11/kotlin-coroutine-start.html</id>
    <published>2020-11-22T13:57:27.000Z</published>
    <updated>2020-12-16T16:00:43.376Z</updated>
    
    <content type="html"><![CDATA[<h2 id="协程的基本概念"><a href="#协程的基本概念" class="headerlink" title="协程的基本概念"></a>协程的基本概念</h2><ul><li>协程是可以由程序自行控制挂起，恢复的程序</li><li>协程可以用来实现多任务的协作执行</li><li>协程可以用来解决异步在任务控制流中的灵活转移</li></ul><h3 id="协程的作用"><a href="#协程的作用" class="headerlink" title="协程的作用"></a>协程的作用</h3><ul><li>协程可以让异步代码同步化</li><li>协程可以降低异步代码的程序复杂度</li><li>同步代码比异步代码更灵活，更容易实现复杂业务</li></ul><h3 id="线程VS协程"><a href="#线程VS协程" class="headerlink" title="线程VS协程"></a>线程VS协程</h3><p>线程是抢占式的，协程是协作式的<br>线程是根据时间片轮转，由操作系统调度<br>协程则是程序之间相互协作<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog8/p1.jpg" alt></p><h4 id="Kotlin协程只是个“线程框架”"><a href="#Kotlin协程只是个“线程框架”" class="headerlink" title="Kotlin协程只是个“线程框架”?"></a>Kotlin协程只是个“线程框架”?</h4><ul><li>运行在线程上的框架不一定就是“线程框架”，例如所有框架</li><li>支持线程切换的框架也不一定就是”线程框架” ,例如OkHttp</li></ul><h3 id="协程的主要内容"><a href="#协程的主要内容" class="headerlink" title="协程的主要内容"></a>协程的主要内容</h3><p>如下图所示：<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog8/p2.png" alt></p><h3 id="协程的分类"><a href="#协程的分类" class="headerlink" title="协程的分类"></a>协程的分类</h3><h4 id="按调用栈"><a href="#按调用栈" class="headerlink" title="按调用栈"></a>按调用栈</h4><p>1.有栈协程:每个协程会分配单独的调用栈,类似线程的调用栈<br>2.无栈协程:不会分配单独的调用栈,挂起点状态通过闭包或对象保存</p><h4 id="按调用关系"><a href="#按调用关系" class="headerlink" title="按调用关系"></a>按调用关系</h4><p>1.对称协程:调度权可以转移给任意协程,协程之间是对等关系<br>2.非对称协程:调度权只能转移给调用自己的协程,协程存在父子关系</p><h2 id="kotlin协程的基本要素"><a href="#kotlin协程的基本要素" class="headerlink" title="kotlin协程的基本要素"></a>kotlin协程的基本要素</h2><h3 id="挂起函数"><a href="#挂起函数" class="headerlink" title="挂起函数"></a>挂起函数</h3><ul><li>挂起函数:以suspend修饰的函数</li><li>挂起函数只能在其他挂起函数或协程中调用</li><li>挂起函数调用时包含了协程“挂起”的语义</li><li>挂起函数返回时则包含了协程“恢复”的语义</li></ul><h3 id="挂起函数怎么做到挂起和恢复？"><a href="#挂起函数怎么做到挂起和恢复？" class="headerlink" title="挂起函数怎么做到挂起和恢复？"></a>挂起函数怎么做到挂起和恢复？</h3><p>当我们写下面这样一个方法的时候<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Temp</span> </span>&#123;</span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后将他编译，获得其java字节码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Temp</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title">test</span><span class="params">(@NotNull Continuation $completion)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> Unit.INSTANCE;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，挂起函数中默认有一个不可见的参数Continuation<br>挂起函数的挂起与恢复即利用这个Continuation参数来实现的<br>成功时回调Continuation.resume,失败时回调Continuation.resumeWithException</p><p>下面看一个将回调转写成挂起函数的例子，利用suspendCoroutine实现将retrofit的回调转化成挂起函数<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getUserSuspend</span><span class="params">(name: <span class="type">String</span>)</span></span> = suspendCoroutine&lt;User&gt;&#123;continuation -&gt;</span><br><span class="line">        githubApi.getUserCallback(name).enqueue( <span class="keyword">object</span> : Callback&lt;User&gt;&#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFailure</span><span class="params">(call: <span class="type">Call</span>&lt;<span class="type">User</span>&gt;, t: <span class="type">Throwable</span>)</span></span> =</span><br><span class="line">            continuation.resumeWithException<span class="string">'t)</span></span><br><span class="line"><span class="string">        override fun onResponse(call: Call&lt;User&gt;, response: Response&lt;User&gt;) =</span></span><br><span class="line"><span class="string">            response.takeIf(it.isSuccessfu /)?.body()?.let (continuation:resume)</span></span><br><span class="line"><span class="string">        &#125;)</span></span><br><span class="line"><span class="string">    &#125;</span></span><br></pre></td></tr></table></figure></p><h3 id="协程上下文"><a href="#协程上下文" class="headerlink" title="协程上下文"></a>协程上下文</h3><p>协程上下文是一个数据集合</p><ul><li>协程执行过程中需要携带数据</li><li>索弓|是CoroutineContext.Key</li><li>元素是CoroutineContext. Element</li></ul><h4 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h4><ul><li>拦截器ContinuationInterceptor是一类协程上下文元素</li><li>可以对协程上下文所在协程的Continuation进行拦截</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">interceptContinuation</span><span class="params">(continuation: <span class="type">Continuation</span>&lt;<span class="type">T</span>&gt;)</span></span>: Continuation&lt;T&gt;</span><br></pre></td></tr></table></figure><p>利用拦截器可以实现线程切换</p><h2 id="手写Python生成器"><a href="#手写Python生成器" class="headerlink" title="手写Python生成器"></a>手写Python生成器</h2><p>python语法中也存在协程，我们先介绍一下python中协程的简单用法<br>要理解协程，首先需要知道生成器是什么。生成器其实就是不断产出值的函数，只不过在函数中需要使用yield这一个关键词将值产出。下面来看一个例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen</span><span class="params">()</span>:</span></span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">yield</span> n</span><br><span class="line">        n += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">g = gen()</span><br><span class="line">print(g)  <span class="comment"># &lt;generator object gen at 0x00000246E165A7C8&gt;</span></span><br><span class="line">print(next(g))  <span class="comment"># 输出结果为0</span></span><br><span class="line">print(next(g))  <span class="comment"># 输出结果为1</span></span><br></pre></td></tr></table></figure></p><p>我们调用gen()函数并不会直接执行该函数，而是会得到一个生成器对象。对这个生成器对象调用next()函数，这个生成器对象会开始执行到第一个yield处，于是产出一个值0，注意：这时候gen()就暂停在yield处，直到第二次调用next()函数。</p><p>到这里我们可以发现，生成器函数是可以暂停的函数，它在调用方的驱使下（调用方使用next()函数），每次执行到yield处将yield后方的值产出给调用方后就暂停自己的执行，直到调用方下一次驱动它执行。</p><p>接下来看看我们怎么使用kotlin实现同样的效果</p><h3 id="1-先看看最终要实现的调用代码"><a href="#1-先看看最终要实现的调用代码" class="headerlink" title="1.先看看最终要实现的调用代码"></a>1.先看看最终要实现的调用代码</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> nums = generator &#123; start: <span class="built_in">Int</span> -&gt;</span><br><span class="line">            <span class="comment">//限制yield的调用范围，只能在lambda中使用</span></span><br><span class="line">            <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span>..<span class="number">5</span>) &#123;</span><br><span class="line">                yield(start + i)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> seqs = nums(<span class="number">10</span>)</span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> seqs)&#123;</span><br><span class="line">            println(j)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上面就是我们最终要实现的效果<br>可以看出，我们需要实现的有<br>1.generator方法<br>2.generator方法获得的结果需要支持Iterator接口<br>3.yield方法<br>4.yield需要限制在一定的范围之内</p><h3 id="2-Generator接口与实现"><a href="#2-Generator接口与实现" class="headerlink" title="2.Generator接口与实现"></a>2.Generator接口与实现</h3><h4 id="定义Generator接口"><a href="#定义Generator接口" class="headerlink" title="定义Generator接口"></a>定义Generator接口</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Generator</span>&lt;<span class="type">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">iterator</span><span class="params">()</span></span>: Iterator&lt;T&gt;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="定义Generator实现"><a href="#定义Generator实现" class="headerlink" title="定义Generator实现"></a>定义Generator实现</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GeneratorImpl</span>&lt;<span class="type">T</span>&gt;</span>(</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> block: <span class="keyword">suspend</span> GeneratorScope&lt;T&gt;.(T) -&gt; <span class="built_in">Unit</span>,</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> parameter: T</span><br><span class="line">    ) : Generator&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">iterator</span><span class="params">()</span></span>: Iterator&lt;T&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> GeneratorIterator(block, parameter)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="定义GeneratorScope"><a href="#定义GeneratorScope" class="headerlink" title="定义GeneratorScope"></a>定义GeneratorScope</h4><p>为了限定yield方法的使用范围，需要定义GeneratorScope<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">GeneratorScope</span>&lt;<span class="type">T</span>&gt; <span class="keyword">internal</span> <span class="keyword">constructor</span></span>() &#123;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">val</span> parameter: T</span><br><span class="line">        <span class="keyword">abstract</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">yield</span><span class="params">(value: <span class="type">T</span>)</span></span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h4 id="写出generator方法"><a href="#写出generator方法" class="headerlink" title="写出generator方法"></a>写出generator方法</h4><p>定义了上面这些内容，我们就可以写出generator方法了<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">generator</span><span class="params">(block: <span class="type">suspend</span> <span class="type">GeneratorScope</span>&lt;<span class="type">T</span>&gt;.(<span class="type">T</span>) -&gt; <span class="type">Unit</span>)</span></span>: (T) -&gt; Generator&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            GeneratorImpl(block, it)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>上面的语句用到了带接收者的lambda表达式<br>lambda 作为形参函数声明时，可以携带接收者，如下图：<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog8/p5.webp" alt><br>带接收者的 lambda 丰富了函数声明的信息，当传递该 lambda值时，将携带该接收者,比如：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明接收者</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">kotlinDSL</span><span class="params">(block:<span class="type">StringBuilder</span>.()-&gt;<span class="type">Unit</span>)</span></span>&#123;</span><br><span class="line">  block(StringBuilder(<span class="string">"Kotlin"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用高阶函数</span></span><br><span class="line">kotlinDSL &#123;</span><br><span class="line">  <span class="comment">// 这个 lambda 的接收者类型为StringBuilder</span></span><br><span class="line">  append(<span class="string">" DSL"</span>)</span><br><span class="line">  println(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; 输出 Kotlin DSL</span><br></pre></td></tr></table></figure></p><h3 id="3-GeneratorIterator的具体实现"><a href="#3-GeneratorIterator的具体实现" class="headerlink" title="3.GeneratorIterator的具体实现"></a>3.GeneratorIterator的具体实现</h3><h4 id="定义生成器状态"><a href="#定义生成器状态" class="headerlink" title="定义生成器状态"></a>定义生成器状态</h4><p>首先我们需要定义生成器的状态，方便后续判断生成器是否准备好，并根据相应条件做好状态转换<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">NotReady</span></span>(<span class="keyword">val</span> continuation: Continuation&lt;<span class="built_in">Unit</span>&gt;) : State()</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Ready</span>&lt;<span class="type">T</span>&gt;</span>(<span class="keyword">val</span> continuation: Continuation&lt;<span class="built_in">Unit</span>&gt;, <span class="keyword">val</span> nextValue: T) : State()</span><br><span class="line">        <span class="keyword">object</span> Done : State()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>如上所示，定义了3种状态<br>1.NotReady,未准备好，初始状态，挂起状态<br>2.Ready,已准备好，准备返回<br>3.Done,生成器内已经没有了数据</p><p>上面的语句使用了sealed密封类<br>1.密封(Sealed)类是一个限制类层次结构的类。<br>2.可以在类名之前使用sealed关键字将类声明为密封类。<br>3.它用于表示受限制的类层次结构。<br>4.当对象具有来自有限集的类型之一，但不能具有任何其他类型时，使用密封类。<br>5.密封类的构造函数在默认情况下是私有的，它也不能允许声明为非私有。   </p><p>密封类的主要优点在于与when一起使用时<br>由于密封类的子类将自身类型作为一种情况。 因此，密封类中的when表达式涵盖所有情况，从而避免使用else子句。</p><h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GeneratorIterator</span>&lt;<span class="type">T</span>&gt;</span>(</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> block: <span class="keyword">suspend</span> GeneratorScope&lt;T&gt;.(T) -&gt; <span class="built_in">Unit</span>,</span><br><span class="line">        <span class="keyword">override</span> <span class="keyword">val</span> parameter: T</span><br><span class="line">    ) : Iterator&lt;T&gt;, Continuation&lt;Any?&gt;, GeneratorScope&lt;T&gt;() &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="keyword">val</span> context: CoroutineContext = EmptyCoroutineContext</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">var</span> state: State</span><br><span class="line"></span><br><span class="line">        <span class="keyword">init</span> &#123;</span><br><span class="line">            <span class="keyword">val</span> coroutineBlock: <span class="keyword">suspend</span> GeneratorScope&lt;T&gt;.() -&gt; <span class="built_in">Unit</span> = &#123;</span><br><span class="line">                block(parameter)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">val</span> start = coroutineBlock.createCoroutine(<span class="keyword">this</span>, <span class="keyword">this</span>)</span><br><span class="line">            state = State.NotReady(start)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">hasNext</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">            resume()</span><br><span class="line">            <span class="keyword">return</span> state != State.Done</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">next</span><span class="params">()</span></span>: T &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">when</span> (<span class="keyword">val</span> currentState = state) &#123;</span><br><span class="line">                <span class="keyword">is</span> State.NotReady -&gt; &#123;</span><br><span class="line">                    <span class="keyword">return</span> next()</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">is</span> State.Ready&lt;*&gt; -&gt; &#123;</span><br><span class="line">                    state = State.NotReady(currentState.continuation)</span><br><span class="line">                    (currentState <span class="keyword">as</span> State.Ready&lt;T&gt;).nextValue</span><br><span class="line">                &#125;</span><br><span class="line">                State.Done -&gt; <span class="keyword">throw</span> IndexOutOfBoundsException(<span class="string">"No Value Left"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">Any</span>?&gt;)</span></span> &#123;</span><br><span class="line">            state = State.Done</span><br><span class="line">            result.getOrThrow()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">yield</span><span class="params">(value: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">return</span> suspendCoroutine &#123;</span><br><span class="line">                state = <span class="keyword">when</span> (state) &#123;</span><br><span class="line">                    <span class="keyword">is</span> State.NotReady -&gt; State.Ready(it, value)</span><br><span class="line">                    <span class="keyword">is</span> State.Ready&lt;*&gt; -&gt; <span class="keyword">throw</span> IllegalStateException(<span class="string">"Cannot yield a value while ready"</span>)</span><br><span class="line">                    State.Done -&gt; <span class="keyword">throw</span> IllegalStateException(<span class="string">"Cannot yield a value while Done"</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">resume</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">when</span> (<span class="keyword">val</span> currentState = state) &#123;</span><br><span class="line">                <span class="keyword">is</span> State.NotReady -&gt; currentState.continuation.resume(<span class="built_in">Unit</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>主要的遍历，挂起与恢复逻辑便定义在GeneratorIterator中<br>1.调用coroutineBlock.createCoroutine创建协程<br>2.调用continuation.resume启动<br>3.调用传入的block,即yield,挂起函数，并更新状态<br>4.在next方法中返回值，并更新状态<br>5.然后再在hasNext方法中恢复协程，遍历到下一个<br>6.最后在完成时调用resumeWith，状态设置为Done</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.jianshu.com/p/7c851145ee4c" target="_blank" rel="noopener">Python协程</a><br><a href="https://www.jianshu.com/p/f5f0d38e3e44" target="_blank" rel="noopener">带接收者的 lambda表达式</a><br><a href="https://blog.csdn.net/alfredkao/article/details/107592173" target="_blank" rel="noopener">Kotlin Sealed类</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;协程的基本概念&quot;&gt;&lt;a href=&quot;#协程的基本概念&quot; class=&quot;headerlink&quot; title=&quot;协程的基本概念&quot;&gt;&lt;/a&gt;协程的基本概念&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;协程是可以由程序自行控制挂起，恢复的程序&lt;/li&gt;
&lt;li&gt;协程可以用来实现多任务的协作
      
    
    </summary>
    
    
      <category term="kotlin" scheme="http://ShenZhen2017.github.io/tags/kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Android自定义View问题总结</title>
    <link href="http://ShenZhen2017.github.io/blog/2020/11/android-view-arcitechture.html"/>
    <id>http://ShenZhen2017.github.io/blog/2020/11/android-view-arcitechture.html</id>
    <published>2020-11-22T02:01:51.000Z</published>
    <updated>2020-12-16T16:00:43.376Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>带着问题学习可以让我们在学习的过程中更加有目的性与条理。<br>例如在读源码的过程中，我们如果从头开始读，往往千头万绪，抓不住要领。<br>而如果在开始读之前先带着几个问题，则可以让我们在读源码的过程中有一个主线。<br>最后也可以通过判断自己的问题是否得到解决了，来判断自己是否真的读懂了，不然面对成千上万行的代码，很容易有白读了的感觉。<br>阅读本文前，下面先列出几个问题</p><p>1.View什么时候发生绘制？<br>2.setContentView之后发生了什么？<br>3.View怎么测量大小？MeasureSpec的作用是什么？如何产生？<br>4.MeasureSpec中UNSPECIFIED的用途<br>5.如何自定义FlowLayout<br>6.一道滴滴面试题</p><h2 id="View什么时候发生绘制"><a href="#View什么时候发生绘制" class="headerlink" title="View什么时候发生绘制"></a>View什么时候发生绘制</h2><p>在Android应用中，View的第一次绘制是伴随这个Activity启动开始的。当Activity生命周期执行到onCreate时，我们都知道这时候会调用setContentView方法。View的绘制就是从这里开始。</p><p>除此之外，当View树中的视图发生变化时，会开始View的绘制；或者主动调用View的绘制方法，比如invalidate方法。这个都会发起View的绘制。</p><h2 id="setContentView之后发生了什么？"><a href="#setContentView之后发生了什么？" class="headerlink" title="setContentView之后发生了什么？"></a>setContentView之后发生了什么？</h2><p>通过在Activity中调用setContentView方法开始View的加载。这个过程是通过Window对象加载的。我们可以再PhoneWindow中找到这个方法。在这个方法中可以看到一个installDecor的方法。这个方法的作用就是初始化顶级View，也就是DecorView（这里不再介绍DecorView的创建过程，想了解的同学可以自行阅读代码）。之后View的工作流程就是从DecorView开始的，这个后面再讲。</p><p>setContentView只是先将顶级View初始化，还没有开始View的绘制。接着往下看，ActivityThread继续执行Activity的生命周期。在ActivityThread执行到handleResumeActivity方法时，这里调用了Activity的生命周期函数onResume。接着在通过WindowManager添加了DecorView，然后才开始了View的工作流程。这里也解释了为什么在Activity在执行完onResume的时候用户才可以跟App交互。</p><p>最后创建了ViewRootImpl的实例，ViewRootImpl的作用就是沟通View和WindowManager，实现两者所需要的协议，它管理着View的工作流程。<br>ViewRootImpl中的performTraversals方法中可以看到执行了3个方法。分别是performMeasure、performLayout、performDraw，从名称上也可以想到，着3个方法执行了View的measure、layout、draw方法</p><p>关于setConteView后发生什么的详情解析可见：<a href="https://juejin.cn/post/6890152854649225230" target="_blank" rel="noopener">Android视图体系—View的工作流程</a></p><h2 id="View怎么测量大小？"><a href="#View怎么测量大小？" class="headerlink" title="View怎么测量大小？"></a>View怎么测量大小？</h2><p>View通过measure来确定大小<br>measure的作用就是决定View到底有多大。在整个View树种是由View和ViewGroup组成。而measure也分为着两种绘制方式。View的measure只测试自身大小。ViewGroup除了测量自身大小，还负责测量子View的大小。</p><h3 id="MeasureSpec的作用"><a href="#MeasureSpec的作用" class="headerlink" title="MeasureSpec的作用"></a>MeasureSpec的作用</h3><p>MeasureSpec封装了View的规格尺寸参数，包括View的宽高以及测量模式。<br>它的高2位代表测量模式（通过mode &amp; MODE_MASK计算），低30位代表尺寸。其中测量模式总共有3中。</p><ul><li>UNSPECIFIED：未指定模式不对子View的尺寸进行限制。</li><li>AT_MOST：最大模式对应于wrap_content属性，父容器已经确定子View的大小，并且子View不能大于这个值。</li><li>EXACTLY：精确模式对应于match_parent属性和具体的数值，子View可以达到父容器指定大小的值。</li></ul><p>对于每一个View，都会有一个MeasureSpec属性来保存View的尺寸规格信息。在View测量的时候，通过makeMeasureSpec来保存宽高信息，通过getMode获取测量模式，通过getSize获取宽或高。</p><h3 id="MeasureSpec是如何产生的"><a href="#MeasureSpec是如何产生的" class="headerlink" title="MeasureSpec是如何产生的"></a>MeasureSpec是如何产生的</h3><p>MeasureSpec相当于View测量过程中的一个规格，在View开始测量前需要先生成MeasureSpec来指导View以何种方式测量。<br>MeasureSpec生成是由父布局决定的，同时对于顶级ViewDecorView来说是由LayoutParams决定的。<br>在上面分析View工作流程开始的时候，在ViewRootImpl中开始工作流程前，有一个方法measureHierarchy()，这个方法就是生成DecorView的方式。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">measureHierarchy</span><span class="params">(<span class="keyword">final</span> View host, <span class="keyword">final</span> WindowManager.LayoutParams lp,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> Resources res, <span class="keyword">final</span> <span class="keyword">int</span> desiredWindowWidth, <span class="keyword">final</span> <span class="keyword">int</span> desiredWindowHeight)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (baseSize != <span class="number">0</span> &amp;&amp; desiredWindowWidth &gt; baseSize) &#123;</span><br><span class="line">        childWidthMeasureSpec = getRootMeasureSpec(baseSize, lp.width);</span><br><span class="line">        childHeightMeasureSpec = getRootMeasureSpec(desiredWindowHeight, lp.height);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在代码中可以看到通过getRootMeasureSpec()方法获取了DecorView的MeasureSpec。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getRootMeasureSpec</span><span class="params">(<span class="keyword">int</span> windowSize, <span class="keyword">int</span> rootDimension)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> measureSpec;</span><br><span class="line">    <span class="keyword">switch</span> (rootDimension) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> ViewGroup.LayoutParams.MATCH_PARENT:</span><br><span class="line">        <span class="comment">// Window can't resize. Force root view to be windowSize.</span></span><br><span class="line">        measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ViewGroup.LayoutParams.WRAP_CONTENT:</span><br><span class="line">        <span class="comment">// Window can resize. Set max size for root view.</span></span><br><span class="line">        measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// Window wants to be an exact size. Force root view to be that size.</span></span><br><span class="line">        measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> measureSpec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>getRootMeasureSpec()也不复杂，在方法中可以看出如果是LayoutParams.MATCH_PARENT，那么DecorView的大小就是Window的大小；如果是LayoutParams.WRAP_CONTENT，那么DecorView的大小不确定。<br>对于普通的View，MeasureSpec来自于父布局（ViewGroup）生成。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChildWithMargins</span><span class="params">(View child,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> parentWidthMeasureSpec, <span class="keyword">int</span> widthUsed,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> parentHeightMeasureSpec, <span class="keyword">int</span> heightUsed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</span><br><span class="line">            mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin</span><br><span class="line">                    + widthUsed, lp.width);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</span><br><span class="line">            mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin</span><br><span class="line">                    + heightUsed, lp.height);</span><br><span class="line"></span><br><span class="line">    child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这里可以看到生成子View的MeasureSpec时与父布局的MeasureSpec以及padding相关，同时也与View本身的margin有关。</p><h3 id="MeasureSpec中UNSPECIFIED的用途"><a href="#MeasureSpec中UNSPECIFIED的用途" class="headerlink" title="MeasureSpec中UNSPECIFIED的用途"></a>MeasureSpec中UNSPECIFIED的用途</h3><p>UNSPECIFIED主要在一线父View不限制子View宽高的情况下使用，比如ScrollView<br>1.UNSPECIFIED会在ScrollView的measure方法里传给子View<br>2.子View收到UNSPECIFIED，会根据自己的实际内容大小来决定高度<br>3.UNSPECIFIED与AT_MOST的区别就是，它没有最大size限定这也说明UNSPECIFIED在ScrollView里很实用，因为ScrllView不需要限定子View的大小，它可以滚动嘛<br>详情可见：<a href="https://blog.csdn.net/u012947056/article/details/81292621" target="_blank" rel="noopener">measure之UNSPECIFIED的用途</a></p><h2 id="如何自定义FlowLayout"><a href="#如何自定义FlowLayout" class="headerlink" title="如何自定义FlowLayout"></a>如何自定义FlowLayout</h2><p>实现自定义View主要需要解决以下3个问题<br>1.自定义控件的大小，也就是宽和高分别设置多少；<br>2.如果是 ViewGroup，如何合理安排其内部子 View 的摆放位置。<br>3.如何根据相应的属性将 UI 元素绘制到界面；    </p><p>以上 3 个问题依次在如下 3 个方法中得到解决：<br>onMeasure,onLayout,onDraw</p><h3 id="FlowLayout的onMeasure方法"><a href="#FlowLayout的onMeasure方法" class="headerlink" title="FlowLayout的onMeasure方法"></a>FlowLayout的onMeasure方法</h3><p>因为自定义的控件是一个容器，onMeasure 方法会更加复杂一些。因为 ViewGroup 在测量自己的宽高之前，需要先确定其内部子 View 的所占大小，然后才能确定自己的大小。<br>如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测量控件的宽和高</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">     <span class="comment">//获得宽高的测量模式和测量值</span></span><br><span class="line">     <span class="keyword">int</span> widthMode = MeasureSpec.getMode(widthMeasureSpec);</span><br><span class="line">     <span class="keyword">int</span> widthSize = MeasureSpec.getSize(widthMeasureSpec);</span><br><span class="line">     <span class="keyword">int</span> heightSize = MeasureSpec.getSize(heightMeasureSpec);</span><br><span class="line">     <span class="keyword">int</span> heightMode = MeasureSpec.getMode(heightMeasureSpec);</span><br><span class="line"></span><br><span class="line">     <span class="comment">//获得容器中子View的个数</span></span><br><span class="line">     <span class="keyword">int</span> childCount = getChildCount();</span><br><span class="line">     <span class="comment">//记录每一行View的总宽度</span></span><br><span class="line">     <span class="keyword">int</span> totalLineWidth = <span class="number">0</span>;</span><br><span class="line">     <span class="comment">//记录每一行最高View的高度</span></span><br><span class="line">     <span class="keyword">int</span> perLineMaxHeight = <span class="number">0</span>;</span><br><span class="line">     <span class="comment">//记录当前ViewGroup的总高度</span></span><br><span class="line">     <span class="keyword">int</span> totalHeight = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childCount; i++) &#123;</span><br><span class="line">         View childView = getChildAt(i);</span><br><span class="line">         <span class="comment">//对子View进行测量</span></span><br><span class="line">         measureChild(childView, widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">         MarginLayoutParams lp = (MarginLayoutParams) childView.getLayoutParams();</span><br><span class="line">         <span class="comment">//获得子View的测量宽度</span></span><br><span class="line">         <span class="keyword">int</span> childWidth = childView.getMeasuredWidth() + lp.leftMargin + lp.rightMargin;</span><br><span class="line">         <span class="comment">//获得子View的测量高度</span></span><br><span class="line">         <span class="keyword">int</span> childHeight = childView.getMeasuredHeight() + lp.topMargin + lp.bottomMargin;</span><br><span class="line">         <span class="keyword">if</span> (totalLineWidth + childWidth &gt; widthSize) &#123;</span><br><span class="line">             <span class="comment">//统计总高度</span></span><br><span class="line">             totalHeight += perLineMaxHeight;</span><br><span class="line">             <span class="comment">//开启新的一行</span></span><br><span class="line">             totalLineWidth = childWidth;</span><br><span class="line">             perLineMaxHeight = childHeight;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="comment">//记录每一行的总宽度</span></span><br><span class="line">             totalLineWidth += childWidth;</span><br><span class="line">             <span class="comment">//比较每一行最高的View</span></span><br><span class="line">             perLineMaxHeight = Math.max(perLineMaxHeight, childHeight);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//当该View已是最后一个View时，将该行最大高度添加到totalHeight中</span></span><br><span class="line">         <span class="keyword">if</span> (i == childCount - <span class="number">1</span>) &#123;</span><br><span class="line">             totalHeight += perLineMaxHeight;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//如果高度的测量模式是EXACTLY，则高度用测量值，否则用计算出来的总高度（这时高度的设置为wrap_content）</span></span><br><span class="line">     heightSize = heightMode == MeasureSpec.EXACTLY ? heightSize : totalHeight;</span><br><span class="line">     setMeasuredDimension(widthSize, heightSize);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>上述 onMeasure 方法的主要目的有 2 个：<br>1.调用 measureChild 方法递归测量子 View；<br>2.通过叠加每一行的高度，计算出最终 FlowLayout 的最终高度 totalHeight。  </p><h3 id="FlowLayout的onLayout方法"><a href="#FlowLayout的onLayout方法" class="headerlink" title="FlowLayout的onLayout方法"></a>FlowLayout的onLayout方法</h3><p>上面的 FlowLayout 中的 onMeasure 方法只是计算出 ViewGroup 的最终显示宽高，但是并没有规定某一个子 View 应该显示在何处位置。要定义 ViewGroup 内部子 View 的显示规则，则需要复写并实现 onLayout 方法。<br>onLayout是一个抽象方法，也就是说每一个自定义 ViewGroup 都必须主动实现如何排布子 View，具体就是遍历每一个子 View，调用 child.(l, t, r, b) 方法来为每个子 View 设置具体的布局位置。四个参数分别代表左上右下的坐标位置，一个简易的 FlowLayout 实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    mAllViews.clear();</span><br><span class="line">    mPerLineMaxHeight.clear();</span><br><span class="line">    <span class="comment">//存放每一行的子View</span></span><br><span class="line">    List&lt;View&gt; lineViews = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//记录每一行已存放View的总宽度</span></span><br><span class="line">    <span class="keyword">int</span> totalLineWidth = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//记录每一行最高View的高度</span></span><br><span class="line">    <span class="keyword">int</span> lineMaxHeight = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/****遍历所有View，将View添加到List&lt;List&lt;View&gt;&gt;集合中**********/</span></span><br><span class="line">    <span class="comment">//获得子View的总个数</span></span><br><span class="line">    <span class="keyword">int</span> childCount = getChildCount();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childCount; i++) &#123;</span><br><span class="line">        View childView = getChildAt(i);</span><br><span class="line">        MarginLayoutParams lp = (MarginLayoutParams) childView.getLayoutParams();</span><br><span class="line">        <span class="keyword">int</span> childWidth = childView.getMeasuredWidth() + lp.leftMargin + lp.rightMargin;</span><br><span class="line">        <span class="keyword">int</span> childHeight = childView.getMeasuredHeight() + lp.topMargin + lp.bottomMargin;</span><br><span class="line">        <span class="keyword">if</span> (totalLineWidth + childWidth &gt; getWidth()) &#123;</span><br><span class="line">            mAllViews.add(lineViews);</span><br><span class="line">            mPerLineMaxHeight.add(lineMaxHeight);</span><br><span class="line">            <span class="comment">//开启新的一行</span></span><br><span class="line">            totalLineWidth = <span class="number">0</span>;</span><br><span class="line">            lineMaxHeight = <span class="number">0</span>;</span><br><span class="line">            lineViews = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        totalLineWidth += childWidth;</span><br><span class="line">        lineViews.add(childView);</span><br><span class="line">        lineMaxHeight = Math.max(lineMaxHeight, childHeight);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//单独处理最后一行</span></span><br><span class="line">    mAllViews.add(lineViews);</span><br><span class="line">    mPerLineMaxHeight.add(lineMaxHeight);</span><br><span class="line">    <span class="comment">/************遍历集合中的所有View并显示出来************/</span></span><br><span class="line">    <span class="comment">//表示一个View和父容器左边的距离</span></span><br><span class="line">    <span class="keyword">int</span> mLeft = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//表示View和父容器顶部的距离</span></span><br><span class="line">    <span class="keyword">int</span> mTop = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mAllViews.size(); i++) &#123;</span><br><span class="line">        <span class="comment">//获得每一行的所有View</span></span><br><span class="line">        lineViews = mAllViews.get(i);</span><br><span class="line">        lineMaxHeight = mPerLineMaxHeight.get(i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; lineViews.size(); j++) &#123;</span><br><span class="line">            View childView = lineViews.get(j);</span><br><span class="line">            MarginLayoutParams lp = (MarginLayoutParams) childView.getLayoutParams();</span><br><span class="line">            <span class="keyword">int</span> leftChild = mLeft + lp.leftMargin;</span><br><span class="line">            <span class="keyword">int</span> topChild = mTop + lp.topMargin;</span><br><span class="line">            <span class="keyword">int</span> rightChild = leftChild + childView.getMeasuredWidth()；</span><br><span class="line">            <span class="keyword">int</span> bottomChild = topChild + childView.getMeasuredHeight();</span><br><span class="line">            <span class="comment">//四个参数分别表示View的左上角和右下角</span></span><br><span class="line">            childView.layout(leftChild, topChild, rightChild, bottomChild);</span><br><span class="line">            mLeft += lp.leftMargin + childView.getMeasuredWidth() + lp.rightMargin;</span><br><span class="line">        &#125;</span><br><span class="line">        mLeft = <span class="number">0</span>;</span><br><span class="line">        mTop += lineMaxHeight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>完整代码可见：<a href="https://github.com/McoyJiang/LagouAndroidShare/tree/master/course15_%E8%87%AA%E5%AE%9A%E4%B9%89View/LagouCustomizedView" target="_blank" rel="noopener">自定义FlowLayout代码</a></p><h2 id="一道滴滴面试题"><a href="#一道滴滴面试题" class="headerlink" title="一道滴滴面试题"></a>一道滴滴面试题</h2><p>之前在面试滴滴时碰到了这样一首题目，这个问题如果你如果理解了，相信你已经充分掌握了自定义View的measure过程<br>Activity内根布局LinearLayout，背景颜色为红色,宽高为wrap_content<br>内部包含View背影颜色为蓝色,宽高也为wrap_content<br>求界面颜色<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:background</span>=<span class="string">"@color/red"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">View</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">"@color/blue"</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><strong>答案是蓝色</strong><br>在下当时想当然的认为，既然都是wrap_content，界面颜色应该是白色。但是正确答案是蓝色<br>下面就来分析下具体原因  </p><h3 id="LinearLayout的onMeasure"><a href="#LinearLayout的onMeasure" class="headerlink" title="LinearLayout的onMeasure()"></a>LinearLayout的onMeasure()</h3><p>onMeasure()中比较简单，但是这里我们需要明确一下，这个方法的参数是什么含义：</p><p>MeasureSpec就不用多说了，记录当前View的尺寸和测量模式<br>另外明确一点，这里的MeasureSpec是父View的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> widthMeasureSpec horizontal space requirements as imposed by the parent.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> heightMeasureSpec vertical space requirements as imposed by the parent.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mOrientation == VERTICAL) &#123;</span><br><span class="line">        measureVertical(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        measureHorizontal(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里咱们就选measureVertical()追进去，方法里的边界条件非常的多，但其中对于子View的测量过程比较的简单，遍历所有的子View，挨个调用measureChildBeforeLayout()方法，而这个方法最终会走到ViewGroup中的measureChildWithMargins()：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChildWithMargins</span><span class="params">(View child,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> parentWidthMeasureSpec, <span class="keyword">int</span> widthUsed,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> parentHeightMeasureSpec, <span class="keyword">int</span> heightUsed)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这个方法主要就是做了一件事情：通过子View的LayoutParams和父View的MeasureSpec来决定子View的MeasureSpec</span></span><br><span class="line">    <span class="keyword">final</span> MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</span><br><span class="line">            mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin</span><br><span class="line">                    + widthUsed, lp.width);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</span><br><span class="line">            mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin</span><br><span class="line">                    + heightUsed, lp.height);</span><br><span class="line"></span><br><span class="line">    child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="生成子View的MeasureSpec"><a href="#生成子View的MeasureSpec" class="headerlink" title="生成子View的MeasureSpec"></a>生成子View的MeasureSpec</h3><p>这部分逻辑主要在getChildMeasureSpec()方法中，我们直接追进去就好了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getChildMeasureSpec</span><span class="params">(<span class="keyword">int</span> spec, <span class="keyword">int</span> padding, <span class="keyword">int</span> childDimension)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略部分初始化代码</span></span><br><span class="line">    <span class="keyword">switch</span> (specMode) &#123; </span><br><span class="line">        <span class="keyword">case</span> MeasureSpec.EXACTLY: </span><br><span class="line">            <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123; </span><br><span class="line">                resultSize = childDimension;</span><br><span class="line">                resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">                resultSize = size;</span><br><span class="line">                resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">                resultSize = size;</span><br><span class="line">                resultMode = MeasureSpec.AT_MOST;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MeasureSpec.AT_MOST: </span><br><span class="line">            <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                resultSize = childDimension;</span><br><span class="line">                resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">                resultSize = size;</span><br><span class="line">                resultMode = MeasureSpec.AT_MOST;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">                resultSize = size;</span><br><span class="line">                resultMode = MeasureSpec.AT_MOST;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MeasureSpec.UNSPECIFIED: </span><br><span class="line">            <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                resultSize = childDimension;</span><br><span class="line">                resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">                resultSize = View.sUseZeroUnspecifiedMeasureSpec ? <span class="number">0</span> : size;</span><br><span class="line">                resultMode = MeasureSpec.UNSPECIFIED;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">                resultSize = View.sUseZeroUnspecifiedMeasureSpec ? <span class="number">0</span> : size;</span><br><span class="line">                resultMode = MeasureSpec.UNSPECIFIED;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> MeasureSpec.makeMeasureSpec(resultSize, resultMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这部分代码，就是Google定的规则，也没什么好说的。总结起来就是《Android开发艺术探索》中的那张图：<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog7/p2.png" alt><br>看了这个，咱们就可以思考一下咱们开篇遇到的问题：父View（LinearLayout）是wrap_content，子View是wrap_parent，那么子View的MeasureSpec是什么样子？</p><p>有了上边的分析，我们很容易得出答案：parentSize + AT_MOST。因此咱们就知道这种场景下，子View的wrap_parent意味自己的宽高就是父View的宽高。那么此时父View的宽高是多少呢？</p><p>由于这里的父View已经是根View了，那么它的外边便是DecorView，而DecorView的MeasureSpec相对简单些，直接基于Window的宽高和自身的LayoutParams进行计算。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getRootMeasureSpec</span><span class="params">(<span class="keyword">int</span> windowSize, <span class="keyword">int</span> rootDimension)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> measureSpec;</span><br><span class="line">    <span class="keyword">switch</span> (rootDimension) &#123;</span><br><span class="line">        <span class="keyword">case</span> ViewGroup.LayoutParams.MATCH_PARENT:</span><br><span class="line">            measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ViewGroup.LayoutParams.WRAP_CONTENT:</span><br><span class="line">            measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> measureSpec;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">    setContentView(view, <span class="keyword">new</span> ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因此这种场景下，DecorView的MeasureSpec是屏幕宽高 + EXACTLY，那么父View（LinearLayout）的宽高就很明确了：parentSize + AT_MOST。</p><p>1.子View（TextView）的MeasureSpec是parentSize + AT_MOST<br>2.父View（LinearLayout）的MeasureSpec是parentSize + AT_MOST<br>3.DecorView的MeasureSpec是屏幕的size + EXACTLY   </p><h3 id="执行子View的measure-方法"><a href="#执行子View的measure-方法" class="headerlink" title="执行子View的measure()方法"></a>执行子View的measure()方法</h3><p>接下来咱们去看一看子View的measure()方法，<br>上述的部分我们已经知道measureChildWithMargins()方法中会基于父View的MeasureSpec和子View的LayoutParams计算子View的MeasureSpec,<br>然后调用子View的measure()：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),</span><br><span class="line">getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getDefaultSize</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> measureSpec)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> result = size;</span><br><span class="line"><span class="keyword">int</span> specMode = MeasureSpec.getMode(measureSpec);</span><br><span class="line"><span class="keyword">int</span> specSize = MeasureSpec.getSize(measureSpec);</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (specMode) &#123;</span><br><span class="line"><span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</span><br><span class="line">result = size;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> MeasureSpec.AT_MOST:</span><br><span class="line"><span class="keyword">case</span> MeasureSpec.EXACTLY:</span><br><span class="line">result = specSize;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中可以看出，View的宽度即为父View传过来的宽高，即屏幕宽高。<br>因此最终效果为全屏显示蓝色。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://juejin.cn/post/6890152854649225230" target="_blank" rel="noopener">Android视图体系—View的工作流程</a><br><a href="https://blog.csdn.net/u012947056/article/details/81292621" target="_blank" rel="noopener">measure之UNSPECIFIED的用途</a><br><a href="https://juejin.cn/post/6893699917458604046" target="_blank" rel="noopener">深入理解自定义ViewGroup的布局测量过程</a><br><a href="https://juejin.cn/post/6877731252871364615" target="_blank" rel="noopener">来解释一下这个简单布局为什么是这个效果吧！</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;带着问题学习可以让我们在学习的过程中更加有目的性与条理。&lt;br&gt;例如在读源码的过程中，我们如果从头开始读，往往千头万绪，抓不住要领。&lt;br&gt;
      
    
    </summary>
    
    
      <category term="android" scheme="http://ShenZhen2017.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>ARTS打卡5</title>
    <link href="http://ShenZhen2017.github.io/blog/2020/11/arts-way-five.html"/>
    <id>http://ShenZhen2017.github.io/blog/2020/11/arts-way-five.html</id>
    <published>2020-11-17T14:25:02.000Z</published>
    <updated>2020-12-16T16:00:43.376Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><blockquote><p><a href="https://leetcode-cn.com/contest/weekly-contest-216/problems/check-if-two-string-arrays-are-equivalent/" target="_blank" rel="noopener">5605. 检查两个字符串数组是否相等</a><br>给你两个字符串数组 word1 和 word2 。如果两个数组表示的字符串相同，返回 true ；否则，返回 false 。<br>数组表示的字符串 是由数组中的所有元素 按顺序 连接形成的字符串。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">arrayStringsAreEqual</span><span class="params">(word1: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;, word2: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> stringBuilder1 = StringBuilder()</span><br><span class="line">        <span class="keyword">val</span> stringBuilder2 = StringBuilder()</span><br><span class="line">        word1.forEach &#123; </span><br><span class="line">            stringBuilder1.append(it)</span><br><span class="line">        &#125;</span><br><span class="line">        word2.forEach &#123; </span><br><span class="line">            stringBuilder2.append(it)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stringBuilder1.toString()==stringBuilder2.toString()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p><a href="https://android-developers.googleblog.com/2019/05/android-studio-35-beta.html" target="_blank" rel="noopener">Android Studio 3.5 Beta</a><br><a href="https://medium.com/androiddevelopers/improving-build-speed-in-android-studio-3e1425274837" target="_blank" rel="noopener">Improving build speed in Android Studio</a><br><a href="https://juejin.cn/post/6844903875401498631" target="_blank" rel="noopener">[译] 改善 Android Studio 的构建速度</a></p><p>本文主要讲述了Android Studio在提高编译速度方面的努力<br>1.首次定义了编译速度的衡量标准<br>2.为什么在android studio努力提高编译速度后，大部分项目的编译时间还增长了？<br>3.如何修复内部流程并持续改进性能<br>4.改善性能工具，让用户更便于使用<br>5.为了提高编译速度，你可以做什么</p><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><p>TabLayout底部指示条自定义为圆角</p><h3 id="1-自定义drawable"><a href="#1-自定义drawable" class="headerlink" title="1.自定义drawable"></a>1.自定义drawable</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">shape</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">corners</span> <span class="attr">android:radius</span>=<span class="string">"2dp"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">size</span> <span class="attr">android:height</span>=<span class="string">"2dp"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">solid</span> <span class="attr">android:color</span>=<span class="string">"@color/red"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">shape</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-tab添加indicator"><a href="#2-tab添加indicator" class="headerlink" title="2.tab添加indicator"></a>2.tab添加indicator</h3><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">com</span>.google.android.material.tabs.TabLayout</span><br><span class="line"><span class="symbol">android:</span>id=<span class="string">"@+id/tab_layout"</span></span><br><span class="line"><span class="symbol">android:</span>layout_width=<span class="string">"match_parent"</span></span><br><span class="line"><span class="symbol">android:</span>layout_height=<span class="string">"45dp"</span></span><br><span class="line"><span class="symbol">app:</span>tabIndicator=<span class="string">"@drawable/shape_tab_corner_indicator"</span></span><br><span class="line"><span class="symbol">app:</span>tabIndicatorColor=<span class="string">"@color/red"</span></span><br><span class="line"><span class="symbol">app:</span>tabIndicatorFullWidth=<span class="string">"false"</span></span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure><h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p>本周主要总结了Android自定义View相关问题，详情可见：<br><a href="https://shenzhen2017.github.io/blog/2020/11/android-view-arcitechture.html">Android自定义View问题总结</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Algorithm&quot;&gt;&lt;a href=&quot;#Algorithm&quot; class=&quot;headerlink&quot; title=&quot;Algorithm&quot;&gt;&lt;/a&gt;Algorithm&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.
      
    
    </summary>
    
    
      <category term="ARTS" scheme="http://ShenZhen2017.github.io/tags/ARTS/"/>
    
  </entry>
  
  <entry>
    <title>Java与Kotlin泛型详解</title>
    <link href="http://ShenZhen2017.github.io/blog/2020/11/kotlin-java-generic.html"/>
    <id>http://ShenZhen2017.github.io/blog/2020/11/kotlin-java-generic.html</id>
    <published>2020-11-15T12:13:06.000Z</published>
    <updated>2020-12-16T16:00:43.376Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>带着问题学习可以让我们在学习的过程中更加有目的性与条理。<br>例如在读源码的过程中，我们如果从头开始读，往往千头万绪，抓不住要领。<br>而如果在开始读之前先带着几个问题，则可以让我们在读源码的过程中有一个主线。<br>最后也可以通过判断自己的问题是否得到解决了，来判断自己是否真的读懂了，不然面对成千上万行的代码，很容易有白读了的感觉。</p><p>阅读本文前，下面先列出几个问题<br>1.为什么我们需要泛型？<br>2.如何定义泛型类？如何定义泛型方法?<br>3.怎么限定类型变量？<br>4.泛型有什么局限性？<br>5.泛型类型的继承规则是怎样的？<br>6.什么是泛型的通配符？什么是PECS原则？<br>7.虚拟机如何实现泛型？什么是泛型擦除？<br>8.kotlin中的泛型与Java泛型有什么区别？</p><h2 id="为什么我们需要泛型？"><a href="#为什么我们需要泛型？" class="headerlink" title="为什么我们需要泛型？"></a>为什么我们需要泛型？</h2><p>首先举两个例子</p><h3 id="1-求和函数"><a href="#1-求和函数" class="headerlink" title="1.求和函数"></a>1.求和函数</h3><p>实际开发中，经常有数值类型求和的需求，例如实现int类型的加法, 有时候还需要实现long类型的求和<br>如果还需要double类型的求和，又需要重新在重载一个输入是double类型的add方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addInt</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">addFloat</span><span class="params">(<span class="keyword">float</span> x,<span class="keyword">float</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这种情况就会写很多重复代码</p><h3 id="2-List中添加元素"><a href="#2-List中添加元素" class="headerlink" title="2.List中添加元素"></a>2.List中添加元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">list.add(<span class="string">"mark"</span>);</span><br><span class="line">list.add(<span class="string">"OK"</span>);</span><br><span class="line">list.add(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">        String name = list.get(i); <span class="comment">// 1</span></span><br><span class="line">        System.out.println(<span class="string">"name:"</span> + name);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>定义了一个List类型的集合，先向其中加入了两个字符串类型的值，随后加入一个Integer类型的值。这是完全允许的，因为此时list默认的类型为Object类型</p><p>在之后的循环中，由于忘记了之前在list中也加入了Integer类型的值或其他编码原因,容易引发类型转换错误.<br>因为编译阶段正常,因此，导致此类错误编码过程中不易发现。</p><p>在如上的编码过程中，我们发现主要存在两个问题：<br>1.当我们将一个对象放入集合中，集合不会记住此对象的类型，当再次从集合中取出此对象时，改对象的编译类型变成了Object类型，但其运行时类型任然为其本身类型。<br>2.因此，从List取出集合元素时需要人为的强制类型转化到具体的目标类型，且很容易出现“java.lang.ClassCastException”异常。</p><p>所以泛型的好处就是：<br>1.适用于多种数据类型执行相同的代码<br>2.泛型中的类型在使用时指定，不需要强制类型转换</p><h2 id="如何定义泛型类与泛型方法？"><a href="#如何定义泛型类与泛型方法？" class="headerlink" title="如何定义泛型类与泛型方法？"></a>如何定义泛型类与泛型方法？</h2><p>泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？<br>顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。<br>泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。<br>也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。</p><h3 id="泛型类与泛型接口的定义"><a href="#泛型类与泛型接口的定义" class="headerlink" title="泛型类与泛型接口的定义"></a>泛型类与泛型接口的定义</h3><p>引入一个类型变量T（其他大写字母都可以，不过常用的就是T，E，K，V等等），并且用&lt;&gt;括起来，并放在类名的后面。泛型类是允许有多个类型变量的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Genertor</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImplGenertor</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Genertor</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="泛型方法的定义"><a href="#泛型方法的定义" class="headerlink" title="泛型方法的定义"></a>泛型方法的定义</h3><p>泛型方法，是在调用方法的时候指明泛型的具体类型 ，泛型方法可以在任何地方和任何场景中使用，包括普通类和泛型类。<br>注意泛型类中定义的普通方法和泛型方法的区别。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.<span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">genericMethod</span><span class="params">(T...a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[a.length/<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>.<span class="function"><span class="keyword">public</span> T <span class="title">genericMethod</span><span class="params">(T...a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[a.length/<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>如上所示，第2种虽然在方法中使用了泛型，却不是一个泛型方法。<br>这只是类中的一个普通的成员方法，只不过他的返回值是泛型类中已经声明了的泛型。</p><h2 id="怎么限定类型变量？"><a href="#怎么限定类型变量？" class="headerlink" title="怎么限定类型变量？"></a>怎么限定类型变量？</h2><p>有时候，我们需要对类型变量加以约束，比如计算两个变量的最小，最大值。<br>请问，如果确保传入的两个变量一定有compareTo方法？那么解决这个问题的方案就是将T限制为实现了接口Comparable的类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&gt; <span class="function">T <span class="title">min</span><span class="params">(T a,T b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.comapareTo(b)&gt;<span class="number">0</span>) <span class="keyword">return</span> a; <span class="keyword">else</span> <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>同时extends左右都允许有多个，如 T,V extends Comparable &amp; Serializable<br>这种类的限定既可以用在泛型方法上也可以用在泛型类上。</p><h2 id="泛型有什么局限性？"><a href="#泛型有什么局限性？" class="headerlink" title="泛型有什么局限性？"></a>泛型有什么局限性？</h2><p>因为Java中的泛型是利用泛型擦除实现的，目前还有以下局限性<br>1.不能用基本类型实例化类型参数<br>2.运行时类型查询只适用于原始类型<br>3.泛型类的静态上下文中类型变量失效<br>4.不能创建参数化类型的数组<br>5.不能实例化类型变量<br>6.不能捕获泛型类的实例</p><p>不能在静态域或方法中引用类型变量。因为泛型是要在对象创建的时候才知道是什么类型的，而对象创建的代码执行先后顺序是static的部分，然后才是构造函数等等。所以在对象初始化之前static的部分已经执行了，如果你在静态部分引用的泛型，那么毫无疑问虚拟机根本不知道是什么东西，因为这个时候类还没有初始化。</p><h2 id="泛型类型的继承规则是怎样的？"><a href="#泛型类型的继承规则是怎样的？" class="headerlink" title="泛型类型的继承规则是怎样的？"></a>泛型类型的继承规则是怎样的？</h2><p>现在我们有一个类和子类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Emplyee</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">Emplyee</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></p><p>有一个泛型类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt;</span>&#123;&#125;</span><br></pre></td></tr></table></figure></p><p>请问Pair<employee>和Pair<worker>是继承关系吗？<br>答案：不是，他们之间没有什么关系<br>但是泛型类可以继承或者扩展其他泛型类，比如List和ArrayList</worker></employee></p><h2 id="通配符与PECS"><a href="#通配符与PECS" class="headerlink" title="通配符与PECS"></a>通配符与PECS</h2><p>正是因为前面所述的，Pair<employee>和Pair<worker>没有任何关系,而我们有时候需要用到类之前的继承关系<br>为解决这个问题，于是提出了一个通配符类型 ?<br>有两种使用方式：<br>？ extends X  表示类型的上界，类型参数是X的子类<br>？ super X  表示类型的下界，类型参数是X的超类<br>这两种 方式从名字上来看，特别是super，很有迷惑性，下面我们来仔细辨析这两种方法。</worker></employee></p><h3 id="？-extends-X"><a href="#？-extends-X" class="headerlink" title="？ extends X"></a>？ extends X</h3><p>表示传递给方法的参数，必须是X的子类（包括X本身）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print2</span><span class="params">(GenericType&lt;? extends Fruit&gt; p)</span></span>&#123;</span><br><span class="line">System.out.println(p.getData().getColor());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">use2</span><span class="params">()</span></span>&#123;</span><br><span class="line">GenericType&lt;Fruit&gt; a = <span class="keyword">new</span> GenericType&lt;&gt;();</span><br><span class="line">print2(a);</span><br><span class="line">GenericType&lt;Orange&gt; b = <span class="keyword">new</span> GenericType&lt;&gt;();</span><br><span class="line">print2(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是对泛型类GenericType来说，如果其中提供了get和set类型参数变量的方法的话，set方法是不允许被调用的，会出现编译错误<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GenericType&lt;? extends Fruit&gt; c =  <span class="keyword">new</span> GenericType&lt;&gt;();</span><br><span class="line"></span><br><span class="line">Apple apple =  <span class="keyword">new</span> Apple();</span><br><span class="line">Fruit fruit = <span class="keyword">new</span> Fruit();</span><br><span class="line">        <span class="comment">//set会报错</span></span><br><span class="line">        <span class="comment">//c.setData(apple);</span></span><br><span class="line">        <span class="comment">//c.setData(fruit);</span></span><br><span class="line">        <span class="comment">//get是可以的</span></span><br><span class="line">Fruit x = c.getData();</span><br></pre></td></tr></table></figure></p><p>get方法则没问题，会返回一个Fruit类型的值。<br>为何？<br>道理很简单，？extends X  表示类型的上界，类型参数是X的子类，那么可以肯定的说，get方法返回的一定是个X（不管是X或者X的子类）编译器是可以确定知道的。但是set方法只知道传入的是个X，至于具体是X的那个子类，不知道。</p><p>总结：主要用于安全地访问数据，可以访问X及其子类型，并且不能写入非null的数据。</p><h3 id="？-super-X"><a href="#？-super-X" class="headerlink" title="？ super X"></a>？ super X</h3><p>表示传递给方法的参数，必须是X的超类（包括X本身）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printSuper</span><span class="params">(GenericType&lt;? <span class="keyword">super</span> Apple&gt; p)</span></span>&#123;</span><br><span class="line">System.out.println(p.getData());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">useSuper</span><span class="params">()</span></span>&#123;</span><br><span class="line">GenericType&lt;Fruit&gt; fruitGenericType = <span class="keyword">new</span> GenericType&lt;&gt;();</span><br><span class="line">GenericType&lt;Apple&gt; appleGenericType = <span class="keyword">new</span> GenericType&lt;&gt;();</span><br><span class="line">GenericType&lt;HongFuShi&gt; hongFuShiGenericType = <span class="keyword">new</span> GenericType&lt;&gt;();</span><br><span class="line">GenericType&lt;Orange&gt; orangeGenericType = <span class="keyword">new</span> GenericType&lt;&gt;();</span><br><span class="line">printSuper(fruitGenericType);</span><br><span class="line">printSuper(appleGenericType);</span><br><span class="line">printSuper(hongFuShiGenericType);</span><br><span class="line">printSuper(orangeGenericType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是对泛型类GenericType来说，如果其中提供了get和set类型参数变量的方法的话，set方法可以被调用的，且能传入的参数只能是X或者X的子类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表示GenericType的类型参数的下界是Apple</span></span><br><span class="line">GenericType&lt;? <span class="keyword">super</span> Apple&gt; x = <span class="keyword">new</span> GenericType&lt;&gt;();</span><br><span class="line">x.setData(<span class="keyword">new</span> Apple());</span><br><span class="line">x.setData(<span class="keyword">new</span> HongFuShi());</span><br><span class="line">        <span class="comment">//x.setData(new Fruit());</span></span><br><span class="line">Object data = x.getData();</span><br></pre></td></tr></table></figure></p><p>get方法只会返回一个Object类型的值。<br>为何？<br>？super X  表示类型的下界，类型参数是X的超类（包括X本身），那么可以肯定的说，get方法返回的一定是个X的超类，那么到底是哪个超类？不知道，但是可以肯定的说，Object一定是它的超类，所以get方法返回Object。编译器是可以确定知道的。对于set方法来说，编译器不知道它需要的确切类型，但是X和X的子类可以安全的转型为X。</p><p>总结：主要用于安全地写入数据，可以写入X及其子类型</p><h3 id="无限定的通配符"><a href="#无限定的通配符" class="headerlink" title="无限定的通配符 ?"></a>无限定的通配符 ?</h3><p>表示对类型没有什么限制，可以把？看成所有类型的父类，如Pair&lt; ?&gt;；<br>比如：<br>ArrayList<t> al=new ArrayList<t>(); 指定集合元素只能是T类型<br>ArrayList&lt;?&gt; al=new ArrayList&lt;?&gt;();集合元素可以是任意类型，这种没有意义，一般是方法中，只是为了说明用法。<br>在使用上：<br>？ getFirst() ： 返回值只能赋给 Object，；<br>void setFirst(?) ： setFirst 方法不能被调用， 甚至不能用 Object 调用；</t></t></p><h3 id="PECS原则"><a href="#PECS原则" class="headerlink" title="PECS原则"></a>PECS原则</h3><p>上面讲解的extend与super的使用，其实可以用PECS原则来总结<br>PECS指“Producer Extends，Consumer Super”。换句话说，如果参数化类型表示一个生产者，就使用&lt;? extends T&gt;；如果它表示一个消费者，就使用&lt;? super T&gt;</p><p>总结 ? extends 和 the ? super 通配符的特征，我们可以得出以下结论：</p><ul><li>如果你想从一个数据类型里获取数据，使用 ? extends 通配符</li><li>如果你想把对象写入一个数据结构里，使用 ? super 通配符</li><li>如果你既想存，又想取，那就别用通配符。</li></ul><h2 id="虚拟机是如何实现泛型的？什么是泛型擦除？"><a href="#虚拟机是如何实现泛型的？什么是泛型擦除？" class="headerlink" title="虚拟机是如何实现泛型的？什么是泛型擦除？"></a>虚拟机是如何实现泛型的？什么是泛型擦除？</h2><p>泛型思想早在C++语言的模板（Template）中就开始生根发芽，在Java语言处于还没有出现泛型的版本时，只能通过Object是所有类型的父类和类型强制转换两个特点的配合来实现类型泛化。，由于Java语言里面所有的类型都继承于java.lang.Object，所以Object转型成任何对象都是有可能的。但是也因为有无限的可能性，就只有程序员和运行期的虚拟机才知道这个Object到底是个什么类型的对象。在编译期间，编译器无法检查这个Object的强制转型是否成功，如果仅仅依赖程序员去保障这项操作的正确性，许多ClassCastException的风险就会转嫁到程序运行期之中。</p><p>泛型技术在C#和Java之中的使用方式看似相同，但实现上却有着根本性的分歧，C#里面泛型无论在程序源码中、编译后的IL中（Intermediate Language，中间语言，这时候泛型是一个占位符），或是运行期的CLR中，都是切实存在的，List＜int＞与List＜String＞就是两个不同的类型，它们在系统运行期生成，有自己的虚方法表和类型数据，这种实现称为类型膨胀，基于这种方法实现的泛型称为真实泛型。</p><p>Java语言中的泛型则不一样，它只在程序源码中存在，在编译后的字节码文件中，就已经替换为原来的原生类型（Raw Type，也称为裸类型）了，并且在相应的地方插入了强制转型代码，因此，对于运行期的Java语言来说，ArrayList＜int＞与ArrayList＜String＞就是同一个类，所以泛型技术实际上是Java语言的一颗语法糖，Java语言中的泛型实现方法称为<strong>类型擦除</strong>，基于这种方法实现的泛型称为伪泛型。</p><p>将一段Java代码编译成Class文件，然后再用字节码反编译工具进行反编译后，将会发现泛型都不见了，程序又变回了Java泛型出现之前的写法，泛型类型都变回了原生类型<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">method</span><span class="params">(List&lt;String&gt; stringList)</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"List"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="string">"OK"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">method</span><span class="params">(List&lt;Integer&gt; stringList)</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"List"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面这段代码是不能被编译的，因为参数List＜Integer＞和List＜String＞编译之后都被擦除了，变成了一样的原生类型List＜E＞，擦除动作导致这两种方法的特征签名变得一模一样。</p><h3 id="为什么泛型擦除后get不需要类型转换？"><a href="#为什么泛型擦除后get不需要类型转换？" class="headerlink" title="为什么泛型擦除后get不需要类型转换？"></a>为什么泛型擦除后get不需要类型转换？</h3><p>因为类型擦除的问题，所以所有的泛型类型变量最后都会被替换为原始类型。这样就引起了一个问题，既然都被替换为原始类型，那么为什么我们在获取的时候，不需要进行强制类型转换呢？看下ArrayList和get方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">RangeCheck(index);</span><br><span class="line"><span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看以看到，在return之前，会根据泛型变量进行强转。<br>写了个简单的测试代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">ArrayList&lt;Date&gt; list=<span class="keyword">new</span> ArrayList&lt;Date&gt;();</span><br><span class="line">list.add(<span class="keyword">new</span> Date());</span><br><span class="line">Date myDate=list.get(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后反编了下字节码，如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">Code:</span><br><span class="line">0: new #16 // class java/util/ArrayList</span><br><span class="line"><span class="number">3</span>: dup</span><br><span class="line">4: invokespecial #18 // Method java/util/ArrayList."&lt;init</span><br><span class="line">:()V</span><br><span class="line"><span class="number">7</span>: astore_1</span><br><span class="line"><span class="number">8</span>: aload_1</span><br><span class="line">9: new #19 // class java/util/Date</span><br><span class="line"><span class="number">12</span>: dup</span><br><span class="line">13: invokespecial #21 // Method java/util/Date."&lt;init&gt;":()</span><br><span class="line"> </span><br><span class="line">16: invokevirtual #22 // Method java/util/ArrayList.add:(L</span><br><span class="line">va/lang/Object;)Z</span><br><span class="line"><span class="number">19</span>: pop</span><br><span class="line"><span class="number">20</span>: aload_1</span><br><span class="line"><span class="number">21</span>: iconst_0</span><br><span class="line">22: invokevirtual #26 // Method java/util/ArrayList.get:(I</span><br><span class="line">java/lang/Object;</span><br><span class="line">25: checkcast #19 // class java/util/Date</span><br><span class="line"><span class="number">28</span>: astore_2</span><br><span class="line"><span class="number">29</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure></p><p>看第22 ，它调用的是ArrayList.get()方法，方法返回值是Object，说明类型擦除了。然后第25，它做了一个checkcast操作，即检查类型#19， 在在上面找#19引用的类型，他是<br>9: new #19 // class java/util/Date<br>是一个Date类型，即做Date类型的强转。<br>所以不是在get方法里强转的，是在你调用的地方强转的</p><h2 id="kotlin泛型"><a href="#kotlin泛型" class="headerlink" title="kotlin泛型"></a>kotlin泛型</h2><p>kotlin泛型中引入了in和out</p><h3 id="Out-协变"><a href="#Out-协变" class="headerlink" title="Out (协变)"></a>Out (协变)</h3><p>如果你的类是将泛型作为内部方法的返回，那么可以用 out：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Production</span>&lt;<span class="type">out T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">produce</span><span class="params">()</span></span>: T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以称其为 production class/interface，因为其主要是产生（produce）指定泛型对象。因此，可以这样来记：produce = output = out。<br>相当于Java中的? extends T</p><h3 id="In-逆变"><a href="#In-逆变" class="headerlink" title="In(逆变)"></a>In(逆变)</h3><p>如果你的类是将泛型对象作为函数的参数，那么可以用 in：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Consumer</span>&lt;<span class="type">in T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">consume</span><span class="params">(item: <span class="type">T</span>)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以称其为 consumer class/interface，因为其主要是消费指定泛型对象。因此，可以这样来记：consume = input = in。<br>相当于Java中的? super T</p><h3 id="Invariant-不变"><a href="#Invariant-不变" class="headerlink" title="Invariant(不变)"></a>Invariant(不变)</h3><p>如果既将泛型作为函数参数，又将泛型作为函数的输出，那就既不用 in 或 out。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ProductionConsumer</span>&lt;<span class="type">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">produce</span><span class="params">()</span></span>: T</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">consume</span><span class="params">(item: <span class="type">T</span>)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>“父类泛型对象可以赋值给子类泛型对象，用 in；<br>子类泛型对象可以赋值给父类泛型对象，用 out。”</p></blockquote><p>关于In out使用的例子，可见：<a href="https://zhuanlan.zhihu.com/p/32583310" target="_blank" rel="noopener">Kotlin 泛型中的 in 和 out</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.cnblogs.com/dldrjyy13102/p/8297045.html" target="_blank" rel="noopener">PECS法则与extends和super关键字</a><br><a href="https://blog.csdn.net/LonelyRoamer/article/details/7868820" target="_blank" rel="noopener">什么是泛型擦除</a><br><a href="https://blog.csdn.net/wanliguodu/article/details/80260224" target="_blank" rel="noopener">由Kotlin 中关键字out和in和Java中的泛型的比较学习</a><br><a href="https://zhuanlan.zhihu.com/p/32583310" target="_blank" rel="noopener">Kotlin 泛型中的 in 和 out</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;带着问题学习可以让我们在学习的过程中更加有目的性与条理。&lt;br&gt;例如在读源码的过程中，我们如果从头开始读，往往千头万绪，抓不住要领。&lt;br&gt;
      
    
    </summary>
    
    
      <category term="kotlin" scheme="http://ShenZhen2017.github.io/tags/kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Gradle多模块复用技巧</title>
    <link href="http://ShenZhen2017.github.io/blog/2020/11/gradle-tips-learn.html"/>
    <id>http://ShenZhen2017.github.io/blog/2020/11/gradle-tips-learn.html</id>
    <published>2020-11-15T08:27:41.000Z</published>
    <updated>2020-12-16T16:00:43.376Z</updated>
    
    <content type="html"><![CDATA[<p>随着项目中的模块越来越多，模块中的依赖，版本号等都需要统一控制，下面介绍几种Gradle代码，多模块复用的技巧</p><h2 id="ext方式"><a href="#ext方式" class="headerlink" title="ext方式"></a>ext方式</h2><p>Android 开发中统一不同 module 的依赖版本十分重要，传统的方式是使用 ext 的方式<br>如下所示，首先是创建config.gradle,然后在根build.gradle和app模块下的build.gradle下使用</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// config.gradle</span></span><br><span class="line">ext &#123;</span><br><span class="line">    android = [</span><br><span class="line">            compileSdkVersion: <span class="number">26</span>,</span><br><span class="line">            buildToolsVersion: <span class="string">"25.0.0"</span>,</span><br><span class="line">            minSdkVersion    : <span class="number">14</span>,</span><br><span class="line">            targetSdkVersion : <span class="number">22</span>,</span><br><span class="line">            versionCode      : <span class="number">17</span>,</span><br><span class="line">            versionName      : <span class="string">"1.7"</span>,</span><br><span class="line">            applicationId    : <span class="string">"com.king.headline"</span>,</span><br><span class="line">            applicationId2222: <span class="string">"com.king.headline"</span>,</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">dependencies</span> = [</span><br><span class="line">            appcompatv7: <span class="string">"com.android.support:design:22.2.0"</span>,</span><br><span class="line">            loadtoast: <span class="string">"net.steamcrafted:load-toast:1.0.6"</span>,</span><br><span class="line">            constraintlayout: <span class="string">"com.android.support.constraint:constraint-layout:1.0.2"</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>于根目录下的build.gradle于引用当前gradle<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// root builf.gradle</span></span><br><span class="line">apply <span class="keyword">from</span>: <span class="string">"config.gradle"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">buildscript</span> &#123;</span><br><span class="line">    ext.kotlin_version = <span class="string">"1.4.10"</span></span><br><span class="line">    <span class="keyword">repositories</span> &#123;</span><br><span class="line">        google()</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">dependencies</span> &#123;</span><br><span class="line">        <span class="keyword">classpath</span> <span class="string">"com.android.tools.build:gradle:4.0.1"</span></span><br><span class="line">        <span class="keyword">classpath</span> <span class="string">"org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在app模块下的build.gradle中使用</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app build.gradle</span></span><br><span class="line">apply plugin: <span class="string">'com.android.application'</span></span><br><span class="line"><span class="keyword">def</span> cfg = rootProject.ext.android</span><br><span class="line"><span class="keyword">def</span> dpc = rootProject.ext.<span class="keyword">dependencies</span></span><br><span class="line">android &#123;</span><br><span class="line">    compileSdkVersion cfg.compileSdkVersion</span><br><span class="line">    buildToolsVersion cfg.buildToolsVersion</span><br><span class="line"></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        applicationId <span class="string">"com.king.headline"</span></span><br><span class="line">        minSdkVersion <span class="number">14</span></span><br><span class="line">        targetSdkVersion <span class="number">22</span></span><br><span class="line">        versionCode <span class="number">17</span></span><br><span class="line">        versionName <span class="string">"1.7"</span></span><br><span class="line">    &#125;</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled <span class="keyword">false</span></span><br><span class="line">            proguardFiles getDefaultProguardFile(<span class="string">'proguard-android.txt'</span>), <span class="string">'proguard-rules.pro'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="keyword">compile</span> <span class="keyword">fileTree</span>(dir: <span class="string">'libs'</span>, <span class="keyword">include</span>: [<span class="string">'*.jar'</span>])</span><br><span class="line">    <span class="keyword">compile</span> dpc.loadtoast</span><br><span class="line">    <span class="keyword">compile</span> dpc.appcompatv7</span><br><span class="line">    <span class="keyword">compile</span> dpc.constraintlayout</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="进阶使用-遍历代替一行行手写"><a href="#进阶使用-遍历代替一行行手写" class="headerlink" title="进阶使用:遍历代替一行行手写"></a>进阶使用:遍历代替一行行手写</h3><p>因为项目中的依赖太多了，还有一种写法是在在 ext{…} 中写依赖，然后在脚本中遍历添加依赖的方式<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ext&#123;</span><br><span class="line">    <span class="keyword">dependencies</span> = [...]</span><br><span class="line">    annotationd_ependencies = [...]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">dependencies</span>.<span class="keyword">each</span> &#123; k, v -&gt; implementation v &#125;</span><br><span class="line">annotationd_ependencies.<span class="keyword">each</span> &#123; k, v -&gt; kapt v &#125;</span><br></pre></td></tr></table></figure></p><h2 id="自定义-plugin-includeBuild"><a href="#自定义-plugin-includeBuild" class="headerlink" title="自定义 plugin + includeBuild"></a>自定义 plugin + includeBuild</h2><h3 id="1-我们新建一个-module，命名为-version"><a href="#1-我们新建一个-module，命名为-version" class="headerlink" title="1.我们新建一个 module，命名为 version"></a>1.我们新建一个 module，命名为 version</h3><h3 id="2-添加DependencyVersionPlugin"><a href="#2-添加DependencyVersionPlugin" class="headerlink" title="2.添加DependencyVersionPlugin"></a>2.添加DependencyVersionPlugin</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DependencyVersionPlugin</span> : <span class="type">Plugin</span>&lt;<span class="type">Project</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">apply</span><span class="params">(project: <span class="type">Project</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 version 的 build.gradle 文件加入<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">gradlePlugin</span> &#123;</span><br><span class="line">    <span class="section">plugins</span> &#123;</span><br><span class="line">        <span class="section">version</span> &#123;</span><br><span class="line">            <span class="attribute">id</span> = <span class="string">'com.test.version'</span></span><br><span class="line">            implementationClass = <span class="string">'com.test.version.DependencyVersionPlugin'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="3-在-settings-gradle-加入-includeBuild-“version”-（重点）"><a href="#3-在-settings-gradle-加入-includeBuild-“version”-（重点）" class="headerlink" title="3.在 settings.gradle 加入 includeBuild(“version”) （重点）"></a>3.在 settings.gradle 加入 includeBuild(“version”) （重点）</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">includeBuild</span><span class="params">(<span class="string">"version"</span>)</span></span></span><br><span class="line"></span><br><span class="line">rootProject.name=<span class="string">'VersionControlDemo'</span></span><br><span class="line">include <span class="string">':app'</span></span><br><span class="line">include <span class="string">':lib'</span></span><br></pre></td></tr></table></figure><h3 id="4-接下来在需要引用的-module-中引入该插件"><a href="#4-接下来在需要引用的-module-中引入该插件" class="headerlink" title="4.接下来在需要引用的 module 中引入该插件"></a>4.接下来在需要引用的 module 中引入该插件</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">plugins</span> &#123;</span><br><span class="line">    <span class="attribute">id</span> <span class="string">"com.flywith24.version"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就可以使用了</p><h3 id="定义依赖库版本"><a href="#定义依赖库版本" class="headerlink" title="定义依赖库版本"></a>定义依赖库版本</h3><p>示例如下所示：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> Testing &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">val</span> jUnit = <span class="string">"junit:junit:4.12"</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">val</span> androidJunit = <span class="string">"androidx.test.ext:junit:1.1.1"</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">val</span> espresso = <span class="string">"androidx.test.espresso:espresso-core:3.2.0"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="然后在build-gradle中使用"><a href="#然后在build-gradle中使用" class="headerlink" title="然后在build.gradle中使用"></a>然后在build.gradle中使用</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">implementation(AndroidX.coreKtx)</span><br><span class="line">implementation(AndroidX.appcompat)</span><br><span class="line">implementation(AndroidX.constraintlayout)</span><br></pre></td></tr></table></figure><h2 id="使用组合构建切换远程依赖-本地module"><a href="#使用组合构建切换远程依赖-本地module" class="headerlink" title="使用组合构建切换远程依赖/本地module"></a>使用组合构建切换远程依赖/本地module</h2><p>在settings.gralde中添加<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">if</span> (Boolean.valueOf(useLocal)) &#123;</span><br><span class="line">    <span class="selector-tag">includeBuild</span>(<span class="string">'../Flywith24-Permission'</span>) &#123;</span><br><span class="line">        <span class="selector-tag">dependencySubstitution</span> &#123;</span><br><span class="line">            <span class="selector-tag">substitute</span> <span class="selector-tag">module</span>(<span class="string">'com.github.Flywith24:Flywith24-Permission'</span>) <span class="selector-tag">with</span> <span class="selector-tag">project</span>(<span class="string">':library'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果使用本地代码，将useLocal设置为true即可.</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/jinfulin/article/details/80421927" target="_blank" rel="noopener">gradle配置优化及dependencies中各种依赖方式说明</a><br><a href="https://juejin.im/post/6844904169833234439" target="_blank" rel="noopener">【奇技淫巧】除了 buildSrc 还能这样统一配置依赖版本？巧用 includeBuild</a><br><a href="https://juejin.im/post/6870082590397693965" target="_blank" rel="noopener">【奇技淫巧】子 module 的 build.gradle 中没有一行代码？多项目构建技巧</a><br><a href="https://juejin.im/post/6890549273105006600" target="_blank" rel="noopener">Gradle 爬坑指南 – Gradle 核心模型、Hook 函数、ext 扩展属性、Project API</a><br><a href="https://github.com/hi-dhl/ComposingBuilds-vs-buildSrc" target="_blank" rel="noopener">Composing builds vs buildSrc区别</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;随着项目中的模块越来越多，模块中的依赖，版本号等都需要统一控制，下面介绍几种Gradle代码，多模块复用的技巧&lt;/p&gt;
&lt;h2 id=&quot;ext方式&quot;&gt;&lt;a href=&quot;#ext方式&quot; class=&quot;headerlink&quot; title=&quot;ext方式&quot;&gt;&lt;/a&gt;ext方式&lt;/h
      
    
    </summary>
    
    
      <category term="android" scheme="http://ShenZhen2017.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>常用工具总结</title>
    <link href="http://ShenZhen2017.github.io/blog/2020/11/common-usage-tools.html"/>
    <id>http://ShenZhen2017.github.io/blog/2020/11/common-usage-tools.html</id>
    <published>2020-11-10T00:57:41.000Z</published>
    <updated>2020-12-16T16:00:43.376Z</updated>
    
    <content type="html"><![CDATA[<p>1.markdown排版工具<br><a href="https://www.mdnice.com/" target="_blank" rel="noopener">https://www.mdnice.com/</a></p><p>2.封面图设计工具<br><a href="https://www.chuangkit.com/" target="_blank" rel="noopener">https://www.chuangkit.com/</a></p><p>3.UML图工具<br><a href="https://www.draw.io/" target="_blank" rel="noopener">https://www.draw.io/</a></p><p>4.mac屏幕保护时钟工具<br><a href="https://fliqlo.com/#/screensaver" target="_blank" rel="noopener">https://fliqlo.com/#/screensaver</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.markdown排版工具&lt;br&gt;&lt;a href=&quot;https://www.mdnice.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.mdnice.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2.封面图设计工具&lt;br&gt;&lt;a hre
      
    
    </summary>
    
    
      <category term="总结" scheme="http://ShenZhen2017.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>ARTS打卡4</title>
    <link href="http://ShenZhen2017.github.io/blog/2020/11/arts-way-four.html"/>
    <id>http://ShenZhen2017.github.io/blog/2020/11/arts-way-four.html</id>
    <published>2020-11-09T00:18:51.000Z</published>
    <updated>2020-12-16T16:00:43.376Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><blockquote><p><a href="https://leetcode-cn.com/problems/check-array-formation-through-concatenation/" target="_blank" rel="noopener">1640. 能否连接形成数组</a><br>给你一个整数数组 arr ，数组中的每个整数 互不相同 。另有一个由整数数组构成的数组 pieces，其中的整数也 互不相同 。请你以 任意顺序 连接 pieces 中的数组以形成 arr 。但是，不允许 对每个数组 pieces[i] 中的整数重新排序。<br>如果可以连接 pieces 中的数组形成 arr ，返回 true ；否则，返回 false 。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">fun canFormArray(arr: IntArray, pieces: Array&lt;IntArray&gt;): Boolean &#123;</span><br><span class="line">        val map = hashMapOf&lt;Int, IntArray&gt;()</span><br><span class="line">        pieces.forEach &#123;</span><br><span class="line">            map[it[0]] = it</span><br><span class="line">        &#125;</span><br><span class="line">        var i = 0</span><br><span class="line">        while (i &lt; arr.size) &#123;</span><br><span class="line">            if (map.contains(arr[i]).not()) &#123;</span><br><span class="line">                return false</span><br><span class="line">            &#125;</span><br><span class="line">            val array = map[arr[i]]!!</span><br><span class="line">            var j = 0</span><br><span class="line">            while (j &lt; array.size) &#123;</span><br><span class="line">                if (arr[i] != array[j]) &#123;</span><br><span class="line">                    return false</span><br><span class="line">                &#125;</span><br><span class="line">                i++</span><br><span class="line">                j++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p><a href="https://android-developers.googleblog.com/2020/10/android-studio-41.html" target="_blank" rel="noopener">What’s New in android studio 4.1</a><br>本文主要讲述了Android studio 4.1的新特性<br>1.新数据库检查器<br>2.直接在Android Studio中运行Android模拟器<br>3.使用TensorFlow Lite模型<br>4.使用TensorFlow Lite模型<br>5.本机内存探查器<br>6.系统跟踪用户界面：更轻松的选择新的分析选项以及更多的帧渲染数据<br>7.Dagger navigation support<br>8.自定义视图预览<br>9.Apply Changes</p><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><p>获取APK包名的方法<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb <span class="keyword">shell</span></span><br><span class="line"><span class="bash">logcat | grep START<span class="comment">#需要先打开apk后，再敲入命令</span></span></span><br></pre></td></tr></table></figure></p><p>详情可见：<a href="https://www.jianshu.com/p/f6e8a03db025" target="_blank" rel="noopener">获取APK包名的几种方法</a></p><h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p>本周主要总结了工作中常用到的一些工具,详情可见：<br><a href="https://shenzhen2017.github.io/blog/2020/11/common-usage-tools.html">常用工具总结</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Algorithm&quot;&gt;&lt;a href=&quot;#Algorithm&quot; class=&quot;headerlink&quot; title=&quot;Algorithm&quot;&gt;&lt;/a&gt;Algorithm&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.
      
    
    </summary>
    
    
      <category term="ARTS" scheme="http://ShenZhen2017.github.io/tags/ARTS/"/>
    
  </entry>
  
  <entry>
    <title>【带着问题学】关于LiveData你应该知道的知识点</title>
    <link href="http://ShenZhen2017.github.io/blog/2020/11/live-data-sum.html"/>
    <id>http://ShenZhen2017.github.io/blog/2020/11/live-data-sum.html</id>
    <published>2020-11-08T02:26:07.000Z</published>
    <updated>2020-12-16T16:00:43.376Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>带着问题学习可以让我们在学习的过程中更加有目的性与条理。<br>例如在读源码的过程中，我们如果从头开始读，往往千头万绪，抓不住要领。<br>而如果在开始读之前先带着几个问题，则可以让我们在读源码的过程中有一个主线。<br>最后也可以通过判断自己的问题是否得到解决了，来判断自己是否真的读懂了，不然面对成千上万行的代码，很容易有白读了的感觉。</p><p>下面列出先列出几个问题<br>1.LiveData为什么可以自动取消订阅，如何避免内存泄漏？<br>2.LiveData设置相同的值，会不会回调？<br>3.LiveData有什么坑？如何实现LiveDataBus？</p><p>本文主要回答了以上3个问题，读者在读完后可以看看相关问题有没有得到解答~</p><h2 id="LiveData如何避免内存泄漏"><a href="#LiveData如何避免内存泄漏" class="headerlink" title="LiveData如何避免内存泄漏?"></a>LiveData如何避免内存泄漏?</h2><p>首先说说为什么会发生内存泄漏<br>当一个长生命周期的对象引用了一个短生命周期的对象，就会产生内存泄漏。<br>比如当我们使用Rxjava来发起一个网络请求的时候，而在Activity关闭的时候没有取消订阅，就会发生内存泄漏.<br>所以需要用户使用CompositeDisposable，来在onDestroy时取消订阅<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> d: Disposable? = <span class="literal">null</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> ds: CompositeDisposable</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">(v: <span class="type">View</span>)</span></span> &#123;</span><br><span class="line">       <span class="keyword">when</span> (v.id) &#123;</span><br><span class="line">           R.id.btn_start_count -&gt; &#123;</span><br><span class="line">               d = Observable.interval(<span class="number">1</span>, TimeUnit.SECONDS)</span><br><span class="line">                       .subscribeOn(Schedulers.io())</span><br><span class="line">                       .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">                       .subscribe &#123;</span><br><span class="line">                           tv_count.text = it.toString()</span><br><span class="line">                           loge(TAG, <span class="string">"count:<span class="variable">$it</span>"</span>)</span><br><span class="line">                       &#125;</span><br><span class="line">               ds.add(d!!)</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span> &#123;</span><br><span class="line">       <span class="keyword">super</span>.onDestroy()</span><br><span class="line">       ds.dispose()</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>如上所示：通过compositeDisable可以避免Rxjava发生内存泄漏。<br>但是这种方法依赖于用户手动操作，容易忘记与出现问题。</p><p>但使用LiveData却不用担心这个问题,LiveData订阅后，在页面销毁后可以自动取消订阅<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MutableLiveDataFragment</span> : <span class="type">Fragment</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> changeObserver = Observer&lt;String&gt; &#123; value -&gt;</span><br><span class="line">        value?.let &#123; txt_fragment.text = it &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onAttach</span><span class="params">(context: <span class="type">Context</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onAttach(context)</span><br><span class="line">        getLiveDataA().observe(<span class="keyword">this</span>, changeObserver)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// .. some other Fragment specific code ..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="为什么LiveData可以自动取消订阅？"><a href="#为什么LiveData可以自动取消订阅？" class="headerlink" title="为什么LiveData可以自动取消订阅？"></a>为什么LiveData可以自动取消订阅？</h3><p>如果一个Observer的生命周期处于STARTED或RESUMED状态，那么LiveData将认为这个Observer处于活跃状态.LiveData仅通知活跃的Observer去更新UI。<br>非活跃状态的Observer，即使订阅了LiveData，也不会收到更新的通知。</p><p>结合一个实现了LifecycleOwner接口的对象，你能注册一个Observer。这种结合关系使得当具有生命周期的对象的状态变为DESTROYED时，Observer将被取消订阅。这对于活和片段尤其有用，因为它们可以安全地订阅LiveData对象，而不必担心内存泄漏 - 当活和片段生命周期为DESTROYED时，它们立即会被取消订阅。</p><h4 id="1-首先看看订阅时发生了什么"><a href="#1-首先看看订阅时发生了什么" class="headerlink" title="1.首先看看订阅时发生了什么"></a>1.首先看看订阅时发生了什么</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MainThread</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">observe</span><span class="params">(@NonNull LifecycleOwner owner, @NonNull Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class="line">        assertMainThread(<span class="string">"observe"</span>);</span><br><span class="line">        <span class="keyword">if</span> (owner.getLifecycle().getCurrentState() == DESTROYED) &#123;</span><br><span class="line">            <span class="comment">// ignore</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LifecycleBoundObserver wrapper = <span class="keyword">new</span> LifecycleBoundObserver(owner, observer);</span><br><span class="line">        ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper);</span><br><span class="line">        <span class="keyword">if</span> (existing != <span class="keyword">null</span> &amp;&amp; !existing.isAttachedTo(owner)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Cannot add the same observer"</span></span><br><span class="line">                    + <span class="string">" with different lifecycles"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (existing != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        owner.getLifecycle().addObserver(wrapper);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>观察者被存放到了mObservers之中，其中存放的是LifecycleBoundObserver类型</p><h4 id="接下来看看LifecycleBoundObserver类"><a href="#接下来看看LifecycleBoundObserver类" class="headerlink" title="接下来看看LifecycleBoundObserver类"></a>接下来看看LifecycleBoundObserver类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LifecycleBoundObserver</span> <span class="keyword">extends</span> <span class="title">ObserverWrapper</span> <span class="keyword">implements</span> <span class="title">GenericLifecycleObserver</span> </span>&#123;</span><br><span class="line">        <span class="meta">@NonNull</span></span><br><span class="line">        <span class="keyword">final</span> LifecycleOwner mOwner;</span><br><span class="line"></span><br><span class="line">        LifecycleBoundObserver(<span class="meta">@NonNull</span> LifecycleOwner owner, Observer&lt;? <span class="keyword">super</span> T&gt; observer) &#123;</span><br><span class="line">            <span class="keyword">super</span>(observer);</span><br><span class="line">            mOwner = owner;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">shouldBeActive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> mOwner.getLifecycle().getCurrentState().isAtLeast(STARTED);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStateChanged</span><span class="params">(LifecycleOwner source, Lifecycle.Event event)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (mOwner.getLifecycle().getCurrentState() == DESTROYED) &#123;</span><br><span class="line">                removeObserver(mObserver);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            activeStateChanged(shouldBeActive());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">isAttachedTo</span><span class="params">(LifecycleOwner owner)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> mOwner == owner;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">detachObserver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            mOwner.getLifecycle().removeObserver(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>当Lifecycles的State发生变化会回调onStateChanged方法，当State为DESTROYED是，则移除观察者Observer。里面调用的是LiveData的removeObserver方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MainThread</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(@NonNull <span class="keyword">final</span> Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class="line">        assertMainThread(<span class="string">"removeObserver"</span>);</span><br><span class="line">        ObserverWrapper removed = mObservers.remove(observer);</span><br><span class="line">        <span class="keyword">if</span> (removed == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        removed.detachObserver();</span><br><span class="line">        removed.activeStateChanged(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>当页面销毁时，在mObservers中remove了observer，就这样完成了订阅的自动取消。</p><h2 id="livedata传相同的值会不会执行onchanged回调"><a href="#livedata传相同的值会不会执行onchanged回调" class="headerlink" title="livedata传相同的值会不会执行onchanged回调?"></a>livedata传相同的值会不会执行onchanged回调?</h2><p>当我们给liveData设置value时，Observer就会更新。但如果我们两次设置一样的value，Observer是否会更新？</p><p>首先看看setValue方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MainThread</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        assertMainThread(<span class="string">"setValue"</span>);</span><br><span class="line">        mVersion++;</span><br><span class="line">        mData = value;</span><br><span class="line">        dispatchingValue(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>其中最重要的是mVersion参数<br>接下来看dispatchingValue方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatchingValue</span><span class="params">(@Nullable ObserverWrapper initiator)</span> </span>&#123;</span><br><span class="line">        ....</span><br><span class="line">        considerNotify(initiator);</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">considerNotify</span><span class="params">(ObserverWrapper observer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!observer.mActive) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Check latest state b4 dispatch. Maybe it changed state but we didn't get the event yet.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// we still first check observer.active to keep it as the entrance for events. So even if</span></span><br><span class="line">        <span class="comment">// the observer moved to an active state, if we've not received that event, we better not</span></span><br><span class="line">        <span class="comment">// notify for a more predictable notification order.</span></span><br><span class="line">        <span class="keyword">if</span> (!observer.shouldBeActive()) &#123;</span><br><span class="line">            observer.activeStateChanged(<span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (observer.mLastVersion &gt;= mVersion) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        observer.mLastVersion = mVersion;</span><br><span class="line">        observer.mObserver.onChanged((T) mData);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>到这里一目了然，只要mVersion是大于等于之前的值，就会回调onChanged方法，也就是说，不管值是否相同，只看version的值，也就是基本只有int到达最大值的时候才会导致bug，2的31次方-1，估计只有无聊的人才会写改这么多次值的代码了。</p><h2 id="LiveDataBus实现"><a href="#LiveDataBus实现" class="headerlink" title="LiveDataBus实现"></a>LiveDataBus实现</h2><h3 id="为什么要使用LiveData来实现通信总线？"><a href="#为什么要使用LiveData来实现通信总线？" class="headerlink" title="为什么要使用LiveData来实现通信总线？"></a>为什么要使用LiveData来实现通信总线？</h3><h4 id="使用LiveData的理由"><a href="#使用LiveData的理由" class="headerlink" title="使用LiveData的理由"></a>使用LiveData的理由</h4><ul><li>LiveData具有的这种可观察性和生命周期感知的能力，使其非常适合作为Android通信总线的基础构件。</li><li>使用者不用显示调用反注册方法。<br>由于LiveData具有生命周期感知能力，所以LiveDataBus只需要调用注册回调方法，而不需要显示的调用反注册方法。这样带来的好处不仅可以编写更少的代码，而且可以完全杜绝其他通信总线类框架（如EventBus、RxBus）忘记调用反注册所带来的内存泄漏的风险。</li></ul><h4 id="为什么要用LiveDataBus替代EventBus和RxBus"><a href="#为什么要用LiveDataBus替代EventBus和RxBus" class="headerlink" title="为什么要用LiveDataBus替代EventBus和RxBus"></a>为什么要用LiveDataBus替代EventBus和RxBus</h4><ul><li>LiveDataBus的实现及其简单 相对EventBus复杂的实现，LiveDataBus只需要一个类就可以实现。</li><li>LiveDataBus可以减小APK包的大小 由于LiveDataBus只依赖Android官方Android Architecture Components组件的LiveData，没有其他依赖，本身实现只有一个类。作为比较，EventBus JAR包大小为57kb，RxBus依赖RxJava和RxAndroid，其中RxJava2包大小2.2MB，RxJava1包大小1.1MB，RxAndroid包大小9kb。使用LiveDataBus可以大大减小APK包的大小。</li><li>LiveDataBus依赖方支持更好 LiveDataBus只依赖Android官方Android Architecture Components组件的LiveData，相比RxBus依赖的RxJava和RxAndroid，依赖方支持更好。</li><li>LiveDataBus具有生命周期感知 LiveDataBus具有生命周期感知，在Android系统中使用调用者不需要调用反注册，相比EventBus和RxBus使用更为方便，并且没有内存泄漏风险。</li></ul><h3 id="LiveData实现事件总线的坑"><a href="#LiveData实现事件总线的坑" class="headerlink" title="LiveData实现事件总线的坑"></a>LiveData实现事件总线的坑</h3><p>由于LiveData的粘性特性，用LiveData实现LiveDataBus，订阅者会收到订阅之前发布的消息。对于一个消息总线来说，这是不可接受的。无论EventBus或者RxBus，订阅方都不会收到订阅之前发出的消息。对于一个消息总线，LiveDataBus必须要解决这个问题。</p><h4 id="粘性消息的原因"><a href="#粘性消息的原因" class="headerlink" title="粘性消息的原因"></a>粘性消息的原因</h4><p>当LifeCircleOwner的状态发生变化的时候，会调用LiveData.ObserverWrapper的activeStateChanged函数，如果这个时候ObserverWrapper的状态是active，就会调用LiveData的dispatchingValue。<br>前面分析过，最后会调用到considerNotify方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">considerNotify</span><span class="params">(ObserverWrapper observer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!observer.mActive) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Check latest state b4 dispatch. Maybe it changed state but we didn't get the event yet.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// we still first check observer.active to keep it as the entrance for events. So even if</span></span><br><span class="line">        <span class="comment">// the observer moved to an active state, if we've not received that event, we better not</span></span><br><span class="line">        <span class="comment">// notify for a more predictable notification order.</span></span><br><span class="line">        <span class="keyword">if</span> (!observer.shouldBeActive()) &#123;</span><br><span class="line">            observer.activeStateChanged(<span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (observer.mLastVersion &gt;= mVersion) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        observer.mLastVersion = mVersion;</span><br><span class="line">        observer.mObserver.onChanged((T) mData);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>在LiveData的considerNotify方法中，如果ObserverWrapper的mLastVersion小于LiveData的mVersion，就会去回调mObserver的onChanged方法。而每个新的订阅者，其version都是-1，LiveData一旦设置过其version是大于-1的（每次LiveData设置值都会使其version加1），这样就会导致LiveDataBus每注册一个新的订阅者，这个订阅者立刻会收到一个回调，即使这个设置的动作发生在订阅之前。</p><h4 id="问题原因总结"><a href="#问题原因总结" class="headerlink" title="问题原因总结"></a>问题原因总结</h4><p>对于这个问题，总结一下发生的核心原因。对于LiveData，其初始的version是-1，当我们调用了其setValue或者postValue，其vesion会+1；对于每一个观察者的封装ObserverWrapper，其初始version也为-1，也就是说，每一个新注册的观察者，其version为-1；当LiveData设置这个ObserverWrapper的时候，如果LiveData的version大于ObserverWrapper的version，LiveData就会强制把当前value推送给Observer。</p><h4 id="如何解决这个问题"><a href="#如何解决这个问题" class="headerlink" title="如何解决这个问题"></a>如何解决这个问题</h4><p>明白了问题产生的原因之后，我们来看看怎么才能解决这个问题。很显然，根据之前的分析，只需要在注册一个新的订阅者的时候把Wrapper的version设置成跟LiveData的version一致即可。</p><p>那么怎么实现呢，看看LiveData的observe方法，他会在observe时创建一个LifecycleBoundObserver，LifecycleBoundObserver是ObserverWrapper的派生类。然后会把这个LifecycleBoundObserver放入一个私有Map容器mObservers中。无论ObserverWrapper还是LifecycleBoundObserver都是私有的或者包可见的，所以无法通过继承的方式更改LifecycleBoundObserver的version。</p><p>那么能不能从Map容器mObservers中取到LifecycleBoundObserver，然后再更改version呢？答案是肯定的，通过查看SafeIterableMap的源码我们发现有一个protected的get方法。因此，在调用observe的时候，我们可以通过反射拿到LifecycleBoundObserver，再把LifecycleBoundObserver的version设置成和LiveData一致即可。</p><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>具体实现可见于美团分享的文章，链接在文末</p><h3 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h3><p>使用美团的这种方式，依赖于反射，在时间上会慢一些，同时性能上有一些损失。<br>我还看到网络上有一种基于LiveData,不利用反射实现消息总线的方案，比起美团方案各有利弊，有兴趣的同学可以了解下。<br><a href="https://github.com/KunMinX/UnPeek-LiveData" target="_blank" rel="noopener">MVVM最佳实践之UnPeek-LiveData</a></p><h2 id="LiveData丢失数据的坑"><a href="#LiveData丢失数据的坑" class="headerlink" title="LiveData丢失数据的坑"></a>LiveData丢失数据的坑</h2><h3 id="postValue-数据丢失的问题"><a href="#postValue-数据丢失的问题" class="headerlink" title="postValue 数据丢失的问题"></a>postValue 数据丢失的问题</h3><p>postValue 只是把传进来的数据先存到 mPendingData，然后往主线程抛一个 Runnable，在这个 Runnable 里面再调用 setValue 来把存起来的值真正设置上去，并回调观察者们。而如果在这个 Runnable 执行前多次 postValue，其实只是改变暂存的值 mPendingData，并不会再次抛另一个 Runnable。这就会出现后设置的值把前面的值覆盖掉的问题，会导致事件丢失。<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">protected</span> <span class="function"><span class="keyword">void</span> <span class="title">postValue</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> postTask;</span><br><span class="line">    <span class="keyword">synchronized</span> (mDataLock) &#123;</span><br><span class="line">        postTask = mPendingData == NOT_SET;</span><br><span class="line">        <span class="comment">// 这里先把数据暂存起来，后来的数据会覆盖前面的</span></span><br><span class="line">        mPendingData = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里保证只抛一个 mPostValueRunnable，#-.-</span></span><br><span class="line">    <span class="keyword">if</span> (!postTask) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ArchTaskExecutor.getInstance().postToMainThread(mPostValueRunnable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="setValue-不回调观察者"><a href="#setValue-不回调观察者" class="headerlink" title="setValue 不回调观察者"></a>setValue 不回调观察者</h3><p>LiveData 的生命周期感知能力就体现在这里，它不会回调处于「非激活状态」（即 onStart 之后到 onPause 之前）的观察者，因为这时更新 View 没有意义，而且比较危险，它会等到观察者激活之后再把新的值回调给他。<br>但是如果我传了多个数据（假设都是用 setValue 保证不会被覆盖），那些处于非激活状态的观察者是毫不知情的，他们在激活的时候只会收到最后一个数据。这对于事件传递来说，就表现为事件丢失，中间传的任何数据都无法收到，那也就失去了事件传递的意义。</p><h3 id="打造一个不会丢事件的-LiveData"><a href="#打造一个不会丢事件的-LiveData" class="headerlink" title="打造一个不会丢事件的 LiveData"></a>打造一个不会丢事件的 LiveData</h3><h4 id="postValue-的问题"><a href="#postValue-的问题" class="headerlink" title="postValue 的问题"></a>postValue 的问题</h4><p>对于 postValue 的问题，既然它最后也是调用的 setValue，丢数据是因为只抛了一次 Runable，那我们就自己每次都往主线程抛一个 Runable 就能解决这个问题</p><h4 id="非激活状态的问题"><a href="#非激活状态的问题" class="headerlink" title="非激活状态的问题"></a>非激活状态的问题</h4><p>对于非激活状态，可以用observeForever来观察，但是observeForever不会帮我们自动取消订阅。<br>我们需要在不使用时手动调用 public void removeObserver(@NonNull final Observer&lt;? super T&gt; observer) 移除观察者，否则可能会内存泄漏。</p><h4 id="造一个生命周期感知的还不丢事件的观察者"><a href="#造一个生命周期感知的还不丢事件的观察者" class="headerlink" title="造一个生命周期感知的还不丢事件的观察者"></a>造一个生命周期感知的还不丢事件的观察者</h4><p>具体实现可见：<a href="https://www.jianshu.com/p/b2646bf112ce" target="_blank" rel="noopener">把 LiveData 用于事件传递那些坑</a></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://tech.meituan.com/2018/07/26/android-livedatabus.html" target="_blank" rel="noopener">Android消息总线的演进之路：用LiveDataBus替代RxBus、EventBus</a><br><a href="https://github.com/KunMinX/UnPeek-LiveData" target="_blank" rel="noopener">UnPeek-LiveData</a><br><a href="https://www.jianshu.com/p/b2646bf112ce" target="_blank" rel="noopener">把 LiveData 用于事件传递那些坑</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;带着问题学习可以让我们在学习的过程中更加有目的性与条理。&lt;br&gt;例如在读源码的过程中，我们如果从头开始读，往往千头万绪，抓不住要领。&lt;br&gt;
      
    
    </summary>
    
    
      <category term="android" scheme="http://ShenZhen2017.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>怎么从官方文档学习</title>
    <link href="http://ShenZhen2017.github.io/blog/2020/11/learn-by-document.html"/>
    <id>http://ShenZhen2017.github.io/blog/2020/11/learn-by-document.html</id>
    <published>2020-11-04T14:43:22.000Z</published>
    <updated>2020-12-16T16:00:43.376Z</updated>
    
    <content type="html"><![CDATA[<p>有很多Android开发者，或者是因为语言，或许因为科学上网等原因，不太习惯逛Android官网<br>其实Android官网中有许多资源，包括kotlin,协程,jetpack，android各种最佳实践和项目例子等。<br>下面做一些总结，希望对大家有用。</p><h2 id="kotlin相关学习资源"><a href="#kotlin相关学习资源" class="headerlink" title="kotlin相关学习资源"></a>kotlin相关学习资源</h2><p>1.<a href="https://developer.android.google.cn/kotlin/first" target="_blank" rel="noopener">https://developer.android.google.cn/kotlin/first</a><br>2.<a href="https://developers.google.cn/codelabs/advanced-android-kotlin-training-welcome#0" target="_blank" rel="noopener">https://developers.google.cn/codelabs/advanced-android-kotlin-training-welcome</a></p><h3 id="kotlin协程"><a href="#kotlin协程" class="headerlink" title="kotlin协程"></a>kotlin协程</h3><p><a href="https://developer.android.google.cn/kotlin/coroutines" target="_blank" rel="noopener">https://developer.android.google.cn/kotlin/coroutines</a></p><h2 id="jetPack相关文档"><a href="#jetPack相关文档" class="headerlink" title="jetPack相关文档"></a>jetPack相关文档</h2><p><a href="https://developer.android.google.cn/jetpack" target="_blank" rel="noopener">https://developer.android.google.cn/jetpack</a></p><h2 id="Android架构组件"><a href="#Android架构组件" class="headerlink" title="Android架构组件"></a>Android架构组件</h2><p><a href="https://developer.android.google.cn/docs" target="_blank" rel="noopener">https://developer.android.google.cn/docs</a></p><h2 id="UI组件"><a href="#UI组件" class="headerlink" title="UI组件"></a>UI组件</h2><p>1.android 各种widgets的使用实例<br><a href="https://github.com/android/views-widgets-samples.git" target="_blank" rel="noopener">https://github.com/android/views-widgets-samples.git</a></p><p>2.motion-layout code lab<br><a href="https://developers.google.cn/codelabs/motion-layout/#0" target="_blank" rel="noopener">https://developers.google.cn/codelabs/motion-layout/</a><br><a href="https://codelabs.developers.google.com/codelabs/kotlin-android-training-linear-layout/index.html?index=..%2F..android-kotlin-fundamentals#0" target="_blank" rel="noopener">https://codelabs.developers.google.com/codelabs/kotlin-android-training-linear-layout/index.html?index=..%2F..android-kotlin-fundamentals#0</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有很多Android开发者，或者是因为语言，或许因为科学上网等原因，不太习惯逛Android官网&lt;br&gt;其实Android官网中有许多资源，包括kotlin,协程,jetpack，android各种最佳实践和项目例子等。&lt;br&gt;下面做一些总结，希望对大家有用。&lt;/p&gt;
&lt;h
      
    
    </summary>
    
    
      <category term="android" scheme="http://ShenZhen2017.github.io/tags/android/"/>
    
  </entry>
  
</feed>
