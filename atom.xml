<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ricardo-谁谓河广</title>
  
  <subtitle>谁谓河广</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://ShenZhen2017.github.io/"/>
  <updated>2021-03-13T13:37:51.384Z</updated>
  <id>http://ShenZhen2017.github.io/</id>
  
  <author>
    <name>Ricardo.M.Jiang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MMKV缺陷：不支持getAll?</title>
    <link href="http://ShenZhen2017.github.io/blog/2021/03/mmkv-disadvange-sum.html"/>
    <id>http://ShenZhen2017.github.io/blog/2021/03/mmkv-disadvange-sum.html</id>
    <published>2021-03-13T13:35:39.000Z</published>
    <updated>2021-03-13T13:37:51.384Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文主要包括以下内容<br>1.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本文主要包括以下内容&lt;br&gt;1.&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="android" scheme="http://ShenZhen2017.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>Gradle语法学习</title>
    <link href="http://ShenZhen2017.github.io/blog/2021/03/gradle-learn-start.html"/>
    <id>http://ShenZhen2017.github.io/blog/2021/03/gradle-learn-start.html</id>
    <published>2021-03-11T13:45:45.000Z</published>
    <updated>2021-03-11T13:46:16.519Z</updated>
    
    <content type="html"><![CDATA[<p>Gradle资源</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Gradle资源&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="android" scheme="http://ShenZhen2017.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>ARTS打卡21</title>
    <link href="http://ShenZhen2017.github.io/blog/2021/03/arts-way-twentyone.html"/>
    <id>http://ShenZhen2017.github.io/blog/2021/03/arts-way-twentyone.html</id>
    <published>2021-03-09T13:51:40.000Z</published>
    <updated>2021-03-09T13:52:45.250Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Algorithmn"><a href="#Algorithmn" class="headerlink" title="Algorithmn"></a>Algorithmn</h2><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Algorithmn&quot;&gt;&lt;a href=&quot;#Algorithmn&quot; class=&quot;headerlink&quot; title=&quot;Algorithmn&quot;&gt;&lt;/a&gt;Algorithmn&lt;/h2&gt;&lt;h2 id=&quot;Review&quot;&gt;&lt;a href=&quot;#Review&quot; class=&quot;
      
    
    </summary>
    
    
      <category term="ARTS" scheme="http://ShenZhen2017.github.io/tags/ARTS/"/>
    
  </entry>
  
  <entry>
    <title>Paging痛点：必须继承PagingDataAdapter吗？</title>
    <link href="http://ShenZhen2017.github.io/blog/2021/03/paging-pain-points.html"/>
    <id>http://ShenZhen2017.github.io/blog/2021/03/paging-pain-points.html</id>
    <published>2021-03-06T14:26:54.000Z</published>
    <updated>2021-03-07T08:32:37.629Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文主要包括以下内容<br>1.使用<code>Paging</code>必须继承<code>PagingDataAdapter</code>吗？<br>2.使用<code>AsyncPagingDataDiffer</code>实现<code>Paging</code>功能示例<br>3.更进一步，利用装饰模式实现<code>Paging</code>功能    </p><p>如果觉得本文对您有所帮助，请帮忙点赞，谢谢~</p><h2 id="使用Paging必须继承PagingDataAdapter吗？"><a href="#使用Paging必须继承PagingDataAdapter吗？" class="headerlink" title="使用Paging必须继承PagingDataAdapter吗？"></a>使用<code>Paging</code>必须继承<code>PagingDataAdapter</code>吗？</h2><p><code>Paging3</code>最近已经发布了beta版本，相信几个月内应该就会正式release了<br>使用<code>Paging3</code>可以比较方便地简化加载更多逻辑，可以更轻松的在<code>RecyclerView</code>中逐步妥善地加载数据    </p><p>最近在查阅关于<code>Paging3</code>的资料时，看到有不少文章说使用<code>Paging3</code>必须继承于<code>PagingAdapter</code>，这其实是错误的<br>如果我们点开<code>PagingDataAdapter</code>的源码，可以看到其实他的主要工作是由<code>AsyncPagingDataDiffer</code>完成的</p><blockquote><p>界面层中的主要 <code>Paging</code> 库组件是 <code>PagingDataAdapter</code>，它是一种处理分页数据的 <code>RecyclerView</code> 适配器。<br>此外，您也可以使用随附的 <code>AsyncPagingDataDiffer</code> 组件来构建自己的自定义适配器。</p></blockquote><p>由于在实际开发中，我们的<code>adapter</code>往往都已经有了自己的基类了，再继承<code>PagingDataAdapter</code>并不方便<br>所以实际开发中基于<code>AsyncPagingDataDiffer</code>来构建自己的自定义适配器是一个更加实用的选择     </p><h2 id="使用AsyncPagingDataDiffer自定义适配器"><a href="#使用AsyncPagingDataDiffer自定义适配器" class="headerlink" title="使用AsyncPagingDataDiffer自定义适配器"></a>使用<code>AsyncPagingDataDiffer</code>自定义适配器</h2><h3 id="1-首先看看原有的BaseAdapter"><a href="#1-首先看看原有的BaseAdapter" class="headerlink" title="1.首先看看原有的BaseAdapter"></a>1.首先看看原有的<code>BaseAdapter</code></h3><p>我们的项目中往往已经有了<code>Adapter</code>的基类，我们这里先定义一个简单的<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseAdapter</span>&lt;<span class="type">T:DifferData,VH:RecyclerView.ViewHolder</span>&gt;:<span class="type">RecyclerView.Adapter</span>&lt;<span class="type">VH</span>&gt;</span>() &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">var</span> mDataList = mutableListOf&lt;T&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setDataList</span><span class="params">(dataList:<span class="type">List</span>&lt;<span class="type">T</span>&gt;)</span></span>&#123;</span><br><span class="line">        mDataList = dataList.toMutableList()</span><br><span class="line">        notifyDataSetChanged()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getItemCount</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mDataList.size</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">```    </span><br><span class="line"></span><br><span class="line">我们这里定义的`BaseAdapter`非常简单，只做模拟作用    </span><br><span class="line">主要就是支持`setDataList`功能，其他就没有什么了     </span><br><span class="line"></span><br><span class="line">### <span class="number">2</span>.自定义`PagingAdapter`</span><br><span class="line">我们可以通过我自定义`PagingAdapter`来实现`Paging`功能，同时继承于`BaseAdapter`,并不影响原有功能    </span><br><span class="line">```kotlin</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">PagingAdapter</span>&lt;<span class="type">T:DifferData,VH:RecyclerView.ViewHolder</span>&gt; : <span class="type">BaseAdapter</span>&lt;<span class="type">T,VH</span>&gt;</span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> differ = AsyncPagingDataDiffer&lt;T&gt;(</span><br><span class="line">        diffCallback =DifferCallback(),</span><br><span class="line">        updateCallback = AdapterListUpdateCallback(<span class="keyword">this</span>),</span><br><span class="line">        mainDispatcher = Dispatchers.Main,</span><br><span class="line">        workerDispatcher = Dispatchers.Default</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">    <span class="comment">//监听数据，加载成功后给BaseAdapter赋值</span></span><br><span class="line">        differ.addLoadStateListener &#123;</span><br><span class="line">            <span class="keyword">if</span> (it.append <span class="keyword">is</span> LoadState.NotLoading) &#123;</span><br><span class="line">                <span class="keyword">val</span> items = differ.snapshot().items</span><br><span class="line">                setDataList(items)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">submitList</span><span class="params">(pagingData: <span class="type">PagingData</span>&lt;<span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">        differ.submitData(pagingData)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBindViewHolder</span><span class="params">(holder: <span class="type">VH</span>, position: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">//这一步必不可少，因为Paging就是通过getItem触发预加载的</span></span><br><span class="line">        differ.getItem(position)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>PagingAdapter</code>主要做了以下工作<br>1.定义<code>differ</code>，供后续<code>submitList</code>后更新数据使用<br>2.提供<code>submitList</code>方法更新数据<br>3.在<code>onBindViewHolder</code>中调用<code>getItem</code>，这一步是必不可少的，因为<code>Paging</code>预载下一页就是通过<code>getItem</code>触发的<br>4.监听加载状态，在加载成功后调用<code>setDataList</code>给BaseAdapter中赋值即可    </p><h3 id="3-使用自定义的PagingAdapter"><a href="#3-使用自定义的PagingAdapter" class="headerlink" title="3.使用自定义的PagingAdapter"></a>3.使用自定义的<code>PagingAdapter</code></h3><p>当我们要开发新的Adapter时，直接继承<code>PagingAdapter</code>即可<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoAdapter</span>:<span class="type">PagingAdapter</span>&lt;<span class="type">NewsBean.StoriesBean,DemoAdapter.ViewHolder</span>&gt;</span>() &#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ViewHolder</span></span>(itemView:View):RecyclerView.ViewHolder(itemView)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateViewHolder</span><span class="params">(parent: <span class="type">ViewGroup</span>, viewType: <span class="type">Int</span>)</span></span>: ViewHolder &#123;</span><br><span class="line">        <span class="keyword">return</span> ViewHolder(LayoutInflater.from(parent.context).inflate(R.layout.item_news,parent,<span class="literal">false</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBindViewHolder</span><span class="params">(holder: <span class="type">ViewHolder</span>, position: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onBindViewHolder(holder, position)</span><br><span class="line">        holder.itemView.run &#123;</span><br><span class="line">            <span class="keyword">val</span> <span class="keyword">data</span> = mDataList[position]</span><br><span class="line">            tv_title.text = <span class="keyword">data</span>.title</span><br><span class="line">            Glide.with(context).load(<span class="keyword">data</span>.images?.<span class="keyword">get</span>(<span class="number">0</span>)).into(iv_cover)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>原本继承于<code>BaseAdapter</code>的<code>DemoAdapter</code>，几乎不用修改代码，改为继承于<code>PagingAdapter</code>,就实现了功能的增强，支持了自动预加载的功能  </p><h2 id="实现装饰模式实现Paging功能"><a href="#实现装饰模式实现Paging功能" class="headerlink" title="实现装饰模式实现Paging功能"></a>实现装饰模式实现Paging功能</h2><p>上文我们通过<code>AsyncPagingDataDiffer</code>自定义适配器，继承于<code>BaseAdapter</code>，实现了功能的增强，这样做有什么问题？    </p><h3 id="1-继承方式有什么问题？"><a href="#1-继承方式有什么问题？" class="headerlink" title="1.继承方式有什么问题？"></a>1.继承方式有什么问题？</h3><p>上文所用的方法，本质还是重重继承的方式   </p><ul><li>增加了继承层次，影响代码的可维护性<br>我们在<code>BaseAdapter</code>与<code>DemoAdapter</code>之间，又增加了一层<code>PagingAdapter</code>,如果我们以后要添加新功能时，可能又要增加新的<code>Adapter</code>基类，这是难以维护的       </li><li>子类的实现依赖于父类的实现，破坏了类的封装性<br>如果我们要搞清楚子类有哪些方法与属性，必须层层跟进阅读父类的代码，同时子类的实现依赖于父类的实现，如果父类修改会影响所有子类的逻辑，会带来不可预知的bug   </li></ul><h3 id="2-使用装饰方式实现"><a href="#2-使用装饰方式实现" class="headerlink" title="2.使用装饰方式实现"></a>2.使用装饰方式实现</h3><h4 id="1-首先定义一个PagingWrapAdapter"><a href="#1-首先定义一个PagingWrapAdapter" class="headerlink" title="1.首先定义一个PagingWrapAdapter"></a>1.首先定义一个<code>PagingWrapAdapter</code></h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PagingWrapAdapter</span>&lt;<span class="type">T : DifferData, VH : RecyclerView.ViewHolder</span>&gt;</span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> innerAdapter: RecyclerView.Adapter&lt;VH&gt;,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> callback: ((List&lt;T&gt;) -&gt; <span class="built_in">Unit</span>)</span><br><span class="line">) : RecyclerView.Adapter&lt;VH&gt;() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> differ = AsyncPagingDataDiffer&lt;T&gt;(</span><br><span class="line">        diffCallback = DifferCallback(),</span><br><span class="line">        updateCallback = AdapterListUpdateCallback(<span class="keyword">this</span>),</span><br><span class="line">        mainDispatcher = Dispatchers.Main,</span><br><span class="line">        workerDispatcher = Dispatchers.Default</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        differ.addLoadStateListener &#123;</span><br><span class="line">            <span class="keyword">if</span> (it.append <span class="keyword">is</span> LoadState.NotLoading) &#123;</span><br><span class="line">                <span class="keyword">val</span> items = differ.snapshot().items</span><br><span class="line">                callback.invoke(items)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">submitList</span><span class="params">(pagingData: <span class="type">PagingData</span>&lt;<span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">        differ.submitData(pagingData)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateViewHolder</span><span class="params">(parent: <span class="type">ViewGroup</span>, viewType: <span class="type">Int</span>)</span></span>: VH &#123;</span><br><span class="line">        <span class="keyword">return</span> innerAdapter.onCreateViewHolder(parent, viewType)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBindViewHolder</span><span class="params">(holder: <span class="type">VH</span>, position: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        differ.getItem(position)</span><br><span class="line">        innerAdapter.onBindViewHolder(holder, position)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getItemCount</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> innerAdapter.itemCount</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>PagingWrapAdapter</code>主要做了以下工作<br>1.继承于<code>RecyclerView.Adapter</code>，并实现几个默认方法<br>2.构建’differ’，实现Paging功能<br>2.传入一个<code>innerAdapter</code>,将以上方法的实现由其代理实现   </p><p>UML图如下所示：<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog10/p3.png" alt></p><h4 id="2-调用方式"><a href="#2-调用方式" class="headerlink" title="2.调用方式"></a>2.调用方式</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> mAdapter <span class="keyword">by</span> lazy &#123;</span><br><span class="line">    <span class="keyword">val</span> readAdapter = Demo2Adapter()</span><br><span class="line">    PagingWrapAdapter&lt;NewsBean.StoriesBean, Demo2Adapter.ViewHolder&gt;(readAdapter) &#123;</span><br><span class="line">        readAdapter.setDataList(it)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，原有的<code>adapter</code>不需要任何修改，只需要传入<code>PagingWrapAdapter</code>中，即可实现预加载功能   </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>由于我们实际项目中的<code>adapter</code>常常已经有基类了，再去继承<code>PaginDataAdapter</code>并不方便<br>基于<code>AsyncPagingDataDiffer</code>构建自定义适配器是一个更好的选择    </p><p>使用继承方式也会带来可维护性等问题，更好的选择是使用装饰模式实现对功能的增强以达到:实现<code>Paging</code>功能并不修改原有代码的目标    </p><h3 id="Show-Me-The-Code"><a href="#Show-Me-The-Code" class="headerlink" title="Show Me The Code"></a>Show Me The Code</h3><p>本文所有代码可见：<a href="https://github.com/shenzhen2017/PagingAdapter" target="_blank" rel="noopener">PagingAdapter</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本文主要包括以下内容&lt;br&gt;1.使用&lt;code&gt;Paging&lt;/code&gt;必须继承&lt;code&gt;PagingDataAdapter&lt;/code
      
    
    </summary>
    
    
      <category term="android" scheme="http://ShenZhen2017.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>ARTS打卡20</title>
    <link href="http://ShenZhen2017.github.io/blog/2021/03/arts-way-twenty.html"/>
    <id>http://ShenZhen2017.github.io/blog/2021/03/arts-way-twenty.html</id>
    <published>2021-03-02T13:57:09.000Z</published>
    <updated>2021-03-07T06:52:05.823Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Algorithmn"><a href="#Algorithmn" class="headerlink" title="Algorithmn"></a>Algorithmn</h2><blockquote><p><a href="https://leetcode-cn.com/contest/weekly-contest-231/problems/check-if-binary-string-has-at-most-one-segment-of-ones/" target="_blank" rel="noopener">5697. 检查二进制字符串字段</a><br>给你一个二进制字符串 s ，该字符串 不含前导零 。<br>如果 s 最多包含 一个由连续的 ‘1’ 组成的字段 ，返回 true​​​ 。否则，返回 false 。</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">checkOnesSegment</span><span class="params">(s: <span class="type">String</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> itemCount =<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until s.length-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i]!=s[i+<span class="number">1</span>])&#123;</span><br><span class="line">                itemCount++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> itemCount&lt;<span class="number">2</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p><a href="https://www.lukaslechner.com/why-exception-handling-with-kotlin-coroutines-is-so-hard-and-how-to-successfully-master-it/" target="_blank" rel="noopener">Why exception handling with Kotlin Coroutines is so hard and how to successfully master it!</a><br>为什么不能通过try,Catch捕获异常</p><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><h3 id="markdown-to-do-list语法"><a href="#markdown-to-do-list语法" class="headerlink" title="markdown to do list语法"></a>markdown to do list语法</h3><p>详情可见：<a href="https://blog.csdn.net/csu_passer/article/details/102495104" target="_blank" rel="noopener">https://blog.csdn.net/csu_passer/article/details/102495104</a></p><h3 id="markdown-划线语法"><a href="#markdown-划线语法" class="headerlink" title="markdown 划线语法"></a>markdown 划线语法</h3><p>详情可见: <a href="https://www.jianshu.com/p/99999a9bd40d" target="_blank" rel="noopener">https://www.jianshu.com/p/99999a9bd40d</a></p><h3 id="ConstraintLayout流式动态设置布局"><a href="#ConstraintLayout流式动态设置布局" class="headerlink" title="ConstraintLayout流式动态设置布局"></a>ConstraintLayout流式动态设置布局</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> properties = ConstraintProperties(findViewById(R.id.image))</span><br><span class="line">       properties.translationZ(<span class="number">32f</span>)</span><br><span class="line">               .margin(ConstraintSet.START, <span class="number">43</span>)</span><br><span class="line">               .apply()</span><br></pre></td></tr></table></figure><p><a href="https://juejin.cn/post/6844903872255754248#heading-9" target="_blank" rel="noopener">https://juejin.cn/post/6844903872255754248#heading-9</a></p><h3 id="Android11无线调试"><a href="#Android11无线调试" class="headerlink" title="Android11无线调试"></a>Android11无线调试</h3><p>1.首先配对，adb pair<br>2.然后连接，adb connect<br>详情可见：<a href="https://blog.csdn.net/photondncs/article/details/110273415" target="_blank" rel="noopener">Android 11 adb无线调试使用方法</a></p><h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p><a href="https://shenzhen2017.github.io/blog/2021/03/paging-pain-points.html">Paging痛点：必须继承PagingDataAdapter吗？</a><br>关于Paging使用的痛点   </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Algorithmn&quot;&gt;&lt;a href=&quot;#Algorithmn&quot; class=&quot;headerlink&quot; title=&quot;Algorithmn&quot;&gt;&lt;/a&gt;Algorithmn&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode
      
    
    </summary>
    
    
      <category term="ARTS" scheme="http://ShenZhen2017.github.io/tags/ARTS/"/>
    
  </entry>
  
  <entry>
    <title>协程异常机制与优雅封装</title>
    <link href="http://ShenZhen2017.github.io/blog/2021/02/corountine-handle-exeception.html"/>
    <id>http://ShenZhen2017.github.io/blog/2021/02/corountine-handle-exeception.html</id>
    <published>2021-02-28T12:22:15.000Z</published>
    <updated>2021-03-03T16:56:37.613Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文主要包括以下内容<br>1.协程的3种作用域以及异常的传播方式<br>2.协程异常的两种捕获方式及对比<br>3.协程异常的优雅封装  </p><p>如果觉得本文对您有所帮助，请帮忙点赞，谢谢~</p><h2 id="协程的异常是怎么传播的？"><a href="#协程的异常是怎么传播的？" class="headerlink" title="协程的异常是怎么传播的？"></a>协程的异常是怎么传播的？</h2><h3 id="首先了解下协程作用域"><a href="#首先了解下协程作用域" class="headerlink" title="首先了解下协程作用域"></a>首先了解下协程作用域</h3><p>协程作用域分为顶级作用域，协同作用域与主从作用域，分别对应GlobalScope,coroutineScope,supervisorScope<br><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/38c42668a11d4d7b9535d7927c9d020f~tplv-k3u1fbpfcp-watermark.image" alt><br>作用分析：<br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b8389309dbcd440bb606ce1e33184112~tplv-k3u1fbpfcp-watermark.image" alt>   </p><p>说明：     </p><ul><li>C2-1发生异常的时候，C2-1-&gt;C2-&gt;C2-2-&gt;C2-&gt;C1-&gt;C3（包括里面的子协程）-&gt;C4</li><li>C3-1-1发生异常的时候,C3-1-1-&gt;C3-1-1-1，其他不受影响</li><li>C3-1-1-1发生异常的时候，C3-1-1-1-&gt;C3-1-1，其他不受影响</li></ul><h3 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h3><h4 id="1、C1和C2没有关系"><a href="#1、C1和C2没有关系" class="headerlink" title="1、C1和C2没有关系"></a>1、C1和C2没有关系</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GlobalScope.launch &#123; <span class="comment">//协程C1</span></span><br><span class="line">    GlobalScope.launch &#123;<span class="comment">//协程C2</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C1,C2不会互相影响，完全独立</p><h4 id="2-C2和C3是C1的子协程，C2和C3异常会取消C1"><a href="#2-C2和C3是C1的子协程，C2和C3异常会取消C1" class="headerlink" title="2.C2和C3是C1的子协程，C2和C3异常会取消C1"></a>2.C2和C3是C1的子协程，C2和C3异常会取消C1</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GlobalScope.launch &#123; <span class="comment">//协程C1</span></span><br><span class="line">    coroutineScoope &#123;</span><br><span class="line">         launch&#123;&#125;<span class="comment">//协程C2</span></span><br><span class="line">         launch&#123;&#125;<span class="comment">//协程C3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-C2和C3是C1的子协程，C2和C3异常不会取消C1"><a href="#3-C2和C3是C1的子协程，C2和C3异常不会取消C1" class="headerlink" title="3.C2和C3是C1的子协程，C2和C3异常不会取消C1"></a>3.C2和C3是C1的子协程，C2和C3异常不会取消C1</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GlobalScope.launch &#123; <span class="comment">//协程C1</span></span><br><span class="line">    supervisorScope &#123;</span><br><span class="line">         launch&#123;&#125;<span class="comment">//协程C2</span></span><br><span class="line">         launch&#123;&#125;<span class="comment">//协程C3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何捕获异常"><a href="#如何捕获异常" class="headerlink" title="如何捕获异常"></a>如何捕获异常</h2><h3 id="1-直接用Try-Catch会有什么问题？"><a href="#1-直接用Try-Catch会有什么问题？" class="headerlink" title="1.直接用Try,Catch会有什么问题？"></a>1.直接用Try,Catch会有什么问题？</h3><p>在java与Kotlin中，我们一般直接try,catch捕获异常<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> topLevelScope = CoroutineScope(Job())</span><br><span class="line">    topLevelScope.launch &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> RuntimeException(<span class="string">"RuntimeException in coroutine"</span>)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (exception: Exception) &#123;</span><br><span class="line">            println(<span class="string">"Handle <span class="variable">$exception</span>"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Thread.sleep(<span class="number">100</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// Handle java.lang.RuntimeException: RuntimeException in coroutine</span></span><br></pre></td></tr></table></figure></p><p>但是当我们在try模块中<code>launch</code>一个新的协程时，会有一个意外的发现   </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> topLevelScope = CoroutineScope(Job())</span><br><span class="line">    topLevelScope.launch &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            launch &#123;</span><br><span class="line">                <span class="keyword">throw</span> RuntimeException(<span class="string">"RuntimeException in nested coroutine"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (exception: Exception) &#123;</span><br><span class="line">            println(<span class="string">"Handle <span class="variable">$exception</span>"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Thread.sleep(<span class="number">100</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你会发现捕获失效了，并且app crash了<br>我们发现try,catch无法catch住子协程的异常  </p><p><strong>发生了什么</strong><br>在协程中未捕获的异常会发生什么呢？ 协程最创新的功能之一就是<strong>结构化并发</strong>。 为了使结构化并发的所有功能成为可能，CoroutineScope的Job对象以及Coroutines和Child-Coroutines的Job对象形成了父子关系的层次结构。      未传播的异常（而不是重新抛出）是“在工作层次结构中传播”。 这种异常传播会导致父Job的失败，进而导致其子级所有Job的取消。</p><p>上面示例代码的job层次大概如下所示:<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog10/p1.png" alt><br>子协程的异常传播到协程（1）的Job，然后传播到topLevelScope（2）的Job。<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog10/p2.png" alt>  </p><p>传播的异常可以通过CoroutineExceptionHandler来捕获，如果没有设置，则将调用线程的未捕获异常处理程序，可能会导致退出应用<br>我们看出，协程有两种异常处理机制，这也是协程的异常处理比较复杂的原因  </p><h4 id="小结1"><a href="#小结1" class="headerlink" title="小结1"></a>小结1</h4><p>如果协程本身不使用try-catch子句自行处理异常，则不会重新抛出该异常，因此无法通过外部try-catch子句进行处理。<br>异常会在“Job层次结构中传播”，可以由已设置的CoroutineExceptionHandler处理。 如果未设置，则调用该线程的未捕获异常处理程序。    </p><h3 id="2-CoroutineExceptionHandler"><a href="#2-CoroutineExceptionHandler" class="headerlink" title="2.CoroutineExceptionHandler"></a>2.CoroutineExceptionHandler</h3><p>现在我们知道，如果我们在try块中launch失败的协程，try-catch是没有用的。<br>因此，我们需要配置一个CoroutineExceptionHandler，我们可以将context传递给启动协程生成器。<br>由于CoroutineExceptionHandler是一个ContextElement，因此我们可以通过在启动子协程时将其传递给launch：     </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">val</span> coroutineExceptionHandler = CoroutineExceptionHandler &#123; coroutineContext, exception -&gt;</span><br><span class="line">        println(<span class="string">"Handle <span class="variable">$exception</span> in CoroutineExceptionHandler"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">val</span> topLevelScope = CoroutineScope(Job())</span><br><span class="line"></span><br><span class="line">    topLevelScope.launch &#123;</span><br><span class="line">        launch(coroutineExceptionHandler) &#123;</span><br><span class="line">            <span class="keyword">throw</span> RuntimeException(<span class="string">"RuntimeException in nested coroutine"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">100</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// Exception in thread "DefaultDispatcher-worker-2" java.lang.RuntimeException: RuntimeException in nested coroutine</span></span><br></pre></td></tr></table></figure><p>可以发现程序还是crash了<br><strong>为什么不生效？</strong>    </p><p>这是因为给子协程设置CoroutineExceptionHandler是没有效果的，我们必须给顶级协程设置,或者初始化Scope时设置才有效<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">val</span> topLevelScope = CoroutineScope(Job() + coroutineExceptionHandler)</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">topLevelScope.launch(coroutineExceptionHandler) &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure></p><h4 id="小结2"><a href="#小结2" class="headerlink" title="小结2"></a>小结2</h4><p>为了使CoroutineExceptionHandler起作用，必须将其设置在CoroutineScope或顶级协程中。</p><h3 id="3-Try-Catch与CoroutineExceptionHandler对比"><a href="#3-Try-Catch与CoroutineExceptionHandler对比" class="headerlink" title="3.Try,Catch与CoroutineExceptionHandler对比"></a>3.Try,Catch与CoroutineExceptionHandler对比</h3><p>如上面介绍的，协程支持两种异常处理机制，那么我们应该选择哪种呢？  </p><p><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-exception-handler/" target="_blank" rel="noopener">CoroutineExceptionHandler</a>的官方文档提供了一些很好的答案：   </p><blockquote><p>“ CoroutineExceptionHandler是用于全局“全部捕获”行为的最后手段。 您无法从CoroutineExceptionHandler中的异常中恢复。 当调用处理程序时，协程已经完成，并带有相应的异常。 通常，处理程序用于记录异常，显示某种错误消息，终止和/或重新启动应用程序。    </p></blockquote><blockquote><p>如果需要在代码的特定部分处理异常，建议在协程内部的相应代码周围使用try / catch。 这样，您可以防止协程异常完成（现在已捕获异常），重试该操作和/或采取其他任意操作：”</p></blockquote><h4 id="小结3"><a href="#小结3" class="headerlink" title="小结3"></a>小结3</h4><p>如果要在协程完成之前重试该操作或执行其他操作，请使用try / catch。<br>请记住，通过直接在协同程序中捕获异常，该异常不会在Job层次结构中传播，也不会利用结构化并发的取消功能。<br>而使用CoroutineExceptionHandler处理应该在协程完成后发生的逻辑。<br>可以看出，我们绝大多数时候应该使用CoroutineExceptionHandler   </p><h3 id="4-launch-vs-async"><a href="#4-launch-vs-async" class="headerlink" title="4.launch{} vs async{}"></a>4.launch{} vs async{}</h3><p>我们上面的例子都是使用launch启动协程的异常，但是launch与async的协常处理是完全不同的<br>下面看个例子<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> topLevelScope = CoroutineScope(SupervisorJob())</span><br><span class="line"></span><br><span class="line">    topLevelScope.async &#123;</span><br><span class="line">        <span class="keyword">throw</span> RuntimeException(<span class="string">"RuntimeException in async coroutine"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">100</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有输出</span></span><br><span class="line">```   </span><br><span class="line">**为什么这里不会抛出异常？**     </span><br><span class="line">我们先要了解下launch与async的区别   </span><br><span class="line"></span><br><span class="line">从launch开始的协程的返回类型是Job，它只是协程的一种表示形式，没有返回值。    </span><br><span class="line">如果我们需要协程的某些结果，则必须使用async，它返回Deferred，这是一种特殊的Job，另外还保存一个结果值。    如果异步协程失败，则将该异常封装在Deferred返回类型中，并在我们调用<span class="keyword">suspend</span>函数.await（）来检索其结果值时将其重新抛出。     </span><br><span class="line"></span><br><span class="line">因此，我们可以使用<span class="keyword">try</span>-<span class="keyword">catch</span>子句将对.await（）的调用括起来。      </span><br><span class="line">```kotlin</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> topLevelScope = CoroutineScope(SupervisorJob())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> deferredResult = topLevelScope.async &#123;</span><br><span class="line">        <span class="keyword">throw</span> RuntimeException(<span class="string">"RuntimeException in async coroutine"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    topLevelScope.launch &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            deferredResult.await()</span><br><span class="line">        &#125; <span class="keyword">catch</span> (exception: Exception) &#123;</span><br><span class="line">            println(<span class="string">"Handle <span class="variable">$exception</span> in try/catch"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">100</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// Handle java.lang.RuntimeException: RuntimeException in async coroutine in try/catch</span></span><br></pre></td></tr></table></figure></p><p>注意：如果async协程是顶级协程，则会将异常封装在Deferred中,等待调用await才会抛出异常。<br>否则，该异常将立即传播到Job层次结构中，并由CoroutineExceptionHandler处理，甚至传递给线程的未捕获异常处理程序，即使不对其调用.await（），如以下示例所示：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">val</span> coroutineExceptionHandler = CoroutineExceptionHandler &#123; coroutineContext, exception -&gt;</span><br><span class="line">        println(<span class="string">"Handle <span class="variable">$exception</span> in CoroutineExceptionHandler"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">val</span> topLevelScope = CoroutineScope(SupervisorJob() + coroutineExceptionHandler)</span><br><span class="line">    topLevelScope.launch &#123;</span><br><span class="line">        async &#123;</span><br><span class="line">            <span class="keyword">throw</span> RuntimeException(<span class="string">"RuntimeException in async coroutine"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Thread.sleep(<span class="number">100</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// Handle java.lang.RuntimeException: RuntimeException in async coroutine in CoroutineExceptionHandler</span></span><br></pre></td></tr></table></figure></p><h4 id="小结4"><a href="#小结4" class="headerlink" title="小结4"></a>小结4</h4><p><code>launch</code>和<code>async</code>协程中未捕获的异常会立即在作业层次结构中传播。<br>但是，如果顶层Coroutine是从launch启动的，则异常将由CoroutineExceptionHandler处理或传递给线程的未捕获异常处理程序。<br>如果顶级协程以async方式启动，则异常封装在Deferred返回类型中，并在调用.await（）时重新抛出。    </p><h3 id="5-coroutineScope异常处理特性"><a href="#5-coroutineScope异常处理特性" class="headerlink" title="5.coroutineScope异常处理特性"></a>5.coroutineScope异常处理特性</h3><p>文章开头我们举了个例子，失败的协程将其异常传播到<code>Job</code>层次结构中，而不是重新抛出该异常，因此，外部try-catch无效。<br>但是，当我们用<code>coroutineScope {}</code>作用域函数将失败的协程包围起来时，会发生一些有趣的事情：    </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">val</span> topLevelScope = CoroutineScope(Job())</span><br><span class="line">    </span><br><span class="line">  topLevelScope.launch &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            coroutineScope &#123;</span><br><span class="line">                launch &#123;</span><br><span class="line">                    <span class="keyword">throw</span> RuntimeException(<span class="string">"RuntimeException in nested coroutine"</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (exception: Exception) &#123;</span><br><span class="line">            println(<span class="string">"Handle <span class="variable">$exception</span> in try/catch"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">100</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// Handle java.lang.RuntimeException: RuntimeException in nested coroutine in try/catch</span></span><br></pre></td></tr></table></figure><p>现在，我们可以使用<code>try-catch</code>子句处理异常。<br>可以看出，范围函数<code>coroutineScope {}</code>重新抛出其失败子项的异常，而不是将其传播到Job层次结构中。  </p><p><code>coroutineScope {}</code>主要用于<code>suspend</code>函数中以实现“并行分解”。 这些<code>suspend</code>函数将重新抛出其失败的协程的异常，因此我们可以相应地设置异常处理逻辑。  </p><h4 id="5-小结5"><a href="#5-小结5" class="headerlink" title="5.小结5"></a>5.小结5</h4><p>范围函数<code>coroutineScope {}</code>重新抛出其失败的子协程的异常，而不是将其传播到<code>Job</code>层次结构中，这使我们能够使用<code>try-catch</code>处理失败的协程的异常    </p><h3 id="6-supervisorScope异常处理特性"><a href="#6-supervisorScope异常处理特性" class="headerlink" title="6.supervisorScope异常处理特性"></a>6.supervisorScope异常处理特性</h3><p>通过使用作用域函数<code>supervisorScope {}</code>，我们将在Job层次结构中添加一个新的，独立的嵌套作用域，并将<code>SupervisorJob</code>作为其<code>Job</code>。   </p><p>代码如下：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> topLevelScope = CoroutineScope(Job())</span><br><span class="line"></span><br><span class="line">    topLevelScope.launch &#123;</span><br><span class="line">        <span class="keyword">val</span> job1 = launch &#123;</span><br><span class="line">            println(<span class="string">"starting Coroutine 1"</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        supervisorScope &#123;</span><br><span class="line">            <span class="keyword">val</span> job2 = launch &#123;</span><br><span class="line">                println(<span class="string">"starting Coroutine 2"</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">val</span> job3 = launch &#123;</span><br><span class="line">                println(<span class="string">"starting Coroutine 3"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">100</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在，在这里了解异常处理至关重要的一点是，supervisorScope是一个必须独立处理异常的新的独立子域。<br>它不会像coroutineScope那样重新抛出失败的协程的异常，也不会将异常传播到其父级– topLevelScope作业。    </p><p>要理解的另一件至关重要的事情是，异常只会向上传播，直到它们到达顶级范围或SupervisorJob。 这意味着job2和job3现在是顶级协程。<br>这也意味着我们可以为它们添加CoroutineExceptionHandler    </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> coroutineExceptionHandler = CoroutineExceptionHandler &#123; coroutineContext, exception -&gt;</span><br><span class="line">        println(<span class="string">"Handle <span class="variable">$exception</span> in CoroutineExceptionHandler"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> topLevelScope = CoroutineScope(Job())</span><br><span class="line"></span><br><span class="line">    topLevelScope.launch &#123;</span><br><span class="line">        <span class="keyword">val</span> job1 = launch &#123;</span><br><span class="line">            println(<span class="string">"starting Coroutine 1"</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        supervisorScope &#123;</span><br><span class="line">            <span class="keyword">val</span> job2 = launch(coroutineExceptionHandler) &#123;</span><br><span class="line">                println(<span class="string">"starting Coroutine 2"</span>)</span><br><span class="line">                <span class="keyword">throw</span> RuntimeException(<span class="string">"Exception in Coroutine 2"</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">val</span> job3 = launch &#123;</span><br><span class="line">                println(<span class="string">"starting Coroutine 3"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">100</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// starting Coroutine 1</span></span><br><span class="line"><span class="comment">// starting Coroutine 2</span></span><br><span class="line"><span class="comment">// Handle java.lang.RuntimeException: Exception in Coroutine 2 in CoroutineExceptionHandler</span></span><br><span class="line"><span class="comment">// starting Coroutine 3</span></span><br></pre></td></tr></table></figure><p>直接在<code>supervisorScope</code>中启动的协程是顶级协程，这也意味着<code>async</code>协程现在将其异常封装在其<code>Deferred</code>对象中,并且仅在调用<code>.await（）</code>时被重新抛出<br>这也是为什么<code>viewModelScope</code>中的<code>async</code>需要调用<code>await</code>才会抛出异常的原因    </p><h4 id="小结6"><a href="#小结6" class="headerlink" title="小结6"></a>小结6</h4><p>范围函数<code>supervisorScope {}</code>在<code>Job</code>层次结构中添加了一个新的独立子范围，并将<code>SupervisorJob</code>作为这个<code>scope</code>的’job’。<br>这个新作用域不会在“Job层次结构”中传播其异常，因此它必须自行处理其异常。<br>直接从<code>supervisorScope</code>启动的协程是顶级协程。<br>顶级协程与子协程在使用<code>launch（）</code>或<code>async（）</code>启动时的行为有所不同，此外，还可以在它们中安装<code>CoroutineExceptionHandlers</code>。</p><h2 id="协程异常处理封装"><a href="#协程异常处理封装" class="headerlink" title="协程异常处理封装"></a>协程异常处理封装</h2><p>如上文所说，在大多数时候，CoroutineExceptionHandler是一个更好的选择     </p><p>如我们所知，协程最大的优点是可以使用同步的方法写异步代码<br>但是CoroutineExceptionHandler将异常处理代码与协程代码分隔开了，感觉上并不是同步的<br>同时每次使用都要新建一个局部变量，不太优雅    </p><p>我们可以对CoroutineExceptionHandler进行封装，利用kotlin扩展函数，实现类似RxJava的调用效果<br>最后调用效果如下<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">fetch</span><span class="params">()</span></span> &#123;</span><br><span class="line">        viewModelScope.rxLaunch&lt;String&gt; &#123;</span><br><span class="line">            onRequest = &#123;</span><br><span class="line">                <span class="comment">//网络请求</span></span><br><span class="line">                resposity.getData()</span><br><span class="line">            &#125;</span><br><span class="line">            onSuccess = &#123;</span><br><span class="line">                <span class="comment">//成功回调</span></span><br><span class="line">            &#125;</span><br><span class="line">            onError = &#123;</span><br><span class="line">                <span class="comment">//失败回调</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>主要利用kotlin扩展函数及DSL语法，封装协程异常处理，达到类似RxJava调用的效果<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> CoroutineScope.<span class="title">rxLaunch</span><span class="params">(<span class="keyword">init</span>: <span class="type">CoroutineBuilder</span>&lt;<span class="type">T</span>&gt;.() -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> result = CoroutineBuilder&lt;T&gt;().apply(<span class="keyword">init</span>)</span><br><span class="line">    <span class="keyword">val</span> coroutineExceptionHandler = CoroutineExceptionHandler &#123; _, exception -&gt;</span><br><span class="line">        result.onError?.invoke(exception)</span><br><span class="line">    &#125;</span><br><span class="line">    launch(coroutineExceptionHandler) &#123;</span><br><span class="line">        <span class="keyword">val</span> res: T? = result.onRequest?.invoke()</span><br><span class="line">        res?.let &#123;</span><br><span class="line">            result.onSuccess?.invoke(it)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CoroutineBuilder</span>&lt;<span class="type">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> onRequest: (<span class="keyword">suspend</span> () -&gt; T)? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">var</span> onSuccess: ((T) -&gt; <span class="built_in">Unit</span>)? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">var</span> onError: ((Throwable) -&gt; <span class="built_in">Unit</span>)? = <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如上即是一个简单封装，可实现上面演示的目标效果<br>将请示，成功，失败分类展示，结构更加清晰，同时不需要写CoroutineExceptionHandler局部变量，更为优雅简洁   </p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://juejin.cn/post/6922625944830083079" target="_blank" rel="noopener">[译] 关于 Kotlin Coroutines， 你可能会犯的 7 个错误</a><br><a href="https://juejin.cn/post/6930973078529720334" target="_blank" rel="noopener">安卓-kotlin协程的异常处理机制分析</a><br><a href="https://www.lukaslechner.com/why-exception-handling-with-kotlin-coroutines-is-so-hard-and-how-to-successfully-master-it/" target="_blank" rel="noopener">why-exception-handling-with-kotlin-coroutines-is-so-hard-and-how-to-successfully-master-it</a>    </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本文主要包括以下内容&lt;br&gt;1.协程的3种作用域以及异常的传播方式&lt;br&gt;2.协程异常的两种捕获方式及对比&lt;br&gt;3.协程异常的优雅封装  
      
    
    </summary>
    
    
      <category term="kotlin" scheme="http://ShenZhen2017.github.io/tags/kotlin/"/>
    
  </entry>
  
  <entry>
    <title>关于协程你应该知道的知识点</title>
    <link href="http://ShenZhen2017.github.io/blog/2021/02/corountine-sum-up.html"/>
    <id>http://ShenZhen2017.github.io/blog/2021/02/corountine-sum-up.html</id>
    <published>2021-02-28T09:13:14.000Z</published>
    <updated>2021-02-28T15:29:32.429Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是协程"><a href="#什么是协程" class="headerlink" title="什么是协程"></a>什么是协程</h2><p>简单的来说，<strong>Coroutine是一个并发的设计模式</strong>，你能通过它使用更简洁的代码来解决异步问题。</p><p>所以并不是一些人所说的什么线程的另一种表现。虽然协程的内部也使用到了线程。但它更大的作用是它的设计思想:将我们传统的Callback回调方式进行消除，使用同步的方式写异步代码</p><p>协程的主要优点</p><ul><li>轻量：您可以在单个线程上运行多个协程，因为协程支持挂起，不会使正在运行协程的线程阻塞。挂起比阻塞节省内存，且支持多个并行操作。</li><li>内存泄露更少：使用结构化并发机制在一个作用域内执行多个操作。</li><li>内置取消支持：取消功能会自动通过正在运行的协程层次结构传播。</li><li>Jetpack集成：许多 Jetpack 库都包含提供全面协程支持的扩展。某些库还提供自己的协程作用域，可供您用于结构化并发。</li></ul><h2 id="什么是suspend"><a href="#什么是suspend" class="headerlink" title="什么是suspend"></a>什么是suspend</h2><p>suspend是协程的关键字，每一个被suspend修饰的方法都必须在另一个suspend函数或者Coroutine协程程序中进行调用</p><p>为什么呢？</p><p>这里涉及到一种机制俗称CPS(Continuation-Passing-Style)。每一个suspend修饰的方法或者lambda表达式都会在代码调用的时候为其额外添加Continuation类型的参数。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GET(<span class="meta-string">"/v2/news"</span>)</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">newsGet</span><span class="params">(<span class="meta">@QueryMap</span> params: <span class="type">Map</span>&lt;<span class="type">String</span>, String&gt;)</span></span>: NewsResponse</span><br><span class="line">```      </span><br><span class="line">上面这段代码经过CPS转换之后真正的面目是这样的     </span><br><span class="line">```kotlin</span><br><span class="line"><span class="meta">@GET(<span class="meta-string">"/v2/news"</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">newsGet</span><span class="params">(<span class="meta">@QueryMap</span> params: <span class="type">Map</span>&lt;<span class="type">String</span>, String&gt;, c: <span class="type">Continuation</span>&lt;<span class="type">NewsResponse</span>&gt;)</span></span>: Any?</span><br></pre></td></tr></table></figure><h3 id="返回值变化"><a href="#返回值变化" class="headerlink" title="返回值变化"></a>返回值变化</h3><p>可以看到，返回值从NewsResponse变成了Any<br>这是因为当suspend函数被协程挂起时，它会返回一个特殊的标识COROUTINE_SUSPENDED，而它本质就是一个Any；当协程不挂起进行执行时，它将返回执行的结果或者引发的异常。这样为了让这两种情况的返回都支持，所以使用了Kotlin独有的Any?类型。</p><p>挂起函数反编译后会生成状态机，各个挂起点对应label，关于字节码编译后的解析详情可见：<a href="https://juejin.cn/post/6883652600462327821" target="_blank" rel="noopener">Kotlin Jetpack 实战 | 09. 图解协程原理</a></p><h3 id="Continuation参数"><a href="#Continuation参数" class="headerlink" title="Continuation参数"></a>Continuation参数</h3><p>我们先来看看上面说的Continutation的源码<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Continuation</span>&lt;<span class="type">in T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The context of the coroutine that corresponds to this continuation.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> context: CoroutineContext</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Resumes the execution of the corresponding coroutine passing a successful or failed [result] as the</span></span><br><span class="line"><span class="comment">     * return value of the last suspension point.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">T</span>&gt;)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>context是协程的上下文，它更多时候是CombinedContext类型，类似于协程的集合<br>resumeWith是用来唤醒挂起的协程。前面已经说过协程在执行的过程中，为了防止阻塞使用了挂起的特性，一旦协程内部的逻辑执行完毕之后，就是通过该方法来唤起协程。让它在之前挂起的位置继续执行下去。</p><p>所以每一个被suspend修饰的函数都会获取上层的Continutation，并将其作为参数传递给自己。<br>协程使用resumeWith替换传统的callback，每一个协程程序的创建都会伴随Continutation的存在<br>后续挂起函数执行完成后，会通过resumeWith唤醒协程，让它在之前挂起的位置继续执行下去。   </p><h2 id="什么是CoroutineContext"><a href="#什么是CoroutineContext" class="headerlink" title="什么是CoroutineContext"></a>什么是CoroutineContext</h2><p>协程的上下文，它包含用户定义的一些数据集合，这些数据与协程密切相关。它类似于map集合，可以通过key来获取不同类型的数据。同时CoroutineContext的灵活性很强，如果其需要改变只需使用当前的CoroutineContext来创建一个新的CoroutineContext即可</p><p>首先来看下CoroutineContext的定义</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CoroutineContext</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the element with the given [key] from this context or `null`.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;E : Element&gt;</span> <span class="title">get</span><span class="params">(key: <span class="type">Key</span>&lt;<span class="type">E</span>&gt;)</span></span>: E?</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Accumulates entries of this context starting with [initial] value and applying [operation]</span></span><br><span class="line"><span class="comment">     * from left to right to current accumulator value and each element of this context.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;R&gt;</span> <span class="title">fold</span><span class="params">(initial: <span class="type">R</span>, operation: (<span class="type">R</span>, <span class="type">Element</span>) -&gt; <span class="type">R</span>)</span></span>: R</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a context containing elements from this context and elements from  other [context].</span></span><br><span class="line"><span class="comment">     * The elements from this context with the same key as in the other one are dropped.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(context: <span class="type">CoroutineContext</span>)</span></span>: CoroutineContext = ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a context containing elements from this context, but without an element with</span></span><br><span class="line"><span class="comment">     * the specified [key].</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">minusKey</span><span class="params">(key: <span class="type">Key</span>&lt;*&gt;)</span></span>: CoroutineContext</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Key for the elements of [CoroutineContext]. [E] is a type of element with this key.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Key</span>&lt;<span class="type">E : Element</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * An element of the [CoroutineContext]. An element of the coroutine context is a singleton context by itself.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Element</span> : <span class="type">CoroutineContext &#123;..&#125;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每一个CoroutineContext都有它唯一的一个Key其中的类型是Element，我们可以通过对应的Key来获取对应的具体对象。<br>我们常用的Job、Dispatchers等都实现了Element接口<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">MainScope</span><span class="params">()</span></span>: CoroutineScope = ContextScope(SupervisorJob() + Dispatchers.Main)</span><br></pre></td></tr></table></figure></p><h3 id="Job与Dispatchers为什么可以通过-号拼接"><a href="#Job与Dispatchers为什么可以通过-号拼接" class="headerlink" title="Job与Dispatchers为什么可以通过+号拼接"></a>Job与Dispatchers为什么可以通过+号拼接</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(context: <span class="type">CoroutineContext</span>)</span></span>: CoroutineContext =</span><br><span class="line">    <span class="keyword">if</span> (context === EmptyCoroutineContext) <span class="keyword">this</span> <span class="keyword">else</span> <span class="comment">// fast path -- avoid lambda creation</span></span><br><span class="line">        context.fold(<span class="keyword">this</span>) &#123; acc, element -&gt;</span><br><span class="line">            <span class="keyword">val</span> removed = acc.minusKey(element.key)</span><br><span class="line">            <span class="keyword">if</span> (removed === EmptyCoroutineContext) element <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// make sure interceptor is always last in the context (and thus is fast to get when present)</span></span><br><span class="line">                <span class="keyword">val</span> interceptor = removed[ContinuationInterceptor]</span><br><span class="line">                <span class="keyword">if</span> (interceptor == <span class="literal">null</span>) CombinedContext(removed, element) <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">val</span> left = removed.minusKey(ContinuationInterceptor)</span><br><span class="line">                    <span class="keyword">if</span> (left === EmptyCoroutineContext) CombinedContext(element, interceptor) <span class="keyword">else</span></span><br><span class="line">                        CombinedContext(CombinedContext(left, element), interceptor)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>拼接本质上是利用了kotlin自定义操作符<br>plus的实现逻辑是将两个拼接的CoroutineContext封装到CombinedContext中组成一个拼接链，同时每次都将ContinuationInterceptor添加到拼接链的最尾部.</p><p>那么CombinedContext又是什么呢？<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">CombinedContext</span></span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> left: CoroutineContext,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> element: Element</span><br><span class="line">) : CoroutineContext, Serializable &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;E : Element&gt;</span> <span class="title">get</span><span class="params">(key: <span class="type">Key</span>&lt;<span class="type">E</span>&gt;)</span></span>: E? &#123;</span><br><span class="line">        <span class="keyword">var</span> cur = <span class="keyword">this</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            cur.element[key]?.let &#123; <span class="keyword">return</span> it &#125;</span><br><span class="line">            <span class="keyword">val</span> next = cur.left</span><br><span class="line">            <span class="keyword">if</span> (next <span class="keyword">is</span> CombinedContext) &#123;</span><br><span class="line">                cur = next</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> next[key]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意看它的两个参数，我们直接拿上面的例子来分析<br>SupervisorJob对应于left，Dispatchers.Main对应element。<br>有了这个基础，我们再看它的get方法就很清晰了。先从element中去取，没有再从之前的left中取<br>所以我们就可以直接通过类似于Map的方式来获取整个协程中CoroutineContext集合中对应Key的CoroutineContext实例。   </p><h2 id="CoroutineScope"><a href="#CoroutineScope" class="headerlink" title="CoroutineScope"></a>CoroutineScope</h2><p>CoroutineScope是什么？如果你觉得陌生，那么GlobalScope、lifecycleScope与viewModelScope相信就很熟悉了吧(当然这个是针对于Android开发者)。它们都实现了CoroutineScope接口。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CoroutineScope</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The context of this scope.</span></span><br><span class="line"><span class="comment">     * Context is encapsulated by the scope and used for implementation of coroutine builders that are extensions on the scope.</span></span><br><span class="line"><span class="comment">     * Accessing this property in general code is not recommended for any purposes except accessing the [Job] instance for advanced usages.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * By convention, should contain an instance of a [job][Job] to enforce structured concurrency.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> coroutineContext: CoroutineContext</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CoroutineScope中只包含一个待实现的变量CoroutineContext,通过它的结构，我们可以认为它是提供CoroutineContext的容器，保证CoroutineContext能在整个协程运行中传递下去，约束CoroutineContext的作用边界。<br>例如，在Android中使用协程来请求数据，当接口还没有请求完成时Activity就已经退出了，这时如果不停止正在运行的协程将会造成不可预期的后果。<br>所以我们推荐使用viewModelScope来请示协程，当页面销毁时会自动取消协程    </p><h3 id="viewModelScope如何实现自动取消协程"><a href="#viewModelScope如何实现自动取消协程" class="headerlink" title="viewModelScope如何实现自动取消协程"></a>viewModelScope如何实现自动取消协程</h3><h4 id="viewModelScope是如何定义的"><a href="#viewModelScope是如何定义的" class="headerlink" title="viewModelScope是如何定义的"></a>viewModelScope是如何定义的</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> ViewModel.viewModelScope: CoroutineScope</span><br><span class="line">        <span class="keyword">get</span>() &#123;</span><br><span class="line">            <span class="keyword">val</span> scope: CoroutineScope? = <span class="keyword">this</span>.getTag(JOB_KEY)</span><br><span class="line">            <span class="keyword">if</span> (scope != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> scope</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> setTagIfAbsent(JOB_KEY,</span><br><span class="line">                CloseableCoroutineScope(SupervisorJob() + Dispatchers.Main.immediate))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">CloseableCoroutineScope</span></span>(context: CoroutineContext) : Closeable, CoroutineScope &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> coroutineContext: CoroutineContext = context</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">close</span><span class="params">()</span></span> &#123;</span><br><span class="line">        coroutineContext.cancel()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>viewModelScope实际上是CloseableCoroutineScope，并实现了closeable与CoroutineScope接口</p><h4 id="关闭页面时发生了什么"><a href="#关闭页面时发生了什么" class="headerlink" title="关闭页面时发生了什么"></a>关闭页面时发生了什么</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mCleared = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// Since clear() is final, this method is still called on mock objects</span></span><br><span class="line">        <span class="comment">// and in those cases, mBagOfTags is null. It'll always be empty though</span></span><br><span class="line">        <span class="comment">// because setTagIfAbsent and getTag are not final so we can skip</span></span><br><span class="line">        <span class="comment">// clearing it</span></span><br><span class="line">        <span class="keyword">if</span> (mBagOfTags != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (mBagOfTags) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Object value : mBagOfTags.values()) &#123;</span><br><span class="line">                    <span class="comment">// see comment for the similar call in setTagIfAbsent</span></span><br><span class="line">                    closeWithRuntimeException(value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        onCleared();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">closeWithRuntimeException</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Closeable) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ((Closeable) obj).close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看出在页面关闭时，自动调用viewModel的clear方法，然后通过tag将viewModelScope取出来，然后再调用close方法实现了取消订阅</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://github.com/idisfkj/android-api-analysis" target="_blank" rel="noopener">Kotlin Coroutine</a><br><a href="https://juejin.cn/post/6893809019425816584" target="_blank" rel="noopener">Kotlin协程实现原理:Suspend&amp;CoroutineContext</a><br><a href="https://juejin.cn/post/6883652600462327821" target="_blank" rel="noopener">Kotlin Jetpack 实战 | 09. 图解协程原理</a>   </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是协程&quot;&gt;&lt;a href=&quot;#什么是协程&quot; class=&quot;headerlink&quot; title=&quot;什么是协程&quot;&gt;&lt;/a&gt;什么是协程&lt;/h2&gt;&lt;p&gt;简单的来说，&lt;strong&gt;Coroutine是一个并发的设计模式&lt;/strong&gt;，你能通过它使用更简洁的代码来解
      
    
    </summary>
    
    
      <category term="kotlin" scheme="http://ShenZhen2017.github.io/tags/kotlin/"/>
    
  </entry>
  
  <entry>
    <title>ARTS打卡19</title>
    <link href="http://ShenZhen2017.github.io/blog/2021/02/arts-way-nineteen.html"/>
    <id>http://ShenZhen2017.github.io/blog/2021/02/arts-way-nineteen.html</id>
    <published>2021-02-27T12:59:21.000Z</published>
    <updated>2021-02-28T12:26:26.720Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Algorighmn"><a href="#Algorighmn" class="headerlink" title="Algorighmn"></a>Algorighmn</h2><blockquote><p><a href="https://leetcode-cn.com/contest/weekly-contest-230/problems/count-items-matching-a-rule/" target="_blank" rel="noopener">5689. 统计匹配检索规则的物品数量</a><br>给你一个数组 items ，其中 items[i] = [typei, colori, namei] ，描述第 i 件物品的类型、颜色以及名称。<br>另给你一条由两个字符串 ruleKey 和 ruleValue 表示的检索规则。<br>如果第 i 件物品能满足下述条件之一，则认为该物品与给定的检索规则 匹配 ：<br>ruleKey == “type” 且 ruleValue == typei 。<br>ruleKey == “color” 且 ruleValue == colori 。<br>ruleKey == “name” 且 ruleValue == namei 。<br>统计并返回 匹配检索规则的物品数量 。</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">countMatches</span><span class="params">(items: <span class="type">List</span>&lt;<span class="type">List</span>&lt;<span class="type">String</span>&gt;&gt;, ruleKey: <span class="type">String</span>, ruleValue: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> index = <span class="keyword">when</span> (ruleKey) &#123;</span><br><span class="line">            <span class="string">"type"</span> -&gt; &#123;</span><br><span class="line">                <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="string">"color"</span> -&gt; &#123;</span><br><span class="line">                <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">                <span class="number">2</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">        items.forEach &#123;</span><br><span class="line">            <span class="keyword">if</span> (it[index] == ruleValue)&#123;</span><br><span class="line">                count++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p><a href="https://developer.android.com/jetpack/compose/tutorial" target="_blank" rel="noopener">https://developer.android.com/jetpack/compose/tutorial</a><br>android compose入门教程</p><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><h3 id="Glide圆角与centerCrop冲突问题"><a href="#Glide圆角与centerCrop冲突问题" class="headerlink" title="Glide圆角与centerCrop冲突问题"></a>Glide圆角与centerCrop冲突问题</h3><p>项目中需要对图片进行圆角显示,并居中裁剪,使用glide时,发现这两种会出现冲突,只能显示一种效果.<br>详情可见：<a href="https://cxyxy.blog.csdn.net/article/details/97399089" target="_blank" rel="noopener">Glide 圆角+居中裁剪centerCrop冲突问题</a></p><h3 id="Kotlin里的takeIf和takeUnless"><a href="#Kotlin里的takeIf和takeUnless" class="headerlink" title="Kotlin里的takeIf和takeUnless"></a>Kotlin里的takeIf和takeUnless</h3><p>我们使用kotlin的时候，会经常用到一些如let、apply、run这些作用域函数，它能让我们方便、简洁地链式调用对象的方法，除了这些，Kotlin标准库还提供了 takeIf 函数和 takeUnless 函数. 这些函数允许你在链式调用中加入对象的状态检查。<br>takeIf满足代码块里面的条件才返回对象本身,否则返回Null,takeUnless则相反<br><a href="https://blog.csdn.net/totond/article/details/106070606" target="_blank" rel="noopener">Kotlin里的takeIf和takeUnless</a></p><h3 id="StateListDrawable与ColorStateList用法"><a href="#StateListDrawable与ColorStateList用法" class="headerlink" title="StateListDrawable与ColorStateList用法"></a>StateListDrawable与ColorStateList用法</h3><p>通过设置StateListDrawable可以动态修改点击时背景颜色，避免在xml中写selector<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">StateListDrawable backgroundDrawable = <span class="keyword">new</span> StateListDrawable();</span><br><span class="line">backgroundDrawable.addState(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;android.R.attr.state_pressed&#125;, mPressedDrawable);</span><br><span class="line">backgroundDrawable.addState(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;android.R.attr.state_checked&#125;, mCheckedDrawable);</span><br><span class="line">backgroundDrawable.addState(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;android.R.attr.state_enabled&#125;, mNormalDrawable);</span><br><span class="line">backgroundDrawable.addState(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-android.R.attr.state_enabled&#125;, mUnableDrawable);</span><br><span class="line"></span><br><span class="line">textView.setBackground(backgroundDrawable);</span><br></pre></td></tr></table></figure></p><p>而ColorStateList则用于设置文字颜色</p><p><a href="https://blog.csdn.net/qq_33337504/article/details/103992395" target="_blank" rel="noopener">GradientDrawable和StateListDrawable 的简单使用，以及如何动态改变TextView的背景颜色和文字颜色</a><br><a href="https://blog.csdn.net/zjh_1110120/article/details/89438309" target="_blank" rel="noopener">ColorStateList 使用详解</a></p><h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p><a href="https://shenzhen2017.github.io/blog/2021/02/corountine-sum-up.html">关于协程你应该知道的知识点</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Algorighmn&quot;&gt;&lt;a href=&quot;#Algorighmn&quot; class=&quot;headerlink&quot; title=&quot;Algorighmn&quot;&gt;&lt;/a&gt;Algorighmn&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode
      
    
    </summary>
    
    
      <category term="ARTS" scheme="http://ShenZhen2017.github.io/tags/ARTS/"/>
    
  </entry>
  
  <entry>
    <title>ARTS打卡18</title>
    <link href="http://ShenZhen2017.github.io/blog/2021/02/arts-way-eighteen.html"/>
    <id>http://ShenZhen2017.github.io/blog/2021/02/arts-way-eighteen.html</id>
    <published>2021-02-20T12:43:55.000Z</published>
    <updated>2021-02-21T14:26:07.955Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Algorithmn"><a href="#Algorithmn" class="headerlink" title="Algorithmn"></a>Algorithmn</h2><blockquote><p><a href="https://leetcode-cn.com/contest/weekly-contest-229/problems/merge-strings-alternately/" target="_blank" rel="noopener">5685. 交替合并字符串</a><br>给你两个字符串 word1 和 word2 。请你从 word1 开始，通过交替添加字母来合并字符串。如果一个字符串比另一个字符串长，就将多出来的字母追加到合并后字符串的末尾。<br>返回 合并后的字符串</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">mergeAlternately</span><span class="params">(word1: <span class="type">String</span>, word2: <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">val</span> stringBuilder = StringBuilder()</span><br><span class="line">        <span class="keyword">val</span> len = maxOf(word1.length,word2.length)</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until len)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i&lt;word1.length)&#123;</span><br><span class="line">                stringBuilder.append(word1[i])</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i&lt;word2.length)&#123;</span><br><span class="line">                stringBuilder.append(word2[i])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stringBuilder.toString()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p><a href="https://medium.com/@Zhuinden/an-opinionated-guide-on-how-to-make-your-kotlin-code-fun-to-read-and-joy-to-work-with-caa3a4036f9e" target="_blank" rel="noopener">An opinionated guide on how to make your Kotlin code fun to read and joy to work with</a></p><p>关于使用kotlin的一些规范与建议</p><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><h3 id="不再需要自定义Shape文件"><a href="#不再需要自定义Shape文件" class="headerlink" title="不再需要自定义Shape文件"></a>不再需要自定义Shape文件</h3><p>自定义shape文件，需要添加xml文件，后面随着文件的增多，很可能会出现文件爆炸问题<br>使用GradientDrawable可以解决这个问题<br><a href="https://juejin.cn/post/6872136025624444941" target="_blank" rel="noopener">干掉 xml | 再也不用为各种形状写一堆资源文件了</a></p><h3 id="RecyclerView-item点击"><a href="#RecyclerView-item点击" class="headerlink" title="RecyclerView item点击"></a>RecyclerView item点击</h3><p>无侵入式的添加RecyclerView item与child item点击<br>利用点击的坐标实现，主要优点在于不需要修改adapter基类<br>详情可见:<a href="https://juejin.cn/post/6881427923316768776/" target="_blank" rel="noopener">更好的 RecyclerView 表项子控件点击监听器</a></p><h3 id="为什么要用HandlerThread"><a href="#为什么要用HandlerThread" class="headerlink" title="为什么要用HandlerThread"></a>为什么要用HandlerThread</h3><p>HandlerThread是Thread的子类，它为我们创建了Looper，之前如果在子线程中使用Looper是需要自己初始化的<br>详情可见：<a href="https://www.jianshu.com/p/f0cdea1c232a" target="_blank" rel="noopener">为什么要用HandlerThread,怎么用？</a></p><h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p><a href="https://shenzhen2017.github.io/blog/2021/02/sp-mmkv-learned.html">SharedPreferences替换:MMKV集成与原理</a><br>本文主要讲解了SharedPreferenes的一些缺陷与MMKV的原理与优势</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Algorithmn&quot;&gt;&lt;a href=&quot;#Algorithmn&quot; class=&quot;headerlink&quot; title=&quot;Algorithmn&quot;&gt;&lt;/a&gt;Algorithmn&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode
      
    
    </summary>
    
    
      <category term="ARTS" scheme="http://ShenZhen2017.github.io/tags/ARTS/"/>
    
  </entry>
  
  <entry>
    <title>SharedPreferences替换:MMKV集成与原理</title>
    <link href="http://ShenZhen2017.github.io/blog/2021/02/sp-mmkv-learned.html"/>
    <id>http://ShenZhen2017.github.io/blog/2021/02/sp-mmkv-learned.html</id>
    <published>2021-02-16T12:58:35.000Z</published>
    <updated>2021-02-17T09:47:57.305Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>SharedPreferences是谷歌提供的轻量级存储方案，使用起来比较方便，可以直接进行数据存储，不必另起线程<br>不过也带来很多问题，尤其是由SP引起的ANR问题，非常常见。<br>正因如此，后来也出现了一些SP的替代解决方案，比如MMKV  </p><p>本文主要包括以下内容<br>1.SharedPreferences存在的问题<br>2.MMKV的基本使用与介绍<br>3.MMKV的原理</p><h2 id="SharedPreferences存在的问题"><a href="#SharedPreferences存在的问题" class="headerlink" title="SharedPreferences存在的问题"></a>SharedPreferences存在的问题</h2><h3 id="SP的效率比较低"><a href="#SP的效率比较低" class="headerlink" title="SP的效率比较低"></a>SP的效率比较低</h3><p>1.读写方式：直接I/O<br>2.数据格式：xml<br>3.写入方式：全量更新<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog9/p7.png" alt></p><p>由于SP使用的xml格式保存数据，所以每次更新数据只能全量替换更新数据<br>这意味着如果我们有100个数据，如果只更新一项数据，也需要将所有数据转化成xml格式，然后再通过io写入文件中<br>这也导致SP的写入效率比较低</p><h3 id="commit导致的ANR"><a href="#commit导致的ANR" class="headerlink" title="commit导致的ANR"></a>commit导致的ANR</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> boolean commit() &#123;</span><br><span class="line">    <span class="comment">// 在当前线程将数据保存到mMap中</span></span><br><span class="line">    MemoryCommitResult mcr = commitToMemory();</span><br><span class="line">    SharedPreferencesImpl.<span class="keyword">this</span>.enqueueDiskWrite(mcr, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 如果是在singleThreadPool中执行写入操作，通过await()暂停主线程，直到写入操作完成。</span></span><br><span class="line">        <span class="comment">// commit的同步性就是通过这里完成的。</span></span><br><span class="line">        mcr.writtenToDiskLatch.await();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 回调的时机：</span></span><br><span class="line"><span class="comment">     * 1. commit是在内存和硬盘操作均结束时回调</span></span><br><span class="line"><span class="comment">     * 2. apply是内存操作结束时就进行回调</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    notifyListeners(mcr);</span><br><span class="line">    <span class="keyword">return</span> mcr.writeToDiskResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示<br>1.commit有返回值，表示修改是否提交成功<br>2.commit提交是同步的，直到磁盘操作成功后才会完成    </p><p>所以当数据量比较大时，使用commit很可能引起ANR</p><h3 id="Apply导致的ANR"><a href="#Apply导致的ANR" class="headerlink" title="Apply导致的ANR"></a>Apply导致的ANR</h3><p>commit是同步的，同时SP也提供了异步的apply<br>apply是将修改数据原子提交到内存, 而后异步真正提交到硬件磁盘, 而commit是同步的提交到硬件磁盘，因此，在多个并发的提交commit的时候，他们会等待正在处理的commit保存到磁盘后在操作，从而降低了效率。而apply只是原子的提交到内容，后面有调用apply的函数的将会直接覆盖前面的内存数据，这样从一定程度上提高了很多效率    </p><p>但是apply同样会引起ANR的问题<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> void apply() &#123;</span><br><span class="line">    <span class="keyword">final</span> long startTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> MemoryCommitResult mcr = commitToMemory();</span><br><span class="line">    <span class="keyword">final</span> Runnable awaitCommit = new Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> void run() &#123;</span><br><span class="line">                mcr.writtenToDiskLatch.await(); <span class="comment">// 等待</span></span><br><span class="line">                ......</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    <span class="comment">// 将 awaitCommit 添加到队列 QueuedWork 中</span></span><br><span class="line">    QueuedWork.addFinisher(awaitCommit);</span><br><span class="line"></span><br><span class="line">    Runnable postWriteRunnable = new Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> void run() &#123;</span><br><span class="line">                awaitCommit.run();</span><br><span class="line">                QueuedWork.removeFinisher(awaitCommit);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    SharedPreferencesImpl.<span class="keyword">this</span>.enqueueDiskWrite(mcr, postWriteRunnable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>将一个 awaitCommit 的  Runnable 任务，添加到队列 QueuedWork 中，在 awaitCommit 中会调用 await() 方法等待，在 handleStopService 、 handleStopActivity 等等生命周期会以这个作为判断条件，等待任务执行完毕</li><li>将一个 postWriteRunnable 的  Runnable 写任务，通过 enqueueDiskWrite 方法，将写入任务加入到队列中，而写入任务在一个线程中执行</li></ul><p>为了保证异步任务及时完成，当生命周期处于 <code>handleStopService()</code> 、 <code>handlePauseActivity()</code> 、 <code>handleStopActivity()</code> 的时候会调用 <code>QueuedWork.waitToFinish()</code> 会等待写入任务执行完毕</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> static <span class="keyword">final</span> ConcurrentLinkedQueue&lt;Runnable&gt; sPendingWorkFinishers =</span><br><span class="line">        new ConcurrentLinkedQueue&lt;Runnable&gt;();</span><br><span class="line">        </span><br><span class="line"><span class="keyword">public</span> static void waitToFinish() &#123;</span><br><span class="line">    Runnable toFinish;</span><br><span class="line">    <span class="keyword">while</span> ((toFinish = sPendingWorkFinishers.poll()) != <span class="literal">null</span>) &#123;</span><br><span class="line">        toFinish.run(); <span class="comment">// 相当于调用 `mcr.writtenToDiskLatch.await()` 方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>sPendingWorkFinishers</code> 是 <code>ConcurrentLinkedQueue</code> 实例，<code>apply</code> 方法会将写入任务添加到 <code>sPendingWorkFinishers</code>队列中，在单个线程的线程池中执行写入任务，线程的调度并不由程序来控制，也就是说当生命周期切换的时候，任务不一定处于执行状态</li><li><code>toFinish.run()</code> 方法，相当于调用 <code>mcr.writtenToDiskLatch.await()</code> 方法，会一直等待</li><li><code>waitToFinish()</code> 方法就做了一件事，会一直等待写入任务执行完毕，其它什么都不做，当有很多写入任务，会依次执行，当文件很大时，效率很低，造成 ANR 就不奇怪了</li></ul><p>所以当数据量比较大时，<code>apply</code>也会造成ANR</p><h3 id="getXXX-导致ANR"><a href="#getXXX-导致ANR" class="headerlink" title="getXXX() 导致ANR"></a>getXXX() 导致ANR</h3><p>不仅是写入操作，所有 getXXX() 方法都是同步的，在主线程调用 get 方法，必须等待 SP 加载完毕，也有可能导致ANR<br>调用 <code>getSharedPreferences()</code> 方法，最终会调用 <code>SharedPreferencesImpl#startLoadFromDisk()</code> 方法开启一个线程异步读取数据。  </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object mLock = new Object();</span><br><span class="line"><span class="keyword">private</span> boolean mLoaded = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">private</span> void startLoadFromDisk() &#123;</span><br><span class="line">    synchronized (mLock) &#123;</span><br><span class="line">        mLoaded = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    new Thread(<span class="string">"SharedPreferencesImpl-load"</span>) &#123;</span><br><span class="line">        <span class="keyword">public</span> void run() &#123;</span><br><span class="line">            loadFromDisk();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如你所看到的，开启一个线程异步读取数据，当我们正在读取一个比较大的数据，还没读取完，接着调用 <code>getXXX()</code> 方法。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String getString(String key, <span class="meta">@Nullable</span> String defValue) &#123;</span><br><span class="line">    synchronized (mLock) &#123;</span><br><span class="line">        awaitLoadedLocked();</span><br><span class="line">        String v = (String)mMap.<span class="keyword">get</span>(key);</span><br><span class="line">        <span class="keyword">return</span> v != <span class="literal">null</span> ? v : defValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> void awaitLoadedLocked() &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">while</span> (!mLoaded) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mLock.wait();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException unused) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在同步方法内调用了 <code>wait()</code> 方法，会一直等待 <code>getSharedPreferences()</code> 方法开启的线程读取完数据才能继续往下执行，如果读取几 KB 的数据还好，假设读取一个大的文件，势必会造成主线程阻塞。  </p><h2 id="MMKV的使用"><a href="#MMKV的使用" class="headerlink" title="MMKV的使用"></a>MMKV的使用</h2><p>MMKV 是基于 mmap 内存映射的 key-value 组件，底层序列化/反序列化使用 protobuf 实现，性能高，稳定性强。从 2015 年中至今在微信上使用，其性能和稳定性经过了时间的验证。近期也已移植到 Android / macOS / Win32 / POSIX 平台，一并开源。</p><h3 id="MMKV优点"><a href="#MMKV优点" class="headerlink" title="MMKV优点"></a>MMKV优点</h3><p>1.MMKV实现了SharedPreferences接口，可以无缝切换<br>2.通过 mmap 内存映射文件，提供一段可供随时写入的内存块，App 只管往里面写数据，由操作系统负责将内存回写到文件，不必担心 crash 导致数据丢失。<br>3.MMKV数据序列化方面选用 protobuf 协议，pb 在性能和空间占用上都有不错的表现<br>4.SP是全量更新，MMKV是增量更新，有性能优势  </p><p>详细的使用细节可以参考文档：<a href="https://github.com/Tencent/MMKV/wiki" target="_blank" rel="noopener">https://github.com/Tencent/MMKV/wiki</a></p><h2 id="MMKV原理"><a href="#MMKV原理" class="headerlink" title="MMKV原理"></a>MMKV原理</h2><h3 id="为什么MMKV写入速度更快"><a href="#为什么MMKV写入速度更快" class="headerlink" title="为什么MMKV写入速度更快"></a>为什么MMKV写入速度更快</h3><h4 id="IO操作"><a href="#IO操作" class="headerlink" title="IO操作"></a>IO操作</h4><p>我们知道，SP是写入是基于IO操作的，为了了解IO，我们需要先了解下用户空间与内核空间<br>虚拟内存被操作系统划分成两块：用户空间和内核空间，用户空间是用户程序代码运行的地方，内核空间是内核代码运行的地方。为了安全，它们是隔离的，即使用户的程序崩溃了，内核也不受影响。<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog9/p8.png" alt><br><strong>写文件流程:</strong><br>1、调用write，告诉内核需要写入数据的开始地址与长度<br>2、内核将数据拷贝到内核缓存<br>3、由操作系统调用，将数据拷贝到磁盘，完成写入    </p><h4 id="MMAP"><a href="#MMAP" class="headerlink" title="MMAP"></a>MMAP</h4><p>Linux通过将一个虚拟内存区域与一个磁盘上的对象关联起来，以初始化这个虚拟内存区域的内容，这个过程称为内存映射(memory mapping)。<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog9/p9.png" alt><br>对文件进行mmap，会在进程的虚拟内存分配地址空间，创建映射关系。<br>实现这样的映射关系后，就可以采用指针的方式读写操作这一段内存，而系统会自动回写到对应的文件磁盘上    </p><h4 id="MMAP优势"><a href="#MMAP优势" class="headerlink" title="MMAP优势"></a>MMAP优势</h4><ul><li>MMAP对文件的读写操作只需要从磁盘到用户主存的一次数据拷贝过程，减少了数据的拷贝次数，提高了文件读写效率。</li><li>MMAP使用逻辑内存对磁盘文件进行映射，操作内存就相当于操作文件，不需要开启线程，操作MMAP的速度和操作内存的速度一样快；</li><li>MMAP提供一段可供随时写入的内存块，App 只管往里面写数据，由操作系统如内存不足、进程退出等时候负责将内存回写到文件，不必担心 crash 导致数据丢失。</li></ul><p><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog9/p10.png" alt><br>可以看出，MMAP的写入速度基本与内存写入速度一致，远高于SP，这就是MMKV写入速度更快的原因    </p><h3 id="MMKV写入方式"><a href="#MMKV写入方式" class="headerlink" title="MMKV写入方式"></a>MMKV写入方式</h3><h4 id="SP的数据结构"><a href="#SP的数据结构" class="headerlink" title="SP的数据结构"></a>SP的数据结构</h4><p>SP是使用XML格式存储数据的，如下所示<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog9/p11.png" alt><br>但是这也导致SP如果要更新数据的话，只能全量更新</p><h4 id="MMKV数据结构"><a href="#MMKV数据结构" class="headerlink" title="MMKV数据结构"></a>MMKV数据结构</h4><p>MMKV数据结构如下<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog9/p12.png" alt><br>MMKV使用Protobuf存储数据，冗余数据更少，更省空间，同时可以方便地在末尾追加数据   </p><h4 id="写入方式"><a href="#写入方式" class="headerlink" title="写入方式"></a>写入方式</h4><p><strong>增量写入</strong><br>不管key是否重复，直接将数据追加在前数据后。<br>这样效率更高，更新数据只需要插入一条数据即可。    </p><p>当然这样也会带来问题，如果不断增量追加内容，文件越来越大，怎么办？<br>当文件大小不够，这时候需要全量写入。将数据去掉重复key后，如果文件大小满足写入的数据大小，则可以直接更新全量写入，否则需要扩容。（在扩容时根据平均每个K-V大小计算未来可能需要的文件大小进行扩容，防止经常性的全量写入）   </p><h3 id="MMKV三大优势"><a href="#MMKV三大优势" class="headerlink" title="MMKV三大优势"></a>MMKV三大优势</h3><ul><li>mmap防止数据丢失，提高读写效率;</li><li>精简数据，以最少的数据量表示最多的信息，减少数据大小;</li><li>增量更新，避免每次进行相对增量来说大数据量的全量写入。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://juejin.cn/post/6881442312560803853" target="_blank" rel="noopener">[Google] 再见 SharedPreferences 拥抱 Jetpack DataStore</a><br><a href="https://juejin.cn/post/6844903729217404935" target="_blank" rel="noopener">浅析SharedPreferences</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;SharedPreferences是谷歌提供的轻量级存储方案，使用起来比较方便，可以直接进行数据存储，不必另起线程&lt;br&gt;不过也带来很多问题
      
    
    </summary>
    
    
      <category term="android" scheme="http://ShenZhen2017.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>RecyclerView相关知识点总结</title>
    <link href="http://ShenZhen2017.github.io/blog/2021/02/recyclerview-sum-up.html"/>
    <id>http://ShenZhen2017.github.io/blog/2021/02/recyclerview-sum-up.html</id>
    <published>2021-02-14T14:57:58.000Z</published>
    <updated>2021-02-28T02:24:56.167Z</updated>
    
    <content type="html"><![CDATA[<p>1.RecyclerView缓存机制<br><a href="https://mp.weixin.qq.com/s/VI68qPFr-iNa_-lwCh7fwA" target="_blank" rel="noopener">再也不用担心面试官问RecycleView了</a><br><a href="https://juejin.cn/post/6930412704578404360" target="_blank" rel="noopener">RecyclerView 面试题 | 哪些情况下表项会被回收到缓存池？</a><br><a href="https://mp.weixin.qq.com/s/Qm8HWRG0kwAkOvNibHsK6Q" target="_blank" rel="noopener">看完感觉我RecyclerView白学了！ | 刘望舒</a></p><p>2.RecyclerView吸顶</p><p>3.RecyclerView折叠展开</p><p>4.局部刷新<br>payload</p><p>5.预取</p><p>6.diffutils<br><a href="https://juejin.cn/post/6882531923537707015" target="_blank" rel="noopener">更高效地刷新 RecyclerView | DiffUtil二次封装</a></p><p>7.RecyclerView item点击<br><a href="https://juejin.cn/post/6881427923316768776/" target="_blank" rel="noopener">https://juejin.cn/post/6881427923316768776/</a></p><p>8.MultiType<br><a href="https://juejin.cn/post/6876967151975006221" target="_blank" rel="noopener">代理模式应用 | 每当为 RecyclerView 新增类型时就很抓狂</a></p><p>9.Paging<br><a href="https://juejin.cn/post/6893699877415436295" target="_blank" rel="noopener">超简单易用的使用Paging3封装的RecyclerView的列表适配器</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.RecyclerView缓存机制&lt;br&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/VI68qPFr-iNa_-lwCh7fwA&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;再也不用担心面试官问RecycleView了&lt;/
      
    
    </summary>
    
    
      <category term="android" scheme="http://ShenZhen2017.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>ARTS打卡17</title>
    <link href="http://ShenZhen2017.github.io/blog/2021/02/arts-seventeen-way.html"/>
    <id>http://ShenZhen2017.github.io/blog/2021/02/arts-seventeen-way.html</id>
    <published>2021-02-13T14:01:46.000Z</published>
    <updated>2021-02-14T12:04:31.516Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Algorithmn"><a href="#Algorithmn" class="headerlink" title="Algorithmn"></a>Algorithmn</h2><blockquote><p><a href="https://leetcode-cn.com/contest/weekly-contest-228/problems/minimum-changes-to-make-alternating-binary-string/" target="_blank" rel="noopener">5676. 生成交替二进制字符串的最少操作数</a><br>给你一个仅由字符 ‘0’ 和 ‘1’ 组成的字符串 s 。一步操作中，你可以将任一 ‘0’ 变成 ‘1’ ，或者将 ‘1’ 变成 ‘0’ 。<br>交替字符串 定义为：如果字符串中不存在相邻两个字符相等的情况，那么该字符串就是交替字符串。例如，字符串 “010” 是交替字符串，而字符串 “0100” 不是。<br>返回使 s 变成 交替字符串 所需的 最少 操作数。</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">minOperations</span><span class="params">(s: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> charArray1 = s.toCharArray()</span><br><span class="line">        <span class="keyword">val</span> charArray2 = s.toCharArray()</span><br><span class="line">        reverseItem(charArray2, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> minOf(getCount(charArray1), getCount(charArray2) + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">reverseItem</span><span class="params">(charArray: <span class="type">CharArray</span>, i: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (charArray[i] == <span class="string">'0'</span>) &#123;</span><br><span class="line">            charArray[i] = <span class="string">'1'</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            charArray[i] = <span class="string">'0'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getCount</span><span class="params">(charArray: <span class="type">CharArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until charArray.size) &#123;</span><br><span class="line">            <span class="keyword">if</span> (charArray[i] == charArray[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                reverseItem(charArray, i)</span><br><span class="line">                count++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p><a href="https://medium.com/mobile-app-development-publication/kotlin-flow-imperative-or-declarative-exception-handler-bf8d64936366" target="_blank" rel="noopener">Kotlin Flow: Imperative or Declarative Exception Handler?</a><br>本文主要讲解了kotlin协程处理异常的几种方法<br>1.强制性<br>2.声明性</p><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><h3 id="Star法则"><a href="#Star法则" class="headerlink" title="Star法则"></a>Star法则</h3><p>STAR法则是指：Situation, Task, Action, Result</p><ul><li>Situation: 事情是在什么情况下发生的</li><li>Task:明确在相关经历及任务中，要达到什么样目标，完成过程中涉及什么环节及流程。</li><li>Action：明确采取的行动，针对这样的情况进行分析，决定的方式以及采取的步骤。</li><li>Result：描述结果怎样，最终取得了什么样的成就。</li></ul><h3 id="TabLayout改变下划线宽度"><a href="#TabLayout改变下划线宽度" class="headerlink" title="TabLayout改变下划线宽度"></a>TabLayout改变下划线宽度</h3><p>有时我们需要自定义TabLayout下划线的宽度，有时还需要与文字一样宽，有时需要固定宽度<br>详情可见：<a href="https://mrfzh.github.io/2019/11/01/TabLayout-%E4%B9%8B%E6%94%B9%E5%8F%98-Indicator-%E7%9A%84%E5%AE%BD%E5%BA%A6/" target="_blank" rel="noopener">TabLayout 之改变 Indicator 的宽度</a></p><h3 id="协程debug"><a href="#协程debug" class="headerlink" title="协程debug"></a>协程debug</h3><p>开启协程debug:System.setProperty(“kotlinx.coroutines.debug”, “on”)</p><h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p>本周暂无</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Algorithmn&quot;&gt;&lt;a href=&quot;#Algorithmn&quot; class=&quot;headerlink&quot; title=&quot;Algorithmn&quot;&gt;&lt;/a&gt;Algorithmn&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode
      
    
    </summary>
    
    
      <category term="ARTS" scheme="http://ShenZhen2017.github.io/tags/ARTS/"/>
    
  </entry>
  
  <entry>
    <title>ARTS打卡16</title>
    <link href="http://ShenZhen2017.github.io/blog/2021/02/arts-way-sixteen.html"/>
    <id>http://ShenZhen2017.github.io/blog/2021/02/arts-way-sixteen.html</id>
    <published>2021-02-06T12:19:04.000Z</published>
    <updated>2021-02-06T14:37:30.495Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><blockquote><p><a href="https://leetcode-cn.com/contest/biweekly-contest-45/problems/sum-of-unique-elements/" target="_blank" rel="noopener">5657. 唯一元素的和</a><br>给你一个整数数组 nums 。数组中唯一元素是那些只出现 恰好一次 的元素。<br>请你返回 nums 中唯一元素的 和 。</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sumOfUnique</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> map = hashMapOf&lt;<span class="built_in">Int</span>,<span class="built_in">Int</span>&gt;()</span><br><span class="line">        nums.forEach &#123;</span><br><span class="line">            map[it] = map.getOrDefault(it,<span class="number">0</span>)+<span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> result = <span class="number">0</span></span><br><span class="line">        map.forEach &#123; i, i2 -&gt;</span><br><span class="line">            <span class="keyword">if</span> (i2==<span class="number">1</span>)&#123;</span><br><span class="line">                result+=i</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p><a href="https://medium.com/better-programming/best-practices-for-using-viewmodels-in-android-e986b25dc78f" target="_blank" rel="noopener">Best Practices for Using ViewModels in Android</a><br>本文主要讲解了ViewModel的最佳实践</p><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><h3 id="Flow与ChannelFlow的区别"><a href="#Flow与ChannelFlow的区别" class="headerlink" title="Flow与ChannelFlow的区别"></a>Flow与ChannelFlow的区别</h3><p>通过Kotlin的Flow可以轻松实现生产者消费者模型。Flow默认是Cold的，生产者和消费者的通信是同步非阻塞的，也就是生产和消费会顺序交替进行<br>如果，我们希望生产者消费者两端能够实现异步非阻塞模型呢？此时可以使用ChannelFlow，顾名思义ChannelFlow中和了Coroutine Channel和Flow的优点：比Channel更冷（collect之后才触发生产）比Flow更热（生产消费可以并行执行）</p><p>详情可见:<a href="https://blog.csdn.net/vitaviva/article/details/104105970" target="_blank" rel="noopener">Kotlin Flow与ChannelFlow</a></p><h3 id="StateFlow与SharedFlow的区别"><a href="#StateFlow与SharedFlow的区别" class="headerlink" title="StateFlow与SharedFlow的区别"></a>StateFlow与SharedFlow的区别</h3><p>StateFlow即包含状态的Flow,可以获取当前value<br>SharedFlow:直接翻译：共享的流。也就是这一类数据流可以为多个使用方提供数据。上面的StateFlow是一种特殊的ShareFlow.</p><p>详情可见:<a href="https://juejin.cn/post/6918644407184916488#heading-12" target="_blank" rel="noopener">Kotlin Flow场景化学习</a></p><h3 id="Flow-Scan的使用"><a href="#Flow-Scan的使用" class="headerlink" title="Flow Scan的使用"></a>Flow Scan的使用</h3><p>Flow语法糖，遍历时可获取当前值与累计值<br>详情可见：<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/scan.html" target="_blank" rel="noopener">https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/scan.html</a></p><h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p>本周暂无  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Algorithm&quot;&gt;&lt;a href=&quot;#Algorithm&quot; class=&quot;headerlink&quot; title=&quot;Algorithm&quot;&gt;&lt;/a&gt;Algorithm&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.
      
    
    </summary>
    
    
      <category term="ARTS" scheme="http://ShenZhen2017.github.io/tags/ARTS/"/>
    
  </entry>
  
  <entry>
    <title>关于Paging3你应该知道的知识点</title>
    <link href="http://ShenZhen2017.github.io/blog/2021/01/paging-source-learn.html"/>
    <id>http://ShenZhen2017.github.io/blog/2021/01/paging-source-learn.html</id>
    <published>2021-01-31T11:46:30.000Z</published>
    <updated>2021-02-14T14:27:26.682Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Paging库是Google新推出的jetPack组件，主要方便封装分页逻辑。<br>使用Paging库后，我们不需要再考虑加载下一页的逻辑，可以做到自动加载，同时可以方便的观察加载下一页的状态，是成功还是失败</p><p>本文主要包括Paging3的基本使用与部分源码解析，具体如下：<br>1.Paging3的基本使用<br>2.Paging3自动加载更多原理    </p><h2 id="Paging3的基本使用"><a href="#Paging3的基本使用" class="headerlink" title="Paging3的基本使用"></a>Paging3的基本使用</h2><h3 id="主要优点"><a href="#主要优点" class="headerlink" title="主要优点"></a>主要优点</h3><p>Paging 库包含以下功能：</p><ul><li>分页数据的内存中缓存。这可确保您的应用在处理分页数据时高效利用系统资源。</li><li>内置的请求重复信息删除功能，可确保您的应用高效地利用网络带宽和系统资源。</li><li>可配置的 RecyclerView 适配器，它们会在用户滚动到已加载数据的末尾时自动请求数据。</li><li>对 Kotlin 协程和流程以及 LiveData 和 RxJava 的一流支持。</li><li>内置对错误处理功能的支持，包括刷新和重试功能。</li></ul><h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><p><img src="https://github.com/shenzhen2017/newImage/blob/master/blog9/p6.jpg?raw=true" alt><br>里面几个类的作用：</p><ul><li><code>PagingSource</code> ：单一的数据源。</li><li><code>RemoteMediator</code> ：其实 <code>RemoteMediator</code> 也是单一的数据源，它会在 <code>PagingSource</code>  没有数据的时候，再使用 <code>RemoteMediator</code>  提供的数据，如果既存在数据库请求，又存在网络请求，通常 <code>PagingSource</code>  用于进行数据库请求，<code>RemoteMediator</code>  进行网络请求。</li><li><code>PagingData</code> ：单次分页数据的容器。</li><li><code>Pager</code>：用来构建 <code>Flow&lt;PagingData&gt;</code> 的类，实现数据加载完成的回调。</li><li><code>PagingDataAdapter</code> ：分页加载数据的 <code>RecyclerView</code> 的适配器。</li></ul><p>简述一下就是 <code>PagingSource</code> 和 <code>RemoteMediator</code> 充当数据源的角色，<code>ViewModel</code> 使用 <code>Pager</code> 中提供的 <code>Flow&lt;PagingData&gt;</code> 监听数据刷新.<br>每当 <code>RecyclerView</code> 即将滚动到底部的时候，就会有新的数据的到来，最后，<code>PagingAdapter</code> 展示数据。</p><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><h4 id="1-配置数据源"><a href="#1-配置数据源" class="headerlink" title="1.配置数据源"></a>1.配置数据源</h4><p>首先需要生成数据层，配置数据源<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> SHOE_START_INDEX = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomPageDataSource</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> shoeRepository: ShoeRepository) : PagingSource&lt;<span class="built_in">Int</span>, Shoe&gt;() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">load</span><span class="params">(params: <span class="type">LoadParams</span>&lt;<span class="type">Int</span>&gt;)</span></span>: LoadResult&lt;<span class="built_in">Int</span>, Shoe&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> pos = params.key ?: SHOE_START_INDEX</span><br><span class="line">        <span class="keyword">val</span> startIndex = pos * params.loadSize + <span class="number">1</span></span><br><span class="line">        <span class="keyword">val</span> endIndex = (pos + <span class="number">1</span>) * params.loadSize</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 从数据库拉去数据</span></span><br><span class="line">            <span class="keyword">val</span> shoes = shoeRepository.getPageShoes(startIndex.toLong(), endIndex.toLong())</span><br><span class="line">            <span class="comment">// 返回你的分页结果，并填入前一页的 key 和后一页的 key</span></span><br><span class="line">            LoadResult.Page(</span><br><span class="line">                shoes,</span><br><span class="line">                <span class="keyword">if</span> (pos &lt;= SHOE_START_INDEX) <span class="literal">null</span> <span class="keyword">else</span> pos - <span class="number">1</span>,</span><br><span class="line">                <span class="keyword">if</span> (shoes.isNullOrEmpty()) <span class="literal">null</span> <span class="keyword">else</span> pos + <span class="number">1</span></span><br><span class="line">            )</span><br><span class="line">        &#125;<span class="keyword">catch</span> (e:Exception)&#123;</span><br><span class="line">            LoadResult.Error(e)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="2-生成可观察的数据集"><a href="#2-生成可观察的数据集" class="headerlink" title="2. 生成可观察的数据集"></a>2. 生成可观察的数据集</h4><p>第二步则是在viewModel中生成可观察的数据集<br>这里可观察数据集包括 <code>LiveData</code> 、<code>Flow</code> 以及 <code>RxJava</code> 中的 <code>Observable</code> 和 <code>Flowable</code>，其中，RxJava 需要单独引入扩展库去支持的。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShoeModel</span> <span class="keyword">constructor</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> shoeRepository: ShoeRepository) : ViewModel() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> config 分页的参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pagingSourceFactory 单一数据源的工厂，在闭包中提供一个PageSource即可</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> remoteMediator 同时支持网络请求和数据库请求的数据源</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> initialKey 初始化使用的key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">var</span> shoes = Pager(config = PagingConfig(</span><br><span class="line">        pageSize = <span class="number">20</span></span><br><span class="line">        , enablePlaceholders = <span class="literal">false</span></span><br><span class="line">        , initialLoadSize = <span class="number">20</span></span><br><span class="line">    ), pagingSourceFactory = &#123; CustomPageDataSource(shoeRepository) &#125;).flow</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="3-创建Adapter"><a href="#3-创建Adapter" class="headerlink" title="3.创建Adapter"></a>3.创建Adapter</h4><p>和普通的 Adapter 没有特别大的区别，主要是：   </p><ul><li>提供 <code>DiffUtil.ItemCallback&lt;Shoe&gt;</code></li><li>继承 <code>PagingDataAdapter</code></li></ul><p>使用<code>PagingAdapter</code>需要实现<code>DiffUtil.ItemCallback</code>接口，因为后续提交数据时，会根据<code>DiffUtil</code>接口判断数据是否相同，从而做插入与删除操作<br>同时使用Paging需要继承<code>PagingDataAdapter</code>，这通常需要我们修改已有的基类，这也是Paging库的一个主要缺点</p><h4 id="4-在UI中使用"><a href="#4-在UI中使用" class="headerlink" title="4.在UI中使用"></a>4.在UI中使用</h4><p>如果只显示数据，我们要做的是：  </p><ul><li>创建和设置适配器。</li><li>开启一个协程</li><li>在协程中接收 Flow 提供的数据。</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> adapter = ShoeAdapter(context!!)</span><br><span class="line">binding.recyclerView.adapter = adapter</span><br><span class="line">job = viewModel.viewModelScope.launch(Dispatchers.IO) &#123;</span><br><span class="line">    viewModel.shoes.collect() &#123;</span><br><span class="line">        adapter.submitData(it)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-监听数据加载状态"><a href="#5-监听数据加载状态" class="headerlink" title="5.监听数据加载状态"></a>5.监听数据加载状态</h4><p>Paging可以监听数据的加载状态，状态对应的类是 LoadState，它有三种状态：</p><ul><li>Loading：数据加载中。</li><li>NotLoading：内存中有已经获取的数据，即使往下滑，Paging 也不需要请求更多的数据。</li><li>Error：请求数据时返回了一个错误。</li></ul><p>监听数据状态的代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">adapter.addLoadStateListener &#123;state:CombinedLoadStates-&gt;</span><br><span class="line">    <span class="comment">//... 状态监听</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>监听方法就是这么简单，可以看到这个 <code>state</code> 并不是 <code>LoadState</code>，而是一个 <code>CombinedLoadStates</code>，顾名思义，就是多个 <code>LoadState</code> 组合而成的状态类，它里面有：</p><ul><li><code>refresh:LoadState</code>：刷新时的状态，因为可以调用 <code>PagingDataAdapter#refresh()</code> 方法进行数据刷新。</li><li><code>append:LoadState</code>：可以理解为 RecyclerView 向下滑时数据的请求状态。</li><li><code>prepend:LoadState</code>：可以理解为RecyclerView 向上滑时数据的请求状态。</li></ul><h2 id="Paging3如何实现自动加载更多？"><a href="#Paging3如何实现自动加载更多？" class="headerlink" title="Paging3如何实现自动加载更多？"></a>Paging3如何实现自动加载更多？</h2><p>当RecyclerView即将滚动到底部时，Paging库会自动加载更多，我们可以看下是怎样实现的</p><p>实际上，Paging的加载更多逻辑是通过<code>PagingDataAdapter</code>的<code>getItem()</code>方法触发的<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">fun</span> <span class="title">getItem</span><span class="params">(<span class="meta">@IntRange(from = 0)</span> position: <span class="type">Int</span>)</span></span> = differ.getItem(position)</span><br></pre></td></tr></table></figure></p><p>这里的<code>differ</code>是一个<code>AsyncPagingDataDiffer</code>对象：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getItem</span><span class="params">(<span class="meta">@IntRange(from = 0)</span> index: <span class="type">Int</span>)</span></span>: T? &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            inGetItem = <span class="literal">true</span></span><br><span class="line">            <span class="keyword">return</span> differBase[index]</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            inGetItem = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>接着看<code>differBase</code>的<code>get()</code>方法，<code>differBase</code>是一个<code>PagingDataDiffer</code>对象：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">(index: <span class="type">Int</span>)</span></span>: T? &#123;</span><br><span class="line">        lastAccessedIndex = index</span><br><span class="line">        receiver?.addHint(presenter.loadAround(index))</span><br><span class="line">        <span class="keyword">return</span> presenter.<span class="keyword">get</span>(index)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>这里的<code>receiver</code>是一个<code>UiReceiver</code>对象,在初始化时会初始化为<code>PagerUiReceiver</code>，下面看一下<code>addHint()</code>方法<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">PagerUiReceiver</span>&lt;<span class="type">Key : Any, Value : Any</span>&gt; <span class="keyword">constructor</span></span>(</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> pageFetcherSnapshot: PageFetcherSnapshot&lt;Key, Value&gt;,</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> retryChannel: SendChannel&lt;<span class="built_in">Unit</span>&gt;</span><br><span class="line">    ) : UiReceiver &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">addHint</span><span class="params">(hint: <span class="type">ViewportHint</span>)</span></span> = pageFetcherSnapshot.addHint(hint)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">retry</span><span class="params">()</span></span> &#123;</span><br><span class="line">            retryChannel.offer(<span class="built_in">Unit</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">refresh</span><span class="params">()</span></span> = <span class="keyword">this</span><span class="symbol">@PageFetcher</span>.refresh()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>这里的<code>pageFetcherSnapshot</code>是一个<code>PageFetcherSnapshot</code>对象<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">addHint</span><span class="params">(hint: <span class="type">ViewportHint</span>)</span></span> &#123;</span><br><span class="line">        lastHint = hint</span><br><span class="line">        <span class="meta">@OptIn(ExperimentalCoroutinesApi::class)</span></span><br><span class="line">        hintChannel.offer(hint)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>这里的<code>hintChannel</code>是一个<code>BroadcastChannel</code>对象，只要该<code>channel</code>中有新值，它会广播给所有的订阅者，下面看一下订阅<code>hintChannel</code>的地方<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">hintChannel.asFlow()</span><br><span class="line">            <span class="comment">// Prevent infinite loop when competing PREPEND / APPEND cancel each other</span></span><br><span class="line">            .drop(<span class="keyword">if</span> (generationId == <span class="number">0</span>) <span class="number">0</span> <span class="keyword">else</span> <span class="number">1</span>)</span><br><span class="line">            .map &#123; hint -&gt; GenerationalViewportHint(generationId, hint) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">// Prioritize new hints that would load the maximum number of items.</span></span><br><span class="line">        .runningReduce &#123; previous, next -&gt;</span><br><span class="line">            <span class="keyword">if</span> (next.shouldPrioritizeOver(previous, loadType)) next <span class="keyword">else</span> previous</span><br><span class="line">        &#125;</span><br><span class="line">        .conflate()</span><br><span class="line">        .collect &#123; generationalHint -&gt;</span><br><span class="line">            doLoad(loadType, generationalHint)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p><p>可以看到上游hintChannel有值时，会构造一个<code>GenerationalViewportHint</code>对象，下游会调用<code>doLoad()</code>方法：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">doLoad</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        loadType: <span class="type">LoadType</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        generationalHint: <span class="type">GenerationalViewportHint</span></span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span> &#123;</span><br><span class="line">    .....</span><br><span class="line">     <span class="keyword">var</span> loadKey: Key? = stateHolder.withLock &#123; state -&gt;</span><br><span class="line">            state.nextLoadKeyOrNull(</span><br><span class="line">                loadType,</span><br><span class="line">                generationalHint.generationId,</span><br><span class="line">                generationalHint.presentedItemsBeyondAnchor(loadType) + itemsLoaded,</span><br><span class="line">            )?.also &#123; state.setLoading(loadType) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="symbol">loop@</span> <span class="keyword">while</span> (loadKey != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">val</span> params = loadParams(loadType, loadKey)</span><br><span class="line">            <span class="keyword">val</span> result: LoadResult&lt;Key, Value&gt; = pagingSource.load(params)</span><br><span class="line">            ....</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看出在<code>loadKey</code>不为<code>null</code>时，会调用<code>pagingSource</code>的<code>load</code>方法从而加载下一页,我们看看<code>nextLoadKeyOrNull</code>方法<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> PageFetcherSnapshotState<span class="type">&lt;Key, Value&gt;</span>.<span class="title">nextLoadKeyOrNull</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        loadType: <span class="type">LoadType</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        generationId: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        presentedItemsBeyondAnchor: <span class="type">Int</span></span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span>: Key? &#123;</span><br><span class="line">        <span class="keyword">if</span> (generationId != generationId(loadType)) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">        <span class="comment">// Skip load if in error state, unless retrying.</span></span><br><span class="line">        <span class="keyword">if</span> (sourceLoadStates.<span class="keyword">get</span>(loadType) <span class="keyword">is</span> Error) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Skip loading if prefetchDistance has been fulfilled.</span></span><br><span class="line">        <span class="keyword">if</span> (presentedItemsBeyondAnchor &gt;= config.prefetchDistance) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">if</span> (loadType == PREPEND) &#123;</span><br><span class="line">            pages.first().prevKey</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pages.last().nextKey</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>从上可以看出,只有当加载状态为成功，且最后一个的距离小于预加载距离时，才会返回<code>nextKey</code>,即开始加载下一页  </p><p>以上就是Paing3自动加载下一页的源码分析，总结为时序图如下：<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog9/p6.png" alt></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://juejin.cn/post/6898133386218045453" target="_blank" rel="noopener">即学即用Android Jetpack - Paging 3</a><br><a href="https://blog.csdn.net/weixin_40888127/article/details/107392096" target="_blank" rel="noopener">Paging内部原理</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Paging库是Google新推出的jetPack组件，主要方便封装分页逻辑。&lt;br&gt;使用Paging库后，我们不需要再考虑加载下一页的逻辑
      
    
    </summary>
    
    
      <category term="android" scheme="http://ShenZhen2017.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>ARTS打卡15</title>
    <link href="http://ShenZhen2017.github.io/blog/2021/01/arts-way-fifteen.html"/>
    <id>http://ShenZhen2017.github.io/blog/2021/01/arts-way-fifteen.html</id>
    <published>2021-01-30T12:16:51.000Z</published>
    <updated>2021-01-31T11:49:39.535Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><blockquote><p><a href="https://leetcode-cn.com/contest/weekly-contest-226/problems/maximum-number-of-balls-in-a-box/" target="_blank" rel="noopener">5654. 盒子中小球的最大数量</a><br>你在一家生产小球的玩具厂工作，有 n 个小球，编号从 lowLimit 开始，到 highLimit 结束（包括 lowLimit 和 highLimit ，即 n == highLimit - lowLimit + 1）。另有无限数量的盒子，编号从 1 到 infinity 。<br>你的工作是将每个小球放入盒子中，其中盒子的编号应当等于小球编号上每位数字的和。例如，编号 321 的小球应当放入编号 3 + 2 + 1 = 6 的盒子，而编号 10 的小球应当放入编号 1 + 0 = 1 的盒子。<br>给你两个整数 lowLimit 和 highLimit ，返回放有最多小球的盒子中的小球数量。如果有多个盒子都满足放有最多小球，只需返回其中任一盒子的小球数量。</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">countBalls</span><span class="params">(lowLimit: <span class="type">Int</span>, highLimit: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> max = <span class="number">0</span></span><br><span class="line">        <span class="keyword">val</span> hashMap = hashMapOf&lt;<span class="built_in">Int</span>,<span class="built_in">Int</span>&gt;()</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> lowLimit..highLimit)&#123;</span><br><span class="line">            <span class="keyword">val</span> item = getNum(i)</span><br><span class="line">            hashMap[item] = hashMap.getOrDefault(item,<span class="number">0</span>)+<span class="number">1</span></span><br><span class="line">            max = maxOf(hashMap.getOrDefault(item,<span class="number">0</span>),max)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getNum</span><span class="params">(item:<span class="type">Int</span>)</span></span>:<span class="built_in">Int</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> num = item</span><br><span class="line">        <span class="keyword">var</span> result = num%<span class="number">10</span></span><br><span class="line">        <span class="keyword">while</span> (num/<span class="number">10</span> &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            num /= <span class="number">10</span></span><br><span class="line">            result += num%<span class="number">10</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p><a href="https://developer.android.com/topic/libraries/architecture/paging/v3-overview" target="_blank" rel="noopener">Paging 3 library overview</a><br>Paging3使用文档</p><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><h3 id="noinline与crossinline"><a href="#noinline与crossinline" class="headerlink" title="noinline与crossinline"></a>noinline与crossinline</h3><p>一个函数中，如果存在一个lambda表达式，在该lambda中不支持直接进行return退出该函数<br>除非，innerFun是inline函数</p><p>crossinline 的作用是让被标记的lambda表达式不允许非局部返回。<br>如果你只想被（作为参数）传给一个内联函数的 lamda 表达式中只有一些被内联，你可以用 noinline 修饰符标记一些函数参数<br>详情可见：<a href="https://blog.csdn.net/u013009899/article/details/78584994" target="_blank" rel="noopener">Kotlin内联：noinline与crossinline</a></p><h3 id="Android-你的自定义View是否比别人多了一个层级"><a href="#Android-你的自定义View是否比别人多了一个层级" class="headerlink" title="Android 你的自定义View是否比别人多了一个层级"></a>Android 你的自定义View是否比别人多了一个层级</h3><p>Android自定义View添加view时往往会多一个层级，可以使用merge来降低自定义view层级<br>但是这种方式有一个缺点，就是在开发过程中我们无法实时的在右侧preview中浏览到正确的布局排列样式<br>可以使用tools:parentTag来指定父布局，从而实现预览<br><a href="https://www.jianshu.com/p/3c6e763d48fc" target="_blank" rel="noopener">Android 你的自定义View是否比别人多了一个层级</a></p><h3 id="判断是否是平板"><a href="#判断是否是平板" class="headerlink" title="判断是否是平板"></a>判断是否是平板</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isTablet</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> xlarge = ((context.getResources().getConfiguration().screenLayout &amp; Configuration.SCREENLAYOUT_SIZE_MASK) == Configuration.SCREENLAYOUT_SIZE_XLARGE);</span><br><span class="line">    <span class="keyword">boolean</span> large = ((context.getResources().getConfiguration().screenLayout &amp; Configuration.SCREENLAYOUT_SIZE_MASK) == Configuration.SCREENLAYOUT_SIZE_LARGE);</span><br><span class="line">    <span class="keyword">return</span> (xlarge || large);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>各种方式都有点问题，详情可见<br><a href="https://stackoverflow.com/questions/5832368/tablet-or-phone-android/41646301#41646301" target="_blank" rel="noopener">https://stackoverflow.com/questions/5832368/tablet-or-phone-android/41646301#41646301</a><br><a href="https://blog.csdn.net/s13383754499/article/details/77448236" target="_blank" rel="noopener">https://blog.csdn.net/s13383754499/article/details/77448236</a><br><a href="https://www.imooc.com/wenda/detail/608728" target="_blank" rel="noopener">https://www.imooc.com/wenda/detail/608728</a>   </p><h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p><a href="https://shenzhen2017.github.io/blog/2021/01/paging-source-learn.html">Paging3源码解析</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Algorithm&quot;&gt;&lt;a href=&quot;#Algorithm&quot; class=&quot;headerlink&quot; title=&quot;Algorithm&quot;&gt;&lt;/a&gt;Algorithm&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.
      
    
    </summary>
    
    
      <category term="ARTS" scheme="http://ShenZhen2017.github.io/tags/ARTS/"/>
    
  </entry>
  
  <entry>
    <title>ARTS打卡14</title>
    <link href="http://ShenZhen2017.github.io/blog/2021/01/arts-way-fourteen.html"/>
    <id>http://ShenZhen2017.github.io/blog/2021/01/arts-way-fourteen.html</id>
    <published>2021-01-23T13:17:23.000Z</published>
    <updated>2021-01-24T03:20:47.891Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><blockquote><p><a href="https://leetcode-cn.com/contest/weekly-contest-225/problems/latest-time-by-replacing-hidden-digits/" target="_blank" rel="noopener">5661. 替换隐藏数字得到的最晚时间</a><br>给你一个字符串 time ，格式为 hh:mm（小时：分钟），其中某几位数字被隐藏（用 ? 表示）。<br>有效的时间为 00:00 到 23:59 之间的所有时间，包括 00:00 和 23:59 。<br>替换 time 中隐藏的数字，返回你可以得到的最晚有效时间。</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">maximumTime</span><span class="params">(time: <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">val</span> array = time.toCharArray()</span><br><span class="line">        <span class="keyword">if</span> (array[<span class="number">0</span>]==<span class="string">'?'</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (array[<span class="number">1</span>]==<span class="string">'?'</span>)&#123;</span><br><span class="line">                array[<span class="number">0</span>] = <span class="string">'2'</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">val</span> num = array[<span class="number">1</span>].toString().toInt()</span><br><span class="line">                <span class="keyword">if</span> (num&gt;<span class="number">3</span>)&#123;</span><br><span class="line">                    array[<span class="number">0</span>]=<span class="string">'1'</span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    array[<span class="number">0</span>]=<span class="string">'2'</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (array[<span class="number">1</span>]==<span class="string">'?'</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (array[<span class="number">0</span>]==<span class="string">'2'</span>)&#123;</span><br><span class="line">                array[<span class="number">1</span>]=<span class="string">'3'</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                array[<span class="number">1</span>]=<span class="string">'9'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (array[<span class="number">3</span>]==<span class="string">'?'</span>)&#123;</span><br><span class="line">            array[<span class="number">3</span>]=<span class="string">'5'</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (array[<span class="number">4</span>]==<span class="string">'?'</span>)&#123;</span><br><span class="line">            array[<span class="number">4</span>]=<span class="string">'9'</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> result = StringBuilder()</span><br><span class="line">        array.forEach &#123; </span><br><span class="line">            result.append(it)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.toString()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p><a href="https://proandroiddev.com/from-rxjava-to-kotlin-flow-error-handling-da1f6a4f2708" target="_blank" rel="noopener">From RxJava to Kotlin Flow: Error Handling</a><br>本文主要讲解了协程异常处理的相关逻辑</p><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><h3 id="DSL封装"><a href="#DSL封装" class="headerlink" title="DSL封装"></a>DSL封装</h3><p>使用DSL封装权限库，优化kotlin调用<br>详情可见：<a href="https://juejin.cn/post/6844904200644591630" target="_blank" rel="noopener">开源项目：使用 Activity Result API + Kotlin 扩展函数 封装权限请求库(支持 DSL 写法)</a></p><h3 id="git同步远程删除分支"><a href="#git同步远程删除分支" class="headerlink" title="git同步远程删除分支"></a>git同步远程删除分支</h3><p>删除远程分支后，本地需要同步，使用git fetch -p同步</p><h3 id="KClass与Class的区别"><a href="#KClass与Class的区别" class="headerlink" title="KClass与Class的区别"></a>KClass与Class的区别</h3><p>KClass是Test::class,Class是Test::class.java<br>详情可见:<a href="https://blog.csdn.net/Goals1989/article/details/107636893" target="_blank" rel="noopener">KClass和Java Class在kotlin文件中使用区别</a></p><h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p>本周暂无</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Algorithm&quot;&gt;&lt;a href=&quot;#Algorithm&quot; class=&quot;headerlink&quot; title=&quot;Algorithm&quot;&gt;&lt;/a&gt;Algorithm&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.
      
    
    </summary>
    
    
      <category term="ARTS" scheme="http://ShenZhen2017.github.io/tags/ARTS/"/>
    
  </entry>
  
  <entry>
    <title>kotlin实用技巧总结</title>
    <link href="http://ShenZhen2017.github.io/blog/2021/01/kotlin-tips-sum.html"/>
    <id>http://ShenZhen2017.github.io/blog/2021/01/kotlin-tips-sum.html</id>
    <published>2021-01-17T13:54:18.000Z</published>
    <updated>2021-01-24T14:45:40.483Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>众所周知，kotlin是google力推的用以取代java的android开发语言<br>kotlin使用起来比较方便，同时有许多语法糖<br>本文主要讲解了一些比较实用的kotlin技巧</p><h2 id="自定义圆角矩形"><a href="#自定义圆角矩形" class="headerlink" title="自定义圆角矩形"></a>自定义圆角矩形</h2><p>在项目中，我们常常要定义圆角矩形背景，一般是用自定义drawable实现的<br>但是圆角矩形的背景与圆角常常会有细微的变化，而一旦变化我们又要新创建一个drawable文件<br>这样就会导致文件爆炸的问题  </p><p>我们可以利用kotlin的扩展函数，来实现简单方便的圆角矩形背景<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> View.<span class="title">setRoundRectBg</span><span class="params">(color: <span class="type">Int</span> = Color.WHITE, cornerRadius: <span class="type">Int</span> = <span class="number">15.</span>dp)</span></span> &#123;</span><br><span class="line">    background = GradientDrawable().apply &#123;</span><br><span class="line">        setColor(color)</span><br><span class="line">        setCornerRadius(cornerRadius.toFloat())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对于需要自定义背景的View,直接调用setRoundRectBg即可，简单方便</p><h2 id="reified使用"><a href="#reified使用" class="headerlink" title="reified使用"></a>reified使用</h2><p>reified,kotlin中的泛型实化关键字，使抽象的东西更加具体或真实。<br>我们举两个例子来看看怎么使用reified</p><h3 id="startActivity例子"><a href="#startActivity例子" class="headerlink" title="startActivity例子"></a>startActivity例子</h3><p>我们一般startActivity是这样写的<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startActivity(context, NewActivity::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br></pre></td></tr></table></figure></p><p>我们利用reified定义一个扩展函数<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Function</span></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T : Activity&gt;</span> Activity.<span class="title">startActivity</span><span class="params">(context: <span class="type">Context</span>)</span></span> &#123;</span><br><span class="line">    startActivity(Intent(context, T::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>))</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Caller</span></span><br><span class="line">startActivity&lt;NewActivity&gt;(context)</span><br></pre></td></tr></table></figure></p><p>使用 reified，通过添加类型传递简化泛型参数<br>这样就不用手动传泛型的类型过去了 </p><h3 id="Gson解析例子"><a href="#Gson解析例子" class="headerlink" title="Gson解析例子"></a>Gson解析例子</h3><p>我们首先看下一般我们使用gson解析json是怎么做的<br>在Java序列化库（如Gson）中，当您想要反序列化该JSON字符串时，您最终必须将Class对象作为参数传递，以便Gson知道您想要的类型。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User user = <span class="keyword">new</span> Gson().fromJson(getJson(), User<span class="class">.<span class="keyword">class</span>)</span></span><br></pre></td></tr></table></figure></p><p>现在，让我们一起展示reified类型实化参数的魔法 我们将创建一个非常轻量级的扩展函数来包装Gson方法：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T&gt;</span> Gson.<span class="title">fromJson</span><span class="params">(json: <span class="type">String</span>)</span></span> = </span><br><span class="line">        fromJson(json, T::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br></pre></td></tr></table></figure></p><p>现在，在我们的Kotlin代码中，我们可以反序列化JSON字符串，甚至根本不需要传递类型信息！<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> user: User = Gson().fromJson(json)</span><br></pre></td></tr></table></figure></p><p>Kotlin根据它的用法推断出类型 - 因为我们将它分配给User类型的变量，Kotlin使用它作为fromJson（）的类型参数</p><h2 id="kotin接口支持SAM转换"><a href="#kotin接口支持SAM转换" class="headerlink" title="kotin接口支持SAM转换"></a>kotin接口支持SAM转换</h2><p>什么是SAM转换？可能有的同学还不太了解，这里先科普一下：</p><p>SAM 转换，即 Single Abstract Method Conversions，就是对于只有单个非默认抽象方法接口的转换 —— 对于符合这个条件的接口（称之为 SAM Type ），在 Kotlin 中可以直接用 Lambda 来表示 —— 当然前提是 Lambda 的所表示函数类型能够跟接口的中方法相匹配。</p><p>在Kotlin1.4之前，Kotlin是不支持Kotlin的SAM转换的，只支持Java SAM转换，官方给出的的解释是：是 Kotlin 本身已经有了函数类型和高阶函数，不需要在去SAM转化。 这个解释开发者并不买账，如果你用过Java Lambda和Fuction Interface。当你切换到Kotlin时，就会很懵逼。看来Kotlin是意识到了这个，或者是看到开发者的反馈，终于支持了。</p><p>在1.4之前，只能传递一个对象，是不支持Kotlin SAM的，而在1.4之后，可以支持Kotlin SAM,但是用法有一丢丢变化。interface需要使用fun关键字声明。使用fun关键字标记接口后，只要将此类接口作为参数，就可以将lambda作为参数传递。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意需用fun 关键字声明</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="keyword">interface</span> Action &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">runAction</span><span class="params">(a: <span class="type">Action</span>)</span></span> = a.run()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// 1.4之前，只能使用object</span></span><br><span class="line">    runAction(<span class="keyword">object</span> : Action&#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">            println(<span class="string">"run action"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">     <span class="comment">// 1.4-M1支持SAM,OK</span></span><br><span class="line">    runAction &#123;</span><br><span class="line">        println(<span class="string">"Hello, Kotlin 1.4!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h2><p>有时候，完成一些工作的方法是将它们委托给别人。这里不是在建议您将自己的工作委托给朋友去做，而是在说将一个对象的工作委托给另一个对象。</p><p>当然，委托在软件行业不是什么新鲜名词。委托 (Delegation) 是一种设计模式，在该模式中，对象会委托一个助手 (helper) 对象来处理请求，这个助手对象被称为代理。代理负责代表原始对象处理请求，并使结果可用于原始对象。</p><h3 id="类委托"><a href="#类委托" class="headerlink" title="类委托"></a>类委托</h3><p>举个例子，当我们要实现一个增强版的ArrayList,支持恢复最后一次删除的item   </p><p>实现这个用例的一种方式，是继承 ArrayList 类。由于新的类继承了具体的 ArrayList 类而不是实现 MutableList 接口，因此它与 ArrayList 的实现高度耦合。<br>如果只需要覆盖 remove() 函数来保持对已删除项目的引用，并将 MutableList 的其余空实现委托给其他对象，那该有多好啊。为了实现这一目标，Kotlin 提供了一种将大部分工作委托给一个内部 ArrayList 实例并且可以自定义其行为的方式，并为此引入了一个新的关键字: by。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Copyright <span class="number">2019</span> Google LLC.</span><br><span class="line">SPDX-License-Identifier: Apache-<span class="number">2.0</span> --&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListWithTrash</span> &lt;<span class="type">T</span>&gt;</span>(<span class="keyword">private</span> <span class="keyword">val</span> innerList: MutableList&lt;T&gt; = ArrayList&lt;T&gt;()) : MutableCollection&lt;T&gt; <span class="keyword">by</span> innerList &#123;</span><br><span class="line"><span class="keyword">var</span> deletedItem : T? = <span class="literal">null</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">remove</span><span class="params">(element: <span class="type">T</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">       deletedItem = element</span><br><span class="line"><span class="keyword">return</span> innerList.remove(element)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">recover</span><span class="params">()</span></span>: T? &#123;</span><br><span class="line"><span class="keyword">return</span> deletedItem</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>by 关键字告诉 Kotlin 将 MutableList 接口的功能委托给一个名为 innerList 的内部 ArrayList。通过桥接到内部 ArrayList 对象方法的方式，ListWithTrash 仍然支持 MutableList 接口中的所有函数。与此同时，现在您可以添加自己的行为了。</p><h3 id="属性委托"><a href="#属性委托" class="headerlink" title="属性委托"></a>属性委托</h3><p>除了类代理，您还可以使用 by 关键字进行属性代理。通过使用属性代理，代理类会负责处理对应属性 get 与 set 函数的调用。这一特性在您需要在其他对象间复用 getter/setter 逻辑时十分有用，同时也能让您可以轻松地对简单支持字段的功能进行扩展</p><p>举个例子，利用委托属性可以封装SharedPreference<br>将数据存储操作委托给代理类有几个好处<br>1.则精简了代码，方便了存储与读取调用<br>2.与SP进行了解耦，后续如果要替换存储库，只需要修改代理类即可   </p><p>调用如下:<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> Pref: PreferenceHolder() &#123;</span><br><span class="line">    <span class="keyword">var</span> isFirstInstall: <span class="built_in">Boolean</span> <span class="keyword">by</span> bindToPreferenceField(<span class="literal">false</span>)</span><br><span class="line">    <span class="keyword">var</span> time: <span class="built_in">Long</span>? <span class="keyword">by</span> bindToPreferenceFieldNullable()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>具体实现可见:<a href="https://juejin.cn/post/6857432013424001038" target="_blank" rel="noopener">SharedPreferences用Kotlin应该这样写</a></p><h2 id="带状态的LiveData"><a href="#带状态的LiveData" class="headerlink" title="带状态的LiveData"></a>带状态的LiveData</h2><p>目前我们在开发的过程中越来越多的使用MVVM模式与ViewModel<br>我们也常常用LiveData来标识网络请求状态<br>我们需要定义请求开始，请求成功，请求失败，三个LiveData    </p><p>这其实也是很冗余重复的代码，因此我们可以进行一定的封装，封装一个带状态的LiveData</p><p>定义如下：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typealias</span> StatefulLiveData&lt;T&gt; = LiveData&lt;RequestState&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">typealias</span> StatefulMutableLiveData&lt;T&gt; = MutableLiveData&lt;RequestState&lt;T&gt;&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> StatefulLiveData<span class="type">&lt;T&gt;</span>.<span class="title">observeState</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    owner: <span class="type">LifecycleOwner</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">init</span>: <span class="type">ResultBuilder</span>&lt;<span class="type">T</span>&gt;.() -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> result = ResultBuilder&lt;T&gt;().apply(<span class="keyword">init</span>)</span><br><span class="line"></span><br><span class="line">    observe(owner) &#123; state -&gt;</span><br><span class="line">        <span class="keyword">when</span> (state) &#123;</span><br><span class="line">            <span class="keyword">is</span> RequestState.Loading -&gt; result.onLading.invoke()</span><br><span class="line">            <span class="keyword">is</span> RequestState.Success -&gt; result.onSuccess(state.<span class="keyword">data</span>)</span><br><span class="line">            <span class="keyword">is</span> RequestState.Error -&gt; result.onError(state.error)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用如下<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> <span class="keyword">data</span> = StatefulMutableLiveData&lt;String&gt;()</span><br><span class="line">viewModel.<span class="keyword">data</span>.observeState(viewLifecycleOwner) &#123;</span><br><span class="line">            onLading = &#123;</span><br><span class="line">                <span class="comment">//loading</span></span><br><span class="line">            &#125;</span><br><span class="line">            onSuccess = &#123; <span class="keyword">data</span> -&gt;</span><br><span class="line">                <span class="comment">//success</span></span><br><span class="line">            &#125;</span><br><span class="line">            onError = &#123; exception -&gt;</span><br><span class="line">                <span class="comment">//error</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p><p>通过以上封装，可以比较优雅简洁的封装网络请求的loading,success,error状态，精简了代码，结构也比较清晰    </p><h2 id="DSL"><a href="#DSL" class="headerlink" title="DSL"></a>DSL</h2><p>DSL（domain specific language），即领域专用语言：专门解决某一特定问题的计算机语言，比如大家耳熟能详的 SQL 和正则表达式。<br>但是，如果为解决某一特定领域问题就创建一套独立的语言，开发成本和学习成本都很高，因此便有了内部 DSL 的概念。所谓内部 DSL，便是使用通用编程语言来构建 DSL。比如，本文提到的 Kotlin DSL，我们为 Kotlin DSL 做一个简单的定义：</p><p>“使用 Kotlin 语言开发的，解决特定领域问题，具备独特代码结构的 API 。”</p><p>举个例子，我们使用TabLayout时，如果要为他添加监听，需要实现以下3个方法<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onTabReselected</span><span class="params">(tab: <span class="type">TabLayout</span>.<span class="type">Tab</span>?)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onTabUnselected</span><span class="params">(tab: <span class="type">TabLayout</span>.<span class="type">Tab</span>?)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onTabSelected</span><span class="params">(tab: <span class="type">TabLayout</span>.<span class="type">Tab</span>?)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其实我们一般只会用到onTabSelected方法，其余两个一般是空实现<br>我们利用DSL对OnTabSelectedListener进行封装，即可避免写不必要的空实现代码   </p><p>具体实现如下：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">typealias</span> OnTabCallback = (tab: TabLayout.Tab?) -&gt; <span class="built_in">Unit</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OnTabSelectedListenerBuilder</span> : <span class="type">TabLayout.OnTabSelectedListener &#123;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> onTabReselectedCallback: OnTabCallback? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> onTabUnselectedCallback: OnTabCallback? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> onTabSelectedCallback: OnTabCallback? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onTabReselected</span><span class="params">(tab: <span class="type">TabLayout</span>.<span class="type">Tab</span>?)</span></span> =</span><br><span class="line">            onTabReselectedCallback?.invoke(tab) ?: <span class="built_in">Unit</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onTabUnselected</span><span class="params">(tab: <span class="type">TabLayout</span>.<span class="type">Tab</span>?)</span></span> =</span><br><span class="line">            onTabUnselectedCallback?.invoke(tab) ?: <span class="built_in">Unit</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onTabSelected</span><span class="params">(tab: <span class="type">TabLayout</span>.<span class="type">Tab</span>?)</span></span> =</span><br><span class="line">            onTabSelectedCallback?.invoke(tab) ?: <span class="built_in">Unit</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onTabReselected</span><span class="params">(callback: <span class="type">OnTabCallback</span>)</span></span> &#123;</span><br><span class="line">        onTabReselectedCallback = callback</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onTabUnselected</span><span class="params">(callback: <span class="type">OnTabCallback</span>)</span></span> &#123;</span><br><span class="line">        onTabUnselectedCallback = callback</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onTabSelected</span><span class="params">(callback: <span class="type">OnTabCallback</span>)</span></span> &#123;</span><br><span class="line">        onTabSelectedCallback = callback</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">registerOnTabSelectedListener</span><span class="params">(function: <span class="type">OnTabSelectedListenerBuilder</span>.() -&gt; <span class="type">Unit</span>)</span></span> =</span><br><span class="line">        OnTabSelectedListenerBuilder().also(function)</span><br></pre></td></tr></table></figure></p><p>定义DSL的一般步骤：    </p><ul><li>1.先定义一个类去实现回调接口，并且实现它的回调方法。</li><li>2.观察回调方法的参数，提取成一个函数类型（function type)，并且按照需要使用类型别名给函数类型起一个别称，并且用私有修饰。</li><li>3.在类里面声明一些可空的函数类型的可变（var）私有成员变量，并且在回调函数中拿到对应的变量实现它的invoke函数，传入对应的参数。</li><li>4.在类中定义一些跟回调接口一样名字，但是参数是对应的函数类型的函数，并且将函数类型赋值给当前类的对应的成员变量。</li><li>5.定义一个成员函数，参数是一个带有我们定好那个类的接受者对象并且返回Unit的Lambda表达式，在函数里创建相应的对象，并且使用also函数把Lambda表达式传进去。</li></ul><p>调用如下：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tabLayout.addOnTabSelectedListener(registerOnTabSelectedListener &#123;</span><br><span class="line">    onTabSelected &#123; vpOrder.currentItem = it?.position ?: <span class="number">0</span> &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>如上，就可以避免写一些不必要的空实现代码了  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;众所周知，kotlin是google力推的用以取代java的android开发语言&lt;br&gt;kotlin使用起来比较方便，同时有许多语法糖&lt;b
      
    
    </summary>
    
    
      <category term="kotlin" scheme="http://ShenZhen2017.github.io/tags/kotlin/"/>
    
  </entry>
  
  <entry>
    <title>ARTS打卡13</title>
    <link href="http://ShenZhen2017.github.io/blog/2021/01/arts-way-thirteen.html"/>
    <id>http://ShenZhen2017.github.io/blog/2021/01/arts-way-thirteen.html</id>
    <published>2021-01-15T14:24:42.000Z</published>
    <updated>2021-01-17T14:00:05.767Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><blockquote><p><a href="https://leetcode-cn.com/contest/weekly-contest-224/problems/number-of-rectangles-that-can-form-the-largest-square/" target="_blank" rel="noopener">5653. 可以形成最大正方形的矩形数目</a><br>给你一个数组 rectangles ，其中 rectangles[i] = [li, wi] 表示第 i 个矩形的长度为 li 、宽度为 wi 。<br>如果存在 k 同时满足 k &lt;= li 和 k &lt;= wi ，就可以将第 i 个矩形切成边长为 k 的正方形。例如，矩形 [4,6] 可以切成边长最大为 4 的正方形。<br>设 maxLen 为可以从矩形数组 rectangles 切分得到的 最大正方形 的边长。<br>返回可以切出边长为 maxLen 的正方形的矩形 数目 。</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">countGoodRectangles</span><span class="params">(rectangles: <span class="type">Array</span>&lt;<span class="type">IntArray</span>&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> map = hashMapOf&lt;<span class="built_in">Int</span>,<span class="built_in">Int</span>&gt;()</span><br><span class="line">        <span class="keyword">var</span> result = <span class="number">0</span></span><br><span class="line">        rectangles.forEach &#123;</span><br><span class="line">            <span class="keyword">val</span> minVaule = minOf(it[<span class="number">0</span>],it[<span class="number">1</span>])</span><br><span class="line">            map[minVaule] = map.getOrDefault(minVaule,<span class="number">0</span>)+<span class="number">1</span></span><br><span class="line">            result = maxOf(result,minVaule)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map.getOrDefault(result,<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p><a href="https://typealias.com/guides/getting-real-with-reified-type-parameters/" target="_blank" rel="noopener">Getting Real with Kotlin’s Reified Type Parameters</a><br>本文主要讲述了利用kotin Reified的一样实用技巧</p><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><h3 id="cpu类型"><a href="#cpu类型" class="headerlink" title="cpu类型"></a>cpu类型</h3><p>Android 设备的CPU类型(通常称为”ABIs”)<br>1.armeabiv-v7a: 第7代及以上的 ARM 处理器。2011年15月以后的生产的大部分Android设备都使用它.<br>2.arm64-v8a: 第8代、64位ARM处理器，很少设备，三星 Galaxy S6是其中之一。<br>3.armeabi: 第5代、第6代的ARM处理器，早期的手机用的比较多。<br>4.x86: 平板、模拟器用得比较多。<br>5.x86_64: 64位的平板。</p><p>详情可见：<a href="https://www.cnblogs.com/janehlp/p/7473240.html" target="_blank" rel="noopener">https://www.cnblogs.com/janehlp/p/7473240.html</a></p><h3 id="kotlin可见性"><a href="#kotlin可见性" class="headerlink" title="kotlin可见性"></a>kotlin可见性</h3><p>如果你声明为 internal，它会在相同模块内随处可见</p><h3 id="refied"><a href="#refied" class="headerlink" title="refied"></a>refied</h3><p>reified：使抽象的东西更加具体或真实，非常推荐 Android 开发使用这个关键字。</p><p>大部分的文章讲解 reified 的使用，都有提到这个点，比如我们定义实现一个扩展函数启动 Activity，一般都需要传 Class<t> 参数：</t></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Function</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Activity&gt;</span> Activity.<span class="title">startActivity</span><span class="params">(context: <span class="type">Context</span>, clazz: <span class="type">Class</span>&lt;<span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">    startActivity(Intent(context, clazz))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Caller</span></span><br><span class="line">startActivity(context, NewActivity::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br></pre></td></tr></table></figure><h4 id="使用refied后"><a href="#使用refied后" class="headerlink" title="使用refied后"></a>使用refied后</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Function</span></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T : Activity&gt;</span> Activity.<span class="title">startActivity</span><span class="params">(context: <span class="type">Context</span>)</span></span> &#123;</span><br><span class="line">    startActivity(Intent(context, T::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>))</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Caller</span></span><br><span class="line">startActivity&lt;NewActivity&gt;(context)</span><br></pre></td></tr></table></figure><p><a href="https://juejin.cn/post/6844903833596854279#heading-1" target="_blank" rel="noopener">推荐使用 Kotlin 关键字 Reified</a><br><a href="https://zhooker.github.io/2018/08/23/%E8%AF%91-Kotlin%E7%9A%84Reified%E5%AE%9E%E5%8C%96%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0/" target="_blank" rel="noopener">[译]Kotlin的Reified实化类型参数</a></p><h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p><a href="https://shenzhen2017.github.io/blog/2021/01/kotlin-tips-sum.html">kotlin实用技巧总结</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Algorithm&quot;&gt;&lt;a href=&quot;#Algorithm&quot; class=&quot;headerlink&quot; title=&quot;Algorithm&quot;&gt;&lt;/a&gt;Algorithm&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.
      
    
    </summary>
    
    
      <category term="ARTS" scheme="http://ShenZhen2017.github.io/tags/ARTS/"/>
    
  </entry>
  
  <entry>
    <title>ARTS打卡12</title>
    <link href="http://ShenZhen2017.github.io/blog/2021/01/arts-way-twelive.html"/>
    <id>http://ShenZhen2017.github.io/blog/2021/01/arts-way-twelive.html</id>
    <published>2021-01-06T12:29:46.000Z</published>
    <updated>2021-01-10T12:03:14.760Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p>本周略</p><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p><a href="https://medium.com/androiddevelopers/simplifying-apis-with-coroutines-and-flow-a6fb65338765" target="_blank" rel="noopener">https://medium.com/androiddevelopers/simplifying-apis-with-coroutines-and-flow-a6fb65338765</a><br>本文主要讲述了通过协程和Flow来简化api的一些操作</p><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><h3 id="回调转化成协程"><a href="#回调转化成协程" class="headerlink" title="回调转化成协程"></a>回调转化成协程</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Extension function on FusedLocationProviderClient, returns last known location</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> FusedLocationProviderClient.<span class="title">awaitLastLocation</span><span class="params">()</span></span>: Location =</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create a new coroutine that can be cancelled</span></span><br><span class="line">  suspendCancellableCoroutine&lt;Location&gt; &#123; continuation -&gt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add listeners that will resume the execution of this coroutine</span></span><br><span class="line">    lastLocation.addOnSuccessListener &#123; location -&gt;</span><br><span class="line">      <span class="comment">// Resume coroutine and return location</span></span><br><span class="line">      continuation.resume(location)</span><br><span class="line">    &#125;.addOnFailureListener &#123; e -&gt;</span><br><span class="line">      <span class="comment">// Resume the coroutine by throwing an exception</span></span><br><span class="line">      continuation.resumeWithException(e)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// End of the suspendCancellableCoroutine block. This suspends the</span></span><br><span class="line">    <span class="comment">// coroutine until one of the callbacks calls the continuation parameter.</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="layoutGoneMargin的使用"><a href="#layoutGoneMargin的使用" class="headerlink" title="layoutGoneMargin的使用"></a>layoutGoneMargin的使用</h3><p>有这样一个需求。当某个控件A存在时，下面的控件B距离A需要一个margin_top=20dp。 当A消失时(gone掉了)，此时margin_top=0dp。 可以用代码去设置这个间距。但是麻烦。。。So， layout_goneMarginTop就有用了。。。</p><p>layout_goneMarginTop - 意思是如果依赖的顶部控件隐藏了，当前我们的间距又应该是怎样的。此时margin_top就不再生效了。反之，也一样<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--工商注册地--&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">android.support.constraint.ConstraintLayout</span></span></span><br><span class="line"><span class="tag">               <span class="attr">android:id</span>=<span class="string">"@+id/fp_location"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">android:layout_marginTop</span>=<span class="string">"20dp"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">android:background</span>=<span class="string">"@color/white"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">android:paddingStart</span>=<span class="string">"20dp"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">android:paddingEnd</span>=<span class="string">"20dp"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">app:layout_constraintTop_toBottomOf</span>=<span class="string">"@+id/fp_numbers"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">app:layout_goneMarginTop</span>=<span class="string">"0dp"</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="BottomSheetDialog圆角问题"><a href="#BottomSheetDialog圆角问题" class="headerlink" title="BottomSheetDialog圆角问题"></a>BottomSheetDialog圆角问题</h3><p>有时候自定义样式，需要在BottomSheetDialog顶部添加圆角<br>需要通过自定义主题的方式实现<br>详情可见：<a href="https://stackoverflow.com/questions/43852562/round-corner-for-bottomsheetdialogfragment" target="_blank" rel="noopener">https://stackoverflow.com/questions/43852562/round-corner-for-bottomsheetdialogfragment</a></p><h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p>本周略</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Algorithm&quot;&gt;&lt;a href=&quot;#Algorithm&quot; class=&quot;headerlink&quot; title=&quot;Algorithm&quot;&gt;&lt;/a&gt;Algorithm&lt;/h2&gt;&lt;p&gt;本周略&lt;/p&gt;
&lt;h2 id=&quot;Review&quot;&gt;&lt;a href=&quot;#Review&quot; 
      
    
    </summary>
    
    
      <category term="ARTS" scheme="http://ShenZhen2017.github.io/tags/ARTS/"/>
    
  </entry>
  
  <entry>
    <title>ARTS打卡11</title>
    <link href="http://ShenZhen2017.github.io/blog/2020/12/arts-way-eleven.html"/>
    <id>http://ShenZhen2017.github.io/blog/2020/12/arts-way-eleven.html</id>
    <published>2020-12-29T00:52:04.000Z</published>
    <updated>2021-01-03T14:31:55.829Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><blockquote><ol start="5641"><li>卡车上的最大单元数<br>请你将一些箱子装在 一辆卡车 上。给你一个二维数组 boxTypes ，其中 boxTypes[i] = [numberOfBoxesi, numberOfUnitsPerBoxi] ：<br>numberOfBoxesi 是类型 i 的箱子的数量。<br>numberOfUnitsPerBoxi 是类型 i 每个箱子可以装载的单元数量。<br>整数 truckSize 表示卡车上可以装载 箱子 的 最大数量 。只要箱子数量不超过 truckSize ，你就可以选择任意箱子装到卡车上。<br>返回卡车可以装载 单元 的 最大 总数。</li></ol></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">maximumUnits</span><span class="params">(boxTypes: <span class="type">Array</span>&lt;<span class="type">IntArray</span>&gt;, truckSize: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        boxTypes.sortByDescending &#123;</span><br><span class="line">            it[<span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> maxSize = truckSize</span><br><span class="line">        <span class="keyword">var</span> result = <span class="number">0</span></span><br><span class="line">        boxTypes.forEach &#123;</span><br><span class="line">            <span class="keyword">var</span> item = it[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">while</span> (item&gt;<span class="number">0</span> &amp;&amp; maxSize&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                item--</span><br><span class="line">                maxSize--</span><br><span class="line">                result+=it[<span class="number">1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (maxSize&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> result</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p><a href="https://medium.com/better-programming/a-new-way-to-pass-data-between-fragments-a5d32acc34e7" target="_blank" rel="noopener">A New Way to Pass Data Between Fragments</a><br>在Fragment中间传递数据的一种新方法<br>主要通过setFragmentResultListener实现<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewCreated</span><span class="params">(view: <span class="type">View</span>, savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onViewCreated(view, savedInstanceState)</span><br><span class="line">    <span class="comment">// Use the Kotlin extension in the fragment-ktx artifact</span></span><br><span class="line">    setFragmentResultListener(<span class="string">"requestKey"</span>) &#123; key, bundle -&gt;</span><br><span class="line">        <span class="keyword">val</span> result = bundle.getString(<span class="string">"name"</span>)</span><br><span class="line">        <span class="comment">// Do something with the result...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><h3 id="写作技巧总结"><a href="#写作技巧总结" class="headerlink" title="写作技巧总结"></a>写作技巧总结</h3><p>1、写文档是第一步，因为你告诉别人怎么去理解你写的东西，所以如果你想开始写作，最简单就是从写文档开始，把你的东西介绍明白了，就是一个好的开始。</p><p>2、写源码分析是第二步，那就是学习和分享如何去理解别人的东西，这个过程可以让自己在学习的过程中有所总结，并且介绍别人的内容就是一种抽象能力的进步。</p><p>3、写问题解决和应用思想是第三步，告诉别人如何去理解别人的思想，这就需要作者对要介绍的内容有自己的理解，才能够把内容变成更好理解的接地气的文字内容。</p><p>其实介绍了这么多写作内容，就是想告诉大家:“大前端是一种思想，就是让你已有的能力可以运用更广泛，而写作是帮助你把能力抽象化的一个过程。”</p><h3 id="lineSpaceExtra在部分低版本机型最后一行会有空行的解决办法"><a href="#lineSpaceExtra在部分低版本机型最后一行会有空行的解决办法" class="headerlink" title="lineSpaceExtra在部分低版本机型最后一行会有空行的解决办法"></a>lineSpaceExtra在部分低版本机型最后一行会有空行的解决办法</h3><p>因为lineHeight在许多机型上有适配问题，因此我们常常用lineSpaceExtra替代<br>但是lineSpaceExtra在部分低版本手机上也会有问题<br>详情可见：<a href="https://blog.csdn.net/etwge/article/details/72818859" target="_blank" rel="noopener">https://blog.csdn.net/etwge/article/details/72818859</a></p><h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p><a href="https://shenzhen2017.github.io/blog/2020/12/hand-lua-curountine.html">手写lua协程</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Algorithm&quot;&gt;&lt;a href=&quot;#Algorithm&quot; class=&quot;headerlink&quot; title=&quot;Algorithm&quot;&gt;&lt;/a&gt;Algorithm&lt;/h2&gt;&lt;blockquote&gt;
&lt;ol start=&quot;5641&quot;&gt;
&lt;li&gt;卡车上的最大单元数&lt;
      
    
    </summary>
    
    
      <category term="ARTS" scheme="http://ShenZhen2017.github.io/tags/ARTS/"/>
    
  </entry>
  
</feed>
