<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ricardo-谁谓河广</title>
  
  <subtitle>谁谓河广</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://ShenZhen2017.github.io/"/>
  <updated>2021-02-20T12:46:40.883Z</updated>
  <id>http://ShenZhen2017.github.io/</id>
  
  <author>
    <name>Ricardo.M.Jiang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ARTS打卡18</title>
    <link href="http://ShenZhen2017.github.io/blog/2021/02/arts-way-eighteen.html"/>
    <id>http://ShenZhen2017.github.io/blog/2021/02/arts-way-eighteen.html</id>
    <published>2021-02-20T12:43:55.000Z</published>
    <updated>2021-02-20T12:46:40.883Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Algorithmn"><a href="#Algorithmn" class="headerlink" title="Algorithmn"></a>Algorithmn</h2><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Algorithmn&quot;&gt;&lt;a href=&quot;#Algorithmn&quot; class=&quot;headerlink&quot; title=&quot;Algorithmn&quot;&gt;&lt;/a&gt;Algorithmn&lt;/h2&gt;&lt;h2 id=&quot;Review&quot;&gt;&lt;a href=&quot;#Review&quot; class=&quot;
      
    
    </summary>
    
    
      <category term="ARTS" scheme="http://ShenZhen2017.github.io/tags/ARTS/"/>
    
  </entry>
  
  <entry>
    <title>SharedPreferences替换:MMKV集成与原理</title>
    <link href="http://ShenZhen2017.github.io/blog/2021/02/sp-mmkv-learned.html"/>
    <id>http://ShenZhen2017.github.io/blog/2021/02/sp-mmkv-learned.html</id>
    <published>2021-02-16T12:58:35.000Z</published>
    <updated>2021-02-17T09:47:57.305Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>SharedPreferences是谷歌提供的轻量级存储方案，使用起来比较方便，可以直接进行数据存储，不必另起线程<br>不过也带来很多问题，尤其是由SP引起的ANR问题，非常常见。<br>正因如此，后来也出现了一些SP的替代解决方案，比如MMKV  </p><p>本文主要包括以下内容<br>1.SharedPreferences存在的问题<br>2.MMKV的基本使用与介绍<br>3.MMKV的原理</p><h2 id="SharedPreferences存在的问题"><a href="#SharedPreferences存在的问题" class="headerlink" title="SharedPreferences存在的问题"></a>SharedPreferences存在的问题</h2><h3 id="SP的效率比较低"><a href="#SP的效率比较低" class="headerlink" title="SP的效率比较低"></a>SP的效率比较低</h3><p>1.读写方式：直接I/O<br>2.数据格式：xml<br>3.写入方式：全量更新<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog9/p7.png" alt></p><p>由于SP使用的xml格式保存数据，所以每次更新数据只能全量替换更新数据<br>这意味着如果我们有100个数据，如果只更新一项数据，也需要将所有数据转化成xml格式，然后再通过io写入文件中<br>这也导致SP的写入效率比较低</p><h3 id="commit导致的ANR"><a href="#commit导致的ANR" class="headerlink" title="commit导致的ANR"></a>commit导致的ANR</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> boolean commit() &#123;</span><br><span class="line">    <span class="comment">// 在当前线程将数据保存到mMap中</span></span><br><span class="line">    MemoryCommitResult mcr = commitToMemory();</span><br><span class="line">    SharedPreferencesImpl.<span class="keyword">this</span>.enqueueDiskWrite(mcr, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 如果是在singleThreadPool中执行写入操作，通过await()暂停主线程，直到写入操作完成。</span></span><br><span class="line">        <span class="comment">// commit的同步性就是通过这里完成的。</span></span><br><span class="line">        mcr.writtenToDiskLatch.await();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 回调的时机：</span></span><br><span class="line"><span class="comment">     * 1. commit是在内存和硬盘操作均结束时回调</span></span><br><span class="line"><span class="comment">     * 2. apply是内存操作结束时就进行回调</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    notifyListeners(mcr);</span><br><span class="line">    <span class="keyword">return</span> mcr.writeToDiskResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示<br>1.commit有返回值，表示修改是否提交成功<br>2.commit提交是同步的，直到磁盘操作成功后才会完成    </p><p>所以当数据量比较大时，使用commit很可能引起ANR</p><h3 id="Apply导致的ANR"><a href="#Apply导致的ANR" class="headerlink" title="Apply导致的ANR"></a>Apply导致的ANR</h3><p>commit是同步的，同时SP也提供了异步的apply<br>apply是将修改数据原子提交到内存, 而后异步真正提交到硬件磁盘, 而commit是同步的提交到硬件磁盘，因此，在多个并发的提交commit的时候，他们会等待正在处理的commit保存到磁盘后在操作，从而降低了效率。而apply只是原子的提交到内容，后面有调用apply的函数的将会直接覆盖前面的内存数据，这样从一定程度上提高了很多效率    </p><p>但是apply同样会引起ANR的问题<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> void apply() &#123;</span><br><span class="line">    <span class="keyword">final</span> long startTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> MemoryCommitResult mcr = commitToMemory();</span><br><span class="line">    <span class="keyword">final</span> Runnable awaitCommit = new Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> void run() &#123;</span><br><span class="line">                mcr.writtenToDiskLatch.await(); <span class="comment">// 等待</span></span><br><span class="line">                ......</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    <span class="comment">// 将 awaitCommit 添加到队列 QueuedWork 中</span></span><br><span class="line">    QueuedWork.addFinisher(awaitCommit);</span><br><span class="line"></span><br><span class="line">    Runnable postWriteRunnable = new Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> void run() &#123;</span><br><span class="line">                awaitCommit.run();</span><br><span class="line">                QueuedWork.removeFinisher(awaitCommit);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    SharedPreferencesImpl.<span class="keyword">this</span>.enqueueDiskWrite(mcr, postWriteRunnable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>将一个 awaitCommit 的  Runnable 任务，添加到队列 QueuedWork 中，在 awaitCommit 中会调用 await() 方法等待，在 handleStopService 、 handleStopActivity 等等生命周期会以这个作为判断条件，等待任务执行完毕</li><li>将一个 postWriteRunnable 的  Runnable 写任务，通过 enqueueDiskWrite 方法，将写入任务加入到队列中，而写入任务在一个线程中执行</li></ul><p>为了保证异步任务及时完成，当生命周期处于 <code>handleStopService()</code> 、 <code>handlePauseActivity()</code> 、 <code>handleStopActivity()</code> 的时候会调用 <code>QueuedWork.waitToFinish()</code> 会等待写入任务执行完毕</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> static <span class="keyword">final</span> ConcurrentLinkedQueue&lt;Runnable&gt; sPendingWorkFinishers =</span><br><span class="line">        new ConcurrentLinkedQueue&lt;Runnable&gt;();</span><br><span class="line">        </span><br><span class="line"><span class="keyword">public</span> static void waitToFinish() &#123;</span><br><span class="line">    Runnable toFinish;</span><br><span class="line">    <span class="keyword">while</span> ((toFinish = sPendingWorkFinishers.poll()) != <span class="literal">null</span>) &#123;</span><br><span class="line">        toFinish.run(); <span class="comment">// 相当于调用 `mcr.writtenToDiskLatch.await()` 方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>sPendingWorkFinishers</code> 是 <code>ConcurrentLinkedQueue</code> 实例，<code>apply</code> 方法会将写入任务添加到 <code>sPendingWorkFinishers</code>队列中，在单个线程的线程池中执行写入任务，线程的调度并不由程序来控制，也就是说当生命周期切换的时候，任务不一定处于执行状态</li><li><code>toFinish.run()</code> 方法，相当于调用 <code>mcr.writtenToDiskLatch.await()</code> 方法，会一直等待</li><li><code>waitToFinish()</code> 方法就做了一件事，会一直等待写入任务执行完毕，其它什么都不做，当有很多写入任务，会依次执行，当文件很大时，效率很低，造成 ANR 就不奇怪了</li></ul><p>所以当数据量比较大时，<code>apply</code>也会造成ANR</p><h3 id="getXXX-导致ANR"><a href="#getXXX-导致ANR" class="headerlink" title="getXXX() 导致ANR"></a>getXXX() 导致ANR</h3><p>不仅是写入操作，所有 getXXX() 方法都是同步的，在主线程调用 get 方法，必须等待 SP 加载完毕，也有可能导致ANR<br>调用 <code>getSharedPreferences()</code> 方法，最终会调用 <code>SharedPreferencesImpl#startLoadFromDisk()</code> 方法开启一个线程异步读取数据。  </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object mLock = new Object();</span><br><span class="line"><span class="keyword">private</span> boolean mLoaded = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">private</span> void startLoadFromDisk() &#123;</span><br><span class="line">    synchronized (mLock) &#123;</span><br><span class="line">        mLoaded = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    new Thread(<span class="string">"SharedPreferencesImpl-load"</span>) &#123;</span><br><span class="line">        <span class="keyword">public</span> void run() &#123;</span><br><span class="line">            loadFromDisk();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如你所看到的，开启一个线程异步读取数据，当我们正在读取一个比较大的数据，还没读取完，接着调用 <code>getXXX()</code> 方法。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String getString(String key, <span class="meta">@Nullable</span> String defValue) &#123;</span><br><span class="line">    synchronized (mLock) &#123;</span><br><span class="line">        awaitLoadedLocked();</span><br><span class="line">        String v = (String)mMap.<span class="keyword">get</span>(key);</span><br><span class="line">        <span class="keyword">return</span> v != <span class="literal">null</span> ? v : defValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> void awaitLoadedLocked() &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">while</span> (!mLoaded) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mLock.wait();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException unused) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在同步方法内调用了 <code>wait()</code> 方法，会一直等待 <code>getSharedPreferences()</code> 方法开启的线程读取完数据才能继续往下执行，如果读取几 KB 的数据还好，假设读取一个大的文件，势必会造成主线程阻塞。  </p><h2 id="MMKV的使用"><a href="#MMKV的使用" class="headerlink" title="MMKV的使用"></a>MMKV的使用</h2><p>MMKV 是基于 mmap 内存映射的 key-value 组件，底层序列化/反序列化使用 protobuf 实现，性能高，稳定性强。从 2015 年中至今在微信上使用，其性能和稳定性经过了时间的验证。近期也已移植到 Android / macOS / Win32 / POSIX 平台，一并开源。</p><h3 id="MMKV优点"><a href="#MMKV优点" class="headerlink" title="MMKV优点"></a>MMKV优点</h3><p>1.MMKV实现了SharedPreferences接口，可以无缝切换<br>2.通过 mmap 内存映射文件，提供一段可供随时写入的内存块，App 只管往里面写数据，由操作系统负责将内存回写到文件，不必担心 crash 导致数据丢失。<br>3.MMKV数据序列化方面选用 protobuf 协议，pb 在性能和空间占用上都有不错的表现<br>4.SP是全量更新，MMKV是增量更新，有性能优势  </p><p>详细的使用细节可以参考文档：<a href="https://github.com/Tencent/MMKV/wiki" target="_blank" rel="noopener">https://github.com/Tencent/MMKV/wiki</a></p><h2 id="MMKV原理"><a href="#MMKV原理" class="headerlink" title="MMKV原理"></a>MMKV原理</h2><h3 id="为什么MMKV写入速度更快"><a href="#为什么MMKV写入速度更快" class="headerlink" title="为什么MMKV写入速度更快"></a>为什么MMKV写入速度更快</h3><h4 id="IO操作"><a href="#IO操作" class="headerlink" title="IO操作"></a>IO操作</h4><p>我们知道，SP是写入是基于IO操作的，为了了解IO，我们需要先了解下用户空间与内核空间<br>虚拟内存被操作系统划分成两块：用户空间和内核空间，用户空间是用户程序代码运行的地方，内核空间是内核代码运行的地方。为了安全，它们是隔离的，即使用户的程序崩溃了，内核也不受影响。<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog9/p8.png" alt><br><strong>写文件流程:</strong><br>1、调用write，告诉内核需要写入数据的开始地址与长度<br>2、内核将数据拷贝到内核缓存<br>3、由操作系统调用，将数据拷贝到磁盘，完成写入    </p><h4 id="MMAP"><a href="#MMAP" class="headerlink" title="MMAP"></a>MMAP</h4><p>Linux通过将一个虚拟内存区域与一个磁盘上的对象关联起来，以初始化这个虚拟内存区域的内容，这个过程称为内存映射(memory mapping)。<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog9/p9.png" alt><br>对文件进行mmap，会在进程的虚拟内存分配地址空间，创建映射关系。<br>实现这样的映射关系后，就可以采用指针的方式读写操作这一段内存，而系统会自动回写到对应的文件磁盘上    </p><h4 id="MMAP优势"><a href="#MMAP优势" class="headerlink" title="MMAP优势"></a>MMAP优势</h4><ul><li>MMAP对文件的读写操作只需要从磁盘到用户主存的一次数据拷贝过程，减少了数据的拷贝次数，提高了文件读写效率。</li><li>MMAP使用逻辑内存对磁盘文件进行映射，操作内存就相当于操作文件，不需要开启线程，操作MMAP的速度和操作内存的速度一样快；</li><li>MMAP提供一段可供随时写入的内存块，App 只管往里面写数据，由操作系统如内存不足、进程退出等时候负责将内存回写到文件，不必担心 crash 导致数据丢失。</li></ul><p><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog9/p10.png" alt><br>可以看出，MMAP的写入速度基本与内存写入速度一致，远高于SP，这就是MMKV写入速度更快的原因    </p><h3 id="MMKV写入方式"><a href="#MMKV写入方式" class="headerlink" title="MMKV写入方式"></a>MMKV写入方式</h3><h4 id="SP的数据结构"><a href="#SP的数据结构" class="headerlink" title="SP的数据结构"></a>SP的数据结构</h4><p>SP是使用XML格式存储数据的，如下所示<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog9/p11.png" alt><br>但是这也导致SP如果要更新数据的话，只能全量更新</p><h4 id="MMKV数据结构"><a href="#MMKV数据结构" class="headerlink" title="MMKV数据结构"></a>MMKV数据结构</h4><p>MMKV数据结构如下<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog9/p12.png" alt><br>MMKV使用Protobuf存储数据，冗余数据更少，更省空间，同时可以方便地在末尾追加数据   </p><h4 id="写入方式"><a href="#写入方式" class="headerlink" title="写入方式"></a>写入方式</h4><p><strong>增量写入</strong><br>不管key是否重复，直接将数据追加在前数据后。<br>这样效率更高，更新数据只需要插入一条数据即可。    </p><p>当然这样也会带来问题，如果不断增量追加内容，文件越来越大，怎么办？<br>当文件大小不够，这时候需要全量写入。将数据去掉重复key后，如果文件大小满足写入的数据大小，则可以直接更新全量写入，否则需要扩容。（在扩容时根据平均每个K-V大小计算未来可能需要的文件大小进行扩容，防止经常性的全量写入）   </p><h3 id="MMKV三大优势"><a href="#MMKV三大优势" class="headerlink" title="MMKV三大优势"></a>MMKV三大优势</h3><ul><li>mmap防止数据丢失，提高读写效率;</li><li>精简数据，以最少的数据量表示最多的信息，减少数据大小;</li><li>增量更新，避免每次进行相对增量来说大数据量的全量写入。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://juejin.cn/post/6881442312560803853" target="_blank" rel="noopener">[Google] 再见 SharedPreferences 拥抱 Jetpack DataStore</a><br><a href="https://juejin.cn/post/6844903729217404935" target="_blank" rel="noopener">浅析SharedPreferences</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;SharedPreferences是谷歌提供的轻量级存储方案，使用起来比较方便，可以直接进行数据存储，不必另起线程&lt;br&gt;不过也带来很多问题
      
    
    </summary>
    
    
      <category term="android" scheme="http://ShenZhen2017.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>RecyclerView相关知识点总结</title>
    <link href="http://ShenZhen2017.github.io/blog/2021/02/recyclerview-sum-up.html"/>
    <id>http://ShenZhen2017.github.io/blog/2021/02/recyclerview-sum-up.html</id>
    <published>2021-02-14T14:57:58.000Z</published>
    <updated>2021-02-18T13:16:40.508Z</updated>
    
    <content type="html"><![CDATA[<p>1.RecyclerView缓存机制<br><a href="https://mp.weixin.qq.com/s/VI68qPFr-iNa_-lwCh7fwA" target="_blank" rel="noopener">再也不用担心面试官问RecycleView了</a><br><a href="https://juejin.cn/post/6930412704578404360" target="_blank" rel="noopener">RecyclerView 面试题 | 哪些情况下表项会被回收到缓存池？</a></p><p>2.RecyclerView吸顶</p><p>3.RecyclerView折叠展开</p><p>4.局部刷新<br>payload</p><p>5.预取</p><p>6.diffutils<br><a href="https://juejin.cn/post/6882531923537707015" target="_blank" rel="noopener">更高效地刷新 RecyclerView | DiffUtil二次封装</a></p><p>7.RecyclerView item点击<br><a href="https://juejin.cn/post/6881427923316768776/" target="_blank" rel="noopener">https://juejin.cn/post/6881427923316768776/</a></p><p>8.MultiType<br><a href="https://juejin.cn/post/6876967151975006221" target="_blank" rel="noopener">代理模式应用 | 每当为 RecyclerView 新增类型时就很抓狂</a></p><p>9.Paging<br><a href="https://juejin.cn/post/6893699877415436295" target="_blank" rel="noopener">超简单易用的使用Paging3封装的RecyclerView的列表适配器</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.RecyclerView缓存机制&lt;br&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/VI68qPFr-iNa_-lwCh7fwA&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;再也不用担心面试官问RecycleView了&lt;/
      
    
    </summary>
    
    
      <category term="android" scheme="http://ShenZhen2017.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>ARTS打卡17</title>
    <link href="http://ShenZhen2017.github.io/blog/2021/02/arts-seventeen-way.html"/>
    <id>http://ShenZhen2017.github.io/blog/2021/02/arts-seventeen-way.html</id>
    <published>2021-02-13T14:01:46.000Z</published>
    <updated>2021-02-14T12:04:31.516Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Algorithmn"><a href="#Algorithmn" class="headerlink" title="Algorithmn"></a>Algorithmn</h2><blockquote><p><a href="https://leetcode-cn.com/contest/weekly-contest-228/problems/minimum-changes-to-make-alternating-binary-string/" target="_blank" rel="noopener">5676. 生成交替二进制字符串的最少操作数</a><br>给你一个仅由字符 ‘0’ 和 ‘1’ 组成的字符串 s 。一步操作中，你可以将任一 ‘0’ 变成 ‘1’ ，或者将 ‘1’ 变成 ‘0’ 。<br>交替字符串 定义为：如果字符串中不存在相邻两个字符相等的情况，那么该字符串就是交替字符串。例如，字符串 “010” 是交替字符串，而字符串 “0100” 不是。<br>返回使 s 变成 交替字符串 所需的 最少 操作数。</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">minOperations</span><span class="params">(s: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> charArray1 = s.toCharArray()</span><br><span class="line">        <span class="keyword">val</span> charArray2 = s.toCharArray()</span><br><span class="line">        reverseItem(charArray2, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> minOf(getCount(charArray1), getCount(charArray2) + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">reverseItem</span><span class="params">(charArray: <span class="type">CharArray</span>, i: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (charArray[i] == <span class="string">'0'</span>) &#123;</span><br><span class="line">            charArray[i] = <span class="string">'1'</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            charArray[i] = <span class="string">'0'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getCount</span><span class="params">(charArray: <span class="type">CharArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until charArray.size) &#123;</span><br><span class="line">            <span class="keyword">if</span> (charArray[i] == charArray[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                reverseItem(charArray, i)</span><br><span class="line">                count++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p><a href="https://medium.com/mobile-app-development-publication/kotlin-flow-imperative-or-declarative-exception-handler-bf8d64936366" target="_blank" rel="noopener">Kotlin Flow: Imperative or Declarative Exception Handler?</a><br>本文主要讲解了kotlin协程处理异常的几种方法<br>1.强制性<br>2.声明性</p><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><h3 id="Star法则"><a href="#Star法则" class="headerlink" title="Star法则"></a>Star法则</h3><p>STAR法则是指：Situation, Task, Action, Result</p><ul><li>Situation: 事情是在什么情况下发生的</li><li>Task:明确在相关经历及任务中，要达到什么样目标，完成过程中涉及什么环节及流程。</li><li>Action：明确采取的行动，针对这样的情况进行分析，决定的方式以及采取的步骤。</li><li>Result：描述结果怎样，最终取得了什么样的成就。</li></ul><h3 id="TabLayout改变下划线宽度"><a href="#TabLayout改变下划线宽度" class="headerlink" title="TabLayout改变下划线宽度"></a>TabLayout改变下划线宽度</h3><p>有时我们需要自定义TabLayout下划线的宽度，有时还需要与文字一样宽，有时需要固定宽度<br>详情可见：<a href="https://mrfzh.github.io/2019/11/01/TabLayout-%E4%B9%8B%E6%94%B9%E5%8F%98-Indicator-%E7%9A%84%E5%AE%BD%E5%BA%A6/" target="_blank" rel="noopener">TabLayout 之改变 Indicator 的宽度</a></p><h3 id="协程debug"><a href="#协程debug" class="headerlink" title="协程debug"></a>协程debug</h3><p>开启协程debug:System.setProperty(“kotlinx.coroutines.debug”, “on”)</p><h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p>本周暂无</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Algorithmn&quot;&gt;&lt;a href=&quot;#Algorithmn&quot; class=&quot;headerlink&quot; title=&quot;Algorithmn&quot;&gt;&lt;/a&gt;Algorithmn&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode
      
    
    </summary>
    
    
      <category term="ARTS" scheme="http://ShenZhen2017.github.io/tags/ARTS/"/>
    
  </entry>
  
  <entry>
    <title>ARTS打卡16</title>
    <link href="http://ShenZhen2017.github.io/blog/2021/02/arts-way-sixteen.html"/>
    <id>http://ShenZhen2017.github.io/blog/2021/02/arts-way-sixteen.html</id>
    <published>2021-02-06T12:19:04.000Z</published>
    <updated>2021-02-06T14:37:30.495Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><blockquote><p><a href="https://leetcode-cn.com/contest/biweekly-contest-45/problems/sum-of-unique-elements/" target="_blank" rel="noopener">5657. 唯一元素的和</a><br>给你一个整数数组 nums 。数组中唯一元素是那些只出现 恰好一次 的元素。<br>请你返回 nums 中唯一元素的 和 。</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sumOfUnique</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> map = hashMapOf&lt;<span class="built_in">Int</span>,<span class="built_in">Int</span>&gt;()</span><br><span class="line">        nums.forEach &#123;</span><br><span class="line">            map[it] = map.getOrDefault(it,<span class="number">0</span>)+<span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> result = <span class="number">0</span></span><br><span class="line">        map.forEach &#123; i, i2 -&gt;</span><br><span class="line">            <span class="keyword">if</span> (i2==<span class="number">1</span>)&#123;</span><br><span class="line">                result+=i</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p><a href="https://medium.com/better-programming/best-practices-for-using-viewmodels-in-android-e986b25dc78f" target="_blank" rel="noopener">Best Practices for Using ViewModels in Android</a><br>本文主要讲解了ViewModel的最佳实践</p><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><h3 id="Flow与ChannelFlow的区别"><a href="#Flow与ChannelFlow的区别" class="headerlink" title="Flow与ChannelFlow的区别"></a>Flow与ChannelFlow的区别</h3><p>通过Kotlin的Flow可以轻松实现生产者消费者模型。Flow默认是Cold的，生产者和消费者的通信是同步非阻塞的，也就是生产和消费会顺序交替进行<br>如果，我们希望生产者消费者两端能够实现异步非阻塞模型呢？此时可以使用ChannelFlow，顾名思义ChannelFlow中和了Coroutine Channel和Flow的优点：比Channel更冷（collect之后才触发生产）比Flow更热（生产消费可以并行执行）</p><p>详情可见:<a href="https://blog.csdn.net/vitaviva/article/details/104105970" target="_blank" rel="noopener">Kotlin Flow与ChannelFlow</a></p><h3 id="StateFlow与SharedFlow的区别"><a href="#StateFlow与SharedFlow的区别" class="headerlink" title="StateFlow与SharedFlow的区别"></a>StateFlow与SharedFlow的区别</h3><p>StateFlow即包含状态的Flow,可以获取当前value<br>SharedFlow:直接翻译：共享的流。也就是这一类数据流可以为多个使用方提供数据。上面的StateFlow是一种特殊的ShareFlow.</p><p>详情可见:<a href="https://juejin.cn/post/6918644407184916488#heading-12" target="_blank" rel="noopener">Kotlin Flow场景化学习</a></p><h3 id="Flow-Scan的使用"><a href="#Flow-Scan的使用" class="headerlink" title="Flow Scan的使用"></a>Flow Scan的使用</h3><p>Flow语法糖，遍历时可获取当前值与累计值<br>详情可见：<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/scan.html" target="_blank" rel="noopener">https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/scan.html</a></p><h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p>本周暂无  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Algorithm&quot;&gt;&lt;a href=&quot;#Algorithm&quot; class=&quot;headerlink&quot; title=&quot;Algorithm&quot;&gt;&lt;/a&gt;Algorithm&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.
      
    
    </summary>
    
    
      <category term="ARTS" scheme="http://ShenZhen2017.github.io/tags/ARTS/"/>
    
  </entry>
  
  <entry>
    <title>关于Paging3你应该知道的知识点</title>
    <link href="http://ShenZhen2017.github.io/blog/2021/01/paging-source-learn.html"/>
    <id>http://ShenZhen2017.github.io/blog/2021/01/paging-source-learn.html</id>
    <published>2021-01-31T11:46:30.000Z</published>
    <updated>2021-02-14T14:27:26.682Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Paging库是Google新推出的jetPack组件，主要方便封装分页逻辑。<br>使用Paging库后，我们不需要再考虑加载下一页的逻辑，可以做到自动加载，同时可以方便的观察加载下一页的状态，是成功还是失败</p><p>本文主要包括Paging3的基本使用与部分源码解析，具体如下：<br>1.Paging3的基本使用<br>2.Paging3自动加载更多原理    </p><h2 id="Paging3的基本使用"><a href="#Paging3的基本使用" class="headerlink" title="Paging3的基本使用"></a>Paging3的基本使用</h2><h3 id="主要优点"><a href="#主要优点" class="headerlink" title="主要优点"></a>主要优点</h3><p>Paging 库包含以下功能：</p><ul><li>分页数据的内存中缓存。这可确保您的应用在处理分页数据时高效利用系统资源。</li><li>内置的请求重复信息删除功能，可确保您的应用高效地利用网络带宽和系统资源。</li><li>可配置的 RecyclerView 适配器，它们会在用户滚动到已加载数据的末尾时自动请求数据。</li><li>对 Kotlin 协程和流程以及 LiveData 和 RxJava 的一流支持。</li><li>内置对错误处理功能的支持，包括刷新和重试功能。</li></ul><h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><p><img src="https://github.com/shenzhen2017/newImage/blob/master/blog9/p6.jpg?raw=true" alt><br>里面几个类的作用：</p><ul><li><code>PagingSource</code> ：单一的数据源。</li><li><code>RemoteMediator</code> ：其实 <code>RemoteMediator</code> 也是单一的数据源，它会在 <code>PagingSource</code>  没有数据的时候，再使用 <code>RemoteMediator</code>  提供的数据，如果既存在数据库请求，又存在网络请求，通常 <code>PagingSource</code>  用于进行数据库请求，<code>RemoteMediator</code>  进行网络请求。</li><li><code>PagingData</code> ：单次分页数据的容器。</li><li><code>Pager</code>：用来构建 <code>Flow&lt;PagingData&gt;</code> 的类，实现数据加载完成的回调。</li><li><code>PagingDataAdapter</code> ：分页加载数据的 <code>RecyclerView</code> 的适配器。</li></ul><p>简述一下就是 <code>PagingSource</code> 和 <code>RemoteMediator</code> 充当数据源的角色，<code>ViewModel</code> 使用 <code>Pager</code> 中提供的 <code>Flow&lt;PagingData&gt;</code> 监听数据刷新.<br>每当 <code>RecyclerView</code> 即将滚动到底部的时候，就会有新的数据的到来，最后，<code>PagingAdapter</code> 展示数据。</p><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><h4 id="1-配置数据源"><a href="#1-配置数据源" class="headerlink" title="1.配置数据源"></a>1.配置数据源</h4><p>首先需要生成数据层，配置数据源<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> SHOE_START_INDEX = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomPageDataSource</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> shoeRepository: ShoeRepository) : PagingSource&lt;<span class="built_in">Int</span>, Shoe&gt;() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">load</span><span class="params">(params: <span class="type">LoadParams</span>&lt;<span class="type">Int</span>&gt;)</span></span>: LoadResult&lt;<span class="built_in">Int</span>, Shoe&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> pos = params.key ?: SHOE_START_INDEX</span><br><span class="line">        <span class="keyword">val</span> startIndex = pos * params.loadSize + <span class="number">1</span></span><br><span class="line">        <span class="keyword">val</span> endIndex = (pos + <span class="number">1</span>) * params.loadSize</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 从数据库拉去数据</span></span><br><span class="line">            <span class="keyword">val</span> shoes = shoeRepository.getPageShoes(startIndex.toLong(), endIndex.toLong())</span><br><span class="line">            <span class="comment">// 返回你的分页结果，并填入前一页的 key 和后一页的 key</span></span><br><span class="line">            LoadResult.Page(</span><br><span class="line">                shoes,</span><br><span class="line">                <span class="keyword">if</span> (pos &lt;= SHOE_START_INDEX) <span class="literal">null</span> <span class="keyword">else</span> pos - <span class="number">1</span>,</span><br><span class="line">                <span class="keyword">if</span> (shoes.isNullOrEmpty()) <span class="literal">null</span> <span class="keyword">else</span> pos + <span class="number">1</span></span><br><span class="line">            )</span><br><span class="line">        &#125;<span class="keyword">catch</span> (e:Exception)&#123;</span><br><span class="line">            LoadResult.Error(e)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="2-生成可观察的数据集"><a href="#2-生成可观察的数据集" class="headerlink" title="2. 生成可观察的数据集"></a>2. 生成可观察的数据集</h4><p>第二步则是在viewModel中生成可观察的数据集<br>这里可观察数据集包括 <code>LiveData</code> 、<code>Flow</code> 以及 <code>RxJava</code> 中的 <code>Observable</code> 和 <code>Flowable</code>，其中，RxJava 需要单独引入扩展库去支持的。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShoeModel</span> <span class="keyword">constructor</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> shoeRepository: ShoeRepository) : ViewModel() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> config 分页的参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pagingSourceFactory 单一数据源的工厂，在闭包中提供一个PageSource即可</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> remoteMediator 同时支持网络请求和数据库请求的数据源</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> initialKey 初始化使用的key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">var</span> shoes = Pager(config = PagingConfig(</span><br><span class="line">        pageSize = <span class="number">20</span></span><br><span class="line">        , enablePlaceholders = <span class="literal">false</span></span><br><span class="line">        , initialLoadSize = <span class="number">20</span></span><br><span class="line">    ), pagingSourceFactory = &#123; CustomPageDataSource(shoeRepository) &#125;).flow</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="3-创建Adapter"><a href="#3-创建Adapter" class="headerlink" title="3.创建Adapter"></a>3.创建Adapter</h4><p>和普通的 Adapter 没有特别大的区别，主要是：   </p><ul><li>提供 <code>DiffUtil.ItemCallback&lt;Shoe&gt;</code></li><li>继承 <code>PagingDataAdapter</code></li></ul><p>使用<code>PagingAdapter</code>需要实现<code>DiffUtil.ItemCallback</code>接口，因为后续提交数据时，会根据<code>DiffUtil</code>接口判断数据是否相同，从而做插入与删除操作<br>同时使用Paging需要继承<code>PagingDataAdapter</code>，这通常需要我们修改已有的基类，这也是Paging库的一个主要缺点</p><h4 id="4-在UI中使用"><a href="#4-在UI中使用" class="headerlink" title="4.在UI中使用"></a>4.在UI中使用</h4><p>如果只显示数据，我们要做的是：  </p><ul><li>创建和设置适配器。</li><li>开启一个协程</li><li>在协程中接收 Flow 提供的数据。</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> adapter = ShoeAdapter(context!!)</span><br><span class="line">binding.recyclerView.adapter = adapter</span><br><span class="line">job = viewModel.viewModelScope.launch(Dispatchers.IO) &#123;</span><br><span class="line">    viewModel.shoes.collect() &#123;</span><br><span class="line">        adapter.submitData(it)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-监听数据加载状态"><a href="#5-监听数据加载状态" class="headerlink" title="5.监听数据加载状态"></a>5.监听数据加载状态</h4><p>Paging可以监听数据的加载状态，状态对应的类是 LoadState，它有三种状态：</p><ul><li>Loading：数据加载中。</li><li>NotLoading：内存中有已经获取的数据，即使往下滑，Paging 也不需要请求更多的数据。</li><li>Error：请求数据时返回了一个错误。</li></ul><p>监听数据状态的代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">adapter.addLoadStateListener &#123;state:CombinedLoadStates-&gt;</span><br><span class="line">    <span class="comment">//... 状态监听</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>监听方法就是这么简单，可以看到这个 <code>state</code> 并不是 <code>LoadState</code>，而是一个 <code>CombinedLoadStates</code>，顾名思义，就是多个 <code>LoadState</code> 组合而成的状态类，它里面有：</p><ul><li><code>refresh:LoadState</code>：刷新时的状态，因为可以调用 <code>PagingDataAdapter#refresh()</code> 方法进行数据刷新。</li><li><code>append:LoadState</code>：可以理解为 RecyclerView 向下滑时数据的请求状态。</li><li><code>prepend:LoadState</code>：可以理解为RecyclerView 向上滑时数据的请求状态。</li></ul><h2 id="Paging3如何实现自动加载更多？"><a href="#Paging3如何实现自动加载更多？" class="headerlink" title="Paging3如何实现自动加载更多？"></a>Paging3如何实现自动加载更多？</h2><p>当RecyclerView即将滚动到底部时，Paging库会自动加载更多，我们可以看下是怎样实现的</p><p>实际上，Paging的加载更多逻辑是通过<code>PagingDataAdapter</code>的<code>getItem()</code>方法触发的<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">fun</span> <span class="title">getItem</span><span class="params">(<span class="meta">@IntRange(from = 0)</span> position: <span class="type">Int</span>)</span></span> = differ.getItem(position)</span><br></pre></td></tr></table></figure></p><p>这里的<code>differ</code>是一个<code>AsyncPagingDataDiffer</code>对象：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getItem</span><span class="params">(<span class="meta">@IntRange(from = 0)</span> index: <span class="type">Int</span>)</span></span>: T? &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            inGetItem = <span class="literal">true</span></span><br><span class="line">            <span class="keyword">return</span> differBase[index]</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            inGetItem = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>接着看<code>differBase</code>的<code>get()</code>方法，<code>differBase</code>是一个<code>PagingDataDiffer</code>对象：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">(index: <span class="type">Int</span>)</span></span>: T? &#123;</span><br><span class="line">        lastAccessedIndex = index</span><br><span class="line">        receiver?.addHint(presenter.loadAround(index))</span><br><span class="line">        <span class="keyword">return</span> presenter.<span class="keyword">get</span>(index)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>这里的<code>receiver</code>是一个<code>UiReceiver</code>对象,在初始化时会初始化为<code>PagerUiReceiver</code>，下面看一下<code>addHint()</code>方法<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">PagerUiReceiver</span>&lt;<span class="type">Key : Any, Value : Any</span>&gt; <span class="keyword">constructor</span></span>(</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> pageFetcherSnapshot: PageFetcherSnapshot&lt;Key, Value&gt;,</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> retryChannel: SendChannel&lt;<span class="built_in">Unit</span>&gt;</span><br><span class="line">    ) : UiReceiver &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">addHint</span><span class="params">(hint: <span class="type">ViewportHint</span>)</span></span> = pageFetcherSnapshot.addHint(hint)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">retry</span><span class="params">()</span></span> &#123;</span><br><span class="line">            retryChannel.offer(<span class="built_in">Unit</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">refresh</span><span class="params">()</span></span> = <span class="keyword">this</span><span class="symbol">@PageFetcher</span>.refresh()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>这里的<code>pageFetcherSnapshot</code>是一个<code>PageFetcherSnapshot</code>对象<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">addHint</span><span class="params">(hint: <span class="type">ViewportHint</span>)</span></span> &#123;</span><br><span class="line">        lastHint = hint</span><br><span class="line">        <span class="meta">@OptIn(ExperimentalCoroutinesApi::class)</span></span><br><span class="line">        hintChannel.offer(hint)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>这里的<code>hintChannel</code>是一个<code>BroadcastChannel</code>对象，只要该<code>channel</code>中有新值，它会广播给所有的订阅者，下面看一下订阅<code>hintChannel</code>的地方<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">hintChannel.asFlow()</span><br><span class="line">            <span class="comment">// Prevent infinite loop when competing PREPEND / APPEND cancel each other</span></span><br><span class="line">            .drop(<span class="keyword">if</span> (generationId == <span class="number">0</span>) <span class="number">0</span> <span class="keyword">else</span> <span class="number">1</span>)</span><br><span class="line">            .map &#123; hint -&gt; GenerationalViewportHint(generationId, hint) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">// Prioritize new hints that would load the maximum number of items.</span></span><br><span class="line">        .runningReduce &#123; previous, next -&gt;</span><br><span class="line">            <span class="keyword">if</span> (next.shouldPrioritizeOver(previous, loadType)) next <span class="keyword">else</span> previous</span><br><span class="line">        &#125;</span><br><span class="line">        .conflate()</span><br><span class="line">        .collect &#123; generationalHint -&gt;</span><br><span class="line">            doLoad(loadType, generationalHint)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p><p>可以看到上游hintChannel有值时，会构造一个<code>GenerationalViewportHint</code>对象，下游会调用<code>doLoad()</code>方法：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">doLoad</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        loadType: <span class="type">LoadType</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        generationalHint: <span class="type">GenerationalViewportHint</span></span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span> &#123;</span><br><span class="line">    .....</span><br><span class="line">     <span class="keyword">var</span> loadKey: Key? = stateHolder.withLock &#123; state -&gt;</span><br><span class="line">            state.nextLoadKeyOrNull(</span><br><span class="line">                loadType,</span><br><span class="line">                generationalHint.generationId,</span><br><span class="line">                generationalHint.presentedItemsBeyondAnchor(loadType) + itemsLoaded,</span><br><span class="line">            )?.also &#123; state.setLoading(loadType) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="symbol">loop@</span> <span class="keyword">while</span> (loadKey != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">val</span> params = loadParams(loadType, loadKey)</span><br><span class="line">            <span class="keyword">val</span> result: LoadResult&lt;Key, Value&gt; = pagingSource.load(params)</span><br><span class="line">            ....</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看出在<code>loadKey</code>不为<code>null</code>时，会调用<code>pagingSource</code>的<code>load</code>方法从而加载下一页,我们看看<code>nextLoadKeyOrNull</code>方法<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> PageFetcherSnapshotState<span class="type">&lt;Key, Value&gt;</span>.<span class="title">nextLoadKeyOrNull</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        loadType: <span class="type">LoadType</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        generationId: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        presentedItemsBeyondAnchor: <span class="type">Int</span></span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span>: Key? &#123;</span><br><span class="line">        <span class="keyword">if</span> (generationId != generationId(loadType)) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">        <span class="comment">// Skip load if in error state, unless retrying.</span></span><br><span class="line">        <span class="keyword">if</span> (sourceLoadStates.<span class="keyword">get</span>(loadType) <span class="keyword">is</span> Error) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Skip loading if prefetchDistance has been fulfilled.</span></span><br><span class="line">        <span class="keyword">if</span> (presentedItemsBeyondAnchor &gt;= config.prefetchDistance) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">if</span> (loadType == PREPEND) &#123;</span><br><span class="line">            pages.first().prevKey</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pages.last().nextKey</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>从上可以看出,只有当加载状态为成功，且最后一个的距离小于预加载距离时，才会返回<code>nextKey</code>,即开始加载下一页  </p><p>以上就是Paing3自动加载下一页的源码分析，总结为时序图如下：<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog9/p6.png" alt></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://juejin.cn/post/6898133386218045453" target="_blank" rel="noopener">即学即用Android Jetpack - Paging 3</a><br><a href="https://blog.csdn.net/weixin_40888127/article/details/107392096" target="_blank" rel="noopener">Paging内部原理</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Paging库是Google新推出的jetPack组件，主要方便封装分页逻辑。&lt;br&gt;使用Paging库后，我们不需要再考虑加载下一页的逻辑
      
    
    </summary>
    
    
      <category term="android" scheme="http://ShenZhen2017.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>ARTS打卡15</title>
    <link href="http://ShenZhen2017.github.io/blog/2021/01/arts-way-fifteen.html"/>
    <id>http://ShenZhen2017.github.io/blog/2021/01/arts-way-fifteen.html</id>
    <published>2021-01-30T12:16:51.000Z</published>
    <updated>2021-01-31T11:49:39.535Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><blockquote><p><a href="https://leetcode-cn.com/contest/weekly-contest-226/problems/maximum-number-of-balls-in-a-box/" target="_blank" rel="noopener">5654. 盒子中小球的最大数量</a><br>你在一家生产小球的玩具厂工作，有 n 个小球，编号从 lowLimit 开始，到 highLimit 结束（包括 lowLimit 和 highLimit ，即 n == highLimit - lowLimit + 1）。另有无限数量的盒子，编号从 1 到 infinity 。<br>你的工作是将每个小球放入盒子中，其中盒子的编号应当等于小球编号上每位数字的和。例如，编号 321 的小球应当放入编号 3 + 2 + 1 = 6 的盒子，而编号 10 的小球应当放入编号 1 + 0 = 1 的盒子。<br>给你两个整数 lowLimit 和 highLimit ，返回放有最多小球的盒子中的小球数量。如果有多个盒子都满足放有最多小球，只需返回其中任一盒子的小球数量。</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">countBalls</span><span class="params">(lowLimit: <span class="type">Int</span>, highLimit: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> max = <span class="number">0</span></span><br><span class="line">        <span class="keyword">val</span> hashMap = hashMapOf&lt;<span class="built_in">Int</span>,<span class="built_in">Int</span>&gt;()</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> lowLimit..highLimit)&#123;</span><br><span class="line">            <span class="keyword">val</span> item = getNum(i)</span><br><span class="line">            hashMap[item] = hashMap.getOrDefault(item,<span class="number">0</span>)+<span class="number">1</span></span><br><span class="line">            max = maxOf(hashMap.getOrDefault(item,<span class="number">0</span>),max)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getNum</span><span class="params">(item:<span class="type">Int</span>)</span></span>:<span class="built_in">Int</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> num = item</span><br><span class="line">        <span class="keyword">var</span> result = num%<span class="number">10</span></span><br><span class="line">        <span class="keyword">while</span> (num/<span class="number">10</span> &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            num /= <span class="number">10</span></span><br><span class="line">            result += num%<span class="number">10</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p><a href="https://developer.android.com/topic/libraries/architecture/paging/v3-overview" target="_blank" rel="noopener">Paging 3 library overview</a><br>Paging3使用文档</p><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><h3 id="noinline与crossinline"><a href="#noinline与crossinline" class="headerlink" title="noinline与crossinline"></a>noinline与crossinline</h3><p>一个函数中，如果存在一个lambda表达式，在该lambda中不支持直接进行return退出该函数<br>除非，innerFun是inline函数</p><p>crossinline 的作用是让被标记的lambda表达式不允许非局部返回。<br>如果你只想被（作为参数）传给一个内联函数的 lamda 表达式中只有一些被内联，你可以用 noinline 修饰符标记一些函数参数<br>详情可见：<a href="https://blog.csdn.net/u013009899/article/details/78584994" target="_blank" rel="noopener">Kotlin内联：noinline与crossinline</a></p><h3 id="Android-你的自定义View是否比别人多了一个层级"><a href="#Android-你的自定义View是否比别人多了一个层级" class="headerlink" title="Android 你的自定义View是否比别人多了一个层级"></a>Android 你的自定义View是否比别人多了一个层级</h3><p>Android自定义View添加view时往往会多一个层级，可以使用merge来降低自定义view层级<br>但是这种方式有一个缺点，就是在开发过程中我们无法实时的在右侧preview中浏览到正确的布局排列样式<br>可以使用tools:parentTag来指定父布局，从而实现预览<br><a href="https://www.jianshu.com/p/3c6e763d48fc" target="_blank" rel="noopener">Android 你的自定义View是否比别人多了一个层级</a></p><h3 id="判断是否是平板"><a href="#判断是否是平板" class="headerlink" title="判断是否是平板"></a>判断是否是平板</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isTablet</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> xlarge = ((context.getResources().getConfiguration().screenLayout &amp; Configuration.SCREENLAYOUT_SIZE_MASK) == Configuration.SCREENLAYOUT_SIZE_XLARGE);</span><br><span class="line">    <span class="keyword">boolean</span> large = ((context.getResources().getConfiguration().screenLayout &amp; Configuration.SCREENLAYOUT_SIZE_MASK) == Configuration.SCREENLAYOUT_SIZE_LARGE);</span><br><span class="line">    <span class="keyword">return</span> (xlarge || large);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>各种方式都有点问题，详情可见<br><a href="https://stackoverflow.com/questions/5832368/tablet-or-phone-android/41646301#41646301" target="_blank" rel="noopener">https://stackoverflow.com/questions/5832368/tablet-or-phone-android/41646301#41646301</a><br><a href="https://blog.csdn.net/s13383754499/article/details/77448236" target="_blank" rel="noopener">https://blog.csdn.net/s13383754499/article/details/77448236</a><br><a href="https://www.imooc.com/wenda/detail/608728" target="_blank" rel="noopener">https://www.imooc.com/wenda/detail/608728</a>   </p><h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p><a href="https://shenzhen2017.github.io/blog/2021/01/paging-source-learn.html">Paging3源码解析</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Algorithm&quot;&gt;&lt;a href=&quot;#Algorithm&quot; class=&quot;headerlink&quot; title=&quot;Algorithm&quot;&gt;&lt;/a&gt;Algorithm&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.
      
    
    </summary>
    
    
      <category term="ARTS" scheme="http://ShenZhen2017.github.io/tags/ARTS/"/>
    
  </entry>
  
  <entry>
    <title>ARTS打卡14</title>
    <link href="http://ShenZhen2017.github.io/blog/2021/01/arts-way-fourteen.html"/>
    <id>http://ShenZhen2017.github.io/blog/2021/01/arts-way-fourteen.html</id>
    <published>2021-01-23T13:17:23.000Z</published>
    <updated>2021-01-24T03:20:47.891Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><blockquote><p><a href="https://leetcode-cn.com/contest/weekly-contest-225/problems/latest-time-by-replacing-hidden-digits/" target="_blank" rel="noopener">5661. 替换隐藏数字得到的最晚时间</a><br>给你一个字符串 time ，格式为 hh:mm（小时：分钟），其中某几位数字被隐藏（用 ? 表示）。<br>有效的时间为 00:00 到 23:59 之间的所有时间，包括 00:00 和 23:59 。<br>替换 time 中隐藏的数字，返回你可以得到的最晚有效时间。</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">maximumTime</span><span class="params">(time: <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">val</span> array = time.toCharArray()</span><br><span class="line">        <span class="keyword">if</span> (array[<span class="number">0</span>]==<span class="string">'?'</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (array[<span class="number">1</span>]==<span class="string">'?'</span>)&#123;</span><br><span class="line">                array[<span class="number">0</span>] = <span class="string">'2'</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">val</span> num = array[<span class="number">1</span>].toString().toInt()</span><br><span class="line">                <span class="keyword">if</span> (num&gt;<span class="number">3</span>)&#123;</span><br><span class="line">                    array[<span class="number">0</span>]=<span class="string">'1'</span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    array[<span class="number">0</span>]=<span class="string">'2'</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (array[<span class="number">1</span>]==<span class="string">'?'</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (array[<span class="number">0</span>]==<span class="string">'2'</span>)&#123;</span><br><span class="line">                array[<span class="number">1</span>]=<span class="string">'3'</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                array[<span class="number">1</span>]=<span class="string">'9'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (array[<span class="number">3</span>]==<span class="string">'?'</span>)&#123;</span><br><span class="line">            array[<span class="number">3</span>]=<span class="string">'5'</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (array[<span class="number">4</span>]==<span class="string">'?'</span>)&#123;</span><br><span class="line">            array[<span class="number">4</span>]=<span class="string">'9'</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> result = StringBuilder()</span><br><span class="line">        array.forEach &#123; </span><br><span class="line">            result.append(it)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.toString()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p><a href="https://proandroiddev.com/from-rxjava-to-kotlin-flow-error-handling-da1f6a4f2708" target="_blank" rel="noopener">From RxJava to Kotlin Flow: Error Handling</a><br>本文主要讲解了协程异常处理的相关逻辑</p><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><h3 id="DSL封装"><a href="#DSL封装" class="headerlink" title="DSL封装"></a>DSL封装</h3><p>使用DSL封装权限库，优化kotlin调用<br>详情可见：<a href="https://juejin.cn/post/6844904200644591630" target="_blank" rel="noopener">开源项目：使用 Activity Result API + Kotlin 扩展函数 封装权限请求库(支持 DSL 写法)</a></p><h3 id="git同步远程删除分支"><a href="#git同步远程删除分支" class="headerlink" title="git同步远程删除分支"></a>git同步远程删除分支</h3><p>删除远程分支后，本地需要同步，使用git fetch -p同步</p><h3 id="KClass与Class的区别"><a href="#KClass与Class的区别" class="headerlink" title="KClass与Class的区别"></a>KClass与Class的区别</h3><p>KClass是Test::class,Class是Test::class.java<br>详情可见:<a href="https://blog.csdn.net/Goals1989/article/details/107636893" target="_blank" rel="noopener">KClass和Java Class在kotlin文件中使用区别</a></p><h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p>本周暂无</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Algorithm&quot;&gt;&lt;a href=&quot;#Algorithm&quot; class=&quot;headerlink&quot; title=&quot;Algorithm&quot;&gt;&lt;/a&gt;Algorithm&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.
      
    
    </summary>
    
    
      <category term="ARTS" scheme="http://ShenZhen2017.github.io/tags/ARTS/"/>
    
  </entry>
  
  <entry>
    <title>kotlin实用技巧总结</title>
    <link href="http://ShenZhen2017.github.io/blog/2021/01/kotlin-tips-sum.html"/>
    <id>http://ShenZhen2017.github.io/blog/2021/01/kotlin-tips-sum.html</id>
    <published>2021-01-17T13:54:18.000Z</published>
    <updated>2021-01-24T14:45:40.483Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>众所周知，kotlin是google力推的用以取代java的android开发语言<br>kotlin使用起来比较方便，同时有许多语法糖<br>本文主要讲解了一些比较实用的kotlin技巧</p><h2 id="自定义圆角矩形"><a href="#自定义圆角矩形" class="headerlink" title="自定义圆角矩形"></a>自定义圆角矩形</h2><p>在项目中，我们常常要定义圆角矩形背景，一般是用自定义drawable实现的<br>但是圆角矩形的背景与圆角常常会有细微的变化，而一旦变化我们又要新创建一个drawable文件<br>这样就会导致文件爆炸的问题  </p><p>我们可以利用kotlin的扩展函数，来实现简单方便的圆角矩形背景<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> View.<span class="title">setRoundRectBg</span><span class="params">(color: <span class="type">Int</span> = Color.WHITE, cornerRadius: <span class="type">Int</span> = <span class="number">15.</span>dp)</span></span> &#123;</span><br><span class="line">    background = GradientDrawable().apply &#123;</span><br><span class="line">        setColor(color)</span><br><span class="line">        setCornerRadius(cornerRadius.toFloat())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对于需要自定义背景的View,直接调用setRoundRectBg即可，简单方便</p><h2 id="reified使用"><a href="#reified使用" class="headerlink" title="reified使用"></a>reified使用</h2><p>reified,kotlin中的泛型实化关键字，使抽象的东西更加具体或真实。<br>我们举两个例子来看看怎么使用reified</p><h3 id="startActivity例子"><a href="#startActivity例子" class="headerlink" title="startActivity例子"></a>startActivity例子</h3><p>我们一般startActivity是这样写的<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startActivity(context, NewActivity::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br></pre></td></tr></table></figure></p><p>我们利用reified定义一个扩展函数<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Function</span></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T : Activity&gt;</span> Activity.<span class="title">startActivity</span><span class="params">(context: <span class="type">Context</span>)</span></span> &#123;</span><br><span class="line">    startActivity(Intent(context, T::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>))</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Caller</span></span><br><span class="line">startActivity&lt;NewActivity&gt;(context)</span><br></pre></td></tr></table></figure></p><p>使用 reified，通过添加类型传递简化泛型参数<br>这样就不用手动传泛型的类型过去了 </p><h3 id="Gson解析例子"><a href="#Gson解析例子" class="headerlink" title="Gson解析例子"></a>Gson解析例子</h3><p>我们首先看下一般我们使用gson解析json是怎么做的<br>在Java序列化库（如Gson）中，当您想要反序列化该JSON字符串时，您最终必须将Class对象作为参数传递，以便Gson知道您想要的类型。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User user = <span class="keyword">new</span> Gson().fromJson(getJson(), User<span class="class">.<span class="keyword">class</span>)</span></span><br></pre></td></tr></table></figure></p><p>现在，让我们一起展示reified类型实化参数的魔法 我们将创建一个非常轻量级的扩展函数来包装Gson方法：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T&gt;</span> Gson.<span class="title">fromJson</span><span class="params">(json: <span class="type">String</span>)</span></span> = </span><br><span class="line">        fromJson(json, T::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br></pre></td></tr></table></figure></p><p>现在，在我们的Kotlin代码中，我们可以反序列化JSON字符串，甚至根本不需要传递类型信息！<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> user: User = Gson().fromJson(json)</span><br></pre></td></tr></table></figure></p><p>Kotlin根据它的用法推断出类型 - 因为我们将它分配给User类型的变量，Kotlin使用它作为fromJson（）的类型参数</p><h2 id="kotin接口支持SAM转换"><a href="#kotin接口支持SAM转换" class="headerlink" title="kotin接口支持SAM转换"></a>kotin接口支持SAM转换</h2><p>什么是SAM转换？可能有的同学还不太了解，这里先科普一下：</p><p>SAM 转换，即 Single Abstract Method Conversions，就是对于只有单个非默认抽象方法接口的转换 —— 对于符合这个条件的接口（称之为 SAM Type ），在 Kotlin 中可以直接用 Lambda 来表示 —— 当然前提是 Lambda 的所表示函数类型能够跟接口的中方法相匹配。</p><p>在Kotlin1.4之前，Kotlin是不支持Kotlin的SAM转换的，只支持Java SAM转换，官方给出的的解释是：是 Kotlin 本身已经有了函数类型和高阶函数，不需要在去SAM转化。 这个解释开发者并不买账，如果你用过Java Lambda和Fuction Interface。当你切换到Kotlin时，就会很懵逼。看来Kotlin是意识到了这个，或者是看到开发者的反馈，终于支持了。</p><p>在1.4之前，只能传递一个对象，是不支持Kotlin SAM的，而在1.4之后，可以支持Kotlin SAM,但是用法有一丢丢变化。interface需要使用fun关键字声明。使用fun关键字标记接口后，只要将此类接口作为参数，就可以将lambda作为参数传递。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意需用fun 关键字声明</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="keyword">interface</span> Action &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">runAction</span><span class="params">(a: <span class="type">Action</span>)</span></span> = a.run()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// 1.4之前，只能使用object</span></span><br><span class="line">    runAction(<span class="keyword">object</span> : Action&#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">            println(<span class="string">"run action"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">     <span class="comment">// 1.4-M1支持SAM,OK</span></span><br><span class="line">    runAction &#123;</span><br><span class="line">        println(<span class="string">"Hello, Kotlin 1.4!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h2><p>有时候，完成一些工作的方法是将它们委托给别人。这里不是在建议您将自己的工作委托给朋友去做，而是在说将一个对象的工作委托给另一个对象。</p><p>当然，委托在软件行业不是什么新鲜名词。委托 (Delegation) 是一种设计模式，在该模式中，对象会委托一个助手 (helper) 对象来处理请求，这个助手对象被称为代理。代理负责代表原始对象处理请求，并使结果可用于原始对象。</p><h3 id="类委托"><a href="#类委托" class="headerlink" title="类委托"></a>类委托</h3><p>举个例子，当我们要实现一个增强版的ArrayList,支持恢复最后一次删除的item   </p><p>实现这个用例的一种方式，是继承 ArrayList 类。由于新的类继承了具体的 ArrayList 类而不是实现 MutableList 接口，因此它与 ArrayList 的实现高度耦合。<br>如果只需要覆盖 remove() 函数来保持对已删除项目的引用，并将 MutableList 的其余空实现委托给其他对象，那该有多好啊。为了实现这一目标，Kotlin 提供了一种将大部分工作委托给一个内部 ArrayList 实例并且可以自定义其行为的方式，并为此引入了一个新的关键字: by。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Copyright <span class="number">2019</span> Google LLC.</span><br><span class="line">SPDX-License-Identifier: Apache-<span class="number">2.0</span> --&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListWithTrash</span> &lt;<span class="type">T</span>&gt;</span>(<span class="keyword">private</span> <span class="keyword">val</span> innerList: MutableList&lt;T&gt; = ArrayList&lt;T&gt;()) : MutableCollection&lt;T&gt; <span class="keyword">by</span> innerList &#123;</span><br><span class="line"><span class="keyword">var</span> deletedItem : T? = <span class="literal">null</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">remove</span><span class="params">(element: <span class="type">T</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">       deletedItem = element</span><br><span class="line"><span class="keyword">return</span> innerList.remove(element)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">recover</span><span class="params">()</span></span>: T? &#123;</span><br><span class="line"><span class="keyword">return</span> deletedItem</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>by 关键字告诉 Kotlin 将 MutableList 接口的功能委托给一个名为 innerList 的内部 ArrayList。通过桥接到内部 ArrayList 对象方法的方式，ListWithTrash 仍然支持 MutableList 接口中的所有函数。与此同时，现在您可以添加自己的行为了。</p><h3 id="属性委托"><a href="#属性委托" class="headerlink" title="属性委托"></a>属性委托</h3><p>除了类代理，您还可以使用 by 关键字进行属性代理。通过使用属性代理，代理类会负责处理对应属性 get 与 set 函数的调用。这一特性在您需要在其他对象间复用 getter/setter 逻辑时十分有用，同时也能让您可以轻松地对简单支持字段的功能进行扩展</p><p>举个例子，利用委托属性可以封装SharedPreference<br>将数据存储操作委托给代理类有几个好处<br>1.则精简了代码，方便了存储与读取调用<br>2.与SP进行了解耦，后续如果要替换存储库，只需要修改代理类即可   </p><p>调用如下:<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> Pref: PreferenceHolder() &#123;</span><br><span class="line">    <span class="keyword">var</span> isFirstInstall: <span class="built_in">Boolean</span> <span class="keyword">by</span> bindToPreferenceField(<span class="literal">false</span>)</span><br><span class="line">    <span class="keyword">var</span> time: <span class="built_in">Long</span>? <span class="keyword">by</span> bindToPreferenceFieldNullable()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>具体实现可见:<a href="https://juejin.cn/post/6857432013424001038" target="_blank" rel="noopener">SharedPreferences用Kotlin应该这样写</a></p><h2 id="带状态的LiveData"><a href="#带状态的LiveData" class="headerlink" title="带状态的LiveData"></a>带状态的LiveData</h2><p>目前我们在开发的过程中越来越多的使用MVVM模式与ViewModel<br>我们也常常用LiveData来标识网络请求状态<br>我们需要定义请求开始，请求成功，请求失败，三个LiveData    </p><p>这其实也是很冗余重复的代码，因此我们可以进行一定的封装，封装一个带状态的LiveData</p><p>定义如下：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typealias</span> StatefulLiveData&lt;T&gt; = LiveData&lt;RequestState&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">typealias</span> StatefulMutableLiveData&lt;T&gt; = MutableLiveData&lt;RequestState&lt;T&gt;&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> StatefulLiveData<span class="type">&lt;T&gt;</span>.<span class="title">observeState</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    owner: <span class="type">LifecycleOwner</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">init</span>: <span class="type">ResultBuilder</span>&lt;<span class="type">T</span>&gt;.() -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> result = ResultBuilder&lt;T&gt;().apply(<span class="keyword">init</span>)</span><br><span class="line"></span><br><span class="line">    observe(owner) &#123; state -&gt;</span><br><span class="line">        <span class="keyword">when</span> (state) &#123;</span><br><span class="line">            <span class="keyword">is</span> RequestState.Loading -&gt; result.onLading.invoke()</span><br><span class="line">            <span class="keyword">is</span> RequestState.Success -&gt; result.onSuccess(state.<span class="keyword">data</span>)</span><br><span class="line">            <span class="keyword">is</span> RequestState.Error -&gt; result.onError(state.error)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用如下<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> <span class="keyword">data</span> = StatefulMutableLiveData&lt;String&gt;()</span><br><span class="line">viewModel.<span class="keyword">data</span>.observeState(viewLifecycleOwner) &#123;</span><br><span class="line">            onLading = &#123;</span><br><span class="line">                <span class="comment">//loading</span></span><br><span class="line">            &#125;</span><br><span class="line">            onSuccess = &#123; <span class="keyword">data</span> -&gt;</span><br><span class="line">                <span class="comment">//success</span></span><br><span class="line">            &#125;</span><br><span class="line">            onError = &#123; exception -&gt;</span><br><span class="line">                <span class="comment">//error</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p><p>通过以上封装，可以比较优雅简洁的封装网络请求的loading,success,error状态，精简了代码，结构也比较清晰    </p><h2 id="DSL"><a href="#DSL" class="headerlink" title="DSL"></a>DSL</h2><p>DSL（domain specific language），即领域专用语言：专门解决某一特定问题的计算机语言，比如大家耳熟能详的 SQL 和正则表达式。<br>但是，如果为解决某一特定领域问题就创建一套独立的语言，开发成本和学习成本都很高，因此便有了内部 DSL 的概念。所谓内部 DSL，便是使用通用编程语言来构建 DSL。比如，本文提到的 Kotlin DSL，我们为 Kotlin DSL 做一个简单的定义：</p><p>“使用 Kotlin 语言开发的，解决特定领域问题，具备独特代码结构的 API 。”</p><p>举个例子，我们使用TabLayout时，如果要为他添加监听，需要实现以下3个方法<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onTabReselected</span><span class="params">(tab: <span class="type">TabLayout</span>.<span class="type">Tab</span>?)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onTabUnselected</span><span class="params">(tab: <span class="type">TabLayout</span>.<span class="type">Tab</span>?)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onTabSelected</span><span class="params">(tab: <span class="type">TabLayout</span>.<span class="type">Tab</span>?)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其实我们一般只会用到onTabSelected方法，其余两个一般是空实现<br>我们利用DSL对OnTabSelectedListener进行封装，即可避免写不必要的空实现代码   </p><p>具体实现如下：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">typealias</span> OnTabCallback = (tab: TabLayout.Tab?) -&gt; <span class="built_in">Unit</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OnTabSelectedListenerBuilder</span> : <span class="type">TabLayout.OnTabSelectedListener &#123;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> onTabReselectedCallback: OnTabCallback? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> onTabUnselectedCallback: OnTabCallback? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> onTabSelectedCallback: OnTabCallback? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onTabReselected</span><span class="params">(tab: <span class="type">TabLayout</span>.<span class="type">Tab</span>?)</span></span> =</span><br><span class="line">            onTabReselectedCallback?.invoke(tab) ?: <span class="built_in">Unit</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onTabUnselected</span><span class="params">(tab: <span class="type">TabLayout</span>.<span class="type">Tab</span>?)</span></span> =</span><br><span class="line">            onTabUnselectedCallback?.invoke(tab) ?: <span class="built_in">Unit</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onTabSelected</span><span class="params">(tab: <span class="type">TabLayout</span>.<span class="type">Tab</span>?)</span></span> =</span><br><span class="line">            onTabSelectedCallback?.invoke(tab) ?: <span class="built_in">Unit</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onTabReselected</span><span class="params">(callback: <span class="type">OnTabCallback</span>)</span></span> &#123;</span><br><span class="line">        onTabReselectedCallback = callback</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onTabUnselected</span><span class="params">(callback: <span class="type">OnTabCallback</span>)</span></span> &#123;</span><br><span class="line">        onTabUnselectedCallback = callback</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onTabSelected</span><span class="params">(callback: <span class="type">OnTabCallback</span>)</span></span> &#123;</span><br><span class="line">        onTabSelectedCallback = callback</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">registerOnTabSelectedListener</span><span class="params">(function: <span class="type">OnTabSelectedListenerBuilder</span>.() -&gt; <span class="type">Unit</span>)</span></span> =</span><br><span class="line">        OnTabSelectedListenerBuilder().also(function)</span><br></pre></td></tr></table></figure></p><p>定义DSL的一般步骤：    </p><ul><li>1.先定义一个类去实现回调接口，并且实现它的回调方法。</li><li>2.观察回调方法的参数，提取成一个函数类型（function type)，并且按照需要使用类型别名给函数类型起一个别称，并且用私有修饰。</li><li>3.在类里面声明一些可空的函数类型的可变（var）私有成员变量，并且在回调函数中拿到对应的变量实现它的invoke函数，传入对应的参数。</li><li>4.在类中定义一些跟回调接口一样名字，但是参数是对应的函数类型的函数，并且将函数类型赋值给当前类的对应的成员变量。</li><li>5.定义一个成员函数，参数是一个带有我们定好那个类的接受者对象并且返回Unit的Lambda表达式，在函数里创建相应的对象，并且使用also函数把Lambda表达式传进去。</li></ul><p>调用如下：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tabLayout.addOnTabSelectedListener(registerOnTabSelectedListener &#123;</span><br><span class="line">    onTabSelected &#123; vpOrder.currentItem = it?.position ?: <span class="number">0</span> &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>如上，就可以避免写一些不必要的空实现代码了  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;众所周知，kotlin是google力推的用以取代java的android开发语言&lt;br&gt;kotlin使用起来比较方便，同时有许多语法糖&lt;b
      
    
    </summary>
    
    
      <category term="kotlin" scheme="http://ShenZhen2017.github.io/tags/kotlin/"/>
    
  </entry>
  
  <entry>
    <title>ARTS打卡13</title>
    <link href="http://ShenZhen2017.github.io/blog/2021/01/arts-way-thirteen.html"/>
    <id>http://ShenZhen2017.github.io/blog/2021/01/arts-way-thirteen.html</id>
    <published>2021-01-15T14:24:42.000Z</published>
    <updated>2021-01-17T14:00:05.767Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><blockquote><p><a href="https://leetcode-cn.com/contest/weekly-contest-224/problems/number-of-rectangles-that-can-form-the-largest-square/" target="_blank" rel="noopener">5653. 可以形成最大正方形的矩形数目</a><br>给你一个数组 rectangles ，其中 rectangles[i] = [li, wi] 表示第 i 个矩形的长度为 li 、宽度为 wi 。<br>如果存在 k 同时满足 k &lt;= li 和 k &lt;= wi ，就可以将第 i 个矩形切成边长为 k 的正方形。例如，矩形 [4,6] 可以切成边长最大为 4 的正方形。<br>设 maxLen 为可以从矩形数组 rectangles 切分得到的 最大正方形 的边长。<br>返回可以切出边长为 maxLen 的正方形的矩形 数目 。</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">countGoodRectangles</span><span class="params">(rectangles: <span class="type">Array</span>&lt;<span class="type">IntArray</span>&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> map = hashMapOf&lt;<span class="built_in">Int</span>,<span class="built_in">Int</span>&gt;()</span><br><span class="line">        <span class="keyword">var</span> result = <span class="number">0</span></span><br><span class="line">        rectangles.forEach &#123;</span><br><span class="line">            <span class="keyword">val</span> minVaule = minOf(it[<span class="number">0</span>],it[<span class="number">1</span>])</span><br><span class="line">            map[minVaule] = map.getOrDefault(minVaule,<span class="number">0</span>)+<span class="number">1</span></span><br><span class="line">            result = maxOf(result,minVaule)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map.getOrDefault(result,<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p><a href="https://typealias.com/guides/getting-real-with-reified-type-parameters/" target="_blank" rel="noopener">Getting Real with Kotlin’s Reified Type Parameters</a><br>本文主要讲述了利用kotin Reified的一样实用技巧</p><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><h3 id="cpu类型"><a href="#cpu类型" class="headerlink" title="cpu类型"></a>cpu类型</h3><p>Android 设备的CPU类型(通常称为”ABIs”)<br>1.armeabiv-v7a: 第7代及以上的 ARM 处理器。2011年15月以后的生产的大部分Android设备都使用它.<br>2.arm64-v8a: 第8代、64位ARM处理器，很少设备，三星 Galaxy S6是其中之一。<br>3.armeabi: 第5代、第6代的ARM处理器，早期的手机用的比较多。<br>4.x86: 平板、模拟器用得比较多。<br>5.x86_64: 64位的平板。</p><p>详情可见：<a href="https://www.cnblogs.com/janehlp/p/7473240.html" target="_blank" rel="noopener">https://www.cnblogs.com/janehlp/p/7473240.html</a></p><h3 id="kotlin可见性"><a href="#kotlin可见性" class="headerlink" title="kotlin可见性"></a>kotlin可见性</h3><p>如果你声明为 internal，它会在相同模块内随处可见</p><h3 id="refied"><a href="#refied" class="headerlink" title="refied"></a>refied</h3><p>reified：使抽象的东西更加具体或真实，非常推荐 Android 开发使用这个关键字。</p><p>大部分的文章讲解 reified 的使用，都有提到这个点，比如我们定义实现一个扩展函数启动 Activity，一般都需要传 Class<t> 参数：</t></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Function</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Activity&gt;</span> Activity.<span class="title">startActivity</span><span class="params">(context: <span class="type">Context</span>, clazz: <span class="type">Class</span>&lt;<span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">    startActivity(Intent(context, clazz))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Caller</span></span><br><span class="line">startActivity(context, NewActivity::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br></pre></td></tr></table></figure><h4 id="使用refied后"><a href="#使用refied后" class="headerlink" title="使用refied后"></a>使用refied后</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Function</span></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T : Activity&gt;</span> Activity.<span class="title">startActivity</span><span class="params">(context: <span class="type">Context</span>)</span></span> &#123;</span><br><span class="line">    startActivity(Intent(context, T::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>))</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Caller</span></span><br><span class="line">startActivity&lt;NewActivity&gt;(context)</span><br></pre></td></tr></table></figure><p><a href="https://juejin.cn/post/6844903833596854279#heading-1" target="_blank" rel="noopener">推荐使用 Kotlin 关键字 Reified</a><br><a href="https://zhooker.github.io/2018/08/23/%E8%AF%91-Kotlin%E7%9A%84Reified%E5%AE%9E%E5%8C%96%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0/" target="_blank" rel="noopener">[译]Kotlin的Reified实化类型参数</a></p><h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p><a href="https://shenzhen2017.github.io/blog/2021/01/kotlin-tips-sum.html">kotlin实用技巧总结</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Algorithm&quot;&gt;&lt;a href=&quot;#Algorithm&quot; class=&quot;headerlink&quot; title=&quot;Algorithm&quot;&gt;&lt;/a&gt;Algorithm&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.
      
    
    </summary>
    
    
      <category term="ARTS" scheme="http://ShenZhen2017.github.io/tags/ARTS/"/>
    
  </entry>
  
  <entry>
    <title>ARTS打卡12</title>
    <link href="http://ShenZhen2017.github.io/blog/2021/01/arts-way-twelive.html"/>
    <id>http://ShenZhen2017.github.io/blog/2021/01/arts-way-twelive.html</id>
    <published>2021-01-06T12:29:46.000Z</published>
    <updated>2021-01-10T12:03:14.760Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p>本周略</p><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p><a href="https://medium.com/androiddevelopers/simplifying-apis-with-coroutines-and-flow-a6fb65338765" target="_blank" rel="noopener">https://medium.com/androiddevelopers/simplifying-apis-with-coroutines-and-flow-a6fb65338765</a><br>本文主要讲述了通过协程和Flow来简化api的一些操作</p><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><h3 id="回调转化成协程"><a href="#回调转化成协程" class="headerlink" title="回调转化成协程"></a>回调转化成协程</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Extension function on FusedLocationProviderClient, returns last known location</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> FusedLocationProviderClient.<span class="title">awaitLastLocation</span><span class="params">()</span></span>: Location =</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create a new coroutine that can be cancelled</span></span><br><span class="line">  suspendCancellableCoroutine&lt;Location&gt; &#123; continuation -&gt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add listeners that will resume the execution of this coroutine</span></span><br><span class="line">    lastLocation.addOnSuccessListener &#123; location -&gt;</span><br><span class="line">      <span class="comment">// Resume coroutine and return location</span></span><br><span class="line">      continuation.resume(location)</span><br><span class="line">    &#125;.addOnFailureListener &#123; e -&gt;</span><br><span class="line">      <span class="comment">// Resume the coroutine by throwing an exception</span></span><br><span class="line">      continuation.resumeWithException(e)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// End of the suspendCancellableCoroutine block. This suspends the</span></span><br><span class="line">    <span class="comment">// coroutine until one of the callbacks calls the continuation parameter.</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="layoutGoneMargin的使用"><a href="#layoutGoneMargin的使用" class="headerlink" title="layoutGoneMargin的使用"></a>layoutGoneMargin的使用</h3><p>有这样一个需求。当某个控件A存在时，下面的控件B距离A需要一个margin_top=20dp。 当A消失时(gone掉了)，此时margin_top=0dp。 可以用代码去设置这个间距。但是麻烦。。。So， layout_goneMarginTop就有用了。。。</p><p>layout_goneMarginTop - 意思是如果依赖的顶部控件隐藏了，当前我们的间距又应该是怎样的。此时margin_top就不再生效了。反之，也一样<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--工商注册地--&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">android.support.constraint.ConstraintLayout</span></span></span><br><span class="line"><span class="tag">               <span class="attr">android:id</span>=<span class="string">"@+id/fp_location"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">android:layout_marginTop</span>=<span class="string">"20dp"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">android:background</span>=<span class="string">"@color/white"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">android:paddingStart</span>=<span class="string">"20dp"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">android:paddingEnd</span>=<span class="string">"20dp"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">app:layout_constraintTop_toBottomOf</span>=<span class="string">"@+id/fp_numbers"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">app:layout_goneMarginTop</span>=<span class="string">"0dp"</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="BottomSheetDialog圆角问题"><a href="#BottomSheetDialog圆角问题" class="headerlink" title="BottomSheetDialog圆角问题"></a>BottomSheetDialog圆角问题</h3><p>有时候自定义样式，需要在BottomSheetDialog顶部添加圆角<br>需要通过自定义主题的方式实现<br>详情可见：<a href="https://stackoverflow.com/questions/43852562/round-corner-for-bottomsheetdialogfragment" target="_blank" rel="noopener">https://stackoverflow.com/questions/43852562/round-corner-for-bottomsheetdialogfragment</a></p><h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p>本周略</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Algorithm&quot;&gt;&lt;a href=&quot;#Algorithm&quot; class=&quot;headerlink&quot; title=&quot;Algorithm&quot;&gt;&lt;/a&gt;Algorithm&lt;/h2&gt;&lt;p&gt;本周略&lt;/p&gt;
&lt;h2 id=&quot;Review&quot;&gt;&lt;a href=&quot;#Review&quot; 
      
    
    </summary>
    
    
      <category term="ARTS" scheme="http://ShenZhen2017.github.io/tags/ARTS/"/>
    
  </entry>
  
  <entry>
    <title>ARTS打卡11</title>
    <link href="http://ShenZhen2017.github.io/blog/2020/12/arts-way-eleven.html"/>
    <id>http://ShenZhen2017.github.io/blog/2020/12/arts-way-eleven.html</id>
    <published>2020-12-29T00:52:04.000Z</published>
    <updated>2021-01-03T14:31:55.829Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><blockquote><ol start="5641"><li>卡车上的最大单元数<br>请你将一些箱子装在 一辆卡车 上。给你一个二维数组 boxTypes ，其中 boxTypes[i] = [numberOfBoxesi, numberOfUnitsPerBoxi] ：<br>numberOfBoxesi 是类型 i 的箱子的数量。<br>numberOfUnitsPerBoxi 是类型 i 每个箱子可以装载的单元数量。<br>整数 truckSize 表示卡车上可以装载 箱子 的 最大数量 。只要箱子数量不超过 truckSize ，你就可以选择任意箱子装到卡车上。<br>返回卡车可以装载 单元 的 最大 总数。</li></ol></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">maximumUnits</span><span class="params">(boxTypes: <span class="type">Array</span>&lt;<span class="type">IntArray</span>&gt;, truckSize: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        boxTypes.sortByDescending &#123;</span><br><span class="line">            it[<span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> maxSize = truckSize</span><br><span class="line">        <span class="keyword">var</span> result = <span class="number">0</span></span><br><span class="line">        boxTypes.forEach &#123;</span><br><span class="line">            <span class="keyword">var</span> item = it[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">while</span> (item&gt;<span class="number">0</span> &amp;&amp; maxSize&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                item--</span><br><span class="line">                maxSize--</span><br><span class="line">                result+=it[<span class="number">1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (maxSize&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> result</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p><a href="https://medium.com/better-programming/a-new-way-to-pass-data-between-fragments-a5d32acc34e7" target="_blank" rel="noopener">A New Way to Pass Data Between Fragments</a><br>在Fragment中间传递数据的一种新方法<br>主要通过setFragmentResultListener实现<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewCreated</span><span class="params">(view: <span class="type">View</span>, savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onViewCreated(view, savedInstanceState)</span><br><span class="line">    <span class="comment">// Use the Kotlin extension in the fragment-ktx artifact</span></span><br><span class="line">    setFragmentResultListener(<span class="string">"requestKey"</span>) &#123; key, bundle -&gt;</span><br><span class="line">        <span class="keyword">val</span> result = bundle.getString(<span class="string">"name"</span>)</span><br><span class="line">        <span class="comment">// Do something with the result...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><h3 id="写作技巧总结"><a href="#写作技巧总结" class="headerlink" title="写作技巧总结"></a>写作技巧总结</h3><p>1、写文档是第一步，因为你告诉别人怎么去理解你写的东西，所以如果你想开始写作，最简单就是从写文档开始，把你的东西介绍明白了，就是一个好的开始。</p><p>2、写源码分析是第二步，那就是学习和分享如何去理解别人的东西，这个过程可以让自己在学习的过程中有所总结，并且介绍别人的内容就是一种抽象能力的进步。</p><p>3、写问题解决和应用思想是第三步，告诉别人如何去理解别人的思想，这就需要作者对要介绍的内容有自己的理解，才能够把内容变成更好理解的接地气的文字内容。</p><p>其实介绍了这么多写作内容，就是想告诉大家:“大前端是一种思想，就是让你已有的能力可以运用更广泛，而写作是帮助你把能力抽象化的一个过程。”</p><h3 id="lineSpaceExtra在部分低版本机型最后一行会有空行的解决办法"><a href="#lineSpaceExtra在部分低版本机型最后一行会有空行的解决办法" class="headerlink" title="lineSpaceExtra在部分低版本机型最后一行会有空行的解决办法"></a>lineSpaceExtra在部分低版本机型最后一行会有空行的解决办法</h3><p>因为lineHeight在许多机型上有适配问题，因此我们常常用lineSpaceExtra替代<br>但是lineSpaceExtra在部分低版本手机上也会有问题<br>详情可见：<a href="https://blog.csdn.net/etwge/article/details/72818859" target="_blank" rel="noopener">https://blog.csdn.net/etwge/article/details/72818859</a></p><h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p><a href="https://shenzhen2017.github.io/blog/2020/12/hand-lua-curountine.html">手写lua协程</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Algorithm&quot;&gt;&lt;a href=&quot;#Algorithm&quot; class=&quot;headerlink&quot; title=&quot;Algorithm&quot;&gt;&lt;/a&gt;Algorithm&lt;/h2&gt;&lt;blockquote&gt;
&lt;ol start=&quot;5641&quot;&gt;
&lt;li&gt;卡车上的最大单元数&lt;
      
    
    </summary>
    
    
      <category term="ARTS" scheme="http://ShenZhen2017.github.io/tags/ARTS/"/>
    
  </entry>
  
  <entry>
    <title>【手写协程】 实现kotlin版yield与resume</title>
    <link href="http://ShenZhen2017.github.io/blog/2020/12/hand-lua-curountine.html"/>
    <id>http://ShenZhen2017.github.io/blog/2020/12/hand-lua-curountine.html</id>
    <published>2020-12-27T14:34:36.000Z</published>
    <updated>2021-01-03T16:12:07.555Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>yield与resume是一种常见的协程实现，例如在Lua语言中的协程就是这样实现的<br>但是在kotlin中并没有这种语法，而是直接的launch<br>本文主要通过手写实现kotlin版的yield与resume<br>有助于读者更加深入地理解协程挂起与恢复的原理   </p><h2 id="Lua协程是怎么使用的？"><a href="#Lua协程是怎么使用的？" class="headerlink" title="Lua协程是怎么使用的？"></a>Lua协程是怎么使用的？</h2><p>1.coroutine.create()    创建 coroutine，返回 coroutine， 参数是一个函数，当和 resume 配合使用的时候就唤醒函数调用<br>2.coroutine.resume()    重启 coroutine(重启时不用再传参数)，和 create 配合使用<br>3.coroutine.yield()    挂起 coroutine，将 coroutine 设置为挂起状态，这个和 resume 配合使用能有很多有用的效果(返回参数)   </p><h2 id="我们要达成的效果"><a href="#我们要达成的效果" class="headerlink" title="我们要达成的效果"></a>我们要达成的效果</h2><p>我们将利用kotlin协程api,实现Lua协程效果，并实现一个生产者消费者的demo<br>最后调用如下：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> producer = Coroutine.create&lt;<span class="built_in">Unit</span>, <span class="built_in">Int</span>&gt;(Dispatcher()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span>..<span class="number">3</span>) &#123;</span><br><span class="line">            log(<span class="string">"send"</span>, i)</span><br><span class="line">            yield(i)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="number">200</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> consumer = Coroutine.create&lt;<span class="built_in">Int</span>, <span class="built_in">Unit</span>&gt;(Dispatcher()) &#123; param: <span class="built_in">Int</span> -&gt;</span><br><span class="line">        log(<span class="string">"start"</span>, param)</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span>..<span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">val</span> value = yield(<span class="built_in">Unit</span>)</span><br><span class="line">            log(<span class="string">"receive"</span>, value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (producer.isActive &amp;&amp; consumer.isActive)&#123;</span><br><span class="line">        <span class="keyword">val</span> result = producer.resume(<span class="built_in">Unit</span>)</span><br><span class="line">        consumer.resume(result)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如上所示，为了实现如上效果，我们需要实现<br>1.线程调度器<code>Dispatcher</code><br>2.Coroutine.create方法<br>3.协程内调用yield挂起方法<br>4.isActive状态判断方法<br>5.resume恢复方法   </p><h2 id="1-首先看看create方法"><a href="#1-首先看看create方法" class="headerlink" title="1.首先看看create方法"></a>1.首先看看create方法</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;P, R&gt;</span> <span class="title">create</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            context: <span class="type">CoroutineContext</span> = EmptyCoroutineContext,</span></span></span><br><span class="line"><span class="function"><span class="params">            block: <span class="type">suspend</span> <span class="type">Coroutine</span>&lt;<span class="type">P</span>,R&gt;.CoroutineBody.(P)</span></span> -&gt; R</span><br><span class="line">        ): Coroutine&lt;P, R&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> Coroutine(context, block)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> body = CoroutineBody()</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> status: AtomicReference&lt;Status&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> isActive: <span class="built_in">Boolean</span></span><br><span class="line">    <span class="keyword">get</span>() = status.<span class="keyword">get</span>() != Status.Dead</span><br><span class="line"></span><br><span class="line"><span class="keyword">init</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> coroutineBlock: <span class="keyword">suspend</span> CoroutineBody.() -&gt; R = &#123; block(parameter!!) &#125;</span><br><span class="line">    <span class="keyword">val</span> start = coroutineBlock.createCoroutine(body, <span class="keyword">this</span>)</span><br><span class="line">    status = AtomicReference(Status.Created(start))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建时主要做了以下工作<br>1.创建协程体并初始化<br>2.初始化协程状态<br>3.添加协程isActive方法     </p><h2 id="2-协程的几种状态"><a href="#2-协程的几种状态" class="headerlink" title="2.协程的几种状态"></a>2.协程的几种状态</h2><p>通过密封类定义了如下几种状态</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">Status</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Created</span></span>(<span class="keyword">val</span> continuation: Continuation&lt;<span class="built_in">Unit</span>&gt;): Status()</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Yielded</span>&lt;<span class="type">P</span>&gt;</span>(<span class="keyword">val</span> continuation: Continuation&lt;P&gt;): Status()</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Resumed</span>&lt;<span class="type">R</span>&gt;</span>(<span class="keyword">val</span> continuation: Continuation&lt;R&gt;): Status()</span><br><span class="line">    <span class="keyword">object</span> Dead: Status()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以注意到每个状态内都有一个Continuation接口，可以获取到协程上下文  </p><h2 id="3-resume实现"><a href="#3-resume实现" class="headerlink" title="3.resume实现"></a>3.resume实现</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">resume</span><span class="params">(value: <span class="type">P</span>)</span></span>: R = suspendCoroutine &#123; continuation -&gt;</span><br><span class="line">        <span class="keyword">val</span> previousStatus = status.getAndUpdate &#123;</span><br><span class="line">            <span class="keyword">when</span>(it) &#123;</span><br><span class="line">                <span class="keyword">is</span> Status.Created -&gt; &#123;</span><br><span class="line">                    body.parameter = value</span><br><span class="line">                    Status.Resumed(continuation)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">is</span> Status.Yielded&lt;*&gt; -&gt; &#123;</span><br><span class="line">                    Status.Resumed(continuation)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">is</span> Status.Resumed&lt;*&gt; -&gt; <span class="keyword">throw</span> IllegalStateException(<span class="string">"Already resumed!"</span>)</span><br><span class="line">                Status.Dead -&gt; <span class="keyword">throw</span> IllegalStateException(<span class="string">"Already dead!"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">when</span>(previousStatus)&#123;</span><br><span class="line">            <span class="keyword">is</span> Status.Created -&gt; previousStatus.continuation.resume(<span class="built_in">Unit</span>)</span><br><span class="line">            <span class="keyword">is</span> Status.Yielded&lt;*&gt; -&gt; (previousStatus <span class="keyword">as</span> Status.Yielded&lt;P&gt;).continuation.resume(value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>协程主要是通过状态机实现的，挂起与恢复就是状态的流转<br>当我们resume时，首先判断协程的state并切换<br>同时如果state是create或Yielded,则恢复上一个挂起点   </p><h3 id="AtomicReference"><a href="#AtomicReference" class="headerlink" title="AtomicReference"></a>AtomicReference</h3><p>status是AtomicReference类型的<br>AtomicReference类提供了一个可以原子读写的对象引用变量。 原子意味着尝试更改相同AtomicReference的多个线程（例如，使用比较和交换操作）不会使AtomicReference最终达到不一致的状态。 AtomicReference甚至有一个先进的compareAndSet（）方法，它可以将引用与预期值（引用）进行比较，如果它们相等，则在AtomicReference对象内设置一个新的引用。</p><h2 id="4-yield实现"><a href="#4-yield实现" class="headerlink" title="4.yield实现"></a>4.yield实现</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">CoroutineBody</span> </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> parameter: P? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">yield</span><span class="params">(value: <span class="type">R</span>)</span></span>: P = suspendCoroutine &#123; continuation -&gt;</span><br><span class="line">            <span class="keyword">val</span> previousStatus = status.getAndUpdate &#123;</span><br><span class="line">                <span class="keyword">when</span>(it) &#123;</span><br><span class="line">                    <span class="keyword">is</span> Status.Created -&gt; <span class="keyword">throw</span> IllegalStateException(<span class="string">"Never started!"</span>)</span><br><span class="line">                    <span class="keyword">is</span> Status.Yielded&lt;*&gt; -&gt; <span class="keyword">throw</span> IllegalStateException(<span class="string">"Already yielded!"</span>)</span><br><span class="line">                    <span class="keyword">is</span> Status.Resumed&lt;*&gt; -&gt; Status.Yielded(continuation)</span><br><span class="line">                    Status.Dead -&gt; <span class="keyword">throw</span> IllegalStateException(<span class="string">"Already dead!"</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            (previousStatus <span class="keyword">as</span>? Status.Resumed&lt;R&gt;)?.continuation?.resume(value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>yield方法同样是状态的流转<br>切换状态后，如果之前的状态是resume，则恢复上一个挂起点   </p><h2 id="5-拦截器切换线程"><a href="#5-拦截器切换线程" class="headerlink" title="5.拦截器切换线程"></a>5.拦截器切换线程</h2><p>我们可以利用协程拦截器切换线程，这样就可以在任意线程调用我们写的yeild与resume了    </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dispatcher</span>: <span class="type">ContinuationInterceptor &#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> key = ContinuationInterceptor</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> executor = Executors.newSingleThreadExecutor()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">interceptContinuation</span><span class="params">(continuation: <span class="type">Continuation</span>&lt;<span class="type">T</span>&gt;)</span></span>: Continuation&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> DispatcherContinuation(continuation, executor)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DispatcherContinuation</span>&lt;<span class="type">T</span>&gt;</span>(<span class="keyword">val</span> continuation: Continuation&lt;T&gt;, <span class="keyword">val</span> executor: Executor): Continuation&lt;T&gt; <span class="keyword">by</span> continuation &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">        executor.execute &#123;</span><br><span class="line">            continuation.resumeWith(result)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加拦截器后，协程会在我们创建的线程池中运行  </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="运行效果"><a href="#运行效果" class="headerlink" title="运行效果"></a>运行效果</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">00<span class="selector-pseudo">:01</span><span class="selector-pseudo">:41</span><span class="selector-pseudo">:906</span> <span class="selector-attr">[pool-1-thread-1]</span> <span class="selector-tag">send</span> 0</span><br><span class="line">00<span class="selector-pseudo">:01</span><span class="selector-pseudo">:41</span><span class="selector-pseudo">:948</span> <span class="selector-attr">[pool-2-thread-1]</span> <span class="selector-tag">start</span> 0</span><br><span class="line">00<span class="selector-pseudo">:01</span><span class="selector-pseudo">:41</span><span class="selector-pseudo">:948</span> <span class="selector-attr">[pool-1-thread-1]</span> <span class="selector-tag">send</span> 1</span><br><span class="line">00<span class="selector-pseudo">:01</span><span class="selector-pseudo">:41</span><span class="selector-pseudo">:948</span> <span class="selector-attr">[pool-2-thread-1]</span> <span class="selector-tag">receive</span> 1</span><br><span class="line">00<span class="selector-pseudo">:01</span><span class="selector-pseudo">:41</span><span class="selector-pseudo">:948</span> <span class="selector-attr">[pool-1-thread-1]</span> <span class="selector-tag">send</span> 2</span><br><span class="line">00<span class="selector-pseudo">:01</span><span class="selector-pseudo">:41</span><span class="selector-pseudo">:949</span> <span class="selector-attr">[pool-2-thread-1]</span> <span class="selector-tag">receive</span> 2</span><br><span class="line">00<span class="selector-pseudo">:01</span><span class="selector-pseudo">:41</span><span class="selector-pseudo">:949</span> <span class="selector-attr">[pool-1-thread-1]</span> <span class="selector-tag">send</span> 3</span><br><span class="line">00<span class="selector-pseudo">:01</span><span class="selector-pseudo">:41</span><span class="selector-pseudo">:949</span> <span class="selector-attr">[pool-2-thread-1]</span> <span class="selector-tag">receive</span> 3</span><br><span class="line">00<span class="selector-pseudo">:01</span><span class="selector-pseudo">:41</span><span class="selector-pseudo">:950</span> <span class="selector-attr">[pool-2-thread-1]</span> <span class="selector-tag">receive</span> 200</span><br></pre></td></tr></table></figure><p>最后调用效果如上，实现了自己手写一个简单的resume与yield，并实现了生产者与消费者模式<br>相信读完本文，读者可以更好的理解协程的挂起与恢复是怎样实现的    </p><h3 id="本文所有相关代码"><a href="#本文所有相关代码" class="headerlink" title="本文所有相关代码"></a>本文所有相关代码</h3><p><a href="https://github.com/shenzhen2017/HandWritingContinuation/blob/main/app/src/main/java/com/zj/handwritingcontinuation/lua/Coroutine.kt" target="_blank" rel="noopener">本文所有相关代码</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;yield与resume是一种常见的协程实现，例如在Lua语言中的协程就是这样实现的&lt;br&gt;但是在kotlin中并没有这种语法，而是直接的l
      
    
    </summary>
    
    
      <category term="kotlin" scheme="http://ShenZhen2017.github.io/tags/kotlin/"/>
    
  </entry>
  
  <entry>
    <title>ARTS打卡10</title>
    <link href="http://ShenZhen2017.github.io/blog/2020/12/arts-way-ten.html"/>
    <id>http://ShenZhen2017.github.io/blog/2020/12/arts-way-ten.html</id>
    <published>2020-12-26T13:02:19.000Z</published>
    <updated>2020-12-27T12:42:54.879Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><blockquote><p><a href="https://leetcode-cn.com/contest/weekly-contest-221/problems/determine-if-string-halves-are-alike/" target="_blank" rel="noopener">5637. 判断字符串的两半是否相似</a><br>给你一个偶数长度的字符串 s 。将其拆分成长度相同的两半，前一半为 a ，后一半为 b 。<br>两个字符串 相似 的前提是它们都含有相同数目的元音（’a’，’e’，’i’，’o’，’u’，’A’，’E’，’I’，’O’，’U’）。注意，s 可能同时含有大写和小写字母。<br>如果 a 和 b 相似，返回 true ；否则，返回 false 。</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">halvesAreAlike</span><span class="params">(s: <span class="type">String</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> yuanYinCount(s.substring(<span class="number">0</span>,s.length/<span class="number">2</span>)) == yuanYinCount(s.substring(s.length/<span class="number">2</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">yuanYinCount</span><span class="params">(s:<span class="type">String</span>)</span></span>:<span class="built_in">Int</span>&#123;</span><br><span class="line">        <span class="keyword">val</span> list = mutableListOf&lt;<span class="built_in">Char</span>&gt;(<span class="string">'a'</span>,<span class="string">'e'</span>,<span class="string">'i'</span>,<span class="string">'o'</span>,<span class="string">'u'</span>,<span class="string">'A'</span>,<span class="string">'E'</span>,<span class="string">'I'</span>,<span class="string">'O'</span>,<span class="string">'U'</span>)</span><br><span class="line">        <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">        s.forEach &#123;</span><br><span class="line">            <span class="keyword">if</span> (list.contains(it))&#123;</span><br><span class="line">                count++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p><a href="https://medium.com/@gilgoldzweig/how-to-perfect-android-animations-using-motionlayout-286cfa0f4f13" target="_blank" rel="noopener">https://medium.com/@gilgoldzweig/how-to-perfect-android-animations-using-motionlayout-286cfa0f4f13</a><br>本文主要是讲解了一些MotionLayout的例子与实例</p><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><h3 id="Lottie预览"><a href="#Lottie预览" class="headerlink" title="Lottie预览"></a>Lottie预览</h3><p>lottie图是Airbnb开源的一种动画，不能直观的察看效果，如果出现问题，很难判定到底是资源问题，还是代码问题，因此需要有一个简单的方法来预览lottie图效果<br>我们可以在本机上，使用 Python 搭建一个最简单的 HTTP 服务器。在本地动画 ZIP 包文件的文件夹下，执行下面的命令。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m SimpleHttpServer <span class="number">8099</span></span><br></pre></td></tr></table></figure></p><p>该命令会在本机上搭建一个 HTTP 服务器，监听 8099 端口<br>然后再用lottie官方app打开相应地址即可预览.</p><p>详情可见：<a href="https://toutiao.io/posts/ml787h/preview" target="_blank" rel="noopener">https://toutiao.io/posts/ml787h/preview</a></p><h3 id="9图四条黑边的意义"><a href="#9图四条黑边的意义" class="headerlink" title=".9图四条黑边的意义"></a>.9图四条黑边的意义</h3><p>顶部：在水平拉伸的时候，保持其他位置不动，只在这个点的区域做无限的延伸</p><p>左边：在竖直拉伸的时候，保持其他位置不动，只在这个点的区域做无限的延伸</p><p>底部：在水平拉伸的时候，指定图片里的内容显示的区域</p><p>右边：在竖直拉伸的时候，指定图片里的内容显示的区域</p><p>详情可见:<a href="https://blog.csdn.net/sunbinkang/article/details/77331718" target="_blank" rel="noopener">https://blog.csdn.net/sunbinkang/article/details/77331718</a></p><h3 id="kotlin-fold与reduce使用"><a href="#kotlin-fold与reduce使用" class="headerlink" title="kotlin fold与reduce使用"></a>kotlin fold与reduce使用</h3><h4 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> index: Array&lt;<span class="built_in">Int</span>&gt; = arrayOf(<span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">10</span>, <span class="number">3</span>, <span class="number">11</span>, <span class="number">5</span>, <span class="number">12</span>)</span><br><span class="line">  <span class="keyword">val</span> index2: Array&lt;<span class="built_in">Int</span>&gt; = arrayOf(<span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * reduce函数：累加函数，第一个参数是用来叠加的返回值，第二个参数是本次循环中列表的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">        println(<span class="string">"使用 reduce  求总和"</span>) <span class="comment">//使用 reduce  求总和</span></span><br><span class="line">        println(index.reduce &#123; acc, i -&gt; acc + i &#125;)</span><br><span class="line">        println(<span class="string">"使用 reduce  求积"</span>) <span class="comment">//使用 reduce  求积</span></span><br><span class="line">        println(index2.reduce &#123; acc, i -&gt; acc * i &#125;)  <span class="comment">//acc是累加的返回值，i是当前遍历列表中的值</span></span><br><span class="line"> </span><br><span class="line">    使用 reduce  求总和</span><br><span class="line">    System.<span class="keyword">out</span>: <span class="number">86</span></span><br><span class="line">    使用 reduce  求积</span><br><span class="line">    <span class="number">60</span></span><br></pre></td></tr></table></figure><h4 id="fold"><a href="#fold" class="headerlink" title="fold"></a>fold</h4><p>In kotlin, “fold” is same in Javascript’s reduce. “fold” has initial value</p><p>“reduce” in kotlin, you don’t give initial value<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> colors = listOf(<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>, <span class="string">"black"</span>)</span><br><span class="line"></span><br><span class="line">    println(colors.reduce &#123;</span><br><span class="line">        acc, curr -&gt; <span class="string">"<span class="variable">$acc</span>, <span class="variable">$curr</span>"</span></span><br><span class="line">    &#125;) <span class="comment">// red, blue, green, black</span></span><br><span class="line"></span><br><span class="line">    println(colors.map &#123;it.length&#125;.fold(<span class="number">0</span>) &#123;</span><br><span class="line">            acc, curr -&gt; acc + curr</span><br><span class="line">    &#125;) <span class="comment">// 17</span></span><br></pre></td></tr></table></figure></p><h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p>本周略</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Algorithm&quot;&gt;&lt;a href=&quot;#Algorithm&quot; class=&quot;headerlink&quot; title=&quot;Algorithm&quot;&gt;&lt;/a&gt;Algorithm&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.
      
    
    </summary>
    
    
      <category term="ARTS" scheme="http://ShenZhen2017.github.io/tags/ARTS/"/>
    
  </entry>
  
  <entry>
    <title>利用MotionLayout实现RecyclerView折叠展开动画</title>
    <link href="http://ShenZhen2017.github.io/blog/2020/12/motionlayout-recyclerview-animation.html"/>
    <id>http://ShenZhen2017.github.io/blog/2020/12/motionlayout-recyclerview-animation.html</id>
    <published>2020-12-20T03:53:32.000Z</published>
    <updated>2020-12-20T13:11:31.973Z</updated>
    
    <content type="html"><![CDATA[<p>RecyclerView的展开与折叠是一种常见的动画<br>主要有两种方式可以实现<br><strong>1.通过添加与移除元素</strong><br>notifyInsert,notifyRemoved，这种方式涉及到元素的加减，动画效果不太流畅<br><strong>2.通过给RecyclerView的item添加动画</strong><br>这种情况需要考虑一个item添加动画时，对其他的item的影响。而利用MotionLayout可以方便的实现这一点。    </p><p><strong>先来看看效果</strong><br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog9/p1.gif" alt><br>1.支持流畅的展开折叠<br>2.支持多类型item<br>3.支持只能同时展开一个    </p><p>下面来看下具体实现  </p><h2 id="1-引入MotionLayout库"><a href="#1-引入MotionLayout库" class="headerlink" title="1.引入MotionLayout库"></a>1.引入MotionLayout库</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">dependencies</span> &#123; <span class="attribute">implementation</span> <span class="string">'com.android.support.constraint:constraint-layout:2.0.0-beta2'</span> &#125;</span><br></pre></td></tr></table></figure><h2 id="2-在布局文件中使用"><a href="#2-在布局文件中使用" class="headerlink" title="2.在布局文件中使用"></a>2.在布局文件中使用</h2><p>MotionLayout 想要使用 MotionLayout，只需要在布局文件中作如下声明即可：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;androidx<span class="selector-class">.constraintlayout</span><span class="selector-class">.motion</span><span class="selector-class">.widget</span><span class="selector-class">.MotionLayout</span> xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    xmlns:app=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span><br><span class="line">    xmlns:tools=<span class="string">"http://schemas.android.com/tools"</span></span><br><span class="line">    android:id=<span class="string">"@+id/motionContainer"</span></span><br><span class="line">    android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">    android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">    android:<span class="attribute">background</span>=<span class="string">"@color/white"</span></span><br><span class="line">    app:layoutDescription=<span class="string">"@xml/motion_list_rv_item_scene"</span>&gt;</span><br><span class="line">.....</span><br><span class="line">&lt;/android<span class="selector-class">.support</span><span class="selector-class">.constraint</span><span class="selector-class">.motion</span>.MotionLayout&gt;</span><br></pre></td></tr></table></figure></p><p>由于 MotionLayout 作为 ConstraintLayout 的子类，那么就自然而然地可以像 ConstraintLayout 那样使用去“约束”子视图了，不过这可就有点“大材小用了”，MotionLayout 的用处可远不止这些。我们先来看看 MotionLayout 的构成：<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog9/p1.webp" alt></p><p>由上图可知，MotionLayout 可分为 <view> 和 <helper> 两个部分。<view> 部分可简单理解为一个 ConstraintLayout，至于 <helper> 其实就是我们的“动画层”了。MotionLayout 为我们提供了 layoutDescription 属性，我们需要为它传入一个 MotionScene 包裹的 XML 文件，想要实现动画交互，就必须通过这个“媒介”来连接。</helper></view></helper></view></p><h2 id="MotionScene"><a href="#MotionScene" class="headerlink" title="MotionScene"></a>MotionScene</h2><p>什么是 MotionScene？结合上图 MotionScene 主要由三部分组成：StateSet、ConstraintSet 和 Transition<br>实现RecyclerView展开折叠效果，主要用到了 ConstarintSet 和 Transition     </p><h3 id="首先来看看布局文件"><a href="#首先来看看布局文件" class="headerlink" title="首先来看看布局文件"></a>首先来看看布局文件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.motion.widget.MotionLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/motionContainer"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:background</span>=<span class="string">"@color/white"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layoutDescription</span>=<span class="string">"@xml/motion_list_rv_item_scene"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/box_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:orientation</span>=<span class="string">"vertical"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"86dp"</span>&gt;</span></span><br><span class="line">            ....</span><br><span class="line">            <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">View</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"100dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:background</span>=<span class="string">"@color/blue_magic"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">View</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/view2"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"1dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_below</span>=<span class="string">"@id/box_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">"#eaeaef"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.motion.widget.MotionLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>布局文件很简单，只不过你可能会注意到，我们对 LinearLayout并没有添加任何约束，原因在于：我们会在 MotionScene 中声明 ConstraintSet，里面将包含该 LinearLayout 的“运动”起始点和终点的约束信息。</p><p>当然你也可以在布局文件中对其加以约束，但 MotionScene 中对于控件约束的优先级会高于布局文件中的设定。这里我们通过 layoutDescription 来为 MotionLayout 设置它的 MotionScene 为 motion_list_rv_item_scene，接下来就让我们一睹 MotionScene 的芳容：</p><h3 id="动画文件"><a href="#动画文件" class="headerlink" title="动画文件"></a>动画文件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">MotionScene</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ConstraintSet</span> <span class="attr">android:id</span>=<span class="string">"@+id/start"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Constraint</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@id/box_content"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"0dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"86dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">"parent"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ConstraintSet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ConstraintSet</span> <span class="attr">android:id</span>=<span class="string">"@+id/end"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Constraint</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@id/box_content"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"0dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"186dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">"parent"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ConstraintSet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Transition</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:constraintSetEnd</span>=<span class="string">"@id/end"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:constraintSetStart</span>=<span class="string">"@+id/start"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:duration</span>=<span class="string">"500"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:motionInterpolator</span>=<span class="string">"easeInOut"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Transition</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">MotionScene</span>&gt;</span></span><br></pre></td></tr></table></figure><p>首先，可以发现我们定义了两个 <constraintset>   分别描述了RecyclerView中的item的动画起始位置以及结束位置的约束信息（仅包含少量必要信息，如：width、height、margin以及位置属性等）。<br>显而易见，itemView起始高度为86dp，结束高度186dp.    </constraintset></p><p><strong>那么问题来了，如何让它动起来呢？</strong><br>这就要依靠我们的 <transition> 元素了。     </transition></p><p>事实上，我们都知道，动画都是有开始位置和结束位置的，而 MotionLayout 正是利用这一客观事实，将首尾位置和动画过程分离，两个点位置和距离虽然是固定的，但是它们之间的 Path 是无限的，可以是“一马平川”，也可以是”蜿蜒曲折”的。</p><p>我们只需要为 Transition 设置起始位置和结束位置的 ConstraintSet 并设置动画时间即可，剩下的都交给 MotionLayout 自动去帮我们完成。</p><p>当然你也可以通过 onClick 点击事件来触发动画，绑定目标控件的 id 以及通过 clickAction 属性来设置点击事件的类型。</p><h3 id="OnClick有多种类型"><a href="#OnClick有多种类型" class="headerlink" title="OnClick有多种类型"></a>OnClick有多种类型</h3><ul><li>1.toggle，如果布局当前处于开始状态，请将动画效果切换为结束状态；否则，请将动画效果切换为开始状态。</li><li>2.transitionToStart,为从当前布局到 <transition> 元素的 motion::constraintSetStart 属性指定的布局添加动画效果。</transition></li><li>3.transitionToEnd,为从当前布局到 <transition> 元素的 motion:constraintSetEnd 属性指定的布局添加动画效果。</transition></li></ul><h2 id="只能同时展开一个item实现"><a href="#只能同时展开一个item实现" class="headerlink" title="只能同时展开一个item实现"></a>只能同时展开一个item实现</h2><p>因为我们需要在展开一个item时，折叠其他item,因此不在xml中指定点击事件，去adapter中指定<br>实现展开一个时折叠其他item 我们可以通过MotionLayout的progress判断当前是在start状态还是end状态。   </p><p>下面的代码主要有几点需要注意的<br>1.如果是start状态则展开，否则则折叠<br>2.利用payload局部刷新达到折叠其他itemView的效果。<br>3.在RecyclerView滚动时会复用，所以需要在onBindViewHolder时初始化item的状态，即progress，不然会发生错位现象</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBindViewHolder</span><span class="params">(holder: <span class="type">RecyclerView</span>.<span class="type">ViewHolder</span>, position: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (holder <span class="keyword">is</span> MotionViewHolder) &#123;</span><br><span class="line">            <span class="keyword">val</span> motionBox = holder.itemView.findViewById&lt;MotionLayout&gt;(R.id.motionContainer)</span><br><span class="line">            <span class="keyword">if</span> (expandList[position])&#123;</span><br><span class="line">                motionBox.progress = <span class="number">1.0f</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                motionBox.progress = <span class="number">0f</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            holder.itemView.setOnClickListener &#123;</span><br><span class="line">                expandList.fill(<span class="literal">false</span>)</span><br><span class="line">                <span class="keyword">if</span> (motionBox.progress == <span class="number">1.0f</span>) &#123;</span><br><span class="line">                    motionBox.transitionToStart()</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (motionBox.progress == <span class="number">0.0f</span>) &#123;</span><br><span class="line">                    motionBox.transitionToEnd()</span><br><span class="line">                    expandList[position] = <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until itemCount) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i != position) &#123;</span><br><span class="line">                        notifyItemChanged(i, <span class="string">"collapse"</span>)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBindViewHolder</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        holder: <span class="type">RecyclerView</span>.<span class="type">ViewHolder</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        position: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        payloads: <span class="type">MutableList</span>&lt;<span class="type">Any</span>&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (payloads.isNullOrEmpty()) &#123;</span><br><span class="line">            <span class="keyword">super</span>.onBindViewHolder(holder, position, payloads)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (holder <span class="keyword">is</span> MotionViewHolder) &#123;</span><br><span class="line">                <span class="keyword">val</span> motionBox = holder.itemView.findViewById&lt;MotionLayout&gt;(R.id.motionContainer)</span><br><span class="line">                motionBox.transitionToStart()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过以上步骤，即利用MotionLayout比较简单的实现了RecyclerView的item展开折叠效果<br>1.支持流畅的展开折叠<br>2.支持多类型item<br>3.支持只能同时展开一个    </p><p>MotionLayout还有很多更强大的功能，比如与AppBarLayout联动，与Lottie联动，实现复杂动画等。<br>读者如有兴趣可阅读下方的参考链接，及本文的所有代码</p><h3 id="本文的所有相关代码"><a href="#本文的所有相关代码" class="headerlink" title="本文的所有相关代码"></a>本文的所有相关代码</h3><p><a href="https://github.com/shenzhen2017/MotionLayoutRecyclerView" target="_blank" rel="noopener">MotionLayoutRecyclerView实现</a></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://juejin.cn/post/6844903918598635534" target="_blank" rel="noopener">MotionLayout：打开动画新世界大门 (part I)</a><br><a href="https://juejin.cn/post/6854573206653812743" target="_blank" rel="noopener">Android MotionLayout动画：续写ConstraintLayout新篇章</a>     </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;RecyclerView的展开与折叠是一种常见的动画&lt;br&gt;主要有两种方式可以实现&lt;br&gt;&lt;strong&gt;1.通过添加与移除元素&lt;/strong&gt;&lt;br&gt;notifyInsert,notifyRemoved，这种方式涉及到元素的加减，动画效果不太流畅&lt;br&gt;&lt;strong&gt;
      
    
    </summary>
    
    
      <category term="android" scheme="http://ShenZhen2017.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>ARTS打卡9</title>
    <link href="http://ShenZhen2017.github.io/blog/2020/12/arts-way-nine.html"/>
    <id>http://ShenZhen2017.github.io/blog/2020/12/arts-way-nine.html</id>
    <published>2020-12-14T04:20:45.000Z</published>
    <updated>2020-12-20T06:18:41.593Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><blockquote><p><a href="https://leetcode-cn.com/contest/weekly-contest-220/problems/reformat-phone-number/" target="_blank" rel="noopener">5629. 重新格式化电话号码</a><br>给你一个字符串形式的电话号码 number 。number 由数字、空格 ‘ ‘、和破折号 ‘-‘ 组成。<br>请你按下述方式重新格式化电话号码。<br>首先，删除 所有的空格和破折号。<br>其次，将数组从左到右 每 3 个一组 分块，直到 剩下 4 个或更少数字。剩下的数字将按下述规定再分块：<br>2 个数字：单个含 2 个数字的块。<br>3 个数字：单个含 3 个数字的块。<br>4 个数字：两个分别含 2 个数字的块。<br>最后用破折号将这些块连接起来。注意，重新格式化过程中 不应该 生成仅含 1 个数字的块，并且 最多 生成两个含 2 个数字的块。<br>返回格式化后的电话号码。</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">reformatNumber</span><span class="params">(number: <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">val</span> item = number.trim().replace(<span class="string">" "</span>,<span class="string">""</span>).replace(<span class="string">"-"</span>,<span class="string">""</span>)</span><br><span class="line">        <span class="keyword">val</span> result = StringBuilder()</span><br><span class="line">        <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; item.length)&#123;</span><br><span class="line">            <span class="keyword">if</span> (item.length-i&lt;=<span class="number">4</span>)&#123;</span><br><span class="line">                <span class="keyword">when</span> &#123;</span><br><span class="line">                    item.length-i==<span class="number">4</span> -&gt; result.append(item[i]).append(item[i+<span class="number">1</span>]).append(<span class="string">"-"</span>).append(item[i+<span class="number">2</span>]).append(item[i+<span class="number">3</span>])</span><br><span class="line">                    item.length-i == <span class="number">3</span> -&gt; result.append(item[i]).append(item[i+<span class="number">1</span>]).append(item[i+<span class="number">2</span>])</span><br><span class="line">                    <span class="keyword">else</span> -&gt; result.append(item[i]).append(item[i+<span class="number">1</span>])</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                result.append(item[i]).append(item[i+<span class="number">1</span>]).append(item[i+<span class="number">2</span>]).append(<span class="string">"-"</span>)</span><br><span class="line">                i += <span class="number">3</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.toString()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p><a href="https://thegeekpage.com/wifi-disconnecting-when-vpn-in-enabled/" target="_blank" rel="noopener">https://thegeekpage.com/wifi-disconnecting-when-vpn-in-enabled/</a><br><a href="https://thegeekpage.com/restart-pc-in-clean-boot-mode/" target="_blank" rel="noopener">https://thegeekpage.com/restart-pc-in-clean-boot-mode/</a><br>本文主要是windows10 安装vpn后，一打开vpn,wifi自动关闭<br>最后通过为windows建立干净启动解决问题</p><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><h3 id="ConstraintLayout给几个View添加背景"><a href="#ConstraintLayout给几个View添加背景" class="headerlink" title="ConstraintLayout给几个View添加背景"></a>ConstraintLayout给几个View添加背景</h3><p>考虑这么一个场景，如果一个页面里面有部分 view 需要加个背景，使用Layer引用这几个 view，然后给Layer设置背景就可以了。如果不用Layer，只能另外加个 ViewGroup 包住这几个 View 了，这样会增加 view 的层级，不利于性能。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;android.support.constraint.helper.Layer</span><br><span class="line">        app:<span class="attribute">layout_constraintLeft_toLeftOf</span>=<span class="string">"parent"</span></span><br><span class="line">        app:<span class="attribute">layout_constraintTop_toTopOf</span>=<span class="string">"parent"</span></span><br><span class="line">        android:<span class="attribute">id</span>=<span class="string">"@+id/layer"</span></span><br><span class="line">        android:<span class="attribute">layout_width</span>=<span class="string">"wrap_content"</span></span><br><span class="line">        android:<span class="attribute">layout_height</span>=<span class="string">"wrap_content"</span></span><br><span class="line">        android:<span class="attribute">background</span>=<span class="string">"@drawable/frame"</span></span><br><span class="line">        android:<span class="attribute">padding</span>=<span class="string">"32dp"</span></span><br><span class="line">        app:<span class="attribute">constraint_referenced_ids</span>=<span class="string">"button4,button5,button7,button6,button3,button2"</span> /&gt;</span><br></pre></td></tr></table></figure><p>详情可见：<a href="https://juejin.cn/post/6844903872255754248" target="_blank" rel="noopener">ConstraintLayout 2.0 新特性详解及实战</a></p><h3 id="圆角View与圆角ImageView实现"><a href="#圆角View与圆角ImageView实现" class="headerlink" title="圆角View与圆角ImageView实现"></a>圆角View与圆角ImageView实现</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;androidx.constraintlayout.utils.widget.ImageFilterButton</span><br><span class="line">    android:<span class="attribute">layout_width</span>=<span class="string">"wrap_content"</span></span><br><span class="line">    android:<span class="attribute">layout_height</span>=<span class="string">"wrap_content"</span></span><br><span class="line">    android:<span class="attribute">layout_marginTop</span>=<span class="string">"100dp"</span></span><br><span class="line">    android:<span class="attribute">src</span>=<span class="string">"@mipmap/ic_launcher"</span></span><br><span class="line">    app:<span class="attribute">layout_constraintLeft_toLeftOf</span>=<span class="string">"parent"</span></span><br><span class="line">    app:<span class="attribute">layout_constraintRight_toRightOf</span>=<span class="string">"parent"</span></span><br><span class="line">    app:<span class="attribute">layout_constraintTop_toTopOf</span>=<span class="string">"parent"</span></span><br><span class="line">    app:<span class="attribute">round</span>=<span class="string">"50dp"</span> /&gt;</span><br></pre></td></tr></table></figure><p>可以使用ImageFilterButton与ImageFilterView实现，通过round属性设置</p><p>详情可见：<a href="https://juejin.cn/post/6854573221312725000#heading-5" target="_blank" rel="noopener">ImageFilterView实现圆角</a></p><h3 id="ConstraintLayout-margin设置为负值"><a href="#ConstraintLayout-margin设置为负值" class="headerlink" title="ConstraintLayout margin设置为负值"></a>ConstraintLayout margin设置为负值</h3><p>有ConstraintLayout实践经验的朋友应该知道margin设置负值在ConstraintLayout是没有效果的<br>我们可以通过轻量级的Space来间接实现这种效果。<br>详情可见：<a href="https://juejin.cn/post/6854573221312725000#heading-9" target="_blank" rel="noopener">ConstraintLayout实现maring为负值</a></p><h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p><a href="https://shenzhen2017.github.io/blog/2020/12/motionlayout-recyclerview-animation.html">利用MotionLayout实现RecyclerView折叠展开动画</a><br>结合MotionLayout与RecyclerView，实现展开折叠动画</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Algorithm&quot;&gt;&lt;a href=&quot;#Algorithm&quot; class=&quot;headerlink&quot; title=&quot;Algorithm&quot;&gt;&lt;/a&gt;Algorithm&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.
      
    
    </summary>
    
    
      <category term="ARTS" scheme="http://ShenZhen2017.github.io/tags/ARTS/"/>
    
  </entry>
  
  <entry>
    <title>【译】取代Android的LiveData:StateFlow还是SharedFlow？</title>
    <link href="http://ShenZhen2017.github.io/blog/2020/12/translate-substituing-liveData.html"/>
    <id>http://ShenZhen2017.github.io/blog/2020/12/translate-substituing-liveData.html</id>
    <published>2020-12-13T13:25:27.000Z</published>
    <updated>2020-12-16T16:00:43.376Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>原标题: Substituting Android’s LiveData: StateFlow or SharedFlow?<br>原文地址: <a href="https://proandroiddev.com/should-we-choose-kotlins-stateflow-or-sharedflow-to-substitute-for-android-s-livedata-2d69f2bd6fa5" target="_blank" rel="noopener">Substituting Android’s LiveData: StateFlow or SharedFlow?</a><br>原文作者：Patrick Steiger</p></blockquote><p>Kotlin Coroutines最近推出了两种Flow类型，SharedFlow和StateFlow，Android社区开始考虑使用用这些新类型去替代LiveData的可能性。<br>这样做的两个主要原因是：    </p><ul><li>1.LiveData与UI紧密绑定（没有自然的方式将工作卸载到工作线程）    </li><li>2.LiveData与Android平台紧密绑定。    </li></ul><p>我们可以从这两个事实得出结论，就Clean Architecture而言，尽管LiveData在展示层上运行良好，但它并不能很好地集成到域层中，后者应该独立于平台（意味着一个纯粹的Kotlin / Java模块）；   而且它也不太适合数据层（存储库实现和数据源），因为我们通常应该将数据访问工作分担给工作线程。<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog9/p1.png" alt><br>但是，我们不能仅用纯Flow代替LiveData。使用纯Flow作为LiveData替代品的主要问题是：   </p><ul><li>1.Flow是无状态的（并且不能通过.value访问）。</li><li>2.Flow是声明性的,一个Flow Builder仅描述Flow是什么，并且仅在收集时才具体化。 并且将为每个收集器有效地实例化新的Flow，这意味着将为每个收集器冗余且重复地运行上游昂贵的数据库访问。</li><li>3.Flow本身对Android生命周期一无所知，并且不会在Android生命周期状态发生变化时自动暂停和恢复收集器。</li></ul><blockquote><p>这些不应被视为Flow固有缺陷：这些只是使其无法很好地替代LiveData，而在其他情况下却可能很实用。</p></blockquote><p>对于（3），我们已经可以使用LifecycleCoroutineScope扩展（例如launchWhenStarted）来启动协程以收集我们的flows-这些收集器将自动暂停并与组件的Lifecycle同步恢复。  </p><blockquote><p>注意：在本文中，我们将收集和观察用作同义词概念。 收集是Kotlin Flows（我们收集一个Flow）的首选术语，观察是Android LiveData（我们观察一个LiveData）的首选术语。  </p></blockquote><p>但是关于（1）访问当前状态，（2）对于N&gt; = 1个收集器仅实现一次，而对于0个收集器则消失，我们该如何实现呢？</p><p>现在，SharedFlow和StateFlow为这两个问题提供了解决方案。     </p><h2 id="一个实例"><a href="#一个实例" class="headerlink" title="一个实例"></a>一个实例</h2><p>我们举一个例子。我们的用例正在获取附近的位置。我们假设将Firebase实时数据库与GeoFire库一起使用，该库允许查询附近的位置。   </p><h3 id="使用LiveData端到端"><a href="#使用LiveData端到端" class="headerlink" title="使用LiveData端到端"></a>使用LiveData端到端</h3><p><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog9/p2.png" alt></p><p>让我们首先展示从数据源一直到视图的LiveData用法。<br>数据源负责通过GeoQuery连接到Firebase实时数据库。<br>当我们收到onGeoQueryReady或onGeoQueryError时，将使用自上一个onGeoQueryReady以来输入，退出或移动的位置的总和来更新LiveData值。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Singleton</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NearbyUsersDataSource</span> <span class="meta">@Inject</span> <span class="keyword">constructor</span></span>() &#123;</span><br><span class="line">    <span class="comment">// Ideally, those should be constructor-injected.</span></span><br><span class="line">    <span class="keyword">val</span> geoFire = GeoFire(FirebaseDatabase.getInstance().getReference(<span class="string">"geofire"</span>))</span><br><span class="line">    <span class="keyword">val</span> geoLocation = GeoLocation(<span class="number">0.0</span>, <span class="number">0.0</span>)</span><br><span class="line">    <span class="keyword">val</span> radius = <span class="number">100.0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">val</span> geoQuery = geoFire.queryAtLocation(geoLocation, radius)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Listener for receiving GeoLocations</span></span><br><span class="line">    <span class="keyword">val</span> listener: GeoQueryEventListener = <span class="keyword">object</span> : GeoQueryEventListener &#123;</span><br><span class="line">        <span class="keyword">val</span> map = mutableMapOf&lt;Key, GeoLocation&gt;()</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onKeyEntered</span><span class="params">(key: <span class="type">String</span>, location: <span class="type">GeoLocation</span>)</span></span> &#123;</span><br><span class="line">            map[key] = location</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onKeyExited</span><span class="params">(key: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">            map.remove(key)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onKeyMoved</span><span class="params">(key: <span class="type">String</span>, location: <span class="type">GeoLocation</span>)</span></span> &#123;</span><br><span class="line">            map[key] = location</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onGeoQueryReady</span><span class="params">()</span></span> &#123;</span><br><span class="line">            _locations.value = State.Ready(map.toMap())</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onGeoQueryError</span><span class="params">(e: <span class="type">DatabaseError</span>)</span></span> &#123;</span><br><span class="line">            _locations.value = State.Error(map.toMap(), e.toException())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Listen for changes only while observed</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> _locations = <span class="keyword">object</span> : MutableLiveData&lt;State&gt;() &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActive</span><span class="params">()</span></span> &#123;</span><br><span class="line">            geoQuery.addGeoQueryEventListener(listener)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onInactive</span><span class="params">()</span></span> &#123;</span><br><span class="line">            geoQuery.removeGeoQueryEventListener(listener)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Expose read-only LiveData</span></span><br><span class="line">    <span class="keyword">val</span> locations: LiveData&lt;State&gt; <span class="keyword">by</span> <span class="keyword">this</span>::_locations</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">State</span></span>(<span class="keyword">open</span> <span class="keyword">val</span> value: Map&lt;Key, GeoLocation&gt;) &#123;</span><br><span class="line">        <span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Ready</span></span>(</span><br><span class="line">            <span class="keyword">override</span> <span class="keyword">val</span> value: Map&lt;Key, GeoLocation&gt;</span><br><span class="line">        ) : State(value)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Error</span></span>(</span><br><span class="line">            <span class="keyword">override</span> <span class="keyword">val</span> value: Map&lt;Key, GeoLocation&gt;,</span><br><span class="line">            <span class="keyword">val</span> exception: Exception</span><br><span class="line">        ) : State(value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后，我们的Repository，ViewModel和Activity应该很简单：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Singleton</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NearbyUsersRepository</span> <span class="meta">@Inject</span> <span class="keyword">constructor</span></span>(</span><br><span class="line">    nearbyUsersDataSource: NearbyUsersDataSource</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="keyword">val</span> locations <span class="keyword">get</span>() = nearbyUsersDataSource.locations</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NearbyUsersViewModel</span> <span class="meta">@ViewModelInject</span> <span class="keyword">constructor</span></span>(</span><br><span class="line">    nearbyUsersRepository: NearbyUsersRepository</span><br><span class="line">) : ViewModel() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> locations <span class="keyword">get</span>() = nearbyUsersRepository.locations</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AndroidEntryPoint</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NearbyUsersActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> viewModel: NearbyUsersViewModel <span class="keyword">by</span> viewModels()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        viewModel.locations.observe(<span class="keyword">this</span>) &#123; state: State -&gt;</span><br><span class="line">            <span class="comment">// Update views with the data.   </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在您决定使包含存储库接口的域层（独立于平台）之前，这种尝试可能不错。 同样，一旦需要将工作分担到数据源上的工作线程上，您将发现LiveData没有简单，惯用的方法。</p><h3 id="在数据源和Repository上使用Flow"><a href="#在数据源和Repository上使用Flow" class="headerlink" title="在数据源和Repository上使用Flow"></a>在数据源和Repository上使用Flow</h3><p><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog9/p3.png" alt><br>让我们将数据源转换为使用Flow。 我们有一个Flow生成器callbackFlow，它将回调转换为Flow。<br>收集此Flow后，它将运行传递给Flow构建器的代码块，添加GeoQuery侦听器并到达awaitClose，在该处暂停直到Flow被关闭（即直到没有人收集或因为异常被取消为止).<br>关闭时，它将删除监听器，并且Flow将取消实现。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Singleton</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NearbyUsersDataSource</span> <span class="meta">@Inject</span> <span class="keyword">constructor</span></span>() &#123;</span><br><span class="line">    <span class="comment">// Ideally, those should be constructor-injected.</span></span><br><span class="line">    <span class="keyword">val</span> geoFire = GeoFire(FirebaseDatabase.getInstance().getReference(<span class="string">"geofire"</span>))</span><br><span class="line">    <span class="keyword">val</span> geoLocation = GeoLocation(<span class="number">0.0</span>, <span class="number">0.0</span>)</span><br><span class="line">    <span class="keyword">val</span> radius = <span class="number">100.0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">val</span> geoQuery = geoFire.queryAtLocation(geoLocation, radius)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> GeoQuery.<span class="title">asFlow</span><span class="params">()</span></span> = callbackFlow &#123;</span><br><span class="line">        <span class="keyword">val</span> listener: GeoQueryEventListener = <span class="keyword">object</span> : GeoQueryEventListener &#123;</span><br><span class="line">            <span class="keyword">val</span> map = mutableMapOf&lt;Key, GeoLocation&gt;()</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onKeyEntered</span><span class="params">(key: <span class="type">String</span>, location: <span class="type">GeoLocation</span>)</span></span> &#123;</span><br><span class="line">                map[key] = location</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onKeyExited</span><span class="params">(key: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">                map.remove(key)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onKeyMoved</span><span class="params">(key: <span class="type">String</span>, location: <span class="type">GeoLocation</span>)</span></span> &#123;</span><br><span class="line">                map[key] = location</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onGeoQueryReady</span><span class="params">()</span></span> &#123;</span><br><span class="line">                emit(State.Ready(locations.toMap()))</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onGeoQueryError</span><span class="params">(e: <span class="type">DatabaseError</span>)</span></span> &#123;</span><br><span class="line">                emit(State.Error(map.toMap(), e.toException()))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        addGeoQueryEventListener(listener)</span><br><span class="line">        </span><br><span class="line">        awaitClose &#123; removeGeoQueryEventListener(listener) &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> locations: Flow&lt;State&gt; = geoQuery.asFlow()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">State</span></span>(<span class="keyword">open</span> <span class="keyword">val</span> value: Map&lt;Key, GeoLocation&gt;) &#123;</span><br><span class="line">        <span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Ready</span></span>(</span><br><span class="line">            <span class="keyword">override</span> <span class="keyword">val</span> value: Map&lt;Key, GeoLocation&gt;</span><br><span class="line">        ) : State(value)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Error</span></span>(</span><br><span class="line">            <span class="keyword">override</span> <span class="keyword">val</span> value: Map&lt;Key, GeoLocation&gt;,</span><br><span class="line">            <span class="keyword">val</span> exception: Exception</span><br><span class="line">        ) : State(value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们的Repository和ViewModel不做任何更改，但是我们的Activity现在接收到Flow而不是LiveData，因此它需要进行调整：我们将收集Flow而不是观察LiveData。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AndroidEntryPoint</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NearbyUsersActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> viewModel: NearbyUsersViewModel <span class="keyword">by</span> viewModels()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        lifecycleScope.launchWhenStarted &#123;</span><br><span class="line">            viewModel.locations.collect &#123;</span><br><span class="line">                <span class="comment">// Update views with the data.   </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们使用launchWhenStarted {}来收集Flow，因此协程仅在Activity达到onStart（）生命周期状态时才自动启动，而当它达到onStop（）生命周期状态时将自动暂停。 这类似于LiveData给我们的生命周期自动处理。 </p><blockquote><p>注意：您可以选择在展示层中继续使用LiveData。 在这种情况下，您可以使用Flow <t>.asLiveData扩展函数轻松地在ViewModel中将Flow从Flow转换为LiveData。<br>这个决定将带来后果，我们将继续进行讨论，并且将证明端到端使用SharedFlow和StateFlow更加通用，并且可能更适合您的体系结构。<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog9/p4.png" alt>  </t></p></blockquote><h3 id="在View层中使用Flow有什么问题？"><a href="#在View层中使用Flow有什么问题？" class="headerlink" title="在View层中使用Flow有什么问题？"></a>在View层中使用Flow有什么问题？</h3><p>这种方法的第一个问题是生命周期的处理，LiveData会自动为我们处理。 在上面的示例中，我们通过使用launchWhenStarted {}实现了类似的行为。    </p><p>但是还有另一个问题：由于Flow是声明性的，并且仅在收集时运行（实例化），因此，如果我们有多个收集器，则将为每个收集器运行一个新的Flow，彼此完全独立。<br>根据完成的操作（例如数据库或网络操作），这可能会非常无效。<br>如果我们期望操作只进行一次以确保正确性，则甚至可能导致错误的状态。<br>在我们的实际示例中，我们将为每个收集器添加一个新的GeoQuery监听器-可能不是关键问题，但肯定会浪费内存和CPU周期。   </p><blockquote><p>注意：如果通过在ViewModel中使用Flow <t> .asLiveData（）将存储库流转换为LiveData，则LiveData将成为Flow的唯一收集器，无论展示层中有多少观察者，都将只有一个Flow 集。<br>但是，为了使该架构正常工作，您需要确保自己的所有其他组件都可以从ViewModel访问LiveData，而绝不能直接从存储库访问Flow。<br>这可能是一个挑战，具体取决于应用程序的分离程度：所有需要存储库的组件现在都将依赖Activity实例来获取ViewModel实例，以及这些组件的范围 需要相应地加以限制。</t></p></blockquote><p>无论我们在View层中有多少个收集器，我们都只需要一个GeoQuery监听器。 我们可以通过共享所有收集器之间的流来实现此目的。     </p><h3 id="SharedFlow"><a href="#SharedFlow" class="headerlink" title="SharedFlow"></a>SharedFlow</h3><p>SharedFlow是一种流，它允许在多个收集器之间共享自己，因此对于所有同时收集器，只有一个流有效地运行（实现）。<br>如果定义访问数据库的SharedFlow并且由多个收集器收集，则数据库访问将仅运行一次，并且所得到的数据将共享给所有收集器。    </p><p>StateFlow也可以用于实现相同的行为：它是具有.value（其当前状态）和特定SharedFlow配置（约束）的专用SharedFlow。 稍后我们将讨论这些限制。<br>我们有一个运算符，用于将任何Flow转换为SharedFlow<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Flow<span class="type">&lt;T&gt;</span>.<span class="title">shareIn</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    scope: <span class="type">CoroutineScope</span>, </span></span></span><br><span class="line"><span class="function"><span class="params">    started: <span class="type">SharingStarted</span>, </span></span></span><br><span class="line"><span class="function"><span class="params">    replay: <span class="type">Int</span> = <span class="number">0</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>: SharedFlow&lt;T&gt; (source)</span><br></pre></td></tr></table></figure></p><p>让我们将其应用于我们的数据源。     </p><p>scope是完成实现该流程的所有计算的地方。<br>由于我们的数据源是@Singleton，因此我们可以使用应用程序进程的LifecycleScope，它是一个LifecycleCoroutineScope，它是在进程创建时创建的，仅在进程销毁时才销毁。    </p><p>对于started参数，我们可以使用SharingStarted.WhileSubscribed（），这使Flow仅在订阅者数量从0变为1时才开始共享（实现），并在订阅者数量从1变为0时停止共享。     与我们之前通过在onActive（）回调中添加GeoQuery侦听器并在onInactive（）回调中删除侦听器实现的LiveData行为类似。      我们还可以将其配置为立即启动（立即实现，而不再取消实现）或懒启动（在首次收集时实现，而从未取消实现），但是我们希望它在下游不再收集时停止上游数据库的收集。    </p><blockquote><p>关于术语的注意事项：正如我们将术语“观察者”用于LiveData，将“收集器”用于Flow一样，我们将术语“订阅”用于SharedFlow。</p></blockquote><p>对于replay参数,我们可以设置为1，新订阅者将在订阅时立即获得最后发出的值。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Singleton</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NearbyUsersDataSource</span> <span class="meta">@Inject</span> <span class="keyword">constructor</span></span>() &#123;</span><br><span class="line">    <span class="comment">// Ideally, those should be constructor-injected.</span></span><br><span class="line">    <span class="keyword">val</span> geoFire = GeoFire(FirebaseDatabase.getInstance().getReference(<span class="string">"geofire"</span>))</span><br><span class="line">    <span class="keyword">val</span> geoLocation = GeoLocation(<span class="number">0.0</span>, <span class="number">0.0</span>)</span><br><span class="line">    <span class="keyword">val</span> radius = <span class="number">100.0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">val</span> geoQuery = geoFire.queryAtLocation(geoLocation, radius)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> GeoQuery.<span class="title">asFlow</span><span class="params">()</span></span> = callbackFlow &#123;</span><br><span class="line">        <span class="keyword">val</span> listener: GeoQueryEventListener = <span class="keyword">object</span> : GeoQueryEventListener &#123;</span><br><span class="line">            <span class="keyword">val</span> map = mutableMapOf&lt;Key, GeoLocation&gt;()</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onKeyEntered</span><span class="params">(key: <span class="type">String</span>, location: <span class="type">GeoLocation</span>)</span></span> &#123;</span><br><span class="line">                map[key] = location</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onKeyExited</span><span class="params">(key: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">                map.remove(key)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onKeyMoved</span><span class="params">(key: <span class="type">String</span>, location: <span class="type">GeoLocation</span>)</span></span> &#123;</span><br><span class="line">                map[key] = location</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onGeoQueryReady</span><span class="params">()</span></span> &#123;</span><br><span class="line">                emit(State.Ready(map.toMap())</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onGeoQueryError</span><span class="params">(e: <span class="type">DatabaseError</span>)</span></span> &#123;</span><br><span class="line">                emit(State.Error(map.toMap(), e.toException())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        addGeoQueryEventListener(listener)</span><br><span class="line">        </span><br><span class="line">        awaitClose &#123; removeGeoQueryEventListener(listener) &#125;</span><br><span class="line">    &#125;.shareIn(</span><br><span class="line">         ProcessLifecycleOwner.<span class="keyword">get</span>().lifecycleScope,</span><br><span class="line">         SharingStarted.WhileSubscribed(),</span><br><span class="line">         <span class="number">1</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> locations: Flow&lt;State&gt; = geoQuery.asFlow()</span><br><span class="line">                     </span><br><span class="line">    <span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">State</span></span>(<span class="keyword">open</span> <span class="keyword">val</span> value: Map&lt;Key, GeoLocation&gt;) &#123;</span><br><span class="line">        <span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Ready</span></span>(</span><br><span class="line">            <span class="keyword">override</span> <span class="keyword">val</span> value: Map&lt;Key, GeoLocation&gt;</span><br><span class="line">        ) : State(value)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Error</span></span>(</span><br><span class="line">            <span class="keyword">override</span> <span class="keyword">val</span> value: Map&lt;Key, GeoLocation&gt;,</span><br><span class="line">            <span class="keyword">val</span> exception: Exception</span><br><span class="line">        ) : State(value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>将SharedFlow本身视为Flow收集器可能会有所帮助，它会将上游的冷流变为热流，并在下游的许多收集器之间共享收集的值。 在冷的上游水流和多个下游收集器之间的中间位置有一个人。  </p><p>现在，我们可能会以为Activity不需要调整。<br>错误！ 有一个陷阱：在使用launchWhenStarted {}启动的协程中收集流时，协程将在onStop（）上暂停，并在onStart（）上恢复，但仍将订阅该流。<br>对于MutableSharedFlow <t>，这意味着MutableSharedFlow <t> .subscriptionCount对于暂停的协程不会更改。 为了利用SharingStarted.WhileSubscribed（）的功能，我们实际上需要在onStop（）上退订，然后在onStart（）上再次订阅。 这意味着取消收集协程并重新创建它。</t></t></p><p>让我们为此目的创建一个类：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PublishedApi</span></span><br><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserverImpl</span>&lt;<span class="type">T</span>&gt; </span>(</span><br><span class="line">    lifecycleOwner: LifecycleOwner,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> flow: Flow&lt;T&gt;,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> collector: <span class="keyword">suspend</span> (T) -&gt; <span class="built_in">Unit</span></span><br><span class="line">) : DefaultLifecycleObserver &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> job: Job? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStart</span><span class="params">(owner: <span class="type">LifecycleOwner</span>)</span></span> &#123;</span><br><span class="line">        job = owner.lifecycleScope.launch &#123;</span><br><span class="line">            flow.collect &#123;</span><br><span class="line">                collector(it)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStop</span><span class="params">(owner: <span class="type">LifecycleOwner</span>)</span></span> &#123;</span><br><span class="line">        job?.cancel()</span><br><span class="line">        job = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        lifecycleOwner.lifecycle.addObserver(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T&gt;</span> Flow<span class="type">&lt;T&gt;</span>.<span class="title">observe</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    lifecycleOwner: <span class="type">LifecycleOwner</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">noinline</span> collector: <span class="type">suspend</span> (<span class="type">T</span>) -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> &#123;</span><br><span class="line">    ObserverImpl(lifecycleOwner, <span class="keyword">this</span>, collector)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T&gt;</span> Flow<span class="type">&lt;T&gt;</span>.<span class="title">observeIn</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    lifecycleOwner: <span class="type">LifecycleOwner</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> &#123;</span><br><span class="line">    ObserverImpl(lifecycleOwner, <span class="keyword">this</span>, &#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在，我们可以调整Activity以使用刚刚创建的.observeIn（LifecycleOwner）扩展功能：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AndroidEntryPoint</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NearbyUsersActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> viewModel: NearbyUsersViewModel <span class="keyword">by</span> viewModels()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        viewModel</span><br><span class="line">            .locations</span><br><span class="line">            .onEach &#123; <span class="comment">/* new locations received */</span> &#125;</span><br><span class="line">            .observeIn(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当LifecycleOwner的生命周期达到CREATED状态（恰好在onStop（）调用之前）时，使用observeIn（LifecycleOwner）创建的收集器协程将被销毁，并且一旦达到STARTED状态（在onStart（）调用之后）将被重新创建。</p><blockquote><p>注意：为什么是CREATED状态？ 不应该是STOPED状态吗？ 乍一看听起来有点违反直觉，但确实很合理。 Lifecycle.State仅具有以下状态：CREATED, DESTROYED, INITIALIZED, RESUMED, STARTED。<br>没有STOPPED和PAUSED状态。 当生命周期达到onPause（）时，它不会返回新状态，而是返回到STARTED状态。 当到达onStop（）时，它返回到CREATED状态。</p></blockquote><p><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog9/p5.png" alt><br>现在，我们有了一个数据源，该数据源一次实现，但将其数据共享给所有订阅者。<br>一旦没有订阅者，它的上游收集将停止，并在第一个订阅者重新出现时重新启动。<br>它不依赖于Android平台，也不与主线程绑定（仅通过应用.flowOn（）运算符即可在其他线程中进行流转换：<br>flowOn（Dispatchers.IO）或.flowOn（Dispatchers.Default） ）。</p><h3 id="但是，如果我最终需要访问Flow的当前状态而不收集它怎么办？"><a href="#但是，如果我最终需要访问Flow的当前状态而不收集它怎么办？" class="headerlink" title="但是，如果我最终需要访问Flow的当前状态而不收集它怎么办？"></a>但是，如果我最终需要访问Flow的当前状态而不收集它怎么办？</h3><p>如果确实需要像使用LiveData一样使用.value访问Flow的状态，则我们可以使用StateFlow，它是一种专用的受限SharedFlow。    </p><p>ShareFlow使用shareIn来实现<br>StateFlow使用stateIn实现</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Flow<span class="type">&lt;T&gt;</span>.<span class="title">stateIn</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    scope: <span class="type">CoroutineScope</span>, </span></span></span><br><span class="line"><span class="function"><span class="params">    started: <span class="type">SharingStarted</span>, </span></span></span><br><span class="line"><span class="function"><span class="params">    initialValue: <span class="type">T</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>: StateFlow&lt;T&gt; (source)</span><br></pre></td></tr></table></figure><p>从方法参数可以看出，sharedIn（）和stateIn（）之间有两个基本区别：</p><p>1.stateIn（）不支持replay自定义。 StateFlow是具有固定replay=1的SharedFlow。 这意味着新订阅者将在订阅后立即获得当前状态。<br>2.stateIn（）需要一个初始值。 这意味着如果您当时没有初始值，则需要使StateFlow <t>类型T为可为空，或使用密封类来表示空的初始值。    </t></p><h3 id="选择哪个，StateFlow或SharedFlow？"><a href="#选择哪个，StateFlow或SharedFlow？" class="headerlink" title="选择哪个，StateFlow或SharedFlow？"></a>选择哪个，StateFlow或SharedFlow？</h3><p>回答此问题的简单方法是尝试回答其他一些问题：   </p><p><strong>“我真的需要在任何给定时间使用myFlow.value访问Flow的当前状态吗？”</strong><br>如果此问题的答案为“否”，则可以考虑使用SharedFlow。 </p><p><strong>“我需要支持发出和收集重复值吗？”</strong><br>如果对这个问题的回答是“是”，则需要SharedFlow。  </p><p><strong>“对于新订户，我是否需要重播超过最新值的内容？”</strong><br>如果对这个问题的回答是“是”，则需要SharedFlow。    </p><p>正如我们所看到的，对于所有内容，StateFlow并不是自动的正确答案。  </p><p>1.它忽略（合并）重复的值，并且这是不可配置的。 有时您不需要忽略重复的值，例如：连接尝试将尝试的结果存储在流中，并且每次失败后都需要重试。   </p><p>2.另外，它需要一个初始值。 由于SharedFlow没有.value，因此不需要使用初始值实例化-收集器将暂停直到第一个值出现，并且没有人会尝试在任何值到达之前访问.value。 如果您没有StateFlow的初始值，则必须将StateFlow类型设为可为null的T？ 并使用null作为初始值（或使用密封类来表示空的初始值）。</p><p>3.另外，您可能需要调整重播值。 SharedFlow可以为新订户重播最后n个值。 StateFlow的固定重播值为1-它仅共享当前状态值</p><p>两者都支持SharingStarted（立刻，懒加载或WhileSubscribed（））配置。我通常使用SharingStarted.WhileSubscribed（）<br>并在Activity onStart（）/ onStop（）时，销毁/重新创建所有收集器，<br>因此，当用户不积极使用该应用程序时，数据源上游收集将停止    </p><p>StateFlow施加在SharedFlow上的约束可能不是最适合您，您可能需要调整行为并选择使用SharedFlow。就个人而言，我很少需要访问myFlow.value，并且享受SharedFlow的灵活性，因此我通常选择SharedFlow。  </p><h3 id="一个使用SharedFlow的实例"><a href="#一个使用SharedFlow的实例" class="headerlink" title="一个使用SharedFlow的实例"></a>一个使用SharedFlow的实例</h3><p>考虑以下围绕Google Billing Client库的包装。我们有一个MutableSharedFlow billingClientStatus，用于存储当前到计费服务的连接状态。<br>我们将其初始值设置为SERVICE_DISCONNECTED。我们收集billingClientStatus，当它不正常时，我们尝试将startConnection（）连接到计费服务。<br>如果连接尝试失败，我们将发出SERVICE_DISCONNECTED。</p><p>在该示例中，如果billingClientStatus是MutableStateFlow而不是MutableSharedFlow，则当其值已经为SERVICE_DISCONNECTED且我们尝试将其设置为相同（连接重试失败）时，它将忽略更新，因此，它将不会尝试重新连接再次。   </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Singleton</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Biller</span> <span class="meta">@Inject</span> <span class="keyword">constructor</span></span>(</span><br><span class="line">    <span class="meta">@ApplicationContext</span> <span class="keyword">private</span> <span class="keyword">val</span> context: Context,</span><br><span class="line">) : PurchasesUpdatedListener, BillingClientStateListener &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> billingClient: BillingClient =</span><br><span class="line">        BillingClient.newBuilder(context)</span><br><span class="line">            .setListener(<span class="keyword">this</span>)</span><br><span class="line">            .enablePendingPurchases()</span><br><span class="line">            .build()</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> billingClientStatus = MutableSharedFlow&lt;<span class="built_in">Int</span>&gt;(</span><br><span class="line">        replay = <span class="number">1</span>,</span><br><span class="line">        onBufferOverflow = BufferOverflow.DROP_OLDEST</span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBillingSetupFinished</span><span class="params">(result: <span class="type">BillingResult</span>)</span></span> &#123;</span><br><span class="line">        billingClientStatus.tryEmit(result.responseCode)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBillingServiceDisconnected</span><span class="params">()</span></span> &#123;</span><br><span class="line">        billingClientStatus.tryEmit(BillingClient.BillingResponseCode.SERVICE_DISCONNECTED)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Suspend until billingClientStatus == BillingClient.BillingResponseCode.OK</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">requireBillingClientSetup</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> =</span><br><span class="line">        withTimeoutOrNull(TIMEOUT_MILLIS) &#123;</span><br><span class="line">            billingClientStatus.first &#123; it == BillingClient.BillingResponseCode.OK &#125;</span><br><span class="line">            <span class="literal">true</span></span><br><span class="line">        &#125; ?: <span class="literal">false</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        billingClientStatus.tryEmit(BillingClient.BillingResponseCode.SERVICE_DISCONNECTED)</span><br><span class="line">        billingClientStatus.observe(ProcessLifecycleOwner.<span class="keyword">get</span>()) &#123;</span><br><span class="line">            <span class="keyword">when</span> (it) &#123;</span><br><span class="line">                BillingClient.BillingResponseCode.OK -&gt; with (billingClient) &#123;</span><br><span class="line">                    updateSkuPrices()</span><br><span class="line">                    handlePurchases()</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">                    delay(RETRY_MILLIS)</span><br><span class="line">                    billingClient.startConnection(<span class="keyword">this</span><span class="symbol">@Biller</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> TIMEOUT_MILLIS = <span class="number">2000L</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> RETRY_MILLIS = <span class="number">3000L</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这种情况下，我们需要使用SharedFlow，它支持发出连续的重复值。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要是关于SharedFlow与StateFlow的一些介绍及使用他们代替LiveData的一些尝试<br>这是在下翻译的第一篇文章，还有很多不足之处，请各位读者结合原文观看，如果有什么总量，欢迎提出指正。    </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;原标题: Substituting Android’s LiveData: StateFlow or Shared
      
    
    </summary>
    
    
      <category term="android" scheme="http://ShenZhen2017.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>android文档之性能优化总结</title>
    <link href="http://ShenZhen2017.github.io/blog/2020/12/android-doc-performace.html"/>
    <id>http://ShenZhen2017.github.io/blog/2020/12/android-doc-performace.html</id>
    <published>2020-12-12T13:44:32.000Z</published>
    <updated>2020-12-22T14:52:40.011Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文地址:<a href="https://developer.android.google.cn/topic/performance" target="_blank" rel="noopener">https://developer.android.google.cn/topic/performance</a></p></blockquote><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>用户对应用具有如下的期望：<br>1.耗电少。<br>2.启动快。<br>3.对用户互动响应迅速。</p><h2 id="Android-Vitals"><a href="#Android-Vitals" class="headerlink" title="Android Vitals"></a>Android Vitals</h2><h3 id="ANR"><a href="#ANR" class="headerlink" title="ANR"></a>ANR</h3><p>如果 Android 应用的界面线程处于阻塞状态的时间过长，会触发“应用无响应”(ANR) 错误<br>出现以下任何情况时，系统都会针对您的应用触发 ANR：</p><ul><li>当您的 Activity 位于前台时，您的应用在 5 秒钟内未响应输入事件或 BroadcastReceiver（如按键或屏幕轻触事件）。</li><li>虽然前台没有 Activity，但您的 BroadcastReceiver 用了相当长的时间仍未执行完毕。</li></ul><p>如果您的应用遇到 ANR 错误，您可以按照本文中的指导来诊断并解决问题。</p><h4 id="诊断-ANR"><a href="#诊断-ANR" class="headerlink" title="诊断 ANR"></a>诊断 ANR</h4><p>诊断 ANR 时需要考虑以下几种常见模式：</p><p>1.应用在主线程上非常缓慢地执行涉及 I/O 的操作。<br>2.应用在主线程上进行长时间的计算。<br>3.主线程在对另一个进程进行同步 binder 调用，而后者需要很长时间才能返回。<br>4.主线程处于阻塞状态，为发生在另一个线程上的长操作等待同步的块。<br>5.主线程在进程中或通过 binder 调用与另一个线程之间发生死锁。主线程不只是在等待长操作执行完毕，而且处于死锁状态</p><p>以下方法可帮助您找出是以上哪种原因造成了 ANR</p><h5 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h5><p>使用 StrictMode 有助于您在开发应用时发现主线程上的意外 I/O 操作。您可以在应用级别或 Activity 级别使用 StrictMode。</p><h5 id="启用后台-ANR-对话框"><a href="#启用后台-ANR-对话框" class="headerlink" title="启用后台 ANR 对话框"></a>启用后台 ANR 对话框</h5><p>只有在设备的开发者选项中启用了显示所有 ANR 时，Android 才会针对花费过长时间处理广播消息的应用显示 ANR 对话框。因此，系统并不会始终向用户显示后台 ANR 对话框，但应用仍可能会遇到性能问题。</p><h5 id="TraceView"><a href="#TraceView" class="headerlink" title="TraceView"></a>TraceView</h5><p>您可以使用 TraceView 在查看用例时获取正在运行的应用的跟踪信息，并找出主线程繁忙的位置。如需了解如何使用 TraceView，请参阅使用 TraceView 和 dmtracedump 分析性能。</p><h5 id="拉取跟踪信息文件"><a href="#拉取跟踪信息文件" class="headerlink" title="拉取跟踪信息文件"></a>拉取跟踪信息文件</h5><p>Android 会在遇到 ANR 时存储跟踪信息。在较低的操作系统版本中，设备上只有一个 /data/anr/traces.txt 文件。在较新的操作系统版本中，有多个 /data/anr/anr_* 文件。您可以使用 Android 调试桥 (ADB) 作为根，从设备或模拟器中获取 ANR 跟踪信息：</p><h4 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h4><h5 id="主线程上执行速度缓慢的代码"><a href="#主线程上执行速度缓慢的代码" class="headerlink" title="主线程上执行速度缓慢的代码"></a>主线程上执行速度缓慢的代码</h5><p>在您的代码中找出应用的主线程忙碌时间超过 5 秒的位置。在您的应用中查找可疑用例并尝试重现 ANR。</p><p>然后通过TraceView来找出</p><h5 id="主线程上的-IO"><a href="#主线程上的-IO" class="headerlink" title="主线程上的 IO"></a>主线程上的 IO</h5><p>在主线程上执行 IO 操作是导致主线程上操作速度缓慢的常见原因，主线程上操作速度缓慢会导致 ANR。建议将所有 IO 操作移至工作线程，如上一部分所示。</p><p>IO 操作示例包括网络和存储操作。如需了解详情，请参阅执行网络操作和保存数据。</p><h5 id="锁争用"><a href="#锁争用" class="headerlink" title="锁争用"></a>锁争用</h5><p>在某些情况下，导致 ANR 的工作并不是直接在应用的主线程上执行。如果某工作线程持有对某项资源的锁，而该资源是主线程完成其工作所必需的，这种情况下就可能会发生 ANR。</p><h3 id="崩溃"><a href="#崩溃" class="headerlink" title="崩溃"></a>崩溃</h3><p>未处理的异常或信号导致的意外退出，会使 Android 应用崩溃。使用 Java 编写的应用会在抛出未处理的异常（由 Throwable 类表示）时崩溃。使用原生代码语言编写的应用，会在执行过程中遇到未处理的信号（如 SIGSEGV）时崩溃。</p><p>当应用崩溃时，Android 会终止应用的进程并显示一个对话框，告知用户应用已停止</p><p>应用并不是只有在前台运行时才会崩溃。任何应用组件，甚至是广播接收器或内容提供程序这类在后台运行的组件，都有可能导致应用崩溃。这些崩溃常常让用户感到困惑，因为他们并没有在使用应用。</p><h4 id="诊断崩溃"><a href="#诊断崩溃" class="headerlink" title="诊断崩溃"></a>诊断崩溃</h4><p>解决崩溃问题可能很困难。但是，如果您能确定崩溃的根本原因，就有很可能能够找到解决方法。</p><h5 id="读取堆栈轨迹"><a href="#读取堆栈轨迹" class="headerlink" title="读取堆栈轨迹"></a>读取堆栈轨迹</h5><p>解决崩溃的第一步是确定它发生的位置。如果您使用的是 Play 管理中心或 logcat 工具的输出，则可使用报告详细信息中提供的堆栈轨迹。如果您没有堆栈轨迹可用，则应通过手动测试应用或联系受影响的用户在本地再现崩溃，并且要在使用 logcat 的情况下再现。</p><h5 id="有关再现崩溃的提示"><a href="#有关再现崩溃的提示" class="headerlink" title="有关再现崩溃的提示"></a>有关再现崩溃的提示</h5><p>再现问题可能无法简单地通过启动模拟器或将设备连接到计算机来实现。开发环境往往具有更多的资源，比如带宽、内存和存储。通过异常类型确定哪项资源不足，或找到 Android 版本、设备类型或应用版本之间的关联。</p><h5 id="内存错误"><a href="#内存错误" class="headerlink" title="内存错误"></a>内存错误</h5><p>如果发生了 OutOfMemoryError 异常，您可以首先创建一个内存容量较低的模拟器。图 2 显示了 AVD 管理器设置，您可以通过这些设置控制设备的内存容量。</p><h2 id="渲染速度缓慢"><a href="#渲染速度缓慢" class="headerlink" title="渲染速度缓慢"></a>渲染速度缓慢</h2><p>界面呈现是指从应用生成帧并将其显示在屏幕上的动作。要确保用户能够流畅地与您的应用互动，您的应用呈现每帧的时间不应超过 16ms，以达到每秒 60 帧的呈现速度（为什么是60fps？）。如果您的应用存在界面呈现缓慢的问题，系统会不得不跳过一些帧，这会导致用户感觉您的应用不流畅。我们将这种情况称为卡顿。</p><h3 id="识别卡顿"><a href="#识别卡顿" class="headerlink" title="识别卡顿"></a>识别卡顿</h3><p>1.目视检查<br>2.Systrace<br>3.自定义性能监控</p><h3 id="常见的卡顿来源"><a href="#常见的卡顿来源" class="headerlink" title="常见的卡顿来源"></a>常见的卡顿来源</h3><h4 id="可滚动列表"><a href="#可滚动列表" class="headerlink" title="可滚动列表"></a>可滚动列表</h4><p>ListView 和 RecyclerView （尤其是后者）常用于最易出现卡顿的复杂滚动列表。它们都包含 Systrace 标记，因此您可以使用 Systrace 来判断它们是不是导致应用出现卡顿的因素。请务必传递命令行参数 -a <your-package-name>，以便让 RecyclerView 中的跟踪部分（以及您添加的所有跟踪标记）显示出来。请遵循系统跟踪信息输出中生成的提醒提供的指导（如果有）。在 Systrace 中，您可以点击 RecyclerView 跟踪部分，以查看关于 RecyclerView 正在执行的工作的说明。</your-package-name></p><h5 id="RecyclerView：notifyDataSetChanged"><a href="#RecyclerView：notifyDataSetChanged" class="headerlink" title="RecyclerView：notifyDataSetChanged"></a>RecyclerView：notifyDataSetChanged</h5><p>如果您在一个帧中看到 RecyclerView 中的每一项都重新绑定（并因此重新布局和重新绘制），请确保您没有调用 notifyDataSetChanged()、setAdapter(Adapter) 或 swapAdapter(Adapter, boolean) 来进行细微更新。这些方法会向系统表明整个列表内容已更改，并会在 Systrace 中显示为 RV FullInvalidate。应改用 SortedList 或 DiffUtil，以便在内容发生更改或添加了内容时生成最少量的更新。</p><h5 id="RecyclerView：嵌套的-RecyclerView"><a href="#RecyclerView：嵌套的-RecyclerView" class="headerlink" title="RecyclerView：嵌套的 RecyclerView"></a>RecyclerView：嵌套的 RecyclerView</h5><p>嵌套 RecyclerView 很常见，对于由水平滚动列表组成的纵向列表（例如 Play 商店主页面上的应用网格），尤其如此。这种方法效果很好，但它也会导致大量来回移动的视图。在首次向下滚动页面时，如果您看到大量内部内容出现扩充，则可能需要检查内部（水平）RecyclerView 之间是否正在共享 RecyclerView.RecycledViewPool。默认情况下，每个 RecyclerView 都将有自己的内容池。然而，在屏幕上同时显示十几个 itemViews 的情况下，如果所有行都显示类型相似的视图，那么当不同的水平列表无法共享 itemViews 时，就会出现问题。</p><h5 id="RecyclerView：膨胀过多-创建过程用时过长"><a href="#RecyclerView：膨胀过多-创建过程用时过长" class="headerlink" title="RecyclerView：膨胀过多/创建过程用时过长"></a>RecyclerView：膨胀过多/创建过程用时过长</h5><p>RecyclerView 中的预取功能会在界面线程处于空闲状态时提前执行工作，因此在大多数情况下应该有助于解决膨胀造成的开销问题。如果您在帧中（而不是标记为 RV 预取的部分中）看到了扩充，请确保您是在版本较新的设备上进行测试（预取功能当前仅在 Android 5.0 API 级别 21 及更高版本上受支持），并且使用的是较新版本的支持库。</p><p>如果您经常在屏幕上出现新内容时看到导致卡顿的扩充问题，请确认您的视图类型数量没有超出所需要的数量。RecyclerView 内容中的视图类型越少，屏幕上出现新的内容类型时需要进行的扩充就越少。如果可能的话，可以在适当情况下合并视图类型 - 如果不同类型之间只有图标、颜色或文本片段不同，您可以在绑定时进行这项更改，从而避免膨胀（同时减少应用占用的内存）。</p><p>如果视图类型看起来合适，请考虑降低膨胀导致的开销。减少不必要的容器和结构视图会有所帮助 – 请考虑使用 ConstraintLayout 构建 itemViews，以便轻松减少结构视图。如果您希望真正进行优化以提升性能，内容的层次结构非常简单，并且您不需要复杂的主题和样式功能，可以考虑自己调用构造函数，但是请注意，通常不值得为此牺牲 XML 的简易性和功能。</p><h5 id="RecyclerView：绑定用时过长"><a href="#RecyclerView：绑定用时过长" class="headerlink" title="RecyclerView：绑定用时过长"></a>RecyclerView：绑定用时过长</h5><p>绑定（即 onBindViewHolder(VH, int)）应该非常简单，并且所有内容（最复杂的内容除外）所需的绑定时间都应远远少于 1 毫秒。它应该只从适配器的内部内容数据获取 POJO 内容，并对 ViewHolder 中的视图调用 setter。如果 RV OnBindView 用时很长，请确认在绑定代码中只执行最少量的工作。</p><p>如果您使用简单的 POJO 对象将数据保存在适配器中，可以使用数据绑定库完全避免在 onBindViewHolder 中写入绑定代码。</p><h5 id="布局性能"><a href="#布局性能" class="headerlink" title="布局性能"></a>布局性能</h5><p>如果 Systrace 表明 Choreographer#doFrame 的布局部分执行的工作过多或者执行工作的频率太高，则意味着您遇到了布局性能问题。应用的布局性能取决于视图层次结构的哪个部分包含会发生改变的布局参数或输入。</p><h2 id="进程和线程概览"><a href="#进程和线程概览" class="headerlink" title="进程和线程概览"></a>进程和线程概览</h2><p>当应用组件启动且该应用未运行任何其他组件时，Android 系统会使用单个执行线程为应用启动新的 Linux 进程。默认情况下，同一应用的所有组件会在相同的进程和线程（称为“主”线程）中运行。如果某个应用组件启动且该应用已存在进程（因为存在该应用的其他组件），则该组件会在此进程内启动并使用相同的执行线程。但是，您可以安排应用中的其他组件在单独的进程中运行，并为任何进程创建额外的线程。</p><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>默认情况下，同一应用的所有组件均在相同的进程中运行，且大多数应用都不应改变这一点。但是，如果您发现需要控制某个组件所属的进程，则可在清单文件中执行此操作。</p><p>各类组件元素（<activity>、<service>、<receiver> 和 <provider>）的清单文件条目均支持 android:process 属性，此属性可指定该组件应在哪个进程中运行。您可以设置此属性，使每个组件均在各自的进程中运行，或者使某些组件共享一个进程，而其他组件则不共享。您也可设置 android:process，以便不同应用的组件在同一进程中运行，但前提是这些应用共享相同的 Linux 用户 ID 并使用相同的证书进行签署。</provider></receiver></service></activity></p><p>此外，<application> 元素还支持 android:process 属性，用来设置适用于所有组件的默认值。</application></p><p>当内存不足，而其他更急于为用户提供服务的进程又需要内存时，Android 可能会决定在某一时刻关闭某个进程。正因如此，系统会销毁在被终止进程中运行的应用组件。当这些组件需再次运行时，系统将为其重启进程。</p><p>决定终止哪个进程时，Android 系统会权衡其对用户的相对重要性。例如，相较于托管可见 Activity 的进程而言，系统更有可能关闭托管屏幕上不再可见的 Activity 的进程。因此，是否终止某个进程的决定取决于该进程中所运行组件的状态。</p><p>如需详细了解进程生命周期及其与应用状态的关系，请参阅进程和应用生命周期。</p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>启动应用时，系统会为该应用创建一个称为“main”（主线程）的执行线程。此线程非常重要，因为其负责将事件分派给相应的界面微件，其中包括绘图事件。此外，应用与 Android 界面工具包组件（来自 android.widget 和 android.view 软件包的组件）也几乎都在该线程中进行交互。因此，主线程有时也称为界面线程。但在一些特殊情况下，应用的主线程可能并非其界面线程，相关详情请参阅线程注解。</p><p>系统不会为每个组件实例创建单独的线程。在同一进程中运行的所有组件均在界面线程中进行实例化，并且对每个组件的系统调用均由该线程进行分派。因此，响应系统回调的方法（例如，报告用户操作的 onKeyDown() 或生命周期回调方法）始终在进程的界面线程中运行。</p><h2 id="缩减应用大小"><a href="#缩减应用大小" class="headerlink" title="缩减应用大小"></a>缩减应用大小</h2><h3 id="使用-Android-Size-Analyzer"><a href="#使用-Android-Size-Analyzer" class="headerlink" title="使用 Android Size Analyzer"></a>使用 Android Size Analyzer</h3><p>您可以使用 Android Studio 中的插件市场下载 Android Size Analyzer 插件，如图 1 所示。要打开插件市场并安装该插件，请按以下步骤操作：</p><p>依次选择 File &gt; Settings（或在 Mac 上，依次选择 Android Studio &gt; Preferences）。<br>选择左侧面板中的 Plugins 部分。<br>点击 Marketplace 标签。<br>搜索“Android Size Analyzer”插件。<br>点击分析器插件的 Install 按钮。</p><h3 id="压缩-PNG-文件"><a href="#压缩-PNG-文件" class="headerlink" title="压缩 PNG 文件"></a>压缩 PNG 文件</h3><p>aapt 工具可以在编译过程中通过无损压缩来优化放置在 res/drawable/ 中的图片资源。例如，aapt 工具可以通过调色板将不需要超过 256 种颜色的真彩色 PNG 转换为 8 位 PNG。这样做会生成质量相同但内存占用量更小的图片。</p><h3 id="使用-WebP-文件格式"><a href="#使用-WebP-文件格式" class="headerlink" title="使用 WebP 文件格式"></a>使用 WebP 文件格式</h3><p>如果以 Android 3.2（API 级别 13）及更高版本为目标，您还可以使用 WebP 文件格式的图片（而不是使用 PNG 或 JPEG 文件）。WebP 格式提供有损压缩（如 JPEG）以及透明度（如 PNG），不过与 JPEG 或 PNG 相比，这种格式可以提供更好的压缩效果。</p><h3 id="使用矢量图形"><a href="#使用矢量图形" class="headerlink" title="使用矢量图形"></a>使用矢量图形</h3><p>您可以使用矢量图形创建与分辨率无关的图标和其他可伸缩媒体。使用这些图形可以极大地减少 APK 占用的空间。 矢量图片在 Android 中以 VectorDrawable 对象的形式表示。借助 VectorDrawable 对象，100 字节的文件可以生成与屏幕大小相同的清晰图片。</p><p>不过，系统渲染每个 VectorDrawable 对象需要花费大量时间，而较大的图片则需要更长的时间才能显示在屏幕上。因此，请考虑仅在显示小图片时使用这些矢量图形。</p><h2 id="内存管理概览"><a href="#内存管理概览" class="headerlink" title="内存管理概览"></a>内存管理概览</h2><p>Android 运行时 (ART) 和 Dalvik 虚拟机使用分页和内存映射来管理内存。这意味着应用修改的任何内存，无论修改的方式是分配新对象还是轻触内存映射的页面，都会一直驻留在 RAM 中，并且无法换出。要从应用中释放内存，只能释放应用保留的对象引用，使内存可供垃圾回收器回收。这种情况有一个例外：对于任何未经修改的内存映射文件（如代码），如果系统想要在其他位置使用其内存，可将其从 RAM 中换出。</p><h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p>ART 或 Dalvik 虚拟机之类的受管内存环境会跟踪每次内存分配。一旦确定程序不再使用某块内存，它就会将该内存重新释放到堆中，无需程序员进行任何干预。这种回收受管内存环境中的未使用内存的机制称为“垃圾回收”。垃圾回收有两个目标：在程序中查找将来无法访问的数据对象，并回收这些对象使用的资源。</p><p>Android 的内存堆是分代的，这意味着它会根据分配对象的预期寿命和大小跟踪不同的分配存储分区。例如，最近分配的对象属于“新生代”。当某个对象保持活动状态达足够长的时间时，可将其提升为较老代，然后是永久代。</p><p>堆的每一代对相应对象可占用的内存量都有其自身的专用上限。每当一代开始填满时，系统便会执行垃圾回收事件以释放内存。垃圾回收的持续时间取决于它回收的是哪一代对象以及每一代有多少个活动对象。</p><p>尽管垃圾回收速度非常快，但仍会影响应用的性能。通常情况下，您无法从代码中控制何时发生垃圾回收事件。系统有一套专门确定何时执行垃圾回收的标准。当条件满足时，系统会停止执行进程并开始垃圾回收。如果在动画或音乐播放等密集型处理循环过程中发生垃圾回收，则可能会增加处理时间，进而可能会导致应用中的代码执行超出建议的 16ms 阈值，无法实现高效、流畅的帧渲染。</p><p>此外，您的代码流执行的各种工作可能迫使垃圾回收事件发生得更频繁或导致其持续时间超过正常范围。 例如，如果您在 Alpha 混合动画的每一帧期间，在 for 循环的最内层分配多个对象，则可能会使内存堆受到大量对象的影响。在这种情况下，垃圾回收器会执行多个垃圾回收事件，并可能降低应用的性能。</p><h3 id="谨慎使用服务"><a href="#谨慎使用服务" class="headerlink" title="谨慎使用服务"></a>谨慎使用服务</h3><p>在不需要某项服务时让其保持运行状态，是 Android 应用可能犯下的最严重的内存管理错误之一。如果您的应用需要某项服务在后台执行工作，请不要让其保持运行状态，除非其需要运行作业。请注意在服务完成任务后使其停止运行。否则，您可能会在无意中导致内存泄漏。</p><p>在您启动某项服务后，系统更倾向于让此服务的进程始终保持运行状态。这种行为会导致服务进程代价十分高昂，因为一旦服务使用了某部分 RAM，那么这部分 RAM 就不再可供其他进程使用。这会减少系统可以在 LRU 缓存中保留的缓存进程数量，从而降低应用切换效率。当内存紧张，并且系统无法维护足够的进程以托管当前运行的所有服务时，这甚至可能导致系统出现抖动。</p><p>您通常应该避免使用持久性服务，因为它们会对可用内存提出持续性的要求。我们建议您采用 JobSchedulerJobScheduler 等替代实现方式。要详细了解如何使用 JobScheduler 调度后台进程，请参阅后台优化。</p><p>如果您必须使用某项服务，则限制此服务的生命周期的最佳方式是使用 IntentService，它会在处理完启动它的 intent 后立即自行结束。有关详情，请参阅在后台服务中运行。</p><h3 id="使用经过优化的数据容器"><a href="#使用经过优化的数据容器" class="headerlink" title="使用经过优化的数据容器"></a>使用经过优化的数据容器</h3><p>编程语言所提供的部分类并未针对移动设备做出优化。例如，常规 HashMap 实现的内存效率可能十分低下，因为每个映射都需要分别对应一个单独的条目对象。</p><p>Android 框架包含几个经过优化的数据容器，包括 SparseArray、SparseBooleanArray 和 LongSparseArray。 例如，SparseArray 类的效率更高，因为它们可以避免系统需要对键（有时还对值）进行自动装箱（这会为每个条目分别再创建 1-2 个对象）。</p><p>如果需要，您可以随时切换到原始数组以获得非常精简的数据结构。</p><h3 id="避免内存抖动"><a href="#避免内存抖动" class="headerlink" title="避免内存抖动"></a>避免内存抖动</h3><p>如前所述，垃圾回收事件通常不会影响应用的性能。不过，如果在短时间内发生许多垃圾回收事件，就可能会快速耗尽帧时间。系统花在垃圾回收上的时间越多，能够花在呈现或流式传输音频等其他任务上的时间就越少。</p><p>通常，“内存抖动”可能会导致出现大量的垃圾回收事件。实际上，内存抖动可以说明在给定时间内出现的已分配临时对象的数量。</p><p>例如，您可以在 for 循环中分配多个临时对象。或者，您也可以在视图的 onDraw() 函数中创建新的 Paint 或 Bitmap 对象。在这两种情况下，应用都会快速创建大量对象。这些操作可以快速消耗新生代 (young generation) 区域中的所有可用内存，从而迫使垃圾回收事件发生。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;原文地址:&lt;a href=&quot;https://developer.android.google.cn/topic/performance&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://developer.androi
      
    
    </summary>
    
    
      <category term="android" scheme="http://ShenZhen2017.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>ARTS打卡8</title>
    <link href="http://ShenZhen2017.github.io/blog/2020/12/arts-way-eight.html"/>
    <id>http://ShenZhen2017.github.io/blog/2020/12/arts-way-eight.html</id>
    <published>2020-12-08T08:05:22.000Z</published>
    <updated>2020-12-16T16:00:43.376Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><blockquote><p><a href="https://leetcode-cn.com/contest/weekly-contest-219/problems/count-of-matches-in-tournament/" target="_blank" rel="noopener">5625. 比赛中的配对次数</a><br>给你一个整数 n ，表示比赛中的队伍数。比赛遵循一种独特的赛制：<br>如果当前队伍数是 偶数 ，那么每支队伍都会与另一支队伍配对。总共进行 n / 2 场比赛，且产生 n / 2 支队伍进入下一轮。<br>如果当前队伍数为 奇数 ，那么将会随机轮空并晋级一支队伍，其余的队伍配对。总共进行 (n - 1) / 2 场比赛，且产生 (n - 1) / 2 + 1 支队伍进入下一轮。<br>返回在比赛中进行的配对次数，直到决出获胜队伍为止。</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">numberOfMatches</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n==<span class="number">0</span>||n==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">if</span> (n%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">            n/<span class="number">2</span>+numberOfMatches(n/<span class="number">2</span>)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            (n-<span class="number">1</span>)/<span class="number">2</span> + numberOfMatches((n-<span class="number">1</span>)/<span class="number">2</span>+<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p><a href="https://developers.google.cn/codelabs/advanced-android-kotlin-training-property-animation#0" target="_blank" rel="noopener">https://developers.google.cn/codelabs/advanced-android-kotlin-training-property-animation#0</a><br>本文主要讲述了android属性动画，是MotionLayout动画的前置知识</p><h2 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h2><h3 id="Git合并多个commit的操作"><a href="#Git合并多个commit的操作" class="headerlink" title="Git合并多个commit的操作"></a>Git合并多个commit的操作</h3><p>当我们需要合并多个提交时，可以使用git rebase -i<br>详情可见：<a href="https://www.jianshu.com/p/964de879904a" target="_blank" rel="noopener">「Git」合并多个 Commit</a></p><h3 id="LineHeight失效问题"><a href="#LineHeight失效问题" class="headerlink" title="LineHeight失效问题"></a>LineHeight失效问题</h3><p>lineHeight的兼容性不好，在很多机型上会失效<br>建议使用lineSpacingExtra替代</p><h3 id="部分机型虚线绘制失效的问题"><a href="#部分机型虚线绘制失效的问题" class="headerlink" title="部分机型虚线绘制失效的问题"></a>部分机型虚线绘制失效的问题</h3><p>直接使用DashEffect会有部分机型失效的问题，可以使用以下方法绘制虚线<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">drawHDashLine</span><span class="params">(canvas: <span class="type">Canvas</span>?, startX: <span class="type">Float</span>, stopX: <span class="type">Float</span>, lineY: <span class="type">Float</span>, paintChineseMindLine: <span class="type">Paint</span>, line: <span class="type">Float</span>, empty: <span class="type">Float</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">var</span> drawPointX = startX</span><br><span class="line">            <span class="keyword">var</span> isLine = <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> (drawPointX &lt; stopX) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isLine == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">val</span> start = drawPointX</span><br><span class="line">                    drawPointX = <span class="keyword">if</span> ((drawPointX + line) &gt;= stopX) stopX <span class="keyword">else</span> drawPointX + line</span><br><span class="line">                    canvas?.drawLine(start, lineY, drawPointX, lineY, paintChineseMindLine)</span><br><span class="line">                    isLine = <span class="number">0</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    drawPointX = <span class="keyword">if</span> ((drawPointX + empty) &gt;= stopX) stopX <span class="keyword">else</span> drawPointX + empty</span><br><span class="line">                    isLine = <span class="number">1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p><h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p>本周主要是翻译：<br>【译】取代Android的LiveData:StateFlow还是SharedFlow？<br>详情可见：<a href="https://shenzhen2017.github.io/blog/2020/12/translate-substituing-liveData.html">https://shenzhen2017.github.io/blog/2020/12/translate-substituing-liveData.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Algorithm&quot;&gt;&lt;a href=&quot;#Algorithm&quot; class=&quot;headerlink&quot; title=&quot;Algorithm&quot;&gt;&lt;/a&gt;Algorithm&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.
      
    
    </summary>
    
    
      <category term="ARTS" scheme="http://ShenZhen2017.github.io/tags/ARTS/"/>
    
  </entry>
  
  <entry>
    <title>【2020年终总结】程序员的三年之痒</title>
    <link href="http://ShenZhen2017.github.io/blog/2020/12/2020-sum-up.html"/>
    <id>http://ShenZhen2017.github.io/blog/2020/12/2020-sum-up.html</id>
    <published>2020-12-06T02:05:32.000Z</published>
    <updated>2020-12-16T16:00:43.376Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对程序员来说，三年是个坎。<br>三年时间，足以让一个刚出校门的年轻人成长为一个真正的打工人。<br>三年时间，可以积累一定的工作经验，拥有一定的技术成长。<br>三年时间，不算太长也不算太短，是一个跳槽的好时机，毕竟有不少工作都是要求3年以上经验。   </p><p>这大概就是程序员三年之痒的来源~   </p><h2 id="2020的收获"><a href="#2020的收获" class="headerlink" title="2020的收获"></a>2020的收获</h2><p>2020是一个神奇的一年，发生了许多大事，但回到个人身上也只是一件一件小事。<br>一件一件小事本没有什么意义，但只要注意积累，重复练习，积少成多，应该也会有一定的价值~<br>下面总结一些2020年的一些小收获   </p><ul><li>完成了第一次跳槽</li><li>掘金升级到了Lv2,阅读量3万+</li><li>拿到了掘金搪瓷杯和卫衣</li><li>有两篇文章被鸿洋大神转载了</li><li>坚持了ARTS打卡</li><li>坚持了每周的总结与下周规划</li></ul><h2 id="2021的展望"><a href="#2021的展望" class="headerlink" title="2021的展望"></a>2021的展望</h2><p>2021,新的一年，新的开始<br>下面列出2021的一些目标与展望        </p><ul><li>掘金升级到LV4</li><li>做一个100以上star的Github开源项目</li><li>读几本计算机原理，计算机网络，数据结构等基础领域的书</li><li>掌握flutter的使用与相关原理</li><li>最后，希望以上都能实现</li></ul><h2 id="一些面试资源"><a href="#一些面试资源" class="headerlink" title="一些面试资源"></a>一些面试资源</h2><p>今年完成了第一次跳槽，积累了一些面试相关的资源，在这里总结一下，希望对读者有用。   </p><h3 id="简历"><a href="#简历" class="headerlink" title="简历"></a>简历</h3><p>首先是简历，一般找一个模板，填写掌握的技能和项目经历即可。<br>github上有一个不错的模板，详情可见：<a href="https://github.com/CyC2018/Markdown-Resume" target="_blank" rel="noopener">https://github.com/CyC2018/Markdown-Resume</a><br>项目clone后，个性Resuem.md即可，然后导出为pdf文件。<br>简历建议长度为2页，太长太短都不好。<br>建议用掌握与熟练掌握取代了解与精通。    </p><h3 id="刷题"><a href="#刷题" class="headerlink" title="刷题"></a>刷题</h3><p>算法题可以说是现在找工作必刷的了。不过根据我面试的经验，算法题总得来说问的还是比较少，还有一些公司是基本不问算法的。<br>当然如果碰到字节，快手这种每轮都问算法的公司，如果因为算法题拿不到offer就很可惜了。<br>算法题就好像高考语文的古诗词默写一样，分不多，但丢了就很可惜了。<br>根据我的经验，大概刷了，掌握100道题就足以应付面试了。<br>当然完全掌握需要重复练习，不是刷了一遍就可以的。<br>这里推荐一下极客时间上覃超的五遍刷题法    </p><h4 id="五遍刷题法"><a href="#五遍刷题法" class="headerlink" title="五遍刷题法"></a>五遍刷题法</h4><p>1.第一遍，直接看解法<br>多解法，比较解法优劣，默写好的解法<br>2.第二遍，打开leetcode，直接开始写<br>多种解法比较，调优<br>3.第三遍，过一天之后，再重复做题<br>4.第四遍，过了一周，再来反复练<br>5.第五遍，面试前一周，恢复性训练      </p><p>极客时间上每周四覃超老师都会直播面试，比较精彩，大家可以去看看。当然也没有必要去买算法课，看一看直播，了解下刷题的思路即可。<br>通过以上方法重复练习，大概刷100题就足以应付面试，如果每天刷3道，大概准备一个月即可    </p><h3 id="题库"><a href="#题库" class="headerlink" title="题库"></a>题库</h3><p>刷题也要注意，不要一题一题刷，比如Leetcode的每日一题<br>建议按知识点分类，这样比较方便重复练习与知识点掌握<br>在知识点刷过一遍后，也可以按照公司分类或者LeetCode热题100刷，一般公司出算法题也是有题库的<br>下面推荐几个题库供大家使用</p><h4 id="按知识点分类"><a href="#按知识点分类" class="headerlink" title="按知识点分类"></a>按知识点分类</h4><p><a href="https://github.com/yuanguangxin/LeetCode" target="_blank" rel="noopener">https://github.com/yuanguangxin/LeetCode</a><br><a href="https://github.com/zhangyixing1007/leetcode" target="_blank" rel="noopener">https://github.com/zhangyixing1007/leetcode</a>     </p><h4 id="按公司分类"><a href="#按公司分类" class="headerlink" title="按公司分类"></a>按公司分类</h4><p><a href="https://github.com/afatcoder/LeetcodeTop" target="_blank" rel="noopener">https://github.com/afatcoder/LeetcodeTop</a>    </p><h4 id="热题100"><a href="#热题100" class="headerlink" title="热题100"></a>热题100</h4><p><a href="https://zhuanlan.zhihu.com/p/84230862" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/84230862</a>    </p><h3 id="一些高质量面经总结"><a href="#一些高质量面经总结" class="headerlink" title="一些高质量面经总结"></a>一些高质量面经总结</h3><p><a href="https://juejin.cn/post/6876968255597051917" target="_blank" rel="noopener">三年经验Android开发面经总结</a><br><a href="https://github.com/Moosphan/Android-Daily-Interview" target="_blank" rel="noopener">Android面试每日一题,内容很多，包罗万象</a><br><a href="https://carlwe.com/2019/12/07/Android%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86%E9%94%A6/" target="_blank" rel="noopener">Android面试题集锦</a><br><a href="https://juejin.cn/post/6844904155153170439" target="_blank" rel="noopener">这些年，我所经历的所有面试｜写给正在求职的 Androider</a>    </p><h2 id="一些学习方法"><a href="#一些学习方法" class="headerlink" title="一些学习方法"></a>一些学习方法</h2><p>如上文所说，坚持是一件很难的事。正因为如此，我们需要通过一些方法来辅助我们。<br>提高放弃的成本，增强坚持下去的成就感，提高最终坚持下去的概率。   </p><h3 id="ARTS打卡"><a href="#ARTS打卡" class="headerlink" title="ARTS打卡"></a>ARTS打卡</h3><p>在开始ARTS打卡之前，先介绍一下什么是ARTS<br>ARTS 源于极客时间《左耳听风》专栏组织的一个学习打卡活动，四个字母对应着四个行动准则：     </p><ul><li>Algorithm：每周至少做一个 leetcode 的算法题</li><li>Review: 阅读并点评一篇英文技术文章</li><li>Tip：学习至少一个技术技巧</li><li>Share：[撰写并]分享一篇有观点和思考的技术文章<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog8/p1.png" alt></li></ul><p>ARTS打卡将坚持拆解成一个一个小任务，当你不太清楚该做什么的时候，当你感觉常常不了了之的时候，可以尝试下ARTS每周打卡。<br>为了提高坚持下去的动力，可以组建一个打卡群，或者发给朋友之类的，提高坚持下去的概率。<br>下面是我每周打卡的一些内容，读者可以参考下<br><a href="https://shenzhen2017.github.io/blog/2020/12/arts-way-seven.html">ARTS打卡7</a><br><a href="https://shenzhen2017.github.io/blog/2020/11/arts-way-six.html">ARTS打卡6</a></p><h3 id="每周总结与下周计划"><a href="#每周总结与下周计划" class="headerlink" title="每周总结与下周计划"></a>每周总结与下周计划</h3><p>为了实现预定的目标，我们需要将任务拆分成一个个小模块，每周制定计划并统计每周的完成率。<br>这样也有利于提高我们坚持下去的概率<br>最初我是在<a href="https://juejin.cn/user/4318537403878167" target="_blank" rel="noopener">jsonchao</a>大神在群里看到的<br>jsonchao大神关于性能优化的系列文章都很优秀，有需要的读者可以关注下         </p><p>jsonchao每周都会在群里发自己的学习计划与完成情况，在他的影响下我也逐渐开始用起了这个学习方法<br>下面给出每周总结与下周计划的示例，用的网站是<a href="http://mubu.com/app" target="_blank" rel="noopener">http://mubu.com/app</a><br><img src="https://raw.githubusercontent.com/shenzhen2017/Goal/master/2020/9%E6%9C%887%E6%97%A5%E8%87%B39%E6%9C%8813%E6%97%A5%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92.png" alt><br><img src="https://raw.githubusercontent.com/shenzhen2017/Goal/master/2020/9%E6%9C%887%E6%97%A5%E8%87%B39%E6%9C%8813%E6%97%A5%E5%AD%A6%E4%B9%A0%E5%AE%8C%E6%88%90%E6%83%85%E5%86%B5.png" alt><br>如果读者觉得有用，也可以尝试下这种方法  </p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>定目标是简单的，但更简单的是没有完成目标。<br>相信大家都有很多类似的体验，年初定好的计划，往往不了了之。<br>达成目标并不是一件简单的事，但我相信我们可以通过坚持做一件件简单的事来达成目标。<br>毕竟，坚持是一件最不简单的事   </p><p>罗老师曾经说过     </p><blockquote><p>“把车停到公司楼下， 我摸了摸，给同事买的几盒炒面依然滚烫。<br>去时的大雪完全停了，我打开天窗，车顶残留的雪落了我一头，能看到很多星星，凉凉的空气好得不像话，喇叭里的音乐也从重金属变成了钢琴曲…<br>突然我就伤感起来了：你只是勤奋工作，努力做好自己，结果很多你的同行就要倒闭了…生命真残酷啊。”<br>——罗永浩</p></blockquote><p>如果我们能够勤奋工作，努力做好自己，相信年底回过头来，会发现这一年有不少收获，会发现自己已经走出了很远。<br>2021,共勉~    </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;对程序员来说，三年是个坎。&lt;br&gt;三年时间，足以让一个刚出校门的年轻人成长为一个真正的打工人。&lt;br&gt;三年时间，可以积累一定的工作经验，拥有
      
    
    </summary>
    
    
      <category term="总结" scheme="http://ShenZhen2017.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
</feed>
