<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo博客安装配置</title>
    <url>/blog/2017/04/hexo-learn-start.html</url>
    <content><![CDATA[<p><strong>Hexo博客安装配置总结</strong>              </p>
<h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><ul>
<li><p>安装Hexo          </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mkdir hexo  <span class="comment">#创建一个文件夹</span></span><br><span class="line">cd hexo</span><br><span class="line">npm <span class="keyword">install</span> -g hexo-cli</span><br><span class="line">npm <span class="keyword">install</span> hexo <span class="comment">--save</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>部署Hexo：在Git shell 中输入         </p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">hexo init</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>安装Hexo 插件：自动生成sitemap,Rss，部署到git等，建议安装      </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">npm <span class="keyword">install</span> hexo-generator-<span class="keyword">index</span> <span class="comment">--save</span></span><br><span class="line">npm <span class="keyword">install</span> hexo-generator-<span class="keyword">archive</span> <span class="comment">--save</span></span><br><span class="line">npm <span class="keyword">install</span> hexo-generator-<span class="keyword">category</span> <span class="comment">--save</span></span><br><span class="line">npm <span class="keyword">install</span> hexo-generator-tag <span class="comment">--save</span></span><br><span class="line">npm <span class="keyword">install</span> hexo-<span class="keyword">server</span> <span class="comment">--save</span></span><br><span class="line">npm <span class="keyword">install</span> hexo-deployer-git <span class="comment">--save</span></span><br><span class="line">npm <span class="keyword">install</span> hexo-deployer-heroku <span class="comment">--save</span></span><br><span class="line">npm <span class="keyword">install</span> hexo-deployer-rsync <span class="comment">--save</span></span><br><span class="line">npm <span class="keyword">install</span> hexo-deployer-openshift <span class="comment">--save</span></span><br><span class="line">npm <span class="keyword">install</span> hexo-renderer-marked@<span class="number">0.2</span> <span class="comment">--save</span></span><br><span class="line">npm <span class="keyword">install</span> hexo-renderer-stylus@<span class="number">0.2</span> <span class="comment">--save</span></span><br><span class="line">npm <span class="keyword">install</span> hexo-generator-feed@<span class="number">1</span> <span class="comment">--save</span></span><br><span class="line">npm <span class="keyword">install</span> hexo-generator-sitemap@<span class="number">1</span> <span class="comment">--save</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Hexo常用的几个命令"><a href="#Hexo常用的几个命令" class="headerlink" title="Hexo常用的几个命令"></a>Hexo常用的几个命令</h3><h4 id="创建新博文"><a href="#创建新博文" class="headerlink" title="创建新博文"></a>创建新博文</h4><p>执行new命令，生成指定名称的文章至hexo\source_posts\postName.md。<br><figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">hexo <span class="keyword">new</span> <span class="type"></span>[layout] <span class="string">"postName"</span> <span class="meta">#新建文章</span></span><br></pre></td></tr></table></figure></p>
<h4 id="运行服务器"><a href="#运行服务器" class="headerlink" title="运行服务器"></a>运行服务器</h4><figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line">$ hexo <span class="keyword">server</span></span><br></pre></td></tr></table></figure>
<h4 id="生成静态站点文件"><a href="#生成静态站点文件" class="headerlink" title="生成静态站点文件"></a>生成静态站点文件</h4><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">hexo <span class="keyword">generate</span></span><br></pre></td></tr></table></figure>
<h4 id="部署到Git"><a href="#部署到Git" class="headerlink" title="部署到Git"></a>部署到Git</h4><p>部署到Github前需要配置_config.yml文件</p>
<p>添加如下内容：<br><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="attribute">deploy</span>:</span><br><span class="line">	<span class="attribute">type</span>: git</span><br><span class="line">	<span class="attribute">repository</span>: git<span class="variable">@github</span>.<span class="attribute">com</span>:shenzhen2017/shenzhen.github.io.git</span><br><span class="line">	<span class="attribute">branch</span>: master</span><br></pre></td></tr></table></figure></p>
<p>然后输入：<br><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>hexo deploy</span><br></pre></td></tr></table></figure></p>
<p>注意，在CMD中输入这个会报错，必须在git bash中输入。                   </p>
<h3 id="主题设置"><a href="#主题设置" class="headerlink" title="主题设置"></a>主题设置</h3><h4 id="下载主题"><a href="#下载主题" class="headerlink" title="下载主题"></a>下载主题</h4><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">cd</span> hexo目录</span><br><span class="line">$ git clone http<span class="variable">s:</span>//github.<span class="keyword">com</span>/iissnan/hexo-theme-<span class="keyword">next</span> themes/<span class="keyword">next</span></span><br></pre></td></tr></table></figure>
<h4 id="应用Hexo主题"><a href="#应用Hexo主题" class="headerlink" title="应用Hexo主题"></a>应用Hexo主题</h4><p>在hexo目录下找到_config.yml配置文件，找到 theme 字段，并将其值更改为 next，如下所示：<br><figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line">theme: <span class="keyword">next</span></span><br></pre></td></tr></table></figure></p>
<h4 id="添加标签tags页面"><a href="#添加标签tags页面" class="headerlink" title="添加标签tags页面"></a>添加标签tags页面</h4><p>定位到 Hexo 站点目录下，使用 hexo new page 新建一个页面，命名为 tags，布局格式为page：<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$ cd hexo目录</span><br><span class="line">$ hexo new<span class="built_in"> page </span>tags</span><br></pre></td></tr></table></figure></p>
<p>内容如下所示，如果要关闭tags页面的评论可以设置comments为false：<br><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">标签</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2014</span><span class="number">-12</span><span class="number">-22</span> <span class="number">12</span><span class="string">:39:04</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">"tags"</span></span><br><span class="line"><span class="attr">comments:</span> <span class="literal">false</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure></p>
<p>这样以后tags页面在每次执行hexo generate后自动更新,注意要设置type为comments。</p>
<h4 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h4><p>你也可以更改代码高亮的主题，一共有五种，可选的值有 normal，night， night blue， night bright， night eighties，修改themes\next_config.yml文件，如下所示：<br><figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">highlight_theme:</span> normal</span><br></pre></td></tr></table></figure></p>
<h4 id="一些常用主题设置"><a href="#一些常用主题设置" class="headerlink" title="一些常用主题设置"></a>一些常用主题设置</h4><p>添加介绍，Archive等标签<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: / || home</span><br><span class="line">  about: /about/ || user</span><br><span class="line">  tags: /tags/ || tags</span><br><span class="line">  #categories: /categories/ || th</span><br><span class="line">  archives: /archives/ || archive</span><br></pre></td></tr></table></figure></p>
<p>首页只展示部分，不展示全文<br><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">auto_excerpt:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">length:</span> <span class="number">150</span></span><br></pre></td></tr></table></figure></p>
<p>首页tab固定在顶部，样式修改<br><figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">scheme:</span> Mist</span><br></pre></td></tr></table></figure></p>
<p>关闭侧边栏<br><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">sidebar</span><br><span class="line">  <span class="keyword">display</span>: <span class="keyword">hide</span></span><br></pre></td></tr></table></figure></p>
<h4 id="统计访问量"><a href="#统计访问量" class="headerlink" title="统计访问量"></a>统计访问量</h4><p>可以在页面下方看到总的访问量与访问人数<br><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Show PV/UV of the website/page with busuanzi.</span></span><br><span class="line"><span class="comment"># Get more information on http://ibruce.info/2015/04/04/busuanzi/</span></span><br><span class="line"><span class="attr">busuanzi_count:</span></span><br><span class="line">  <span class="comment"># count values only if the other configs are false</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># custom uv span for the whole site</span></span><br><span class="line">  <span class="attr">site_uv:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">site_uv_header:</span> <span class="string">&lt;i</span> <span class="string">class="fa</span> <span class="string">fa-user"&gt;&lt;/i&gt;</span></span><br><span class="line">  <span class="attr">site_uv_footer:</span></span><br><span class="line">  <span class="comment"># custom pv span for the whole site</span></span><br><span class="line">  <span class="attr">site_pv:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">site_pv_header:</span> <span class="string">&lt;i</span> <span class="string">class="fa</span> <span class="string">fa-eye"&gt;&lt;/i&gt;</span></span><br><span class="line">  <span class="attr">site_pv_footer:</span></span><br><span class="line">  <span class="comment"># custom pv span for one page only</span></span><br><span class="line">  <span class="attr">page_pv:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">page_pv_header:</span> <span class="string">&lt;i</span> <span class="string">class="fa</span> <span class="string">fa-file-o"&gt;&lt;/i&gt;</span></span><br><span class="line">  <span class="attr">page_pv_footer:</span></span><br></pre></td></tr></table></figure></p>
<h4 id="支持搜索"><a href="#支持搜索" class="headerlink" title="支持搜索"></a>支持搜索</h4><p>详情可见：<br><a href="https://www.cnblogs.com/fsong/p/11759136.html" target="_blank" rel="noopener">Hexo next主题添加站内搜索功能</a><br>我们在使用过程中可能会碰到搜索结果url host不对的问题，可以通过以下方法解决<br><a href="https://blog.csdn.net/ksws0292756/article/details/82714984" target="_blank" rel="noopener">hexo next主题 站内搜索出现异常，无法正常跳转，跳转时出现异常</a></p>
<h4 id="在新电脑上hexo-g生成空白的问题"><a href="#在新电脑上hexo-g生成空白的问题" class="headerlink" title="在新电脑上hexo g生成空白的问题"></a>在新电脑上hexo g生成空白的问题</h4><p>主要原因是node版本太高<br>详情可见：<a href="https://zhuanlan.zhihu.com/p/136552969" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/136552969</a></p>
<h4 id="next主题配置"><a href="#next主题配置" class="headerlink" title="next主题配置"></a>next主题配置</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ===============================================================</span></span><br><span class="line"><span class="comment"># ========================= ATTENTION! ==========================</span></span><br><span class="line"><span class="comment"># ===============================================================</span></span><br><span class="line"><span class="comment"># NexT repository is moving here: https://github.com/theme-next</span></span><br><span class="line"><span class="comment"># ===============================================================</span></span><br><span class="line"><span class="comment"># It's rebase to v6.0.0 and future maintenance will resume there</span></span><br><span class="line"><span class="comment"># ===============================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Theme Core Configuration Settings</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set to true, if you want to fully override the default configuration.</span></span><br><span class="line"><span class="comment"># Useful if you don't want to inherit the theme _config.yml configurations.</span></span><br><span class="line"><span class="attr">override:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Site Information Settings</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># To get or check favicons visit: https://realfavicongenerator.net</span></span><br><span class="line"><span class="comment"># Put your favicons into `hexo-site/source/` (recommend) or `hexo-site/themes/next/source/images/` directory.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Default NexT favicons placed in `hexo-site/themes/next/source/images/` directory.</span></span><br><span class="line"><span class="comment"># And if you want to place your icons in `hexo-site/source/` root directory, you must remove `/images` prefix from pathes.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># For example, you put your favicons into `hexo-site/source/images` directory.</span></span><br><span class="line"><span class="comment"># Then need to rename &amp; redefine they on any other names, otherwise icons from Next will rewrite your custom icons in Hexo.</span></span><br><span class="line"><span class="attr">favicon:</span></span><br><span class="line">  <span class="attr">small:</span> <span class="string">/images/favicon-16x16-next.png</span></span><br><span class="line">  <span class="attr">medium:</span> <span class="string">/images/favicon-32x32-next.png</span></span><br><span class="line">  <span class="attr">apple_touch_icon:</span> <span class="string">/images/apple-touch-icon-next.png</span></span><br><span class="line">  <span class="attr">safari_pinned_tab:</span> <span class="string">/images/logo.svg</span></span><br><span class="line">  <span class="comment">#android_manifest: /images/manifest.json</span></span><br><span class="line">  <span class="comment">#ms_browserconfig: /images/browserconfig.xml</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set default keywords (Use a comma to separate)</span></span><br><span class="line"><span class="attr">keywords:</span> <span class="string">"Hexo, NexT"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set rss to false to disable feed link.</span></span><br><span class="line"><span class="comment"># Leave rss as empty to use site's feed link.</span></span><br><span class="line"><span class="comment"># Set rss to specific value if you have burned your feed already.</span></span><br><span class="line"><span class="attr">rss:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">footer:</span></span><br><span class="line">  <span class="comment"># Specify the date when the site was setup.</span></span><br><span class="line">  <span class="comment"># If not defined, current year will be used.</span></span><br><span class="line">  <span class="comment">#since: 2015</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Icon between year and copyright info.</span></span><br><span class="line">  <span class="attr">icon:</span> <span class="string">user</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># If not defined, will be used `author` from Hexo main config.</span></span><br><span class="line">  <span class="attr">copyright:</span></span><br><span class="line">  <span class="comment"># -------------------------------------------------------------</span></span><br><span class="line">  <span class="comment"># Hexo link (Powered by Hexo).</span></span><br><span class="line">  <span class="attr">powered:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">theme:</span></span><br><span class="line">    <span class="comment"># Theme &amp; scheme info link (Theme - NexT.scheme).</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># Version info of NexT after scheme info (vX.X.X).</span></span><br><span class="line">    <span class="attr">version:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># -------------------------------------------------------------</span></span><br><span class="line">  <span class="comment"># Any custom text can be defined here.</span></span><br><span class="line">  <span class="comment">#custom_text: Hosted by &lt;a target="_blank" href="https://pages.github.com"&gt;GitHub Pages&lt;/a&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># SEO Settings</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Canonical, set a canonical link tag in your hexo, you could use it for your SEO of blog.</span></span><br><span class="line"><span class="comment"># See: https://support.google.com/webmasters/answer/139066</span></span><br><span class="line"><span class="comment"># Tips: Before you open this tag, remember set up your URL in hexo _config.yml ( ex. url: http://yourdomain.com )</span></span><br><span class="line"><span class="attr">canonical:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Change headers hierarchy on site-subtitle (will be main site description) and on all post/pages titles for better SEO-optimization.</span></span><br><span class="line"><span class="attr">seo:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># If true, will add site-subtitle to index page, added in main hexo config.</span></span><br><span class="line"><span class="comment"># subtitle: Subtitle</span></span><br><span class="line"><span class="attr">index_with_subtitle:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Menu Settings</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># When running the site in a subdirectory (e.g. domain.tld/blog), remove the leading slash from link value (/archives -&gt; archives).</span></span><br><span class="line"><span class="comment"># Usage: `Key: /link/ || icon`</span></span><br><span class="line"><span class="comment"># Key is the name of menu item. If translate for this menu will find in languages - this translate will be loaded; if not - Key name will be used. Key is case-senstive.</span></span><br><span class="line"><span class="comment"># Value before `||` delimeter is the target link.</span></span><br><span class="line"><span class="comment"># Value after `||` delimeter is the name of FontAwesome icon. If icon (with or without delimeter) is not specified, question icon will be loaded.</span></span><br><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">home</span></span><br><span class="line">  <span class="attr">about:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">user</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">tags</span></span><br><span class="line">  <span class="comment">#categories: /categories/ || th</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">archive</span></span><br><span class="line">  <span class="comment">#schedule: /schedule/ || calendar</span></span><br><span class="line">  <span class="comment">#sitemap: /sitemap.xml || sitemap</span></span><br><span class="line">  <span class="comment">#commonweal: /404/ || heartbeat</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Enable/Disable menu icons.</span></span><br><span class="line"><span class="attr">menu_icons:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Scheme Settings</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Schemes</span></span><br><span class="line"><span class="comment">#scheme: Muse</span></span><br><span class="line"><span class="attr">scheme:</span> <span class="string">Mist</span></span><br><span class="line"><span class="comment">#scheme: Pisces</span></span><br><span class="line"><span class="comment">#scheme: Gemini</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Sidebar Settings</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Social Links.</span></span><br><span class="line"><span class="comment"># Usage: `Key: permalink || icon`</span></span><br><span class="line"><span class="comment"># Key is the link label showing to end users.</span></span><br><span class="line"><span class="comment"># Value before `||` delimeter is the target permalink.</span></span><br><span class="line"><span class="comment"># Value after `||` delimeter is the name of FontAwesome icon. If icon (with or without delimeter) is not specified, globe icon will be loaded.</span></span><br><span class="line"><span class="comment">#social:</span></span><br><span class="line">  <span class="comment">#GitHub: https://github.com/yourname || github</span></span><br><span class="line">  <span class="comment">#E-Mail: mailto:yourname@gmail.com || envelope</span></span><br><span class="line">  <span class="comment">#Google: https://plus.google.com/yourname || google</span></span><br><span class="line">  <span class="comment">#Twitter: https://twitter.com/yourname || twitter</span></span><br><span class="line">  <span class="comment">#FB Page: https://www.facebook.com/yourname || facebook</span></span><br><span class="line">  <span class="comment">#VK Group: https://vk.com/yourname || vk</span></span><br><span class="line">  <span class="comment">#StackOverflow: https://stackoverflow.com/yourname || stack-overflow</span></span><br><span class="line">  <span class="comment">#YouTube: https://youtube.com/yourname || youtube</span></span><br><span class="line">  <span class="comment">#Instagram: https://instagram.com/yourname || instagram</span></span><br><span class="line">  <span class="comment">#Skype: skype:yourname?call|chat || skype</span></span><br><span class="line"></span><br><span class="line"><span class="attr">social_icons:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">icons_only:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">transition:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Blog rolls</span></span><br><span class="line"><span class="attr">links_icon:</span> <span class="string">link</span></span><br><span class="line"><span class="attr">links_title:</span> <span class="string">Links</span></span><br><span class="line"><span class="attr">links_layout:</span> <span class="string">block</span></span><br><span class="line"><span class="comment">#links_layout: inline</span></span><br><span class="line"><span class="comment">#links:</span></span><br><span class="line">  <span class="comment">#Title: http://example.com/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Sidebar Avatar</span></span><br><span class="line"><span class="comment"># in theme directory(source/images): /images/avatar.gif</span></span><br><span class="line"><span class="comment"># in site  directory(source/uploads): /uploads/avatar.gif</span></span><br><span class="line"><span class="comment">#avatar: /images/avatar.gif</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Table Of Contents in the Sidebar</span></span><br><span class="line"><span class="attr">toc:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Automatically add list number to toc.</span></span><br><span class="line">  <span class="attr">number:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># If true, all words will placed on next lines if header width longer then sidebar width.</span></span><br><span class="line">  <span class="attr">wrap:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Creative Commons 4.0 International License.</span></span><br><span class="line"><span class="comment"># http://creativecommons.org/</span></span><br><span class="line"><span class="comment"># Available: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | zero</span></span><br><span class="line"><span class="comment">#creative_commons: by-nc-sa</span></span><br><span class="line"><span class="comment">#creative_commons:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">sidebar:</span></span><br><span class="line">  <span class="comment"># Sidebar Position, available value: left | right (only for Pisces | Gemini).</span></span><br><span class="line">  <span class="attr">position:</span> <span class="string">left</span></span><br><span class="line">  <span class="comment">#position: right</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Sidebar Display, available value (only for Muse | Mist):</span></span><br><span class="line">  <span class="comment">#  - post    expand on posts automatically. Default.</span></span><br><span class="line">  <span class="comment">#  - always  expand for all pages automatically</span></span><br><span class="line">  <span class="comment">#  - hide    expand only when click on the sidebar toggle icon.</span></span><br><span class="line">  <span class="comment">#  - remove  Totally remove sidebar including sidebar toggle.</span></span><br><span class="line">  <span class="comment">#display: post</span></span><br><span class="line">  <span class="comment">#display: always</span></span><br><span class="line">  <span class="attr">display:</span> <span class="string">hide</span></span><br><span class="line">  <span class="comment">#display: remove</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Sidebar offset from top menubar in pixels (only for Pisces | Gemini).</span></span><br><span class="line">  <span class="attr">offset:</span> <span class="number">12</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Back to top in sidebar (only for Pisces | Gemini).</span></span><br><span class="line">  <span class="attr">b2t:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Scroll percent label in b2t button.</span></span><br><span class="line">  <span class="attr">scrollpercent:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Enable sidebar on narrow view (only for Muse | Mist).</span></span><br><span class="line">  <span class="attr">onmobile:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Post Settings</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Automatically scroll page to section which is under &lt;!-- more --&gt; mark.</span></span><br><span class="line"><span class="attr">scroll_to_more:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Automatically saving scroll position on each post/page in cookies.</span></span><br><span class="line"><span class="attr">save_scroll:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Automatically excerpt description in homepage as preamble text.</span></span><br><span class="line"><span class="attr">excerpt_description:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Automatically Excerpt. Not recommend.</span></span><br><span class="line"><span class="comment"># Please use &lt;!-- more --&gt; in the post to control excerpt accurately.</span></span><br><span class="line"><span class="attr">auto_excerpt:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">length:</span> <span class="number">150</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Post meta display settings</span></span><br><span class="line"><span class="attr">post_meta:</span></span><br><span class="line">  <span class="attr">item_text:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">created_at:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">updated_at:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Post wordcount display settings</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/willin/hexo-wordcount</span></span><br><span class="line"><span class="attr">post_wordcount:</span></span><br><span class="line">  <span class="attr">item_text:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">wordcount:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">min2read:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">totalcount:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">separated_meta:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Wechat Subscriber</span></span><br><span class="line"><span class="comment">#wechat_subscriber:</span></span><br><span class="line">  <span class="comment">#enabled: true</span></span><br><span class="line">  <span class="comment">#qcode: /path/to/your/wechatqcode ex. /uploads/wechat-qcode.jpg</span></span><br><span class="line">  <span class="comment">#description: ex. subscribe to my blog by scanning my public wechat account</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Reward</span></span><br><span class="line"><span class="comment">#reward_comment: Donate comment here</span></span><br><span class="line"><span class="comment">#wechatpay: /images/wechatpay.jpg</span></span><br><span class="line"><span class="comment">#alipay: /images/alipay.jpg</span></span><br><span class="line"><span class="comment">#bitcoin: /images/bitcoin.png</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Declare license on posts</span></span><br><span class="line"><span class="attr">post_copyright:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">license:</span> <span class="string">CC</span> <span class="string">BY-NC-SA</span> <span class="number">3.0</span></span><br><span class="line">  <span class="attr">license_url:</span> <span class="string">https://creativecommons.org/licenses/by-nc-sa/3.0/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Misc Theme Settings</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Reduce padding / margin indents on devices with narrow width.</span></span><br><span class="line"><span class="attr">mobile_layout_economy:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Android Chrome header panel color ($black-deep).</span></span><br><span class="line"><span class="attr">android_chrome_color:</span> <span class="string">"#222"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Custom Logo.</span></span><br><span class="line"><span class="comment"># !!Only available for Default Scheme currently.</span></span><br><span class="line"><span class="comment"># Options:</span></span><br><span class="line"><span class="comment">#   enabled: [true/false] - Replace with specific image</span></span><br><span class="line"><span class="comment">#   image: url-of-image   - Images's url</span></span><br><span class="line"><span class="attr">custom_logo:</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">image:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Code Highlight theme</span></span><br><span class="line"><span class="comment"># Available value:</span></span><br><span class="line"><span class="comment">#    normal | night | night eighties | night blue | night bright</span></span><br><span class="line"><span class="comment"># https://github.com/chriskempson/tomorrow-theme</span></span><br><span class="line"><span class="attr">highlight_theme:</span> <span class="string">normal</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Font Settings</span></span><br><span class="line"><span class="comment"># - Find fonts on Google Fonts (https://www.google.com/fonts)</span></span><br><span class="line"><span class="comment"># - All fonts set here will have the following styles:</span></span><br><span class="line"><span class="comment">#     light, light italic, normal, normal italic, bold, bold italic</span></span><br><span class="line"><span class="comment"># - Be aware that setting too much fonts will cause site running slowly</span></span><br><span class="line"><span class="comment"># - Introduce in 5.0.1</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># CAUTION! Safari Version 10.1.2 <span class="doctag">bug:</span> https://github.com/iissnan/hexo-theme-next/issues/1844</span></span><br><span class="line"><span class="comment"># To avoid space between header and sidebar in Pisces / Gemini themes recommended to use Web Safe fonts for `global` (and `logo`):</span></span><br><span class="line"><span class="comment"># Arial | Tahoma | Helvetica | Times New Roman | Courier New | Verdana | Georgia | Palatino | Garamond | Comic Sans MS | Trebuchet MS</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="attr">font:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Uri of fonts host. E.g. //fonts.googleapis.com (Default).</span></span><br><span class="line">  <span class="attr">host:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Font options:</span></span><br><span class="line">  <span class="comment"># `external: true` will load this font family from `host` above.</span></span><br><span class="line">  <span class="comment"># `family: Times New Roman`. Without any quotes.</span></span><br><span class="line">  <span class="comment"># `size: xx`. Use `px` as unit.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Global font settings used on &lt;body&gt; element.</span></span><br><span class="line">  <span class="attr">global:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">family:</span> <span class="string">Lato</span></span><br><span class="line">    <span class="attr">size:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Font settings for Headlines (h1, h2, h3, h4, h5, h6).</span></span><br><span class="line">  <span class="comment"># Fallback to `global` font settings.</span></span><br><span class="line">  <span class="attr">headings:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">family:</span></span><br><span class="line">    <span class="attr">size:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Font settings for posts.</span></span><br><span class="line">  <span class="comment"># Fallback to `global` font settings.</span></span><br><span class="line">  <span class="attr">posts:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">family:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Font settings for Logo.</span></span><br><span class="line">  <span class="comment"># Fallback to `global` font settings.</span></span><br><span class="line">  <span class="attr">logo:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">family:</span></span><br><span class="line">    <span class="attr">size:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Font settings for &lt;code&gt; and code blocks.</span></span><br><span class="line">  <span class="attr">codes:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">family:</span></span><br><span class="line">    <span class="attr">size:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Third Party Services Settings</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># MathJax Support</span></span><br><span class="line"><span class="attr">mathjax:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">per_page:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">cdn:</span> <span class="string">//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Han Support docs: https://hanzi.pro/</span></span><br><span class="line"><span class="attr">han:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Swiftype Search API Key</span></span><br><span class="line"><span class="comment">#swiftype_key:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Baidu Analytics ID</span></span><br><span class="line"><span class="comment">#baidu_analytics:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Duoshuo ShortName</span></span><br><span class="line"><span class="comment">#duoshuo_shortname:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Disqus</span></span><br><span class="line"><span class="attr">disqus:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">shortname:</span></span><br><span class="line">  <span class="attr">count:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Hypercomments</span></span><br><span class="line"><span class="comment">#hypercomments_id:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># changyan</span></span><br><span class="line"><span class="attr">changyan:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">appid:</span></span><br><span class="line">  <span class="attr">appkey:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Valine.</span></span><br><span class="line"><span class="comment"># You can get your appid and appkey from https://leancloud.cn</span></span><br><span class="line"><span class="comment"># more info please open https://valine.js.org</span></span><br><span class="line"><span class="attr">valine:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">appid:</span>  <span class="comment"># your leancloud application appid</span></span><br><span class="line">  <span class="attr">appkey:</span>  <span class="comment"># your leancloud application appkey</span></span><br><span class="line">  <span class="attr">notify:</span> <span class="literal">false</span> <span class="comment"># mail notifier , https://github.com/xCss/Valine/wiki</span></span><br><span class="line">  <span class="attr">verify:</span> <span class="literal">false</span> <span class="comment"># Verification code</span></span><br><span class="line">  <span class="attr">placeholder:</span> <span class="string">Just</span> <span class="string">go</span> <span class="string">go</span> <span class="comment"># comment box placeholder</span></span><br><span class="line">  <span class="attr">avatar:</span> <span class="string">mm</span> <span class="comment"># gravatar style</span></span><br><span class="line">  <span class="attr">guest_info:</span> <span class="string">nick,mail,link</span> <span class="comment"># custom comment header</span></span><br><span class="line">  <span class="attr">pageSize:</span> <span class="number">10</span> <span class="comment"># pagination size</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Support for youyan comments system.</span></span><br><span class="line"><span class="comment"># You can get your uid from http://www.uyan.cc</span></span><br><span class="line"><span class="comment">#youyan_uid: your uid</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Support for LiveRe comments system.</span></span><br><span class="line"><span class="comment"># You can get your uid from https://livere.com/insight/myCode (General web site)</span></span><br><span class="line"><span class="comment">#livere_uid: your uid</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Gitment</span></span><br><span class="line"><span class="comment"># Introduction: https://imsun.net/posts/gitment-introduction/</span></span><br><span class="line"><span class="comment"># You can get your Github ID from https://api.github.com/users/&lt;Github username&gt;</span></span><br><span class="line"><span class="attr">gitment:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">mint:</span> <span class="literal">true</span> <span class="comment"># RECOMMEND, A mint on Gitment, to support count, language and proxy_gateway</span></span><br><span class="line">  <span class="attr">count:</span> <span class="literal">true</span> <span class="comment"># Show comments count in post meta area</span></span><br><span class="line">  <span class="attr">lazy:</span> <span class="literal">false</span> <span class="comment"># Comments lazy loading with a button</span></span><br><span class="line">  <span class="attr">cleanly:</span> <span class="literal">false</span> <span class="comment"># Hide 'Powered by ...' on footer, and more</span></span><br><span class="line">  <span class="attr">language:</span> <span class="comment"># Force language, or auto switch by theme</span></span><br><span class="line">  <span class="attr">github_user:</span> <span class="comment"># MUST HAVE, Your Github ID</span></span><br><span class="line">  <span class="attr">github_repo:</span> <span class="comment"># MUST HAVE, The repo you use to store Gitment comments</span></span><br><span class="line">  <span class="attr">client_id:</span> <span class="comment"># MUST HAVE, Github client id for the Gitment</span></span><br><span class="line">  <span class="attr">client_secret:</span> <span class="comment"># EITHER this or proxy_gateway, Github access secret token for the Gitment</span></span><br><span class="line">  <span class="attr">proxy_gateway:</span> <span class="comment"># Address of api proxy, See: https://github.com/aimingoo/intersect</span></span><br><span class="line">  <span class="attr">redirect_protocol:</span> <span class="comment"># Protocol of redirect_uri with force_redirect_protocol when mint enabled</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Baidu Share</span></span><br><span class="line"><span class="comment"># Available value:</span></span><br><span class="line"><span class="comment">#    button | slide</span></span><br><span class="line"><span class="comment"># Warning: Baidu Share does not support https.</span></span><br><span class="line"><span class="comment">#baidushare:</span></span><br><span class="line"><span class="comment">##  type: button</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Share</span></span><br><span class="line"><span class="comment"># This plugin is more useful in China, make sure you known how to use it.</span></span><br><span class="line"><span class="comment"># And you can find the use guide at official webiste: http://www.jiathis.com/.</span></span><br><span class="line"><span class="comment"># Warning: JiaThis does not support https.</span></span><br><span class="line"><span class="comment">#jiathis:</span></span><br><span class="line">  <span class="comment">##uid: Get this uid from http://www.jiathis.com/</span></span><br><span class="line"><span class="comment">#add_this_id:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Share</span></span><br><span class="line"><span class="comment">#duoshuo_share: true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># NeedMoreShare2</span></span><br><span class="line"><span class="comment"># This plugin is a pure javascript sharing lib which is useful in China.</span></span><br><span class="line"><span class="comment"># See: https://github.com/revir/need-more-share2</span></span><br><span class="line"><span class="comment"># Also see: https://github.com/DzmVasileusky/needShareButton</span></span><br><span class="line"><span class="comment"># iconStyle: default | box</span></span><br><span class="line"><span class="comment"># boxForm: horizontal | vertical</span></span><br><span class="line"><span class="comment"># position: top / middle / bottom + Left / Center / Right</span></span><br><span class="line"><span class="comment"># networks: Weibo,Wechat,Douban,QQZone,Twitter,Linkedin,Mailto,Reddit,</span></span><br><span class="line"><span class="comment">#           Delicious,StumbleUpon,Pinterest,Facebook,GooglePlus,Slashdot,</span></span><br><span class="line"><span class="comment">#           Technorati,Posterous,Tumblr,GoogleBookmarks,Newsvine,</span></span><br><span class="line"><span class="comment">#           Evernote,Friendfeed,Vkontakte,Odnoklassniki,Mailru</span></span><br><span class="line"><span class="attr">needmoreshare2:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">postbottom:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">options:</span></span><br><span class="line">      <span class="attr">iconStyle:</span> <span class="string">box</span></span><br><span class="line">      <span class="attr">boxForm:</span> <span class="string">horizontal</span></span><br><span class="line">      <span class="attr">position:</span> <span class="string">bottomCenter</span></span><br><span class="line">      <span class="attr">networks:</span> <span class="string">Weibo,Wechat,Douban,QQZone,Twitter,Facebook</span></span><br><span class="line">  <span class="attr">float:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">options:</span></span><br><span class="line">      <span class="attr">iconStyle:</span> <span class="string">box</span></span><br><span class="line">      <span class="attr">boxForm:</span> <span class="string">horizontal</span></span><br><span class="line">      <span class="attr">position:</span> <span class="string">middleRight</span></span><br><span class="line">      <span class="attr">networks:</span> <span class="string">Weibo,Wechat,Douban,QQZone,Twitter,Facebook</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Google Webmaster tools verification setting</span></span><br><span class="line"><span class="comment"># See: https://www.google.com/webmasters/</span></span><br><span class="line"><span class="comment">#google_site_verification:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Google Analytics</span></span><br><span class="line"><span class="comment">#google_analytics:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Bing Webmaster tools verification setting</span></span><br><span class="line"><span class="comment"># See: https://www.bing.com/webmaster/</span></span><br><span class="line"><span class="comment">#bing_site_verification:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Yandex Webmaster tools verification setting</span></span><br><span class="line"><span class="comment"># See: https://webmaster.yandex.ru/</span></span><br><span class="line"><span class="comment">#yandex_site_verification:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># CNZZ count</span></span><br><span class="line"><span class="comment">#cnzz_siteid:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Application Insights</span></span><br><span class="line"><span class="comment"># See https://azure.microsoft.com/en-us/services/application-insights/</span></span><br><span class="line"><span class="comment"># application_insights:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Make duoshuo show UA</span></span><br><span class="line"><span class="comment"># user_id must NOT be null when admin_enable is true!</span></span><br><span class="line"><span class="comment"># you can visit http://dev.duoshuo.com get duoshuo user id.</span></span><br><span class="line"><span class="attr">duoshuo_info:</span></span><br><span class="line">  <span class="attr">ua_enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">admin_enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">user_id:</span> <span class="number">0</span></span><br><span class="line">  <span class="comment">#admin_nickname: Author</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Post widgets &amp; FB/VK comments settings.</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Facebook SDK Support.</span></span><br><span class="line"><span class="comment"># https://github.com/iissnan/hexo-theme-next/pull/410</span></span><br><span class="line"><span class="attr">facebook_sdk:</span></span><br><span class="line">  <span class="attr">enable:</span>       <span class="literal">false</span></span><br><span class="line">  <span class="attr">app_id:</span>       <span class="comment">#&lt;app_id&gt;</span></span><br><span class="line">  <span class="attr">fb_admin:</span>     <span class="comment">#&lt;user_id&gt;</span></span><br><span class="line">  <span class="attr">like_button:</span>  <span class="comment">#true</span></span><br><span class="line">  <span class="attr">webmaster:</span>    <span class="comment">#true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Facebook comments plugin</span></span><br><span class="line"><span class="comment"># This plugin depends on Facebook SDK.</span></span><br><span class="line"><span class="comment"># If facebook_sdk.enable is false, Facebook comments plugin is unavailable.</span></span><br><span class="line"><span class="attr">facebook_comments_plugin:</span></span><br><span class="line">  <span class="attr">enable:</span>       <span class="literal">false</span></span><br><span class="line">  <span class="attr">num_of_posts:</span> <span class="number">10</span>    <span class="comment"># min posts num is 1</span></span><br><span class="line">  <span class="attr">width:</span>        <span class="number">100</span><span class="string">%</span>  <span class="comment"># default width is 550px</span></span><br><span class="line">  <span class="attr">scheme:</span>       <span class="string">light</span> <span class="comment"># default scheme is light (light or dark)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># VKontakte API Support.</span></span><br><span class="line"><span class="comment"># To get your AppID visit https://vk.com/editapp?act=create</span></span><br><span class="line"><span class="attr">vkontakte_api:</span></span><br><span class="line">  <span class="attr">enable:</span>       <span class="literal">false</span></span><br><span class="line">  <span class="attr">app_id:</span>       <span class="comment">#&lt;app_id&gt;</span></span><br><span class="line">  <span class="attr">like:</span>         <span class="literal">true</span></span><br><span class="line">  <span class="attr">comments:</span>     <span class="literal">true</span></span><br><span class="line">  <span class="attr">num_of_posts:</span> <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Star rating support to each article.</span></span><br><span class="line"><span class="comment"># To get your ID visit https://widgetpack.com</span></span><br><span class="line"><span class="attr">rating:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">id:</span>     <span class="comment">#&lt;app_id&gt;</span></span><br><span class="line">  <span class="attr">color:</span>  <span class="string">fc6423</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Show number of visitors to each article.</span></span><br><span class="line"><span class="comment"># You can visit https://leancloud.cn get AppID and AppKey.</span></span><br><span class="line"><span class="attr">leancloud_visitors:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">app_id:</span> <span class="comment">#&lt;app_id&gt;</span></span><br><span class="line">  <span class="attr">app_key:</span> <span class="comment">#&lt;app_key&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Another tool to show number of visitors to each article.</span></span><br><span class="line"><span class="comment"># visit https://console.firebase.google.com/u/0/ to get apiKey and projectId</span></span><br><span class="line"><span class="comment"># visit https://firebase.google.com/docs/firestore/ to get more information about firestore</span></span><br><span class="line"><span class="attr">firestore:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">collection:</span> <span class="string">articles</span> <span class="comment">#required, a string collection name to access firestore database</span></span><br><span class="line">  <span class="attr">apiKey:</span> <span class="comment">#required</span></span><br><span class="line">  <span class="attr">projectId:</span> <span class="comment">#required</span></span><br><span class="line">  <span class="attr">bluebird:</span> <span class="literal">false</span> <span class="comment">#enable this if you want to include bluebird 3.5.1(core version) Promise polyfill</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Show PV/UV of the website/page with busuanzi.</span></span><br><span class="line"><span class="comment"># Get more information on http://ibruce.info/2015/04/04/busuanzi/</span></span><br><span class="line"><span class="attr">busuanzi_count:</span></span><br><span class="line">  <span class="comment"># count values only if the other configs are false</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># custom uv span for the whole site</span></span><br><span class="line">  <span class="attr">site_uv:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">site_uv_header:</span> <span class="string">&lt;i</span> <span class="string">class="fa</span> <span class="string">fa-user"&gt;&lt;/i&gt;</span></span><br><span class="line">  <span class="attr">site_uv_footer:</span></span><br><span class="line">  <span class="comment"># custom pv span for the whole site</span></span><br><span class="line">  <span class="attr">site_pv:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">site_pv_header:</span> <span class="string">&lt;i</span> <span class="string">class="fa</span> <span class="string">fa-eye"&gt;&lt;/i&gt;</span></span><br><span class="line">  <span class="attr">site_pv_footer:</span></span><br><span class="line">  <span class="comment"># custom pv span for one page only</span></span><br><span class="line">  <span class="attr">page_pv:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">page_pv_header:</span> <span class="string">&lt;i</span> <span class="string">class="fa</span> <span class="string">fa-file-o"&gt;&lt;/i&gt;</span></span><br><span class="line">  <span class="attr">page_pv_footer:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Tencent analytics ID</span></span><br><span class="line"><span class="comment"># tencent_analytics:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Tencent MTA ID</span></span><br><span class="line"><span class="comment"># tencent_mta:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Enable baidu push so that the blog will push the url to baidu automatically which is very helpful for SEO</span></span><br><span class="line"><span class="attr">baidu_push:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Google Calendar</span></span><br><span class="line"><span class="comment"># Share your recent schedule to others via calendar page</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># API Documentation:</span></span><br><span class="line"><span class="comment"># https://developers.google.com/google-apps/calendar/v3/reference/events/list</span></span><br><span class="line"><span class="attr">calendar:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">calendar_id:</span> <span class="string">&lt;required&gt;</span></span><br><span class="line">  <span class="attr">api_key:</span> <span class="string">&lt;required&gt;</span></span><br><span class="line">  <span class="attr">orderBy:</span> <span class="string">startTime</span></span><br><span class="line">  <span class="attr">offsetMax:</span> <span class="number">24</span></span><br><span class="line">  <span class="attr">offsetMin:</span> <span class="number">4</span></span><br><span class="line">  <span class="attr">timeZone:</span></span><br><span class="line">  <span class="attr">showDeleted:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">singleEvents:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">maxResults:</span> <span class="number">250</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Algolia Search</span></span><br><span class="line"><span class="attr">algolia_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">hits:</span></span><br><span class="line">    <span class="attr">per_page:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">input_placeholder:</span> <span class="string">Search</span> <span class="string">for</span> <span class="string">Posts</span></span><br><span class="line">    <span class="attr">hits_empty:</span> <span class="string">"We didn't find any results for the search: $&#123;query&#125;"</span></span><br><span class="line">    <span class="attr">hits_stats:</span> <span class="string">"$&#123;hits&#125; results found in $&#123;time&#125; ms"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Local search</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/flashlab/hexo-generator-search</span></span><br><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># if auto, trigger search by changing input</span></span><br><span class="line">  <span class="comment"># if manual, trigger search by pressing enter key or search button</span></span><br><span class="line">  <span class="attr">trigger:</span> <span class="string">auto</span></span><br><span class="line">  <span class="comment"># show top n results per article, show all results by setting to -1</span></span><br><span class="line">  <span class="attr">top_n_per_article:</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Tags Settings</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># External URL with BASE64 encrypt &amp; decrypt.</span></span><br><span class="line"><span class="comment"># Usage: &#123;% exturl text url "title" %&#125;</span></span><br><span class="line"><span class="comment"># Alias: &#123;% extlink text url "title" %&#125;</span></span><br><span class="line"><span class="attr">exturl:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Note tag (bs-callout).</span></span><br><span class="line"><span class="attr">note:</span></span><br><span class="line">  <span class="comment"># Note tag style values:</span></span><br><span class="line">  <span class="comment">#  - simple    bs-callout old alert style. Default.</span></span><br><span class="line">  <span class="comment">#  - modern    bs-callout new (v2-v3) alert style.</span></span><br><span class="line">  <span class="comment">#  - flat      flat callout style with background, like on Mozilla or StackOverflow.</span></span><br><span class="line">  <span class="comment">#  - disabled  disable all CSS styles import of note tag.</span></span><br><span class="line">  <span class="attr">style:</span> <span class="string">simple</span></span><br><span class="line">  <span class="attr">icons:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">border_radius:</span> <span class="number">3</span></span><br><span class="line">  <span class="comment"># Offset lighter of background in % for modern and flat styles (modern: -12 | 12; flat: -18 | 6).</span></span><br><span class="line">  <span class="comment"># Offset also applied to label tag variables. This option can work with disabled note tag.</span></span><br><span class="line">  <span class="attr">light_bg_offset:</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Label tag.</span></span><br><span class="line"><span class="attr">label:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Tabs tag.</span></span><br><span class="line"><span class="attr">tabs:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">transition:</span></span><br><span class="line">    <span class="attr">tabs:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">labels:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">border_radius:</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#! ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment">#! DO NOT EDIT THE FOLLOWING SETTINGS</span></span><br><span class="line"><span class="comment">#! UNLESS YOU KNOW WHAT YOU ARE DOING</span></span><br><span class="line"><span class="comment">#! ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Use velocity to animate everything.</span></span><br><span class="line"><span class="attr">motion:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">async:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">transition:</span></span><br><span class="line">    <span class="comment"># Transition variants:</span></span><br><span class="line">    <span class="comment"># fadeIn | fadeOut | flipXIn | flipXOut | flipYIn | flipYOut | flipBounceXIn | flipBounceXOut | flipBounceYIn | flipBounceYOut</span></span><br><span class="line">    <span class="comment"># swoopIn | swoopOut | whirlIn | whirlOut | shrinkIn | shrinkOut | expandIn | expandOut</span></span><br><span class="line">    <span class="comment"># bounceIn | bounceOut | bounceUpIn | bounceUpOut | bounceDownIn | bounceDownOut | bounceLeftIn | bounceLeftOut | bounceRightIn | bounceRightOut</span></span><br><span class="line">    <span class="comment"># slideUpIn | slideUpOut | slideDownIn | slideDownOut | slideLeftIn | slideLeftOut | slideRightIn | slideRightOut</span></span><br><span class="line">    <span class="comment"># slideUpBigIn | slideUpBigOut | slideDownBigIn | slideDownBigOut | slideLeftBigIn | slideLeftBigOut | slideRightBigIn | slideRightBigOut</span></span><br><span class="line">    <span class="comment"># perspectiveUpIn | perspectiveUpOut | perspectiveDownIn | perspectiveDownOut | perspectiveLeftIn | perspectiveLeftOut | perspectiveRightIn | perspectiveRightOut</span></span><br><span class="line">    <span class="attr">post_block:</span> <span class="string">fadeIn</span></span><br><span class="line">    <span class="attr">post_header:</span> <span class="string">slideDownIn</span></span><br><span class="line">    <span class="attr">post_body:</span> <span class="string">slideDownIn</span></span><br><span class="line">    <span class="attr">coll_header:</span> <span class="string">slideLeftIn</span></span><br><span class="line">    <span class="comment"># Only for Pisces | Gemini.</span></span><br><span class="line">    <span class="attr">sidebar:</span> <span class="string">slideUpIn</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Fancybox</span></span><br><span class="line"><span class="attr">fancybox:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Progress bar in the top during page loading.</span></span><br><span class="line"><span class="attr">pace:</span> <span class="literal">false</span></span><br><span class="line"><span class="comment"># Themes list:</span></span><br><span class="line"><span class="comment">#pace-theme-big-counter</span></span><br><span class="line"><span class="comment">#pace-theme-bounce</span></span><br><span class="line"><span class="comment">#pace-theme-barber-shop</span></span><br><span class="line"><span class="comment">#pace-theme-center-atom</span></span><br><span class="line"><span class="comment">#pace-theme-center-circle</span></span><br><span class="line"><span class="comment">#pace-theme-center-radar</span></span><br><span class="line"><span class="comment">#pace-theme-center-simple</span></span><br><span class="line"><span class="comment">#pace-theme-corner-indicator</span></span><br><span class="line"><span class="comment">#pace-theme-fill-left</span></span><br><span class="line"><span class="comment">#pace-theme-flash</span></span><br><span class="line"><span class="comment">#pace-theme-loading-bar</span></span><br><span class="line"><span class="comment">#pace-theme-mac-osx</span></span><br><span class="line"><span class="comment">#pace-theme-minimal</span></span><br><span class="line"><span class="comment"># For example</span></span><br><span class="line"><span class="comment"># pace_theme: pace-theme-center-simple</span></span><br><span class="line"><span class="attr">pace_theme:</span> <span class="string">pace-theme-minimal</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Canvas-nest</span></span><br><span class="line"><span class="attr">canvas_nest:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># three_waves</span></span><br><span class="line"><span class="attr">three_waves:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># canvas_lines</span></span><br><span class="line"><span class="attr">canvas_lines:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># canvas_sphere</span></span><br><span class="line"><span class="attr">canvas_sphere:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Only fit scheme Pisces</span></span><br><span class="line"><span class="comment"># Canvas-ribbon</span></span><br><span class="line"><span class="comment"># size: The width of the ribbon.</span></span><br><span class="line"><span class="comment"># alpha: The transparency of the ribbon.</span></span><br><span class="line"><span class="comment"># zIndex: The display level of the ribbon.</span></span><br><span class="line"><span class="attr">canvas_ribbon:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">size:</span> <span class="number">300</span></span><br><span class="line">  <span class="attr">alpha:</span> <span class="number">0.6</span></span><br><span class="line">  <span class="attr">zIndex:</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Script Vendors.</span></span><br><span class="line"><span class="comment"># Set a CDN address for the vendor you want to customize.</span></span><br><span class="line"><span class="comment"># For example</span></span><br><span class="line"><span class="comment">#    jquery: https://ajax.googleapis.com/ajax/libs/jquery/2.2.0/jquery.min.js</span></span><br><span class="line"><span class="comment"># Be aware that you should use the same version as internal ones to avoid potential problems.</span></span><br><span class="line"><span class="comment"># Please use the https protocol of CDN files when you enable https on your site.</span></span><br><span class="line"><span class="attr">vendors:</span></span><br><span class="line">  <span class="comment"># Internal path prefix. Please do not edit it.</span></span><br><span class="line">  <span class="attr">_internal:</span> <span class="string">lib</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Internal version: 2.1.3</span></span><br><span class="line">  <span class="attr">jquery:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Internal version: 2.1.5</span></span><br><span class="line">  <span class="comment"># See: http://fancyapps.com/fancybox/</span></span><br><span class="line">  <span class="attr">fancybox:</span></span><br><span class="line">  <span class="attr">fancybox_css:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Internal version: 1.0.6</span></span><br><span class="line">  <span class="comment"># See: https://github.com/ftlabs/fastclick</span></span><br><span class="line">  <span class="attr">fastclick:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Internal version: 1.9.7</span></span><br><span class="line">  <span class="comment"># See: https://github.com/tuupola/jquery_lazyload</span></span><br><span class="line">  <span class="attr">lazyload:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Internal version: 1.2.1</span></span><br><span class="line">  <span class="comment"># See: http://VelocityJS.org</span></span><br><span class="line">  <span class="attr">velocity:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Internal version: 1.2.1</span></span><br><span class="line">  <span class="comment"># See: http://VelocityJS.org</span></span><br><span class="line">  <span class="attr">velocity_ui:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Internal version: 0.7.9</span></span><br><span class="line">  <span class="comment"># See: https://faisalman.github.io/ua-parser-js/</span></span><br><span class="line">  <span class="attr">ua_parser:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Internal version: 4.6.2</span></span><br><span class="line">  <span class="comment"># See: http://fontawesome.io/</span></span><br><span class="line">  <span class="attr">fontawesome:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Internal version: 1</span></span><br><span class="line">  <span class="comment"># https://www.algolia.com</span></span><br><span class="line">  <span class="attr">algolia_instant_js:</span></span><br><span class="line">  <span class="attr">algolia_instant_css:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Internal version: 1.0.2</span></span><br><span class="line">  <span class="comment"># See: https://github.com/HubSpot/pace</span></span><br><span class="line">  <span class="comment"># Or use direct links below:</span></span><br><span class="line">  <span class="comment"># pace: //cdn.bootcss.com/pace/1.0.2/pace.min.js</span></span><br><span class="line">  <span class="comment"># pace_css: //cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-flash.min.css</span></span><br><span class="line">  <span class="attr">pace:</span></span><br><span class="line">  <span class="attr">pace_css:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Internal version: 1.0.0</span></span><br><span class="line">  <span class="comment"># https://github.com/hustcc/canvas-nest.js</span></span><br><span class="line">  <span class="attr">canvas_nest:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># three</span></span><br><span class="line">  <span class="attr">three:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># three_waves</span></span><br><span class="line">  <span class="comment"># https://github.com/jjandxa/three_waves</span></span><br><span class="line">  <span class="attr">three_waves:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># three_waves</span></span><br><span class="line">  <span class="comment"># https://github.com/jjandxa/canvas_lines</span></span><br><span class="line">  <span class="attr">canvas_lines:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># three_waves</span></span><br><span class="line">  <span class="comment"># https://github.com/jjandxa/canvas_sphere</span></span><br><span class="line">  <span class="attr">canvas_sphere:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Internal version: 1.0.0</span></span><br><span class="line">  <span class="comment"># https://github.com/zproo/canvas-ribbon</span></span><br><span class="line">  <span class="attr">canvas_ribbon:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Internal version: 3.3.0</span></span><br><span class="line">  <span class="comment"># https://github.com/ethantw/Han</span></span><br><span class="line">  <span class="attr">han:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># needMoreShare2</span></span><br><span class="line">  <span class="comment"># https://github.com/revir/need-more-share2</span></span><br><span class="line">  <span class="attr">needMoreShare2:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Assets</span></span><br><span class="line"><span class="attr">css:</span> <span class="string">css</span></span><br><span class="line"><span class="attr">js:</span> <span class="string">js</span></span><br><span class="line"><span class="attr">images:</span> <span class="string">images</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Theme version</span></span><br><span class="line"><span class="attr">version:</span> <span class="number">5.1</span><span class="number">.4</span></span><br></pre></td></tr></table></figure>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="http://www.ezlippi.com//blog/2016/02/jekyll-to-hexo.html" target="_blank" rel="noopener">Jekyll迁移到Hexo搭建个人博客</a><br><a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">next主题配置</a></p>
]]></content>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux安装到U盘</title>
    <url>/blog/2017/04/linux-install-usb.html</url>
    <content><![CDATA[<p>鉴于双系统的不安全性，将Linux系统安装到U盘，实现即插即用，且可以在多台电脑上运行不失为一个好办法。          </p>
<h3 id="环境和准备"><a href="#环境和准备" class="headerlink" title="环境和准备"></a>环境和准备</h3><p>本教程使用VMware虚拟机作为安装镜像的引导介质，VMware版本为12.5pro。<br>事先需要下载好ubuntu的iso镜像，我是用的是ubuntu lts16.04。<br>下载地址：<a href="http://cn.ubuntu.com/download/" target="_blank" rel="noopener">http://cn.ubuntu.com/download/</a><br>U盘一个，最好是3.0接口的且容量大于或等于32           </p>
<h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h3><p>准备好环境之后我们需要在VMware里面新建一个虚拟机，注意选择安装来源的时候选稍后安装操作系统。其他的设置就用默认或者推荐就好。<br><img src="http://img.blog.csdn.net/20161115230512812?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt><br>新建完了虚拟机之后点击虚拟机设置，在cd里面如图填上自己下载好的镜像的路径。同时把usb控制器里的所有的选项都勾上，然后兼容性选择USB3.0.<br><img src="http://img.blog.csdn.net/20161115230820185?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt><br>点击确定保存配置，插上事先准备好的U盘。然后点启动虚拟机。会弹出可选用移动设备的提示。<br><img src="http://img.blog.csdn.net/20161115231052970?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt></p>
<p>经过以上的操作之后U盘就能连接到虚拟机里了，然后我们选择好需要安装的语言后，点击try ubuntu，然后会进入 一个临时的系统。<br>点击桌面左上角的install ubuntu，然后会进入到安装程序。<br><img src="http://img.blog.csdn.net/20161115232512897?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt></p>
<p>最重要的是分区：<br>选中dev/sdb 然后点击new partition table新建分区表，然后会有提示和确认。<br>然后将U盘一个划分为etx4的主分区，容量设置为15000MB，和一个格式为swap的交换分区使用U盘剩下的空间。<br>双击dev/sdb/ntfs 然后use as etx4，勾选上format格式化，然后mount point设置为   /<br><img src="http://img.blog.csdn.net/20161115233655324?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt><br>然后最下面的device for boot loader一定是要选择为U盘的。<br>最后的选择应该是下图这个样子的 。<br><img src="http://img.blog.csdn.net/20161115234222749?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt><br>完成这些之后就是一路continue，等着就行了。</p>
<p>安装完成后会提示重启，这时候拔掉U盘就行了。然后就可以在任何一台电脑上使用ubuntu系统了。注意，如果U盘还在电脑上会提示叫你格式化U盘，千万不要格式化，不然又得重新安装了。      </p>
<h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>按F2进入BIOS中设置BOOT模式为Legacy,然后再按F12进入U盘启动即可。<br>如果在boot manager里面找不到自己的U盘选项，可能是因为一下原因：<br>1.bios设置里面没有打开usb boot选项，找到相应的选项将usb boot设置为 enable。<br>2.bios引导设置里只支持uefi，可以打开legacy启动模式，然后重启电脑再进boot manager应该就能看到U盘了</p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="http://blog.csdn.net/qq_24369113/article/details/53179218" target="_blank" rel="noopener">将Linux（ubuntu）安装到U盘上，实现即插即用</a></p>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>串口编程基础</title>
    <url>/blog/2017/04/serial-program-foundation.html</url>
    <content><![CDATA[<h2 id="串口基础知识"><a href="#串口基础知识" class="headerlink" title="串口基础知识"></a>串口基础知识</h2><p>串口是串行接口（serial port）的简称，也称为串行通信接口或COM接口。</p>
<p>串口通信是指采用串行通信协议（serial communication）在一条信号线上将数据一个比特一个比特地逐位进行传输的通信模式。</p>
<p>串口按电气标准及协议来划分，包括RS-232-C、RS-422、RS485等。</p>
<p>串口通信（Serial Communications）的概念非常简单，串口按位（bit）发送和接收字节。尽管比按字节（byte）的并行通信慢，但是串口可以在使用一根线发送数据的同时用另一根线接收数据。它很简单并且能够实现远距离通信。比如IEEE488定义并行通行状态时，规定设备线总长不得超过20米，并且任意两个设备间的长度不得超过2米；而对于串口而言，长度可达1200米。典型地，串口用于ASCII码字符的传输。通信使用3根线完成，分别是地线、发送、接收。由于串口通信是异步的，端口能够在一根线上发送数据同时在另一根线上接收数据。其他线用于握手，但不是必须的。串口通信最重要的参数是波特率、数据位、停止位和奇偶校验。对于两个进行通信的端口，这些参数必须匹配。</p>
<p>a，波特率：这是一个衡量符号传输速率的参数。指的是信号被调制以后在单位时间内的变化，即单位时间内载波参数变化的次数，如每秒钟传送240个字符，而每个字符格式包含10位（1个起始位，1个停止位，8个数据位），这时的波特率为240Bd，比特率为10位*240个/秒=2400bps。一般调制速率大于波特率，比如曼彻斯特编码）。通常电话线的波特率为14400，28800和36600。波特率可以远远大于这些值，但是波特率和距离成反比。高波特率常常用于放置的很近的仪器间的通信，典型的例子就是GPIB设备的通信。<br>b，数据位：这是衡量通信中实际数据位的参数。当计算机发送一个信息包，实际的数据往往不会是8位的，标准的值是6、7和8位。如何设置取决于你想传送的信息。比如，标准的ASCII码是0～127（7位）。扩展的ASCII码是0～255（8位）。如果数据使用简单的文本（标准 ASCII码），那么每个数据包使用7位数据。每个包是指一个字节，包括开始/停止位，数据位和奇偶校验位。由于实际数据位取决于通信协议的选取，术语“包”指任何通信的情况。<br>c，停止位：用于表示单个包的最后一位。典型的值为1，1.5和2位。由于数据是在传输线上定时的，并且每一个设备有其自己的时钟，很可能在通信中两台设备间出现了小小的不同步。因此停止位不仅仅是表示传输的结束，并且提供计算机校正时钟同步的机会。适用于停止位的位数越多，不同时钟同步的容忍程度越大，但是数据传输率同时也越慢。<br>d，奇偶校验位：在串口通信中一种简单的检错方式。有四种检错方式：偶、奇、高和低。当然没有校验位也是可以的。对于偶和奇校验的情况，串口会设置校验位（数据位后面的一位），用一个值确保传输的数据有偶个或者奇个逻辑高位。例如，如果数据是011，那么对于偶校验，校验位为0，保证逻辑高的位数是偶数个。如果是奇校验，校验位为1，这样就有3个逻辑高位。高位和低位不真正的检查数据，简单置位逻辑高或者逻辑低校验。这样使得接收设备能够知道一个位的状态，有机会判断是否有噪声干扰了通信或者是否传输和接收数据是否不同步。</p>
<h3 id="串行通信"><a href="#串行通信" class="headerlink" title="串行通信"></a>串行通信</h3><p>在串行通信中，数据在1位宽的单条线路上进行传输，一个字节的数据要分为8次，由低位到高位按顺序一位一位的进行传送。</p>
<p>串行通信的数据是逐位传输的，发送方发送的每一位都具有固定的时间间隔，这就要求接收方也要按照发送方同样的时间间隔来接收每一位。不仅如此，接收方还必须能够确定一个信息组的开始和结束。</p>
<p>常用的两种基本串行通信方式包括同步通信和异步通信。</p>
<h4 id="串行同步通信"><a href="#串行同步通信" class="headerlink" title="串行同步通信"></a>串行同步通信</h4><p>　　同步通信（SYNC:synchronous data communication）是指在约定的通信速率下，发送端和接收端的时钟信号频率和相位始终保持一致（同步），这样就保证了通信双方在发送和接收数据时具有完全一致的定时关系。</p>
<p>　　同步通信把许多字符组成一个信息组（信息帧），每帧的开始用同步字符来指示，一次通信只传送一帧信息。在传输数据的同时还需要传输时钟信号，以便接收方可以用时针信号来确定每个信息位。</p>
<p>　　同步通信的优点是传送信息的位数几乎不受限制，一次通信传输的数据有几十到几千个字节，通信效率较高。同步通信的缺点是要求在通信中始终保持精确的同步时钟，即发送时钟和接收时钟要严格的同步（常用的做法是两个设备使用同一个时钟源）。</p>
<p>　　在后续的串口通信与编程中将只讨论异步通信方式，所以在这里就不对同步通信做过多的赘述了。</p>
<h4 id="串行异步通信"><a href="#串行异步通信" class="headerlink" title="串行异步通信"></a>串行异步通信</h4><p>　　异步通信（ASYNC:asynchronous data communication），又称为起止式异步通信，是以字符为单位进行传输的，字符之间没有固定的时间间隔要求，而每个字符中的各位则以固定的时间传送。</p>
<p>　　在异步通信中，收发双方取得同步是通过在字符格式中设置起始位和停止位的方法来实现的。具体来说就是，在一个有效字符正式发送之前，发送器先发送一个起始位，然后发送有效字符位，在字符结束时再发送一个停止位，起始位至停止位构成一帧。停止位至下一个起始位之间是不定长的空闲位，并且规定起始位为低电平（逻辑值为0），停止位和空闲位都是高电平（逻辑值为1），这样就保证了起始位开始处一定会有一个下跳沿，由此就可以标志一个字符传输的起始。而根据起始位和停止位也就很容易的实现了字符的界定和同步。</p>
<p>　　显然，采用异步通信时，发送端和接收端可以由各自的时钟来控制数据的发送和接收，这两个时钟源彼此独立，可以互不同步。</p>
<h4 id="几个概念"><a href="#几个概念" class="headerlink" title="几个概念"></a>几个概念</h4><p>　　为了更好的理解串口通信，我们还需要了解几个串口通信当中的基本概念。</p>
<p>　　（1）发送时钟：发送数据时，首先将要发送的数据送入移位寄存器，然后在发送时钟的控制下，将该并行数据逐位移位输出。</p>
<p>　　（2）接收时钟：在接收串行数据时，接收时钟的上升沿对接收数据采样，进行数据位检测，并将其移入接收器的移位寄存器中，最后组成并行数据输出。</p>
<p>　　（3）波特率因子：波特率因子是指发送或接收1个数据位所需要的时钟脉冲个数。</p>
<p><strong>参考链接:</strong><a href="http://www.cnblogs.com/menlsh/archive/2013/01/28/2880580.html" target="_blank" rel="noopener">串口通信与编程01：串口基础知识</a>         </p>
<h2 id="串口通信简单示例"><a href="#串口通信简单示例" class="headerlink" title="串口通信简单示例"></a>串口通信简单示例</h2><p>为了方便串口程序的调试，使用了如下两款工具软件<br>[1]. 串口调试助手<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/chapter1/p1.jpg" alt><br>该软件可以通过串口收发数据。可以通过串口发送数据，也可以查看串口收到的数据。<br>[2]. 虚拟串口<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/chapter1/p2.jpg" alt><br>可以虚拟串口，每次虚拟出一对串口，这对串口相互连通。如图中虚拟出了串口COM2和COM3，这样通过COM2发送的数据，会由COM3接收到，反之亦然。</p>
<h4 id="虚拟串口发送数据"><a href="#虚拟串口发送数据" class="headerlink" title="虚拟串口发送数据"></a>虚拟串口发送数据</h4><figure class="highlight vala"><table><tr><td class="code"><pre><span class="line">import serial</span><br><span class="line">import <span class="keyword">string</span></span><br><span class="line">import binascii</span><br><span class="line">s=serial.Serial(<span class="string">'com1'</span>,<span class="number">9600</span>)</span><br><span class="line"><span class="meta"># s.open()</span></span><br><span class="line"><span class="meta">#接收</span></span><br><span class="line"><span class="meta"># n=s.inWaiting()</span></span><br><span class="line"><span class="meta"># if n:</span></span><br><span class="line"><span class="meta">#     data= str(binascii.b2a_hex(s.read(n)))[2:-1]</span></span><br><span class="line"><span class="meta">#     print(data)</span></span><br><span class="line"><span class="meta">#发送</span></span><br><span class="line">d=bytes.fromhex(<span class="string">'10 11 12 34 6f'</span>)</span><br><span class="line">s.write(d)</span><br><span class="line">s.close()</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/chapter1/p3.jpg" alt></p>
<h4 id="虚拟串口接收数据"><a href="#虚拟串口接收数据" class="headerlink" title="虚拟串口接收数据"></a>虚拟串口接收数据</h4><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line">import serial</span><br><span class="line">import time</span><br><span class="line">import _thread</span><br><span class="line">import binascii</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MSerialPort</span>:</span></span><br><span class="line">    message = <span class="string">''</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, port, buand)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.port = serial.Serial(port, buand)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">self</span>.port.isOpen()<span class="symbol">:</span></span><br><span class="line">            <span class="keyword">self</span>.port.open()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">port_open</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">self</span>.port.isOpen()<span class="symbol">:</span></span><br><span class="line">            <span class="keyword">self</span>.port.open()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">port_close</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.port.close()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">send_data</span><span class="params">(<span class="keyword">self</span>, data)</span></span><span class="symbol">:</span></span><br><span class="line">        number = <span class="keyword">self</span>.write(data)</span><br><span class="line">        <span class="keyword">return</span> number</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read_data</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="symbol">True:</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">#data = self.port.readline()</span></span><br><span class="line">            n=<span class="keyword">self</span>.port.inWaiting()</span><br><span class="line">            <span class="keyword">if</span> <span class="symbol">n:</span></span><br><span class="line">                print(<span class="string">"hello here received data"</span>)</span><br><span class="line">                data = str(binascii.b2a_hex(<span class="keyword">self</span>.port.read(n)))[<span class="number">2</span><span class="symbol">:-</span><span class="number">1</span>]</span><br><span class="line">                <span class="keyword">self</span>.message += data</span><br><span class="line">                print(<span class="keyword">self</span>.message)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name_<span class="number">_</span> == <span class="string">'__main__'</span><span class="symbol">:</span></span><br><span class="line">    mSerial = MSerialPort(<span class="string">'com2'</span>, <span class="number">9600</span>)</span><br><span class="line">    _thread.start_new_thread(mSerial.read_data, ())</span><br><span class="line">    <span class="keyword">while</span> <span class="symbol">True:</span></span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        print(mSerial.message)</span><br><span class="line">        print(<span class="string">'next line'</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/chapter1/p4.png" alt></p>
<p><strong>参考链接:</strong><br><a href="http://blog.csdn.net/mingojiang/article/details/7713529" target="_blank" rel="noopener">串口通信编程–多线程异步方式</a><br><a href="http://blog.csdn.net/horizons_kong/article/details/54412339" target="_blank" rel="noopener">Windows 串口通信简单示例</a></p>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>各类学习资源收藏</title>
    <url>/blog/2017/04/multi-resource-collect.html</url>
    <content><![CDATA[<p><strong>这里是各类学习资源收藏</strong>    </p>
<ul>
<li>在线学习网站，包含PS,AI,AE,AU,乐理，五线谱等内容：<a href="https://zhuanlan.zhihu.com/p/21652487" target="_blank" rel="noopener">doyoudo介绍</a></li>
<li>LeetCode题目答案查询：<a href="http://www.jiuzhang.com/solutions/" target="_blank" rel="noopener">http://www.jiuzhang.com/solutions/</a></li>
</ul>
]]></content>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo多终端操作</title>
    <url>/blog/2017/04/hexo-multi-machine.html</url>
    <content><![CDATA[<h3 id="主要思路"><a href="#主要思路" class="headerlink" title="主要思路"></a>主要思路</h3><p><img src="https://github.com/shenzhen2017/myImage/blob/master/chapter1/p5.png?raw=true" alt><br>对于多终端来说，按照git pull-&gt;编辑博客-&gt;git push-&gt;hexo g -d的顺序就可以实现多终端同步效果</p>
<h3 id="实施前提"><a href="#实施前提" class="headerlink" title="实施前提"></a>实施前提</h3><p>1.旧终端/电脑已安装hexo环境<br>2.旧终端/电脑hexo正常工作<br>3.旧终端/电脑能通过hexo g -d正常发布至远程xxx.github.io</p>
<h3 id="实施步骤"><a href="#实施步骤" class="headerlink" title="实施步骤"></a>实施步骤</h3><p>1.新建远程repo</p>
<p>在github上新增repo，例如名为myhexo，地址为github.com/xxx/myhexo</p>
<p>2.在旧终端中创建本地repo<br>进入本地hexo目录<br><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">git init</span></span><br></pre></td></tr></table></figure></p>
<p>查看未提交的文件（默认不包含public、deploy文件）<br><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">git status</span></span><br></pre></td></tr></table></figure></p>
<p>根据查看结果将本地hexo建站原始文件纳入版本控制（我本地是scaffolds、source、themes文件夹以及.gitignore、_config.yml、package.json文件）<br><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">add</span><span class="bash"> …</span></span><br><span class="line">git commit -m …</span><br></pre></td></tr></table></figure></p>
<p>需要注意的是.gitignore中需要增加一行，忽略~结尾的文件<br><figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="comment">*~</span></span><br></pre></td></tr></table></figure></p>
<p>3.在旧终端中创建远程分支连接<br><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">git remote <span class="keyword">add</span><span class="bash"> origin git@github.com:xxx/myhexo.git</span></span><br><span class="line">git remote -v</span><br></pre></td></tr></table></figure></p>
<p>显示如下：<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">origin git<span class="meta">@github</span>.<span class="string">com:</span>XXX/myhexo.git (fetch)</span><br><span class="line">origin git<span class="meta">@github</span>.<span class="string">com:</span>XXX/myhexo.git (push)</span><br></pre></td></tr></table></figure></p>
<p>4.在旧终端中提交本地文件至远程repo<br><figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">push</span> -u <span class="built_in">origin</span> master</span><br></pre></td></tr></table></figure></p>
<p>5.换了终端以后</p>
<p>在新终端中安装node、git环境，配置github sshkey</p>
<p>在新终端中创建空目录作为hexo工作目录，从远程仓库中clone出之前备份的repo<br><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">mkdir hexo</span><br><span class="line">cd hexo</span><br><span class="line">git init</span><br><span class="line">git <span class="keyword">clone</span> <span class="title">git</span>@github.com:xxx/myhexo.git</span><br></pre></td></tr></table></figure></p>
<p>在新终端中git clone成功后，本地出现myhexo文件夹，开始安装hexo环境<br><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">cd myhexo</span><br><span class="line">npm <span class="keyword">install</span> hexo</span><br><span class="line">npm <span class="keyword">install</span></span><br><span class="line">npm <span class="keyword">install</span> hexo-deployer-git</span><br></pre></td></tr></table></figure></p>
<p>查看本地同步效果，访问localhost:4000<br><figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo <span class="keyword">server</span></span><br></pre></td></tr></table></figure></p>
<p>这样之后好像没效果，安装next主题后成功<br><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">git clone http<span class="variable">s:</span>//github.<span class="keyword">com</span>/iissnan/hexo-theme-<span class="keyword">next</span> themes/<span class="keyword">next</span></span><br></pre></td></tr></table></figure></p>
<p>安装后把next主题的配置文件修改成我们常用的即可。</p>
<p>6.在新终端中继续使用和管理hexo</p>
<p>新建文章并修改<br><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">hexo <span class="keyword">new</span> xxx</span><br></pre></td></tr></table></figure></p>
<p>提交原始md文件至远程repo<br><figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line">git status</span><br><span class="line">git <span class="keyword">add</span></span><br><span class="line">git commit -m xx</span><br><span class="line">git <span class="keyword">push</span></span><br></pre></td></tr></table></figure></p>
<p>发布静态网页<br><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">hexo g -d</span></span><br></pre></td></tr></table></figure></p>
<p>7.切换至旧终端使用hexo</p>
<p>更新网站原始文件<br><figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line">git pull</span><br><span class="line">hexo g</span><br><span class="line">hexo <span class="keyword">server</span></span><br></pre></td></tr></table></figure></p>
<p>测试更新成功后，表明终端顺利切换完成</p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="http://wangmuduo.com/2016/04/02/hexo-change-os/" target="_blank" rel="noopener">Hexo 换终端/换电脑小记</a><br><a href="https://www.zhihu.com/question/21193762" target="_blank" rel="noopener">使用hexo，如果换了电脑怎么更新博客？</a></p>
]]></content>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu使用详解</title>
    <url>/blog/2017/04/ubuntu-use-detail.html</url>
    <content><![CDATA[<h3 id="软件安装及其他"><a href="#软件安装及其他" class="headerlink" title="软件安装及其他"></a>软件安装及其他</h3><p><strong>1、java环境搭建</strong><br>参见：<a href="http://blog.csdn.net/sunxiaoju/article/details/51994559" target="_blank" rel="noopener">ubuntu16.04搭建java环境</a><br><strong>2、sublime text在Ubuntu下不能输入中文解决</strong><br>详情可见：<a href="http://www.jianshu.com/p/1f3a3e4f4e92" target="_blank" rel="noopener">Ubuntu 14.04 LTS 64位 安装激活Sublime Text 3及解决无法输入中文问题的解决方法</a><br><strong>3、Anaconda2与Anaconda3同时安装</strong><br><a href="http://blog.csdn.net/infin1te/article/details/50445217" target="_blank" rel="noopener">Windows下Anaconda2(Python2)和Anaconda3(Python3)的共存</a><br><a href="http://www.jianshu.com/p/0ef49730c5c1" target="_blank" rel="noopener">实战anaconda2/3同时安装opencv</a><br><strong>4、ubuntu下使用命令行版网易云音乐</strong><br><a href="https://github.com/darknessomi/musicbox" target="_blank" rel="noopener">https://github.com/darknessomi/musicbox</a><br><img src="https://camo.githubusercontent.com/5b0f2a90c5eaf8f4e235291c40ffee31f21c06de/687474703a2f2f376a317976332e636f6d312e7a302e676c622e636c6f7564646e2e636f6d2f707265766965772e676966" alt></p>
<h3 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h3><p>窗口快速切换快捷键  Alt+Tab<br>切换到桌面    Ctr+super+d(super键即windows键)</p>
<p>获取屏幕截图  Print Screen<br>获取窗口的截图 Alt+Print Screen<br>获取屏幕上某个区域的截图。光标变为十字。点击并拖动选择区域   Shift+Print Screen</p>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>朝鲜行记</title>
    <url>/blog/2017/04/tour-to-korea.html</url>
    <content><![CDATA[<blockquote>
<p>纣之不善，不如是之甚也。是以君子恶居下流，天下之恶皆归焉。</p>
</blockquote>
<p>&nbsp;&nbsp;说起朝鲜，一时却不知从何说起。一般而论，朝鲜的国际形象大概是贫穷，可笑，独裁，世袭，核弹，东北亚的不稳定因素等等。<br>很多朋友听说我要去朝鲜，可能都会觉得奇葩吧。但是还是挺惊险刺激的，总得来说，对于一个游客来说，朝鲜是个好地方。</p>
<p><center><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/chapter1/p4.jpg"></center><br>&nbsp;&nbsp;我们坐4月13号的深夜航班从浦东机场出发，两个半小时就到了平壤，4月16号平壤时间9点40从平壤机场出发，由于朝鲜与中国有半个小时时差，而且天气较好，11点多一点就到了上海。总共在朝鲜浪了三天两晚，再加上语言不通，其实只是走马观花，谈不上有多了解朝鲜，只不过是眼见为实，一点拙见而已。<br>第一天凌晨入住西山宾馆，是朝鲜的一级酒店，约等于国内的三星与四星之间，环境还是不错的，酒店旁边就是高尔夫球场，从房间阳台看过去，只见一片林海，蓝天白云，空气清新，让人有些心旷神怡。</p>
<p><center><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/chapter1/p5.jpg"></center><br>午饭也在酒店里吃了，除了有点冷了，还都挺满意的，朝鲜人似乎不喜欢吃热菜，午饭后顺便逛了一下酒店的商店，大都是些纪念品什么的，有种穿着朝鲜传统服装的娃娃最萌了，还有朝鲜女交警版的，朝币与人民币的汇率大概是15，换算过来还是挺便宜的。下午的时间主要是参考平壤市内的景点，天还下着小雨，主要逛了万景台，金日成广场，刺绣博物馆之类的，万景台是金日成的出生地，没什么意思，只是有两个草房子而已，但<br>环境颇为清幽，种满了迎春花与金达莱，而且樱花居然还开着，真是人间四月芳菲尽，山寺桃花始盛开。随后我们又前往了万寿台，那里有金日成与金正日的铜像，由于太阳节将至，就是金日成的寿辰，随处可见参拜的人群，男人大都穿一种类似中山装的服装或者军装，女人则穿民族服装或者其他多种多样的衣服。在朝鲜旅游是没有强制消费的，唯一的例外大概便是在参观万寿台时，需要为他们的领袖献花的时候了吧，二十元一束花，据介绍，卖花的姑娘也是朝鲜国旅的，朝鲜并没有私营的小贩经济。随后又参观了刺绣馆，精美的工艺自然不用说，但第一天最大的收获还得是参观平壤少年宫了。据导游介绍，朝鲜小朋友上午上课，下午就参加兴趣活动，可以根据兴趣学钢琴，跳舞，唱歌等等特长，而且都是免费的。<br>来的时候攻略说要带一些礼物给少年宫的小朋友，后来到少年宫一看，发现我应该接受小朋友的捐赠才是。朝鲜的小学生的确厉害，无论是能力，才艺，礼貌还是纪律，都令人印象深刻。在出现领导人图像的时候，朝鲜小学生都会主动起立，以同一个频率鼓掌，当然，这是否是一个好现象我就不予置评了。</p>
<p><center><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/chapter1/p6.jpg"></center><br>第一天主要在平壤市内逛，平壤的道路极其干净，几乎可以说是一尘不染，而且堵车极少，因为本来就没什么车辆，主要的交通工具还是自行车。道理两旁也是颇有一些高楼大厦的，当初著名的烂尾工程柳京饭店外面也已经做好了，当然里面尚未完成，不过道路两旁的高楼大都是居民楼而不是商店，所以灯光没有国内那么夸张，当然入住率还是高的。据导游说，朝鲜国内住房，医疗，教育都是免费的，光凭住房一点，中国人也并没有在朝鲜人面前骄傲的地方，不是吗？晚饭的饭店也是朝鲜国旅开的，就在使馆区对面，这是我在朝鲜三天，唯一一次搜到WIFI，但可惜手机上没装万能钥匙，从此再没有见到WIFI了。</p>
<p>第二天一大早起来，坐车去妙香山，妙香山位于平壤以北168公里，据说沥青是军事物资，所以美国禁止对朝鲜出口，导致朝鲜的公路坑坑洼洼的，一路上可波涛汹涌，此起彼伏，真是刺激，一路颠簸也特别容易让人发困，往往差不多快睡着了，这时就会来个刺激的，来个大坑，让人的身体由于惯性运行离开座位，将你从沉睡边缘彻底拉回来。妙香山是朝鲜人夏令营的地方，更有一个国际友谊展览馆，共有188个国家送给朝鲜的20多万件礼物展出，最开始进去的展厅展示了习近平送的清明上河图屏风，这些珍宝初看还挺有趣，但看久了其实这些东西也挺无聊的。妙香山地区还有朝鲜最大的寺庙普贤寺，但其实也挺小的，也没什么意思。</p>
<p><center><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/chapter1/p7.jpg"></center><br>吃完饭后又是两个半小时回平壤的车程，等到回来时已经四五点了，匆匆跑到牡丹峰志愿军纪念碑献花，纪念碑后有个房间，里面有部分牺牲烈士的名单，朝鲜的灯光很暗，里面的壁画已经渐渐看不清了，逛不了多久便出来了，在夜色中回望牡丹峰下闪闪发光的凯旋门，不由得想起历经三代的海军上将萨镇冰的诗，“五十七载犹如梦，举国沦亡缘汉城，龙游浅水勿自弃，终有扬眉吐气天。”时移势异，不过短短几十年间，这天下就大变样了。第二天是太阳节，金日成广场上有舞会和烟花，但我们都没有赶上，甚是可惜啊。</p>
<p><center><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/chapter1/p8.jpg"></center><br>第三天是在平壤的最后一天，这天我们要向南168公里前往开城，开城是高丽王朝的王都，高丽人参的原产地，同时也是抗美援朝战争停战协议签订的地方，去的路上共有四道岗哨，也只开了2个半小时就到了，据说首尔离三八线只有四十公里，在大炮的射程之内，而平壤离38线其实也不是很远啊。板门店有一个纪念品商店，可以买开城的特产人参，人参茶，人参化妆品之类的，还有朝鲜特色的海报和名信片，勋章和国旗之类的。进去后参观签约地没什么意思，但是最后还会直达朝鲜与韩国的分界线，中间有五间房子，房子的一半是属于韩国的，一半是属于朝鲜的，通常南北朝鲜的人可以在这个房间里面谈判。对了，在边境上可以搜索到韩国的信号，如果开了全球通就可以打电话了。据说38线这些年其实也没那么太平，曾经因为砍树引发斧头战争，还有80年代苏联人跑过38线导致的伤亡事件，看着38线旁边松懈的防御，不禁让人脑洞大开。</p>
<p><center><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/chapter1/p9.jpg"></center><br>在吃了抠门的开城人的铜碗套餐后，下午就来到著名的成均馆啦，成均馆即是高丽时代的国子监，里面种满了千年的银杏树，秋天时最漂亮了，我们时候是春天，效果没那么好，但还是有很多开城人在那结婚，在那拍照。通常男人穿军装，女人装韩服，但看起来是改良过的，越来越像婚纱了。成均馆门口还有卖邮票的，在这里可以买邮票然后寄明信片回去，但是也不知道何时能到，更何况明信片常常收不到，只能作罢。</p>
<p><center><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/chapter1/p10.jpg"></center><br>晚上吃过晚饭后，就又坐飞机回国了。短短几天，对朝鲜其实也还是所知甚少，但也是破除了一些谣言的，以前听说来朝鲜旅游会有人监视行踪，拍照也经常会被删之类的，但其实只要你不拍军人，随便拍都可以。也有人对朝鲜人有所误解，觉得都是被洗脑了之类的，但其实仅从两个导游来看，他们对外界其实也所知甚多，也跟所谓自由世界的人也没多大区别，也有一样的喜乐与悲欢，其中的一个女导游30多岁了，也还没结婚，可见朝鲜女性也享有相当的自由。其实，对于朝鲜，我还所知甚少呢，等到南北朝鲜统一了，还要再去一趟。</p>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>全连接层具体实现</title>
    <url>/blog/2017/04/full-connect-achieve.html</url>
    <content><![CDATA[<p>以前我们实现过全连接的两层神经网络，现在我们通过模块化的方法，实现多层神经网络的构建<br>每一层我们都有一个前向传播与一个反向传播的函数，其形式如下所示：<br>The forward function will receive inputs, weights, and other parameters and will return both an output and a cache object storing data needed for the backward pass, like this:<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">layer_forward</span><span class="params">(x, w)</span>:</span></span><br><span class="line">  <span class="string">""" Receive inputs x and weights w """</span></span><br><span class="line">  <span class="comment"># Do some computations ...</span></span><br><span class="line">  z = <span class="comment"># ... some intermediate value</span></span><br><span class="line">  <span class="comment"># Do some more computations ...</span></span><br><span class="line">  out = <span class="comment"># the output</span></span><br><span class="line"></span><br><span class="line">  cache = (x, w, z, out) <span class="comment"># Values we need to compute gradients</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> out, cache</span><br></pre></td></tr></table></figure></p>
<p>The backward pass will receive upstream derivatives and the cache object, and will return gradients with respect to the inputs and weights, like this:<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">layer_backward</span><span class="params">(dout, cache)</span>:</span></span><br><span class="line">  <span class="string">"""</span></span><br><span class="line"><span class="string">  Receive derivative of loss with respect to outputs and cache,</span></span><br><span class="line"><span class="string">  and compute derivative with respect to inputs.</span></span><br><span class="line"><span class="string">  """</span></span><br><span class="line">  <span class="comment"># Unpack cache values</span></span><br><span class="line">  x, w, z, out = cache</span><br><span class="line"></span><br><span class="line">  <span class="comment"># Use values in cache to compute derivatives</span></span><br><span class="line">  dx = <span class="comment"># Derivative of loss with respect to x</span></span><br><span class="line">  dw = <span class="comment"># Derivative of loss with respect to w</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dx, dw</span><br></pre></td></tr></table></figure></p>
<p>通过构造许多这样的层，我们就可以把它们轻易地组合成不同的结构从而形成各种分类器.<br>在本文中，我们不仅尝试训练不同深度的网络，同时也尝试了一些不同的更新规则用于优化网络。</p>
<h3 id="不同层的构建"><a href="#不同层的构建" class="headerlink" title="不同层的构建"></a>不同层的构建</h3><h4 id="Affine-layer"><a href="#Affine-layer" class="headerlink" title="Affine layer"></a>Affine layer</h4><p>构建Affine layer的前向与反向传播<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">def affine_forward(x, w, b):</span><br><span class="line">out = None</span><br><span class="line"><span class="attribute">N</span>=x.shape[0]</span><br><span class="line"><span class="attribute">x_row</span>=x.reshape(N,-1)</span><br><span class="line"><span class="attribute">out</span>=np.dot(x_row,w)+b</span><br><span class="line">cache = (x, w, b)</span><br><span class="line">return out, cache</span><br><span class="line"></span><br><span class="line">def affine_backward(dout, cache):</span><br><span class="line">x, w, b = cache</span><br><span class="line">dx, dw, db = None, None, None</span><br><span class="line"><span class="attribute">dx</span>=np.dot(dout,w.T)</span><br><span class="line"><span class="attribute">dx</span>=np.reshape(dx,x.shape)</span><br><span class="line"><span class="attribute">x_row</span>=x.reshape(x.shape[0],-1)</span><br><span class="line"><span class="attribute">dw</span>=np.dot(x_row.T,dout)</span><br><span class="line">db = np.sum(dout, <span class="attribute">axis</span>=0, <span class="attribute">keepdims</span>=<span class="literal">True</span>) </span><br><span class="line">return dx, dw, db</span><br></pre></td></tr></table></figure></p>
<p>在构建网络完毕后，可以通过梯度检验判断我们的前向与反向传播是否正确。</p>
<h4 id="ReLU-layer"><a href="#ReLU-layer" class="headerlink" title="ReLU layer"></a>ReLU layer</h4><p>构建ReLu layer的前向与反向传播<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ReLU</span><span class="params">(x)</span>:</span>    </span><br><span class="line">    <span class="string">"""ReLU non-linearity."""</span>    </span><br><span class="line">    <span class="keyword">return</span> np.maximum(<span class="number">0</span>, x)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">relu_forward</span><span class="params">(x)</span>:</span></span><br><span class="line">  out = <span class="literal">None</span></span><br><span class="line">  cache = x</span><br><span class="line">  <span class="keyword">return</span> out, cache</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">relu_backward</span><span class="params">(dout, cache)</span>:</span></span><br><span class="line">  dx, x = <span class="literal">None</span>, cache</span><br><span class="line">  dx=dout</span><br><span class="line">  dx[x&lt;<span class="number">0</span>]=<span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> dx</span><br></pre></td></tr></table></figure></p>
<h4 id="三明治层"><a href="#三明治层" class="headerlink" title="三明治层"></a>三明治层</h4><p>在神经网络中，有一些常用的层的组合方式，比如affine层就常常跟在ReLU层后面，为了以后方便使用，我们可以把这个两个层结合起来：<br><figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">affine_relu_forward</span></span>(x, w, b):</span><br><span class="line">  a, fc_cache = affine_forward(x, w, b)</span><br><span class="line">  <span class="keyword">out</span>, relu_cache = relu_forward(a)</span><br><span class="line">  cache = (fc_cache, relu_cache)</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">out</span>, cache</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">affine_relu_backward</span></span>(dout, cache):</span><br><span class="line">  fc_cache, relu_cache = cache</span><br><span class="line">  da = relu_backward(dout, relu_cache)</span><br><span class="line">  dx, dw, db = affine_backward(da, fc_cache)</span><br><span class="line">  <span class="keyword">return</span> dx, dw, db</span><br></pre></td></tr></table></figure></p>
<h4 id="Loss-layers-Softmax-and-SVM"><a href="#Loss-layers-Softmax-and-SVM" class="headerlink" title="Loss layers: Softmax and SVM"></a>Loss layers: Softmax and SVM</h4><p>通过损失层判定估计值与实际值的差距有多大，主要方法有softmax与SVM两种<br><figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">def svm_loss(x, y):</span><br><span class="line">  N = x.shape[<span class="number">0</span>]</span><br><span class="line">  correct_class_scores = x[<span class="built_in">np</span>.arange(N), y]</span><br><span class="line">  margins = <span class="built_in">np</span>.maximum(<span class="number">0</span>, x - correct_class_scores[:, <span class="built_in">np</span>.newaxis] + <span class="number">1.0</span>)</span><br><span class="line">  margins[<span class="built_in">np</span>.arange(N), y] = <span class="number">0</span></span><br><span class="line">  loss = <span class="built_in">np</span>.<span class="built_in">sum</span>(margins) / N</span><br><span class="line">  num_pos = <span class="built_in">np</span>.<span class="built_in">sum</span>(margins &gt; <span class="number">0</span>, axis=<span class="number">1</span>)</span><br><span class="line">  dx = <span class="built_in">np</span>.zeros_like(x)</span><br><span class="line">  dx[margins &gt; <span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">  dx[<span class="built_in">np</span>.arange(N), y] -= num_pos</span><br><span class="line">  dx /= N</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">return</span> loss, dx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def softmax_loss(x, y):</span><br><span class="line">  probs = <span class="built_in">np</span>.<span class="built_in">exp</span>(x - <span class="built_in">np</span>.<span class="built_in">max</span>(x, axis=<span class="number">1</span>, keepdims=True))</span><br><span class="line">  probs /= <span class="built_in">np</span>.<span class="built_in">sum</span>(probs, axis=<span class="number">1</span>, keepdims=True)</span><br><span class="line">  N = x.shape[<span class="number">0</span>]</span><br><span class="line">  loss = -<span class="built_in">np</span>.<span class="built_in">sum</span>(<span class="built_in">np</span>.<span class="built_in">log</span>(probs[<span class="built_in">np</span>.arange(N), y])) / N</span><br><span class="line">  dx = probs.<span class="built_in">copy</span>()</span><br><span class="line">  dx[<span class="built_in">np</span>.arange(N), y] -= <span class="number">1</span></span><br><span class="line">  dx /= N</span><br><span class="line">  <span class="built_in">return</span> loss, dx</span><br></pre></td></tr></table></figure></p>
<h3 id="两层神经网络的构建"><a href="#两层神经网络的构建" class="headerlink" title="两层神经网络的构建"></a>两层神经网络的构建</h3><p>以前我们在一个单一类中实现过两层神经网络，现在我们用模块化方法实现神经网络。<br>首先定义一个两层神经网络类</p>
<h4 id="TwoLayerNet"><a href="#TwoLayerNet" class="headerlink" title="TwoLayerNet"></a>TwoLayerNet</h4><p>神经网络的主要结构如下：affine - relu - affine - softmax<br><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TwoLayerNet</span>(<span class="title">object</span>):  </span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, input_dim=<span class="number">3</span>*<span class="number">32</span>*<span class="number">32</span>, hidden_dim=<span class="number">100</span>, num_classes=<span class="number">10</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">               weight_scale=<span class="number">1</span>e-<span class="number">3</span>, reg=<span class="number">0</span>.<span class="number">0</span>)</span></span>:    </span><br><span class="line">    <span class="keyword">self</span>.params = &#123;&#125;</span><br><span class="line">    <span class="keyword">self</span>.reg = reg</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.params[<span class="string">'W1'</span>] = weight_scale * np.random.randn(input_dim, hidden_dim)     </span><br><span class="line">    <span class="keyword">self</span>.params[<span class="string">'b1'</span>] = np.zeros((<span class="number">1</span>, hidden_dim))    </span><br><span class="line">    <span class="keyword">self</span>.params[<span class="string">'W2'</span>] = weight_scale * np.random.randn(hidden_dim, num_classes)  </span><br><span class="line">    <span class="keyword">self</span>.params[<span class="string">'b2'</span>] = np.zeros((<span class="number">1</span>, num_classes))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">loss</span><span class="params">(<span class="keyword">self</span>, X, y=None)</span></span><span class="symbol">:</span></span><br><span class="line">    scores = None</span><br><span class="line">    N = X.shape[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># Unpack variables from the params dictionary</span></span><br><span class="line">    W1, b1 = <span class="keyword">self</span>.params[<span class="string">'W1'</span>], <span class="keyword">self</span>.params[<span class="string">'b1'</span>]</span><br><span class="line">    W2, b2 = <span class="keyword">self</span>.params[<span class="string">'W2'</span>], <span class="keyword">self</span>.params[<span class="string">'b2'</span>]</span><br><span class="line">    h1, cache1 = affine_relu_forward(X, W1, b1)</span><br><span class="line">    out, cache2 = affine_forward(h1, W2, b2)</span><br><span class="line">    scores = out              <span class="comment"># (N,C)</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment"># If y is None then we are in test mode so just return scores</span></span><br><span class="line">    <span class="keyword">if</span> y is <span class="symbol">None:</span></span><br><span class="line">      <span class="keyword">return</span> scores</span><br><span class="line">    </span><br><span class="line">    loss, grads = <span class="number">0</span>, &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    data_loss, dscores = softmax_loss(scores, y)</span><br><span class="line">    reg_loss = <span class="number">0</span>.<span class="number">5</span> * <span class="keyword">self</span>.reg * np.sum(W1*W1) + <span class="number">0</span>.<span class="number">5</span> * <span class="keyword">self</span>.reg * np.sum(W2*W2)</span><br><span class="line">    loss = data_loss + reg_loss</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Backward pass: compute gradients</span></span><br><span class="line">    dh1, dW2, db2 = affine_backward(dscores, cache2)</span><br><span class="line">    dX, dW1, db1 = affine_relu_backward(dh1, cache1)</span><br><span class="line">    <span class="comment"># Add the regularization gradient contribution</span></span><br><span class="line">    dW2 += <span class="keyword">self</span>.reg * W2</span><br><span class="line">    dW1 += <span class="keyword">self</span>.reg * W1</span><br><span class="line">    grads[<span class="string">'W1'</span>] = dW1</span><br><span class="line">    grads[<span class="string">'b1'</span>] = db1</span><br><span class="line">    grads[<span class="string">'W2'</span>] = dW2</span><br><span class="line">    grads[<span class="string">'b2'</span>] = db2</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> loss, grads</span><br></pre></td></tr></table></figure></p>
<p>通过这个类我们初始化了神经网络，同时求出了损失函数与梯度。</p>
<h4 id="Solver"><a href="#Solver" class="headerlink" title="Solver"></a>Solver</h4><p>训练模块则与上述部分分离，使用Solver类实现<br><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solver</span>(<span class="title">object</span>):</span></span><br><span class="line">  <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">  A Solver encapsulates all the logic necessary for training classification</span></span><br><span class="line"><span class="string">  models. The Solver performs stochastic gradient descent using different</span></span><br><span class="line"><span class="string">  update rules defined in optim.py.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  The solver accepts both training and validataion data and labels so it can</span></span><br><span class="line"><span class="string">  periodically check classification accuracy on both training and validation</span></span><br><span class="line"><span class="string">  data to watch out for overfitting.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  To train a model, you will first construct a Solver instance, passing the</span></span><br><span class="line"><span class="string">  model, dataset, and various optoins (learning rate, batch size, etc) to the</span></span><br><span class="line"><span class="string">  constructor. You will then call the train() method to run the optimization</span></span><br><span class="line"><span class="string">  procedure and train the model.</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  After the train() method returns, model.params will contain the parameters</span></span><br><span class="line"><span class="string">  that performed best on the validation set over the course of training.</span></span><br><span class="line"><span class="string">  In addition, the instance variable solver.loss_history will contain a list</span></span><br><span class="line"><span class="string">  of all losses encountered during training and the instance variables</span></span><br><span class="line"><span class="string">  solver.train_acc_history and solver.val_acc_history will be lists containing</span></span><br><span class="line"><span class="string">  the accuracies of the model on the training and validation set at each epoch.</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  Example usage might look something like this:</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  data = &#123;</span></span><br><span class="line"><span class="string">    'X_train': # training data</span></span><br><span class="line"><span class="string">    'y_train': # training labels</span></span><br><span class="line"><span class="string">    'X_val': # validation data</span></span><br><span class="line"><span class="string">    'X_train': # validation labels</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  model = MyAwesomeModel(hidden_size=100, reg=10)</span></span><br><span class="line"><span class="string">  solver = Solver(model, data,</span></span><br><span class="line"><span class="string">                  update_rule='sgd',</span></span><br><span class="line"><span class="string">                  optim_config=&#123;</span></span><br><span class="line"><span class="string">                    'learning_rate': 1e-3,</span></span><br><span class="line"><span class="string">                  &#125;,</span></span><br><span class="line"><span class="string">                  lr_decay=0.95,</span></span><br><span class="line"><span class="string">                  num_epochs=10, batch_size=100,</span></span><br><span class="line"><span class="string">                  print_every=100)</span></span><br><span class="line"><span class="string">  solver.train()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  A Solver works on a model object that must conform to the following API:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  - model.params must be a dictionary mapping string parameter names to numpy</span></span><br><span class="line"><span class="string">    arrays containing parameter values.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  - model.loss(X, y) must be a function that computes training-time loss and</span></span><br><span class="line"><span class="string">    gradients, and test-time classification scores, with the following inputs</span></span><br><span class="line"><span class="string">    and outputs:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Inputs:</span></span><br><span class="line"><span class="string">    - X: Array giving a minibatch of input data of shape (N, d_1, ..., d_k)</span></span><br><span class="line"><span class="string">    - y: Array of labels, of shape (N,) giving labels for X where y[i] is the</span></span><br><span class="line"><span class="string">      label for X[i].</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">    If y is None, run a test-time forward pass and return:</span></span><br><span class="line"><span class="string">    - scores: Array of shape (N, C) giving classification scores for X where</span></span><br><span class="line"><span class="string">      scores[i, c] gives the score of class c for X[i].</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    If y is not None, run a training time forward and backward pass and return</span></span><br><span class="line"><span class="string">    a tuple of:</span></span><br><span class="line"><span class="string">    - loss: Scalar giving the loss</span></span><br><span class="line"><span class="string">    - grads: Dictionary with the same keys as self.params mapping parameter</span></span><br><span class="line"><span class="string">      names to gradients of the loss with respect to those parameters.</span></span><br><span class="line"><span class="string">  "</span><span class="string">""</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, model, data, **kwargs)</span></span><span class="symbol">:</span></span><br><span class="line">    <span class="keyword">self</span>.model = model</span><br><span class="line">    <span class="keyword">self</span>.X_train = data[<span class="string">'X_train'</span>]</span><br><span class="line">    <span class="keyword">self</span>.y_train = data[<span class="string">'y_train'</span>]</span><br><span class="line">    <span class="keyword">self</span>.X_val = data[<span class="string">'X_val'</span>]</span><br><span class="line">    <span class="keyword">self</span>.y_val = data[<span class="string">'y_val'</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Unpack keyword arguments</span></span><br><span class="line">    <span class="keyword">self</span>.update_rule = kwargs.pop(<span class="string">'update_rule'</span>, <span class="string">'sgd'</span>)</span><br><span class="line">    <span class="keyword">self</span>.optim_config = kwargs.pop(<span class="string">'optim_config'</span>, &#123;&#125;)</span><br><span class="line">    <span class="keyword">self</span>.lr_decay = kwargs.pop(<span class="string">'lr_decay'</span>, <span class="number">1.0</span>)</span><br><span class="line">    <span class="keyword">self</span>.batch_size = kwargs.pop(<span class="string">'batch_size'</span>, <span class="number">100</span>)</span><br><span class="line">    <span class="keyword">self</span>.num_epochs = kwargs.pop(<span class="string">'num_epochs'</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.print_every = kwargs.pop(<span class="string">'print_every'</span>, <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">self</span>.verbose = kwargs.pop(<span class="string">'verbose'</span>, True)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Throw an error if there are extra keyword arguments</span></span><br><span class="line">    <span class="keyword">if</span> len(kwargs) &gt; <span class="number">0</span><span class="symbol">:</span></span><br><span class="line">      extra = <span class="string">', '</span>.join(<span class="string">'"%s"'</span> % k <span class="keyword">for</span> k <span class="keyword">in</span> kwargs.keys())</span><br><span class="line">      raise ValueError(<span class="string">'Unrecognized arguments %s'</span> % extra)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Make sure the update rule exists, then replace the string</span></span><br><span class="line">    <span class="comment"># name with the actual function</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> hasattr(optim, <span class="keyword">self</span>.update_rule)<span class="symbol">:</span></span><br><span class="line">      raise ValueError(<span class="string">'Invalid update_rule "%s"'</span> % <span class="keyword">self</span>.update_rule)</span><br><span class="line">    <span class="keyword">self</span>.update_rule = getattr(optim, <span class="keyword">self</span>.update_rule)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>._reset()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">_reset</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">    <span class="comment"># Set up some variables for book-keeping</span></span><br><span class="line">    <span class="keyword">self</span>.epoch = <span class="number">0</span></span><br><span class="line">    <span class="keyword">self</span>.best_val_acc = <span class="number">0</span></span><br><span class="line">    <span class="keyword">self</span>.best_params = &#123;&#125;</span><br><span class="line">    <span class="keyword">self</span>.loss_history = []</span><br><span class="line">    <span class="keyword">self</span>.train_acc_history = []</span><br><span class="line">    <span class="keyword">self</span>.val_acc_history = []</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Make a deep copy of the optim_config for each parameter</span></span><br><span class="line">    <span class="keyword">self</span>.optim_configs = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> <span class="keyword">self</span>.model.<span class="symbol">params:</span></span><br><span class="line">      d = &#123;<span class="symbol">k:</span> v <span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="keyword">self</span>.optim_config.iteritems()&#125;</span><br><span class="line">      <span class="keyword">self</span>.optim_configs[p] = d</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">_step</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">    <span class="comment"># Make a minibatch of training data</span></span><br><span class="line">    num_train = <span class="keyword">self</span>.X_train.shape[<span class="number">0</span>]</span><br><span class="line">    batch_mask = np.random.choice(num_train, <span class="keyword">self</span>.batch_size)</span><br><span class="line">    X_batch = <span class="keyword">self</span>.X_train[batch_mask]</span><br><span class="line">    y_batch = <span class="keyword">self</span>.y_train[batch_mask]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Compute loss and gradient</span></span><br><span class="line">    loss, grads = <span class="keyword">self</span>.model.loss(X_batch, y_batch)</span><br><span class="line">    <span class="keyword">self</span>.loss_history.append(loss)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Perform a parameter update</span></span><br><span class="line">    <span class="keyword">for</span> p, w <span class="keyword">in</span> <span class="keyword">self</span>.model.params.iteritems()<span class="symbol">:</span></span><br><span class="line">      dw = grads[p]</span><br><span class="line">      config = <span class="keyword">self</span>.optim_configs[p]</span><br><span class="line">      next_w, next_config = <span class="keyword">self</span>.update_rule(w, dw, config)</span><br><span class="line">      <span class="keyword">self</span>.model.params[p] = next_w</span><br><span class="line">      <span class="keyword">self</span>.optim_configs[p] = next_config</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">check_accuracy</span><span class="params">(<span class="keyword">self</span>, X, y, num_samples=None, batch_size=<span class="number">100</span>)</span></span>:    </span><br><span class="line">    <span class="comment"># Maybe subsample the data</span></span><br><span class="line">    N = X.shape[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">if</span> num_samples is <span class="keyword">not</span> None <span class="keyword">and</span> N &gt; <span class="symbol">num_samples:</span></span><br><span class="line">      mask = np.random.choice(N, num_samples)</span><br><span class="line">      N = num_samples</span><br><span class="line">      X = X[mask]</span><br><span class="line">      y = y[mask]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Compute predictions in batches</span></span><br><span class="line">    num_batches = N / batch_size</span><br><span class="line">    <span class="keyword">if</span> N % batch_size != <span class="number">0</span><span class="symbol">:</span></span><br><span class="line">      num_batches += <span class="number">1</span></span><br><span class="line">    y_pred = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(num_batches)<span class="symbol">:</span></span><br><span class="line">      start = i * batch_size</span><br><span class="line">      <span class="keyword">end</span> = (i + <span class="number">1</span>) * batch_size</span><br><span class="line">      scores = <span class="keyword">self</span>.model.loss(X[<span class="symbol">start:</span><span class="keyword">end</span>])</span><br><span class="line">      y_pred.append(np.argmax(scores, axis=<span class="number">1</span>))</span><br><span class="line">    y_pred = np.hstack(y_pred)</span><br><span class="line">    acc = np.mean(y_pred == y)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> acc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">train</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">    num_train = <span class="keyword">self</span>.X_train.shape[<span class="number">0</span>]</span><br><span class="line">    iterations_per_epoch = max(num_train / <span class="keyword">self</span>.batch_size, <span class="number">1</span>)</span><br><span class="line">    num_iterations = <span class="keyword">self</span>.num_epochs * iterations_per_epoch</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> xrange(num_iterations)<span class="symbol">:</span></span><br><span class="line">      <span class="keyword">self</span>._step()</span><br><span class="line"></span><br><span class="line">      <span class="comment"># Maybe print training loss</span></span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">self</span>.verbose <span class="keyword">and</span> t % <span class="keyword">self</span>.print_every == <span class="number">0</span><span class="symbol">:</span></span><br><span class="line">        print <span class="string">'(Iteration %d / %d) loss: %f'</span> % (</span><br><span class="line">               t + <span class="number">1</span>, num_iterations, <span class="keyword">self</span>.loss_history[-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">      <span class="comment"># At the end of every epoch, increment the epoch counter and decay the</span></span><br><span class="line">      <span class="comment"># learning rate.</span></span><br><span class="line">      epoch_end = (t + <span class="number">1</span>) % iterations_per_epoch == <span class="number">0</span></span><br><span class="line">      <span class="keyword">if</span> <span class="symbol">epoch_end:</span></span><br><span class="line">        <span class="keyword">self</span>.epoch += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="keyword">self</span>.<span class="symbol">optim_configs:</span></span><br><span class="line">          <span class="keyword">self</span>.optim_configs[k][<span class="string">'learning_rate'</span>] *= <span class="keyword">self</span>.lr_decay</span><br><span class="line"></span><br><span class="line">      <span class="comment"># Check train and val accuracy on the first iteration, the last</span></span><br><span class="line">      <span class="comment"># iteration, and at the end of each epoch.</span></span><br><span class="line">      first_it = (t == <span class="number">0</span>)</span><br><span class="line">      last_it = (t == num_iterations + <span class="number">1</span>)</span><br><span class="line">      <span class="keyword">if</span> first_it <span class="keyword">or</span> last_it <span class="keyword">or</span> <span class="symbol">epoch_end:</span></span><br><span class="line">        train_acc = <span class="keyword">self</span>.check_accuracy(<span class="keyword">self</span>.X_train, <span class="keyword">self</span>.y_train,</span><br><span class="line">                                        num_samples=<span class="number">1000</span>)</span><br><span class="line">        val_acc = <span class="keyword">self</span>.check_accuracy(<span class="keyword">self</span>.X_val, <span class="keyword">self</span>.y_val)</span><br><span class="line">        <span class="keyword">self</span>.train_acc_history.append(train_acc)</span><br><span class="line">        <span class="keyword">self</span>.val_acc_history.append(val_acc)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.<span class="symbol">verbose:</span></span><br><span class="line">          print <span class="string">'(Epoch %d / %d) train acc: %f; val_acc: %f'</span> % (</span><br><span class="line">                 <span class="keyword">self</span>.epoch, <span class="keyword">self</span>.num_epochs, train_acc, val_acc)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Keep track of the best model</span></span><br><span class="line">        <span class="keyword">if</span> val_acc &gt; <span class="keyword">self</span>.<span class="symbol">best_val_acc:</span></span><br><span class="line">          <span class="keyword">self</span>.best_val_acc = val_acc</span><br><span class="line">          <span class="keyword">self</span>.best_params = &#123;&#125;</span><br><span class="line">          <span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="keyword">self</span>.model.params.iteritems()<span class="symbol">:</span></span><br><span class="line">            <span class="keyword">self</span>.best_params[k] = v.copy()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># At the end of training swap the best params into the model</span></span><br><span class="line">    <span class="keyword">self</span>.model.params = <span class="keyword">self</span>.best_params</span><br></pre></td></tr></table></figure></p>
<h4 id="两个类的结合使用"><a href="#两个类的结合使用" class="headerlink" title="两个类的结合使用"></a>两个类的结合使用</h4><p>将以上两个类结合起来训练神经网络的方式如下：<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">model = TwoLayerNet()</span><br><span class="line">solver = None</span><br><span class="line">solver = Solver(model, data,</span><br><span class="line">    <span class="attribute">update_rule</span>=<span class="string">'sgd'</span>,</span><br><span class="line">    optim_config=&#123;</span><br><span class="line">    <span class="string">'learning_rate'</span>: 1e-3,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attribute">lr_decay</span>=0.8,</span><br><span class="line">    <span class="attribute">num_epochs</span>=10, <span class="attribute">batch_size</span>=100,</span><br><span class="line">    <span class="attribute">print_every</span>=100)</span><br><span class="line">solver.train()</span><br><span class="line">scores = model.loss(data[<span class="string">'X_test'</span>])</span><br><span class="line">y_pred = np.argmax(scores, axis = 1)</span><br><span class="line">acc = np.mean(y_pred == data[<span class="string">'y_test'</span>])</span><br><span class="line"><span class="builtin-name">print</span> <span class="string">'test acc: %f'</span> %(acc)</span><br></pre></td></tr></table></figure></p>
<p>以上方法可以达到50%以上的准确率。<br>可视化如下：<br><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">plt</span><span class="selector-class">.subplot</span>(<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"><span class="selector-tag">plt</span><span class="selector-class">.title</span>(<span class="string">'Training loss'</span>)</span><br><span class="line"><span class="selector-tag">plt</span><span class="selector-class">.plot</span>(solver.loss_history, <span class="string">'o'</span>)</span><br><span class="line"><span class="selector-tag">plt</span><span class="selector-class">.xlabel</span>(<span class="string">'Iteration'</span>)</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">plt</span><span class="selector-class">.subplot</span>(<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="selector-tag">plt</span><span class="selector-class">.title</span>(<span class="string">'Accuracy'</span>)</span><br><span class="line"><span class="selector-tag">plt</span><span class="selector-class">.plot</span>(solver.train_acc_history, <span class="string">'-o'</span>, label=<span class="string">'train'</span>)</span><br><span class="line"><span class="selector-tag">plt</span><span class="selector-class">.plot</span>(solver.val_acc_history, <span class="string">'-o'</span>, label=<span class="string">'val'</span>)</span><br><span class="line"><span class="selector-tag">plt</span><span class="selector-class">.plot</span>([<span class="number">0.5</span>] * len(solver.val_acc_history), <span class="string">'k--'</span>)</span><br><span class="line"><span class="selector-tag">plt</span><span class="selector-class">.xlabel</span>(<span class="string">'Epoch'</span>)</span><br><span class="line"><span class="selector-tag">plt</span><span class="selector-class">.legend</span>(loc=<span class="string">'lower right'</span>)</span><br><span class="line"><span class="selector-tag">plt</span><span class="selector-class">.gcf</span>()<span class="selector-class">.set_size_inches</span>(<span class="number">15</span>, <span class="number">12</span>)</span><br><span class="line"><span class="selector-tag">plt</span><span class="selector-class">.show</span>()</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/cs231n/chapter1/p1.png" alt></p>
<h3 id="多层神经网络"><a href="#多层神经网络" class="headerlink" title="多层神经网络"></a>多层神经网络</h3><p>多层神经网络的实现：我们首先也需要定义和初始化多层神经网络的类：</p>
<h4 id="FullyConnectedNet"><a href="#FullyConnectedNet" class="headerlink" title="FullyConnectedNet"></a>FullyConnectedNet</h4><p>其主要结构如下所示：{affine - [batch norm] - relu - [dropout]} x (L - 1) - affine - softmax<br>全连接层网络，BatchNomal与DropOut部分可以暂时省略，后续添加。<br><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">class FullyConnectedNet(object):</span><br><span class="line"></span><br><span class="line">  def __init__(<span class="keyword">self</span>, hidden_dims, input_dim=<span class="number">3</span>*<span class="number">32</span>*<span class="number">32</span>, num_classes=<span class="number">10</span>,</span><br><span class="line">               dropout=<span class="number">0</span>, use_batchnorm=False, reg=<span class="number">0.0</span>,</span><br><span class="line">               weight_scale=<span class="number">1e-2</span>, dtype=np.float32, seed=<span class="literal">None</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.use_batchnorm = use_batchnorm</span><br><span class="line">    <span class="keyword">self</span>.use_dropout = dropout &gt; <span class="number">0</span></span><br><span class="line">    <span class="keyword">self</span>.reg = reg</span><br><span class="line">    <span class="keyword">self</span>.num_layers = <span class="number">1</span> + len(hidden_dims)</span><br><span class="line">    <span class="keyword">self</span>.dtype = dtype</span><br><span class="line">    <span class="keyword">self</span>.params = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    layers_dims = [input_dim] + hidden_dims + [num_classes]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="keyword">self</span>.num_layers):    </span><br><span class="line">        <span class="keyword">self</span>.params[<span class="string">'W'</span> + <span class="built_in">str</span>(i+<span class="number">1</span>)] = weight_scale * np.random.randn(layers_dims[i], layers_dims[i+<span class="number">1</span>])    </span><br><span class="line">        <span class="keyword">self</span>.params[<span class="string">'b'</span> + <span class="built_in">str</span>(i+<span class="number">1</span>)] = np.zeros((<span class="number">1</span>, layers_dims[i+<span class="number">1</span>]))    </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.use_batchnorm and i &lt; len(hidden_dims): </span><br><span class="line">            <span class="keyword">self</span>.params[<span class="symbol">'gamma</span>' + <span class="built_in">str</span>(i+<span class="number">1</span>)] = np.ones((<span class="number">1</span>, layers_dims[i+<span class="number">1</span>]))        </span><br><span class="line">            <span class="keyword">self</span>.params[<span class="symbol">'beta</span>' + <span class="built_in">str</span>(i+<span class="number">1</span>)] = np.zeros((<span class="number">1</span>, layers_dims[i+<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.dropout_param = &#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">self</span>.use_dropout:</span><br><span class="line">      <span class="keyword">self</span>.dropout_param = &#123;<span class="symbol">'mode</span>': <span class="symbol">'train</span>', <span class="string">'p'</span>: dropout&#125;</span><br><span class="line">      <span class="keyword">if</span> seed is not <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">self</span>.dropout_param[<span class="symbol">'seed</span>'] = seed</span><br><span class="line">    <span class="keyword">self</span>.bn_params = []</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">self</span>.use_batchnorm:</span><br><span class="line">      <span class="keyword">self</span>.bn_params = [&#123;<span class="symbol">'mode</span>': <span class="symbol">'train</span>'&#125; <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="keyword">self</span>.num_layers - <span class="number">1</span>)]</span><br><span class="line">    </span><br><span class="line">    # Cast all parameters to the correct datatype</span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="keyword">self</span>.params.iteritems():</span><br><span class="line">      <span class="keyword">self</span>.params[k] = v.astype(dtype)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  def loss(<span class="keyword">self</span>, X, y=<span class="literal">None</span>):</span><br><span class="line">    X = X.astype(<span class="keyword">self</span>.dtype)</span><br><span class="line">    mode = <span class="symbol">'test</span>' <span class="keyword">if</span> y is <span class="literal">None</span> <span class="keyword">else</span> <span class="symbol">'train</span>'</span><br><span class="line"></span><br><span class="line">    # Set train/test mode <span class="keyword">for</span> batchnorm params and dropout param since they</span><br><span class="line">    # behave differently during training and testing.</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">self</span>.dropout_param is not <span class="literal">None</span>:</span><br><span class="line">      <span class="keyword">self</span>.dropout_param[<span class="symbol">'mode</span>'] = mode   </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">self</span>.use_batchnorm:</span><br><span class="line">      <span class="keyword">for</span> bn_param <span class="keyword">in</span> <span class="keyword">self</span>.bn_params:</span><br><span class="line">        bn_param[mode] = mode</span><br><span class="line"></span><br><span class="line">    scores = <span class="literal">None</span></span><br><span class="line">    h, cache1, cache2, cache3, bn, out = &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;    </span><br><span class="line">    out[<span class="number">0</span>] = X</span><br><span class="line"></span><br><span class="line">    # Forward pass: compute loss</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="keyword">self</span>.num_layers-<span class="number">1</span>):    </span><br><span class="line">        # Unpack variables from the params dictionary    </span><br><span class="line">        W, b = <span class="keyword">self</span>.params[<span class="string">'W'</span> + <span class="built_in">str</span>(i+<span class="number">1</span>)], <span class="keyword">self</span>.params[<span class="string">'b'</span> + <span class="built_in">str</span>(i+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.use_batchnorm:        </span><br><span class="line">            gamma, beta = <span class="keyword">self</span>.params[<span class="symbol">'gamma</span>' + <span class="built_in">str</span>(i+<span class="number">1</span>)], <span class="keyword">self</span>.params[<span class="symbol">'beta</span>' + <span class="built_in">str</span>(i+<span class="number">1</span>)]        </span><br><span class="line">            h[i], cache1[i] = affine_forward(out[i], W, b)        </span><br><span class="line">            bn[i], cache2[i] = batchnorm_forward(h[i], gamma, beta, <span class="keyword">self</span>.bn_params[i])        </span><br><span class="line">            out[i+<span class="number">1</span>], cache3[i] = relu_forward(bn[i])    </span><br><span class="line">        <span class="keyword">else</span>:        </span><br><span class="line">            out[i+<span class="number">1</span>], cache3[i] = affine_relu_forward(out[i], W, b)</span><br><span class="line"></span><br><span class="line">    W, b = <span class="keyword">self</span>.params[<span class="string">'W'</span> + <span class="built_in">str</span>(<span class="keyword">self</span>.num_layers)], <span class="keyword">self</span>.params[<span class="string">'b'</span> + <span class="built_in">str</span>(<span class="keyword">self</span>.num_layers)]</span><br><span class="line">    scores, cache = affine_forward(out[<span class="keyword">self</span>.num_layers-<span class="number">1</span>], W, b)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    # If test mode <span class="keyword">return</span> early</span><br><span class="line">    <span class="keyword">if</span> mode == <span class="symbol">'test</span>':</span><br><span class="line">      <span class="keyword">return</span> scores</span><br><span class="line"></span><br><span class="line">    loss, grads = <span class="number">0.0</span>, &#123;&#125;</span><br><span class="line"></span><br><span class="line">    reg_loss=<span class="number">0.0</span></span><br><span class="line">    data_loss, dscores = softmax_loss(scores, y)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="keyword">self</span>.num_layers):    </span><br><span class="line">        reg_loss += <span class="number">0.5</span> * <span class="keyword">self</span>.reg * np.sum(<span class="keyword">self</span>.params[<span class="string">'W'</span> + <span class="built_in">str</span>(i+<span class="number">1</span>)]*<span class="keyword">self</span>.params[<span class="string">'W'</span> + <span class="built_in">str</span>(i+<span class="number">1</span>)])</span><br><span class="line">    loss = data_loss + reg_loss</span><br><span class="line"></span><br><span class="line">    # Backward pass: compute gradients</span><br><span class="line">    dout, dbn, dh = &#123;&#125;, &#123;&#125;, &#123;&#125;</span><br><span class="line">    t = <span class="keyword">self</span>.num_layers-<span class="number">1</span></span><br><span class="line">    dout[t], grads[<span class="string">'W'</span>+<span class="built_in">str</span>(t+<span class="number">1</span>)], grads[<span class="string">'b'</span>+<span class="built_in">str</span>(t+<span class="number">1</span>)] = affine_backward(dscores, cache)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(t):    </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.use_batchnorm:        </span><br><span class="line">            dbn[t-<span class="number">1</span>-i] = relu_backward(dout[t-i], cache3[t-<span class="number">1</span>-i]) </span><br><span class="line">            dh[t-<span class="number">1</span>-i], grads[<span class="symbol">'gamma</span>'+<span class="built_in">str</span>(t-i)], grads[<span class="symbol">'beta</span>'+<span class="built_in">str</span>(t-i)] = batchnorm_backward(dbn[t-<span class="number">1</span>-i], cache2[t-<span class="number">1</span>-i])       </span><br><span class="line">            dout[t-<span class="number">1</span>-i], grads[<span class="string">'W'</span>+<span class="built_in">str</span>(t-i)], grads[<span class="string">'b'</span>+<span class="built_in">str</span>(t-i)] = affine_backward(dh[t-<span class="number">1</span>-i], cache1[t-<span class="number">1</span>-i])    </span><br><span class="line">        <span class="keyword">else</span>:        </span><br><span class="line">            dout[t-<span class="number">1</span>-i], grads[<span class="string">'W'</span>+<span class="built_in">str</span>(t-i)], grads[<span class="string">'b'</span>+<span class="built_in">str</span>(t-i)] = affine_relu_backward(dout[t-i], cache3[t-<span class="number">1</span>-i])</span><br><span class="line"></span><br><span class="line">    # Add the regularization gradient contribution</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="keyword">self</span>.num_layers):    </span><br><span class="line">        grads[<span class="string">'W'</span>+<span class="built_in">str</span>(i+<span class="number">1</span>)] += <span class="keyword">self</span>.reg * <span class="keyword">self</span>.params[<span class="string">'W'</span> + <span class="built_in">str</span>(i+<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> loss, grads</span><br></pre></td></tr></table></figure></p>
<h4 id="三层神经网络"><a href="#三层神经网络" class="headerlink" title="三层神经网络"></a>三层神经网络</h4><p>使用一个小的50张图片的数据集作为输入，使用一个隐藏层有100个单元的三层网络来训练运行测试<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">num_train = 50</span><br><span class="line">small_data = &#123;</span><br><span class="line">  <span class="string">'X_train'</span>: data[<span class="string">'X_train'</span>][:num_train],</span><br><span class="line">  <span class="string">'y_train'</span>: data[<span class="string">'y_train'</span>][:num_train],</span><br><span class="line">  <span class="string">'X_val'</span>: data[<span class="string">'X_val'</span>],</span><br><span class="line">  <span class="string">'y_val'</span>: data[<span class="string">'y_val'</span>],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">weight_scale = 1e-2</span><br><span class="line">learning_rate = 8e-3</span><br><span class="line">model = FullyConnectedNet([100, 100],</span><br><span class="line">              <span class="attribute">weight_scale</span>=weight_scale, <span class="attribute">dtype</span>=np.float64)</span><br><span class="line">solver = Solver(model, small_data,</span><br><span class="line">                <span class="attribute">print_every</span>=10, <span class="attribute">num_epochs</span>=20, <span class="attribute">batch_size</span>=25,</span><br><span class="line">                <span class="attribute">update_rule</span>=<span class="string">'sgd'</span>,</span><br><span class="line">                optim_config=&#123;</span><br><span class="line">                  <span class="string">'learning_rate'</span>: learning_rate,</span><br><span class="line">                &#125;</span><br><span class="line">         )</span><br><span class="line">solver.train()</span><br><span class="line"></span><br><span class="line">plt.plot(solver.loss_history, <span class="string">'o'</span>)</span><br><span class="line">plt.title(<span class="string">'Training loss history'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Iteration'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Training loss'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p>
<p>通过更新weight_scale与learning_rate，训练集的准确率可以从0.16增长到1<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/cs231n/chapter1/p2.png" alt></p>
<h4 id="5层神经网络"><a href="#5层神经网络" class="headerlink" title="5层神经网络"></a>5层神经网络</h4><p>同样是上面的50个数据集，这次用5层神经网络，每个隐藏层有100个单元的网络来测试它<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">num_train = 50</span><br><span class="line">small_data = &#123;</span><br><span class="line">  <span class="string">'X_train'</span>: data[<span class="string">'X_train'</span>][:num_train],</span><br><span class="line">  <span class="string">'y_train'</span>: data[<span class="string">'y_train'</span>][:num_train],</span><br><span class="line">  <span class="string">'X_val'</span>: data[<span class="string">'X_val'</span>],</span><br><span class="line">  <span class="string">'y_val'</span>: data[<span class="string">'y_val'</span>],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">learning_rate = 3e-4</span><br><span class="line">weight_scale = 1e-1</span><br><span class="line">model = FullyConnectedNet([100, 100, 100, 100],</span><br><span class="line">                <span class="attribute">weight_scale</span>=weight_scale, <span class="attribute">dtype</span>=np.float64)</span><br><span class="line">solver = Solver(model, small_data,</span><br><span class="line">                <span class="attribute">print_every</span>=10, <span class="attribute">num_epochs</span>=20, <span class="attribute">batch_size</span>=25,</span><br><span class="line">                <span class="attribute">update_rule</span>=<span class="string">'sgd'</span>,</span><br><span class="line">                optim_config=&#123;</span><br><span class="line">                  <span class="string">'learning_rate'</span>: learning_rate,</span><br><span class="line">                &#125;</span><br><span class="line">         )</span><br><span class="line">solver.train()</span><br><span class="line"></span><br><span class="line">plt.plot(solver.loss_history, <span class="string">'o'</span>)</span><br><span class="line">plt.title(<span class="string">'Training loss history'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Iteration'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Training loss'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p>
<p>选择合适的learing_rate与weight_scale，同样可以使准确率从训练0.16提升到1<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/cs231n/chapter1/p3.png" alt></p>
<h4 id="3层与5层神经网络比较"><a href="#3层与5层神经网络比较" class="headerlink" title="3层与5层神经网络比较"></a>3层与5层神经网络比较</h4><p>当我调整五层的超参数时，我发现最小损失对weight_scale更敏感，这使得损失函数容易地收敛到局部最小值。 我认为这种现象发生的原因是五层网络的复杂性，它的复杂也使得五层网络的损失函数比三层网络更复杂和更难以达到最优域，对初始化要敏感得多</p>
]]></content>
      <tags>
        <tag>计算机视觉</tag>
      </tags>
  </entry>
  <entry>
    <title>卷积神经网络之全连接层</title>
    <url>/blog/2017/04/full-connect-layer.html</url>
    <content><![CDATA[<p>全连接层中的任何神经元和上一层的任何神经元之间都有关联。<br>全连接层一般由两个部分组成：</p>
<ul>
<li>线性部分：主要做线性转换，输入用X表示，输出用Z表示</li>
<li>非线性部分：那当然是做非线性变换了，输入用线性部分的输出Z表示，输出用X表示。</li>
</ul>
<h3 id="线性部分"><a href="#线性部分" class="headerlink" title="线性部分"></a>线性部分</h3><p>线性部分的运算方法基本上就是线性加权求和的感觉，如果对于一个输入向量$x=[x_0,x_1…..x_n]^T$,线性部分的输出向量是$z=[z_0,z_1…z_m]^T$,那么线性部分的参数就可以想象一个m<em>n的矩阵W，再加上一个偏置项$b=[b_0…b_m]^T$,于是有：<br>W</em>x+b=z</p>
<h3 id="非线性部分"><a href="#非线性部分" class="headerlink" title="非线性部分"></a>非线性部分</h3><p>非线性部分有一些“套路”函数，这里只说下其中的一个经典函数——sigmoid。它的函数形式如下所示:<br>$$f(x)=\frac{1}{1+e^{-x}}$$<br>这个函数的输入正是我们上一步线性部分的输出z，此时z取值范围在$(-\infty ,+\infty)$，经过了这个函数就变成了(0,1)。<br>那非线性部分为什么要做这个函数转换呢？以我的粗浅理解，其中的一个作用就是作数据的归一化。不管前面的线性部分做了怎样的工作，到了非线性这里，所有的数值将被限制在一个范围内，这样后面的网络层如果要基于前面层的数据继续计算，这个数值就相对可控了。不然如果每一层的数值大小都不一样，有的范围在（0，1），有的在（0，10000），做优化的时候优化步长的设定就会有麻烦。<br>另外一个作用，就是打破之前的线性映射关系。如果全连接层没有非线性部分，只有线性部分，我们在模型中叠加多层神经网络是没有意义的，我们假设有一个2层全连接神经网络，其中没有非线性层，那么对于第一层有：<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/chapter1/p6.png" alt></p>
<h3 id="神经网络的模样"><a href="#神经网络的模样" class="headerlink" title="神经网络的模样"></a>神经网络的模样</h3><p>实际上对于只有一层且只有一个输出的神经网络，如果它的非线性部分还使用sigmoid函数，那么它的形式和逻辑斯特回归（logistic regression）是一样的。所以可以想象神经网络模型从概念上来看比逻辑斯特回归要复杂。那么它的复杂的样子是什么样呢？下面给出一段全连接层的代码，开始做实验：<br><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FC</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, in_num, out_num, lr = <span class="number">0</span>.<span class="number">01</span>)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>._in_num = in_num</span><br><span class="line">        <span class="keyword">self</span>._out_num = out_num</span><br><span class="line">        <span class="keyword">self</span>.w = np.random.randn(out_num, in_num) * <span class="number">10</span></span><br><span class="line">        <span class="keyword">self</span>.b = np.zeros(out_num)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_sigmoid</span><span class="params">(<span class="keyword">self</span>, in_data)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> / (<span class="number">1</span> + np.exp(-in_data))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(<span class="keyword">self</span>, in_data)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>._sigmoid(np.dot(<span class="keyword">self</span>.w, in_data) + <span class="keyword">self</span>.b)</span><br></pre></td></tr></table></figure></p>
<p>从代码上看东西并不多，注意到我们会对参数中的w进行随机初始化，有时我们会随机一个神经网络给我们.</p>
<p>为了方便可视化，这里只做输入为2，输出为1的数据。好了，先来看1号选手：<br><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">x = np.linspace(<span class="number">-10</span>,<span class="number">10</span>,<span class="number">100</span>)</span><br><span class="line">y = np.linspace(<span class="number">-10</span>,<span class="number">10</span>,<span class="number">100</span>)</span><br><span class="line">X, Y = np.meshgrid(x,y)</span><br><span class="line">X_f = X.flatten()</span><br><span class="line">Y_f = Y.flatten()</span><br><span class="line">data = zip(X_f, Y_f)</span><br><span class="line"></span><br><span class="line">fc = FC(<span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">Z1 = np.array([fc.forward(d) for d in data])</span><br><span class="line">Z1 = Z1.reshape((<span class="number">100</span>,<span class="number">100</span>))</span><br><span class="line">draw3D(X, Y, Z1)</span><br></pre></td></tr></table></figure></p>
<p>定睛一看这其实就是一个标准的Logistic Regression。他的图像如下所示：<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/chapter2/p1.png" alt><br>经过多次随机测试，基本上它都是这个形状，只不过随着权重随机的数值变化，这个“台阶”对旋转到不同的方向，但归根结底还是一个台阶。</p>
<p>这也说明1层神经网络是没有出路的，它本质上还是个线性分类器的实力，我们可以给它再加一层：<br><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">fc = FC(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">fc.w = np.array([[<span class="number">0.4</span>, <span class="number">0.6</span>],[<span class="number">0.3</span>,<span class="number">0.7</span>],[<span class="number">0.2</span>,<span class="number">0.8</span>]])</span><br><span class="line">fc.b = np.array([<span class="number">0.5</span>,<span class="number">0.5</span>,<span class="number">0.5</span>])</span><br><span class="line"></span><br><span class="line">fc2 = FC(<span class="number">3</span>, <span class="number">1</span>)</span><br><span class="line">fc2.w = np.array([<span class="number">0.3</span>, <span class="number">0.2</span>, <span class="number">0.1</span>])</span><br><span class="line">fc2.b = np.array([<span class="number">0.5</span>])</span><br><span class="line"></span><br><span class="line">Z1 = np.array([fc.forward(d) for d in data])</span><br><span class="line">Z2 = np.array([fc2.forward(d) for d in Z1])</span><br><span class="line">Z2 = Z2.reshape((<span class="number">100</span>,<span class="number">100</span>))</span><br><span class="line"></span><br><span class="line">draw3D(X, Y, Z2)</span><br></pre></td></tr></table></figure></p>
<p>这次我们暂时不用随机权重，而是自己设置了几个数值，可以看出，参数设置得很用心。两层全都是正数……，那么图像呢？<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/chapter2/p2.png" alt></p>
<p>看上去比之前的台阶“柔软”了一些，但归根结底还是很像一个台阶……好吧，那我们加点负权重，让我们从两个方面分析输入数据：<br><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">fc = FC(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">fc.w = np.array([[<span class="number">-0.4</span>, <span class="number">1.6</span>],[<span class="number">-0.3</span>,<span class="number">0.7</span>],[<span class="number">0.2</span>,<span class="number">-0.8</span>]])</span><br><span class="line">fc.b = np.array([<span class="number">-0.5</span>,<span class="number">0.5</span>,<span class="number">0.5</span>])</span><br><span class="line"></span><br><span class="line">fc2 = FC(<span class="number">3</span>, <span class="number">1</span>)</span><br><span class="line">fc2.w = np.array([<span class="number">-3</span>, <span class="number">2</span>, <span class="number">-1</span>])</span><br><span class="line">fc2.b = np.array([<span class="number">0.5</span>])</span><br><span class="line"></span><br><span class="line">Z1 = np.array([fc.forward(d) for d in data])</span><br><span class="line">Z2 = np.array([fc2.forward(d) for d in Z1])</span><br><span class="line">Z2 = Z2.reshape((<span class="number">100</span>,<span class="number">100</span>))</span><br><span class="line"></span><br><span class="line">draw3D(X, Y, Z2)</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/chapter2/p3.png" alt><br>加了负权重后，看上去终于不那么像台阶了，这时候2层神经网络的非线性能力开始显现出来了。下面把权重交给随机大帝：<br><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">fc = FC(<span class="number">2</span>, <span class="number">100</span>)</span><br><span class="line">fc2 = FC(<span class="number">100</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">Z1 = np.array([fc.forward(d) for d in data])</span><br><span class="line">Z2 = np.array([fc2.forward(d) for d in Z1])</span><br><span class="line">Z2 = Z2.reshape((<span class="number">100</span>,<span class="number">100</span>))</span><br><span class="line">draw3D(X, Y, Z2,(<span class="number">75</span>,<span class="number">80</span>))</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/chapter2/p4.png" alt></p>
<p>这时候的非线性已经非常明显了,我们不妨继续加几层看看DNN的厉害：<br><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">fc = FC(<span class="number">2</span>, <span class="number">10</span>)</span><br><span class="line">fc2 = FC(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">fc3 = FC(<span class="number">20</span>, <span class="number">40</span>)</span><br><span class="line">fc4 = FC(<span class="number">40</span>, <span class="number">80</span>)</span><br><span class="line">fc5 = FC(<span class="number">80</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">Z1 = np.array([fc.forward(d) for d in data])</span><br><span class="line">Z2 = np.array([fc2.forward(d) for d in Z1])</span><br><span class="line">Z3 = np.array([fc3.forward(d) for d in Z2])</span><br><span class="line">Z4 = np.array([fc4.forward(d) for d in Z3])</span><br><span class="line">Z5 = np.array([fc5.forward(d) for d in Z4])</span><br><span class="line">Z5 = Z5.reshape((<span class="number">100</span>,<span class="number">100</span>))</span><br><span class="line">draw3D(X, Y, Z5,(<span class="number">75</span>,<span class="number">80</span>))</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/chapter2/p6.png" alt><br>从上面的实验中可以看出，层数越高，非线性的“能力”确实越强，脑洞开得也越大。</p>
<h3 id="反向传播算法"><a href="#反向传播算法" class="headerlink" title="反向传播算法"></a>反向传播算法</h3><p>神经网络是一个用在监督学习上的模型，所谓的监督学习就是我们要提前知道输入和输出。那么我们的模型训练目标自然是希望模型在接收输入后，可以得到和我们提前知道的一样的输出。<br>但是怎么描述这个“一样”呢？现实中会有很多具体的表述方法。这里我们介绍并采用一种相对简单的方式，那就是二次损失函数。对于模型的输出y，和我们提前知道的理论输出t，有：<br>$$Loss(y,t)=0.5*(y-t)^2$$<br>好了，下面我们定义一个双层神经网络，其中：</p>
<p>1.输入的数据是2维<br>2.第一层神经网络的输入也是2维，输出是4维，非线性部分采用sigmoid函数<br>3.第二层神经网络的输入也是4维，输出是1维，非线性部分采用sigmoid函数<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/chapter2/p1.jpg" alt></p>
<h4 id="链式求导"><a href="#链式求导" class="headerlink" title="链式求导"></a>链式求导</h4><p>我们的目标函数是这个损失函数Loss，优化方法还是之前提到的梯度下降法，那么我们就需要求出每一个参数的梯度，也就是：<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/chapter2/p7.png" alt><br>如果我们能求出上面的17个梯度，后面我们就可以用负梯度乘以步长进行优化迭代了，说实话，直接求解这些确实有点难，这时候微分世界的一大神器就来了，那就是链式求导。</p>
<p>我们把数据传递的过程再详细描述一下：<br>1.输入数据$x^0$<br>2.第一层的线性部分输出$z^0$<br>3.第一层的非线性部分输出$x^1$<br>4.第二层的线性部分输出$z^1$<br>5.第二层的非线性部分输出y<br>6.二次损失函数Loss<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/chapter2/p8.png" alt><br>到这里，我们已经顺利求出第二层的所有参数的导数了<br>下面是第一层<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/chapter2/p9.png" alt></p>
<p>看着十分复杂是吧？可是实际上其中每一个部分都已经被我们计算了，我们只需要把数据全部代入就可以了。当然，实际上如果严格按照公式进行计算，梯度的公式会比这个更复杂，但是其中一部分梯度实际上等于0，所以在此略去。</p>
<p>而且，随着我们从高层网络向低层计算的过程中，很多中间结果可以用于计算高层参数的梯度了。所以经过整理，全部的计算过程可以如下表示：<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/chapter2/p10.png" alt></p>
<h4 id="反向传导的抽象"><a href="#反向传导的抽象" class="headerlink" title="反向传导的抽象"></a>反向传导的抽象</h4><p>上面的8个步骤我们呢可以分成2部分：1-4步实际上完成了第2层神经网络的梯度计算，5-8步实际上完成了第1层神经网络的梯度计算。抽象地分析，可以得出：</p>
<p>1.Loss对本层非线性部分的梯度<br>2.Loss对本层线性部分的梯度<br>3.Loss对本层线性部分w的梯度<br>4.Loss对本层线性部分b的梯度<br>如果每一个高层把下面一层的输出梯度计算好传递过去，那么我们就可以把每一层抽象出来，各自完成各自的计算即可，层与层之间的计算可以做到”完全独立”，虽然它们是连在一起的。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>在做公式推导的时候，我们实际上只是针对一个数据样本进行推导，而实际中，计算和训练都是一批一批完成的。大多数机器学习训练都有batch的概念，而训练中batch的计算不是一个一个地算，而是一批数据集中算，那么就需要用上矩阵了。</p>
<p>首先给出Loss的代码，这里y和t都是按列存储的，每一列都是一个样本：<br><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SquareLoss</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(<span class="keyword">self</span>, y, t)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.loss = y - t</span><br><span class="line">        <span class="keyword">return</span> np.sum(<span class="keyword">self</span>.loss * <span class="keyword">self</span>.loss) /  <span class="keyword">self</span>.loss.shape[<span class="number">1</span>] / <span class="number">2</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backward</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.loss</span><br></pre></td></tr></table></figure></p>
<p>为了代码的简洁，我们在前向运算的时候就把一些后向计算的信息都保存起来，这样在后向计算的时候就能简单点。这样这个类就不能具备多线程的特性了，不过想支持多线程的功能还有别的办法。后面的全连接层也会采用同样的思路——前向为后向准备运算数据。</p>
<p>上一节我们讲了1个例子，输入有2个元素，第一层有4个输出，第2层有1个输出。我们假设训练数据有N个，我们对所有相关的训练数据和参数做以下的约定：</p>
<ul>
<li>所有的训练数据按列存储，也就是说如果把N个数据组成一个矩阵，那个矩阵的行等于数据特征的数目，矩阵的列等于N</li>
<li>线性部分的权值w由一个矩阵构成，它的行数为该层的输入个数，列数为该层的输出个数。如果该层的输入为2，输出为4，那么这个权值w的矩阵就是一个2*4的矩阵。</li>
<li>线性部分的权值b是一个行数等于输出个数，列数为1的矩阵。</li>
</ul>
<p>基于上面的规则，我们把上一节的例子以批量数据的形式画成了下面一张图：<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/chapter2/p2.jpg" alt><br>这张图从左往右有三个部分：<br>1.最左边是神经网络的结构图，可以看出里面的数据x,z和参数w,b都符合我们刚才对数据组织的定义。<br>2.中间是神经网络前向的过程。一共分为5步，其中最后一步用来计算Loss。<br>3.最右边是神经网络反向的过程。这里需要仔细看一下。为了表达上的简洁，我们用残差符号$\delta$表达Loss对指定变量的偏导数。同时为了更加简洁地表达梯度计算的过程，在这个过程中我们对其中一个矩阵做了矩阵转置，这样可以确保最终输出维度的正确</p>
<p>矩阵版后向传播算法如下：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FC</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, in_num, out_num, lr = <span class="number">0</span>.<span class="number">1</span>)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>._in_num = in_num</span><br><span class="line">        <span class="keyword">self</span>._out_num = out_num</span><br><span class="line">        <span class="keyword">self</span>.w = np.random.randn(in_num, out_num)</span><br><span class="line">        <span class="keyword">self</span>.b = np.zeros((out_num, <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">self</span>.lr = lr</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_sigmoid</span><span class="params">(<span class="keyword">self</span>, in_data)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> / (<span class="number">1</span> + np.exp(-in_data))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(<span class="keyword">self</span>, in_data)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.topVal = <span class="keyword">self</span>._sigmoid(np.dot(<span class="keyword">self</span>.w.T, in_data) + <span class="keyword">self</span>.b)</span><br><span class="line">        <span class="keyword">self</span>.bottomVal = in_data</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.topVal</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backward</span><span class="params">(<span class="keyword">self</span>, loss)</span></span><span class="symbol">:</span></span><br><span class="line">        residual_z = loss * <span class="keyword">self</span>.topVal * (<span class="number">1</span> - <span class="keyword">self</span>.topVal)</span><br><span class="line">        grad_w = np.dot(<span class="keyword">self</span>.bottomVal, residual_z.T)</span><br><span class="line">        grad_b = np.sum(residual_z)</span><br><span class="line">        <span class="keyword">self</span>.w -= <span class="keyword">self</span>.lr * grad_w</span><br><span class="line">        <span class="keyword">self</span>.b -= <span class="keyword">self</span>.lr * grad_b</span><br><span class="line">        residual_x = np.dot(<span class="keyword">self</span>.w, residual_z)</span><br><span class="line">        <span class="keyword">return</span> residual_x</span><br></pre></td></tr></table></figure>
<p>好了，现在我们有了Loss类和全连接类，我们还需要一个类把上面两个类串联起来，这里为了后面的内容我们定义了许多默认变量：<br><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Net</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, input_num=<span class="number">2</span>, hidden_num=<span class="number">4</span>, out_num=<span class="number">1</span>, lr=<span class="number">0</span>.<span class="number">1</span>)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.fc1 = FC(input_num, hidden_num, lr)</span><br><span class="line">        <span class="keyword">self</span>.fc2 = FC(hidden_num, out_num, lr)</span><br><span class="line">        <span class="keyword">self</span>.loss = SquareLoss()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">train</span><span class="params">(<span class="keyword">self</span>, X, y)</span></span>: <span class="comment"># X are arranged by col</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10000</span>)<span class="symbol">:</span></span><br><span class="line">            <span class="comment"># forward step</span></span><br><span class="line">            layer1out = <span class="keyword">self</span>.fc1.forward(X)</span><br><span class="line">            layer2out = <span class="keyword">self</span>.fc2.forward(layer1out)</span><br><span class="line">            loss = <span class="keyword">self</span>.loss.forward(layer2out, y)</span><br><span class="line">            <span class="comment"># backward step</span></span><br><span class="line">            layer2loss = <span class="keyword">self</span>.loss.backward()</span><br><span class="line">            layer1loss = <span class="keyword">self</span>.fc2.backward(layer2loss)</span><br><span class="line">            saliency = <span class="keyword">self</span>.fc1.backward(layer1loss)</span><br><span class="line">        layer1out = <span class="keyword">self</span>.fc1.forward(X)</span><br><span class="line">        layer2out = <span class="keyword">self</span>.fc2.forward(layer1out)</span><br><span class="line">        print <span class="string">'X=&#123;0&#125;'</span>.format(X)</span><br><span class="line">        print <span class="string">'t=&#123;0&#125;'</span>.format(y)</span><br><span class="line">        print <span class="string">'y=&#123;0&#125;'</span>.format(layer2out)</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>pytorch开始</title>
    <url>/blog/2017/05/pytorch-learn-start.html</url>
    <content><![CDATA[<p>pytorch是一个python优先的深度学习框架，是一个和tensorflow，Caffe，MXnet一样，非常底层的框架，它的前身是torch，主要的语言接口是Lua，在如今github上前10的机器学习项目有9个都是python的时代，一直没有太多的人使用，比较小众。而pytorch如今重新归来，用python重写了整个框架。</p>
<h3 id="pytorch安装"><a href="#pytorch安装" class="headerlink" title="pytorch安装"></a>pytorch安装</h3><h4 id="安装anaconda"><a href="#安装anaconda" class="headerlink" title="安装anaconda"></a>安装anaconda</h4><p>我安装的是python2.7，64位,可到官方网址<a href="https://www.continuum.io/downloads下载" target="_blank" rel="noopener">https://www.continuum.io/downloads下载</a><br>安装命令如下<br><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">bash Anaconda2<span class="number">-4.3</span><span class="number">.1</span>-Linux-x86_64.sh  </span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure></p>
<h4 id="安装pytorch"><a href="#安装pytorch" class="headerlink" title="安装pytorch"></a>安装pytorch</h4><p>各个系统下安装方式各有不同，在ubuntu16.04下安装如下：<br>首先配置.bashrc文件<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="builtin-name">export</span> CMAKE_PREFIX_PATH=[anaconda root directory]</span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">NO_CUDA</span>=1  #因为我的显卡不支持CUDA加速</span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure></p>
<p>安装依赖包<br><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Install basic dependencies</span></span><br><span class="line">conda <span class="keyword">install</span> numpy pyyaml mkl setuptools cmake gcc cffi</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add LAPACK support for the GPU</span></span><br><span class="line">conda <span class="keyword">install</span> -c soumith magma-cuda80 <span class="comment"># or magma-cuda75 if CUDA 7.5</span></span><br></pre></td></tr></table></figure></p>
<p>源码编译安装<br><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">git clone http<span class="variable">s:</span>//github.<span class="keyword">com</span>/pytorch/pytorch.git</span><br><span class="line">pip install -r requirements.txt </span><br><span class="line"><span class="keyword">python</span> setup.<span class="keyword">py</span> install</span><br></pre></td></tr></table></figure></p>
<h3 id="pytorch学习资源"><a href="#pytorch学习资源" class="headerlink" title="pytorch学习资源"></a>pytorch学习资源</h3><p><a href="http://pytorch.org/tutorials/beginner/deep_learning_60min_blitz.html" target="_blank" rel="noopener">pytorch 60分钟入门</a><br><a href="https://zhuanlan.zhihu.com/p/26646211" target="_blank" rel="noopener">pytorch实现风格迁移</a><br><a href="https://github.com/yunjey/pytorch-tutorial" target="_blank" rel="noopener">PyTorch Tutorial for Deep Learning Researchers</a></p>
]]></content>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Batch Normalization实现</title>
    <url>/blog/2017/05/batch-normaliz-achieve.html</url>
    <content><![CDATA[<p>One way to make deep networks easier to train is to use more sophisticated optimization procedures such as SGD+momentum, RMSProp, or Adam. Another strategy is to change the architecture of the network to make it easier to train. One idea along these lines is batch normalization which was recently proposed. </p>
<h3 id="BN的具体实现"><a href="#BN的具体实现" class="headerlink" title="BN的具体实现"></a>BN的具体实现</h3><h4 id="BN前向传播"><a href="#BN前向传播" class="headerlink" title="BN前向传播"></a>BN前向传播</h4><p>在训练时，利用前向传播时一个小的min-batch更新参数，在测试时就可利用训练时积累的参数直接求值即可</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">def batchnorm_forward(x, <span class="keyword">gamma</span>, beta, bn_param):</span><br><span class="line">  <span class="string">""</span>"</span><br><span class="line">  Forward pass <span class="keyword">for</span> batch normalization.</span><br><span class="line">  </span><br><span class="line">  During training the <span class="keyword">sample</span> <span class="keyword">mean</span> and (uncorrected) <span class="keyword">sample</span> variance are</span><br><span class="line">  computed from minibatch statistics and used to normalize the incoming data.</span><br><span class="line">  During training we also <span class="keyword">keep</span> <span class="keyword">an</span> exponentially decaying running <span class="keyword">mean</span> of the <span class="keyword">mean</span></span><br><span class="line">  and variance of each feature, and these averages are used to normalize data</span><br><span class="line">  at <span class="keyword">test</span>-time.</span><br><span class="line"></span><br><span class="line">  At each timestep we <span class="keyword">update</span> the running averages <span class="keyword">for</span> <span class="keyword">mean</span> and variance using</span><br><span class="line">  <span class="keyword">an</span> exponential decay based <span class="keyword">on</span> the momentum parameter:</span><br><span class="line"></span><br><span class="line">  running_mean = momentum * running_mean + (1 - momentum) * sample_mean</span><br><span class="line">  running_var = momentum * running_var + (1 - momentum) * sample_var</span><br><span class="line"></span><br><span class="line">  <span class="keyword">Note</span> that the batch normalization paper suggests a different <span class="keyword">test</span>-time</span><br><span class="line">  behavior: they compute <span class="keyword">sample</span> <span class="keyword">mean</span> and variance <span class="keyword">for</span> each feature using a</span><br><span class="line">  large number of training images rather than using a running average. <span class="keyword">For</span></span><br><span class="line">  this implementation we have chosen to <span class="keyword">use</span> running averages instead since</span><br><span class="line">  they <span class="keyword">do</span> not require <span class="keyword">an</span> additional estimation step; the torch7 implementation</span><br><span class="line">  of batch normalization also uses running averages.</span><br><span class="line"></span><br><span class="line">  <span class="keyword">Input</span>:</span><br><span class="line">  - x: Data of shape (<span class="keyword">N</span>, <span class="keyword">D</span>)</span><br><span class="line">  - <span class="keyword">gamma</span>: Scale parameter of shape (<span class="keyword">D</span>,)</span><br><span class="line">  - beta: Shift paremeter of shape (<span class="keyword">D</span>,)</span><br><span class="line">  - bn_param: Dictionary with the following keys:</span><br><span class="line">    - mode: 'train' or '<span class="keyword">test</span>'; required</span><br><span class="line">    - eps: Constant <span class="keyword">for</span> numeric stability</span><br><span class="line">    - momentum: Constant <span class="keyword">for</span> running <span class="keyword">mean</span> / variance.</span><br><span class="line">    - running_mean: Array of shape (<span class="keyword">D</span>,) giving running <span class="keyword">mean</span> of features</span><br><span class="line">    - running_var Array of shape (<span class="keyword">D</span>,) giving running variance of features</span><br><span class="line"></span><br><span class="line">  Returns a tuple of:</span><br><span class="line">  - <span class="keyword">out</span>: of shape (<span class="keyword">N</span>, <span class="keyword">D</span>)</span><br><span class="line">  - cache: A tuple of values needed <span class="keyword">in</span> the backward pass</span><br><span class="line">  <span class="string">""</span>"</span><br><span class="line">  mode = bn_param['mode']</span><br><span class="line">  eps = bn_param.<span class="built_in">get</span>('eps', 1e-5)</span><br><span class="line">  momentum = bn_param.<span class="built_in">get</span>('momentum', 0.9)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">N</span>, <span class="keyword">D</span> = x.shape</span><br><span class="line">  running_mean = bn_param.<span class="built_in">get</span>('running_mean', np.zeros(<span class="keyword">D</span>, dtype=x.dtype))</span><br><span class="line">  running_var = bn_param.<span class="built_in">get</span>('running_var', np.zeros(<span class="keyword">D</span>, dtype=x.dtype))</span><br><span class="line"></span><br><span class="line">  <span class="keyword">out</span>, cache = None, None</span><br><span class="line">  <span class="keyword">if</span> mode == 'train':</span><br><span class="line">    sample_mean = np.<span class="keyword">mean</span>(x, axis = 0)</span><br><span class="line">    sample_var = np.<span class="keyword">var</span>(x , axis = 0)</span><br><span class="line">    x_hat = (x - sample_mean) / (np.<span class="built_in">sqrt</span>(sample_var  + eps))</span><br><span class="line">    <span class="keyword">out</span> = <span class="keyword">gamma</span> * x_hat + beta</span><br><span class="line">    cache = (<span class="keyword">gamma</span>, x, sample_mean, sample_var, eps, x_hat)</span><br><span class="line">    running_mean = momentum * running_mean + (1 - momentum) * sample_mean</span><br><span class="line">    running_var = momentum * running_var + (1 - momentum) * sample_var</span><br><span class="line">  elif mode == '<span class="keyword">test</span>':</span><br><span class="line">    scale = <span class="keyword">gamma</span> / (np.<span class="built_in">sqrt</span>(running_var  + eps))</span><br><span class="line">    <span class="keyword">out</span> = x * scale + (beta - running_mean * scale)</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    raise ValueError('Invalid forward batchnorm mode <span class="string">"%s"</span>' % mode)</span><br><span class="line"></span><br><span class="line">  # Store the updated running <span class="keyword">means</span> back into bn_param</span><br><span class="line">  bn_param['running_mean'] = running_mean</span><br><span class="line">  bn_param['running_var'] = running_var</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">out</span>, cache</span><br></pre></td></tr></table></figure>
<h4 id="BN反向传播"><a href="#BN反向传播" class="headerlink" title="BN反向传播"></a>BN反向传播</h4><p>BN反向传播的公式见前文，依公式可得表达式<br><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">def batchnorm_backward(dout, cache):</span><br><span class="line">  <span class="string">""</span>"</span><br><span class="line">  Backward pass <span class="keyword">for</span> batch normalization.</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">For</span> this implementation, you should write <span class="keyword">out</span> a computation <span class="keyword">graph</span> <span class="keyword">for</span></span><br><span class="line">  batch normalization <span class="keyword">on</span> paper and propagate gradients backward through</span><br><span class="line">  intermediate nodes.</span><br><span class="line">  </span><br><span class="line">  Inputs:</span><br><span class="line">  - dout: Upstream derivatives, of shape (<span class="keyword">N</span>, <span class="keyword">D</span>)</span><br><span class="line">  - cache: Variable of intermediates from batchnorm_forward.</span><br><span class="line">  </span><br><span class="line">  Returns a tuple of:</span><br><span class="line">  - dx: Gradient with respect to inputs x, of shape (<span class="keyword">N</span>, <span class="keyword">D</span>)</span><br><span class="line">  - dgamma: Gradient with respect to scale parameter <span class="keyword">gamma</span>, of shape (<span class="keyword">D</span>,)</span><br><span class="line">  - <span class="keyword">dbeta</span>: Gradient with respect to shift parameter beta, of shape (<span class="keyword">D</span>,)</span><br><span class="line">  <span class="string">""</span>"</span><br><span class="line">  dx, dgamma, <span class="keyword">dbeta</span> = None, None, None</span><br><span class="line">  <span class="keyword">gamma</span>, x, miu, <span class="keyword">var</span>, eps, x_hat = cache</span><br><span class="line">  <span class="keyword">m</span> = len(x)</span><br><span class="line">  dx_hat = dout * <span class="keyword">gamma</span></span><br><span class="line">  dvar = np.<span class="built_in">sum</span>(dx_hat * (x-miu), axis=0) * -0.5 * (<span class="keyword">var</span> + eps) ** (-1.5)</span><br><span class="line">  dmiu = np.<span class="built_in">sum</span>(dx_hat * (-1) / np.<span class="built_in">sqrt</span>(<span class="keyword">var</span>+eps), axis=0) + dvar * np.<span class="keyword">mean</span>(-2 * (x - miu), axis=0)</span><br><span class="line">  dx = dx_hat / np.<span class="built_in">sqrt</span>(<span class="keyword">var</span> + eps) + dvar * 2 * (x - miu) / <span class="keyword">m</span> + dmiu / <span class="keyword">m</span></span><br><span class="line">  dgamma = np.<span class="built_in">sum</span>(dout * x_hat, axis=0)</span><br><span class="line">  <span class="keyword">dbeta</span> = np.<span class="built_in">sum</span>(dout, axis=0)</span><br><span class="line">  <span class="keyword">return</span> dx, dgamma, <span class="keyword">dbeta</span></span><br></pre></td></tr></table></figure></p>
<h3 id="BN应用于全连接层"><a href="#BN应用于全连接层" class="headerlink" title="BN应用于全连接层"></a>BN应用于全连接层</h3><p>要将Batch Normalization应用于Fully Connected Nets，我们用一个参数use_batchnorm来判断是否有BN层，BN层通常放在ReLU层之前，</p>
<p>计算loss时<br><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> self.use_batchnorm:        </span><br><span class="line">            <span class="built_in">gamma</span>, <span class="built_in">beta</span> = self.params[<span class="string">'gamma'</span> + str(<span class="built_in">i</span>+<span class="number">1</span>)], self.params[<span class="string">'beta'</span> + str(<span class="built_in">i</span>+<span class="number">1</span>)]        </span><br><span class="line">            h[<span class="built_in">i</span>], cache1[<span class="built_in">i</span>] = affine_forward(out[<span class="built_in">i</span>], W, b)        </span><br><span class="line">            bn[<span class="built_in">i</span>], cache2[<span class="built_in">i</span>] = batchnorm_forward(h[<span class="built_in">i</span>], <span class="built_in">gamma</span>, <span class="built_in">beta</span>, self.bn_params[<span class="built_in">i</span>])        </span><br><span class="line">            out[<span class="built_in">i</span>+<span class="number">1</span>], cache3[<span class="built_in">i</span>] = relu_forward(bn[<span class="built_in">i</span>])</span><br></pre></td></tr></table></figure></p>
<p>计算grads时<br><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> self.use_batchnorm:        </span><br><span class="line">            dbn[t<span class="number">-1</span>-<span class="built_in">i</span>] = relu_backward(dout[t-<span class="built_in">i</span>], cache3[t<span class="number">-1</span>-<span class="built_in">i</span>]) </span><br><span class="line">            dh[t<span class="number">-1</span>-<span class="built_in">i</span>], grads[<span class="string">'gamma'</span>+str(t-<span class="built_in">i</span>)], grads[<span class="string">'beta'</span>+str(t-<span class="built_in">i</span>)] = batchnorm_backward(dbn[t<span class="number">-1</span>-<span class="built_in">i</span>], cache2[t<span class="number">-1</span>-<span class="built_in">i</span>])       </span><br><span class="line">            dout[t<span class="number">-1</span>-<span class="built_in">i</span>], grads[<span class="string">'W'</span>+str(t-<span class="built_in">i</span>)], grads[<span class="string">'b'</span>+str(t-<span class="built_in">i</span>)] = affine_backward(dh[t<span class="number">-1</span>-<span class="built_in">i</span>], cache1[t<span class="number">-1</span>-<span class="built_in">i</span>])</span><br></pre></td></tr></table></figure></p>
<h4 id="有无BN层的表现对比"><a href="#有无BN层的表现对比" class="headerlink" title="有无BN层的表现对比"></a>有无BN层的表现对比</h4><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Try training a very deep net with batchnorm</span></span><br><span class="line">hidden_dims = [100, 100, 100, 100, 100]</span><br><span class="line"></span><br><span class="line">num_train = 1000</span><br><span class="line">small_data = &#123;</span><br><span class="line">  <span class="string">'X_train'</span>: data[<span class="string">'X_train'</span>][:num_train],</span><br><span class="line">  <span class="string">'y_train'</span>: data[<span class="string">'y_train'</span>][:num_train],</span><br><span class="line">  <span class="string">'X_val'</span>: data[<span class="string">'X_val'</span>],</span><br><span class="line">  <span class="string">'y_val'</span>: data[<span class="string">'y_val'</span>],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">weight_scale = 2e-2</span><br><span class="line">bn_model = FullyConnectedNet(hidden_dims, <span class="attribute">weight_scale</span>=weight_scale, <span class="attribute">use_batchnorm</span>=<span class="literal">True</span>)</span><br><span class="line">model = FullyConnectedNet(hidden_dims, <span class="attribute">weight_scale</span>=weight_scale, <span class="attribute">use_batchnorm</span>=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">bn_solver = Solver(bn_model, small_data,</span><br><span class="line">                <span class="attribute">num_epochs</span>=10, <span class="attribute">batch_size</span>=50,</span><br><span class="line">                <span class="attribute">update_rule</span>=<span class="string">'adam'</span>,</span><br><span class="line">                optim_config=&#123;</span><br><span class="line">                  <span class="string">'learning_rate'</span>: 1e-3,</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attribute">verbose</span>=<span class="literal">True</span>, <span class="attribute">print_every</span>=200)</span><br><span class="line">bn_solver.train()</span><br><span class="line"></span><br><span class="line">solver = Solver(model, small_data,</span><br><span class="line">                <span class="attribute">num_epochs</span>=10, <span class="attribute">batch_size</span>=50,</span><br><span class="line">                <span class="attribute">update_rule</span>=<span class="string">'adam'</span>,</span><br><span class="line">                optim_config=&#123;</span><br><span class="line">                  <span class="string">'learning_rate'</span>: 1e-3,</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attribute">verbose</span>=<span class="literal">True</span>, <span class="attribute">print_every</span>=200)</span><br><span class="line">solver.train()</span><br><span class="line"></span><br><span class="line">plt.subplot(3, 1, 1)</span><br><span class="line">plt.title(<span class="string">'Training loss'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Iteration'</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(3, 1, 2)</span><br><span class="line">plt.title(<span class="string">'Training accuracy'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Epoch'</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(3, 1, 3)</span><br><span class="line">plt.title(<span class="string">'Validation accuracy'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Epoch'</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(3, 1, 1)</span><br><span class="line">plt.plot(solver.loss_history, <span class="string">'o'</span>, <span class="attribute">label</span>=<span class="string">'baseline'</span>)</span><br><span class="line">plt.plot(bn_solver.loss_history, <span class="string">'o'</span>, <span class="attribute">label</span>=<span class="string">'batchnorm'</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(3, 1, 2)</span><br><span class="line">plt.plot(solver.train_acc_history, <span class="string">'-o'</span>, <span class="attribute">label</span>=<span class="string">'baseline'</span>)</span><br><span class="line">plt.plot(bn_solver.train_acc_history, <span class="string">'-o'</span>, <span class="attribute">label</span>=<span class="string">'batchnorm'</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(3, 1, 3)</span><br><span class="line">plt.plot(solver.val_acc_history, <span class="string">'-o'</span>, <span class="attribute">label</span>=<span class="string">'baseline'</span>)</span><br><span class="line">plt.plot(bn_solver.val_acc_history, <span class="string">'-o'</span>, <span class="attribute">label</span>=<span class="string">'batchnorm'</span>)</span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> [1, 2, 3]:</span><br><span class="line">  plt.subplot(3, 1, i)</span><br><span class="line">  plt.legend(<span class="attribute">loc</span>=<span class="string">'upper center'</span>, <span class="attribute">ncol</span>=4)</span><br><span class="line">plt.gcf().set_size_inches(15, 15)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>从下图中可以明显看出使用了BN层的神经网络收敛更快，训练与测试时的准确率都更高<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/cs231n/chapter2/p7.png" alt></p>
<h4 id="BN与初始化"><a href="#BN与初始化" class="headerlink" title="BN与初始化"></a>BN与初始化</h4><p>我们接下来探究BN与初始化之间的关系，通过对一个8层神经网络，我们随机初始化不同的W，看看有没有BN层对结果有何影响。<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Try training a very deep net with batchnorm</span></span><br><span class="line">hidden_dims = [50, 50, 50, 50, 50, 50, 50]</span><br><span class="line"></span><br><span class="line">num_train = 1000</span><br><span class="line">small_data = &#123;</span><br><span class="line">  <span class="string">'X_train'</span>: data[<span class="string">'X_train'</span>][:num_train],</span><br><span class="line">  <span class="string">'y_train'</span>: data[<span class="string">'y_train'</span>][:num_train],</span><br><span class="line">  <span class="string">'X_val'</span>: data[<span class="string">'X_val'</span>],</span><br><span class="line">  <span class="string">'y_val'</span>: data[<span class="string">'y_val'</span>],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bn_solvers = &#123;&#125;</span><br><span class="line">solvers = &#123;&#125;</span><br><span class="line">weight_scales = np.logspace(-4, 0, <span class="attribute">num</span>=20)</span><br><span class="line"><span class="keyword">for</span> i, weight_scale <span class="keyword">in</span> enumerate(weight_scales):</span><br><span class="line">  <span class="builtin-name">print</span> <span class="string">'Running weight scale %d / %d'</span> % (i + 1, len(weight_scales))</span><br><span class="line">  bn_model = FullyConnectedNet(hidden_dims, <span class="attribute">weight_scale</span>=weight_scale, <span class="attribute">use_batchnorm</span>=<span class="literal">True</span>)</span><br><span class="line">  model = FullyConnectedNet(hidden_dims, <span class="attribute">weight_scale</span>=weight_scale, <span class="attribute">use_batchnorm</span>=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">  bn_solver = Solver(bn_model, small_data,</span><br><span class="line">                  <span class="attribute">num_epochs</span>=10, <span class="attribute">batch_size</span>=50,</span><br><span class="line">                  <span class="attribute">update_rule</span>=<span class="string">'adam'</span>,</span><br><span class="line">                  optim_config=&#123;</span><br><span class="line">                    <span class="string">'learning_rate'</span>: 1e-3,</span><br><span class="line">                  &#125;,</span><br><span class="line">                  <span class="attribute">verbose</span>=<span class="literal">False</span>, <span class="attribute">print_every</span>=200)</span><br><span class="line">  bn_solver.train()</span><br><span class="line">  bn_solvers[weight_scale] = bn_solver</span><br><span class="line"></span><br><span class="line">  solver = Solver(model, small_data,</span><br><span class="line">                  <span class="attribute">num_epochs</span>=10, <span class="attribute">batch_size</span>=50,</span><br><span class="line">                  <span class="attribute">update_rule</span>=<span class="string">'adam'</span>,</span><br><span class="line">                  optim_config=&#123;</span><br><span class="line">                    <span class="string">'learning_rate'</span>: 1e-3,</span><br><span class="line">                  &#125;,</span><br><span class="line">                  <span class="attribute">verbose</span>=<span class="literal">False</span>, <span class="attribute">print_every</span>=200)</span><br><span class="line">  solver.train()</span><br><span class="line">  solvers[weight_scale] = solver</span><br><span class="line"></span><br><span class="line"><span class="comment"># Plot results of weight scale experiment</span></span><br><span class="line">best_train_accs, bn_best_train_accs = [], []</span><br><span class="line">best_val_accs, bn_best_val_accs = [], []</span><br><span class="line">final_train_loss, bn_final_train_loss = [], []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ws <span class="keyword">in</span> weight_scales:</span><br><span class="line">  best_train_accs.append(max(solvers[ws].train_acc_history))</span><br><span class="line">  bn_best_train_accs.append(max(bn_solvers[ws].train_acc_history))</span><br><span class="line">  </span><br><span class="line">  best_val_accs.append(max(solvers[ws].val_acc_history))</span><br><span class="line">  bn_best_val_accs.append(max(bn_solvers[ws].val_acc_history))</span><br><span class="line">  </span><br><span class="line">  final_train_loss.append(np.mean(solvers[ws].loss_history[-100:]))</span><br><span class="line">  bn_final_train_loss.append(np.mean(bn_solvers[ws].loss_history[-100:]))</span><br><span class="line">  </span><br><span class="line">plt.subplot(3, 1, 1)</span><br><span class="line">plt.title(<span class="string">'Best val accuracy vs weight initialization scale'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Weight initialization scale'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Best val accuracy'</span>)</span><br><span class="line">plt.semilogx(weight_scales, best_val_accs, <span class="string">'-o'</span>, <span class="attribute">label</span>=<span class="string">'baseline'</span>)</span><br><span class="line">plt.semilogx(weight_scales, bn_best_val_accs, <span class="string">'-o'</span>, <span class="attribute">label</span>=<span class="string">'batchnorm'</span>)</span><br><span class="line">plt.legend(<span class="attribute">ncol</span>=2, <span class="attribute">loc</span>=<span class="string">'lower right'</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(3, 1, 2)</span><br><span class="line">plt.title(<span class="string">'Best train accuracy vs weight initialization scale'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Weight initialization scale'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Best training accuracy'</span>)</span><br><span class="line">plt.semilogx(weight_scales, best_train_accs, <span class="string">'-o'</span>, <span class="attribute">label</span>=<span class="string">'baseline'</span>)</span><br><span class="line">plt.semilogx(weight_scales, bn_best_train_accs, <span class="string">'-o'</span>, <span class="attribute">label</span>=<span class="string">'batchnorm'</span>)</span><br><span class="line">plt.legend()</span><br><span class="line"></span><br><span class="line">plt.subplot(3, 1, 3)</span><br><span class="line">plt.title(<span class="string">'Final training loss vs weight initialization scale'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Weight initialization scale'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Final training loss'</span>)</span><br><span class="line">plt.semilogx(weight_scales, final_train_loss, <span class="string">'-o'</span>, <span class="attribute">label</span>=<span class="string">'baseline'</span>)</span><br><span class="line">plt.semilogx(weight_scales, bn_final_train_loss, <span class="string">'-o'</span>, <span class="attribute">label</span>=<span class="string">'batchnorm'</span>)</span><br><span class="line">plt.legend()</span><br><span class="line"></span><br><span class="line">plt.gcf().set_size_inches(10, 15)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p>
<p>通过下图可以明显看出，当有BN层时，参数初始化对结果干扰较小，不会因为参数初始化错误就结果非常不理想。<br>同时使用了BN层后，validation准确率会提升，同时使用BN层可以有效的避免过拟合，导致train时准确率高，validation时准确率低的现象<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/cs231n/chapter2/p8.png" alt></p>
]]></content>
      <tags>
        <tag>计算机视觉</tag>
      </tags>
  </entry>
  <entry>
    <title>全连接层的优化</title>
    <url>/blog/2017/05/full-connect-optimize.html</url>
    <content><![CDATA[<p>上文我们已经初步实现了全连接层的主要结构，本文主要探讨全连接层的优化过程。</p>
<h3 id="参数更新"><a href="#参数更新" class="headerlink" title="参数更新"></a>参数更新</h3><p>当我们确信解析梯度实现正确后，那就该在后向传播算法中使用它更新权重参数了。就单参数更新这个部分，也是有讲究的。<br>有多种方式可以实现参数更新</p>
<h4 id="随机梯度下降"><a href="#随机梯度下降" class="headerlink" title="随机梯度下降"></a>随机梯度下降</h4><p>随机梯度下降法是最常用的参数更新方法，其形式如下<br><figure class="highlight fix"><table><tr><td class="code"><pre><span class="line"><span class="attr">普通更新</span></span><br><span class="line"><span class="attr">x +</span>=<span class="string"> - learning_rate * dx</span></span><br></pre></td></tr></table></figure></p>
<p>其中learning_rate是一个超参数，它是一个固定的常量。当在整个数据集上进行计算时，只要学习率足够低，总是能在损失函数上得到非负的进展。<br>实现代码如下：<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">def sgd(w, dw, <span class="attribute">config</span>=None):</span><br><span class="line">  <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">  Performs vanilla stochastic gradient descent.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  config format:</span></span><br><span class="line"><span class="string">  - learning_rate: Scalar learning rate.</span></span><br><span class="line"><span class="string">  "</span><span class="string">""</span></span><br><span class="line">  <span class="keyword">if</span><span class="built_in"> config </span>is None:<span class="built_in"> config </span>= &#123;&#125;</span><br><span class="line">  config.setdefault(<span class="string">'learning_rate'</span>, 1e-2)</span><br><span class="line"></span><br><span class="line">  w -= config[<span class="string">'learning_rate'</span>] * dw</span><br><span class="line">  return w, config</span><br></pre></td></tr></table></figure></p>
<h4 id="Momentum-update"><a href="#Momentum-update" class="headerlink" title="Momentum update"></a>Momentum update</h4><p>这是上面参数更新方法的一种小小的优化，通常说来，在深层次的神经网络中，收敛效率更高一些(速度更快)这种参数更新方式源于物理学角度的优化。<br>主要形式如下：<br><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">物理动量角度启发的参数更新</span><br><span class="line">v = mu*v - learning_rate*dx <span class="comment"># 合入一部分附加速度</span></span><br><span class="line">x += v <span class="comment"># 更新参数</span></span><br></pre></td></tr></table></figure></p>
<p>这里v是初始化为0的一个值，mu是我们敲定的另外一个超变量(最常见的设定值为0.9，物理含义和摩擦力系数相关)，一个比较粗糙的理解是，(随机)梯度下降可以看做从山上下山到山底的过程，这种方式，相当于在下山的过程中，加上了一定的摩擦阻力，消耗掉一小部分动力系统的能量，这样会比较高效地在山底停住，而不是持续震荡。对了，其实我们也可以用交叉验证来选择最合适的mu值，一般我们会从[0.5, 0.9, 0.95, 0.99]里面选出最合适的。<br>实现代码如下：<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">def sgd_momentum(w, dw, <span class="attribute">config</span>=None):</span><br><span class="line">  <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">  Performs stochastic gradient descent with momentum.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  config format:</span></span><br><span class="line"><span class="string">  - learning_rate: Scalar learning rate.</span></span><br><span class="line"><span class="string">  - momentum: Scalar between 0 and 1 giving the momentum value.</span></span><br><span class="line"><span class="string">    Setting momentum = 0 reduces to sgd.</span></span><br><span class="line"><span class="string">  - velocity: A numpy array of the same shape as w and dw used to store a moving</span></span><br><span class="line"><span class="string">    average of the gradients.</span></span><br><span class="line"><span class="string">  "</span><span class="string">""</span></span><br><span class="line">  <span class="keyword">if</span><span class="built_in"> config </span>is None:<span class="built_in"> config </span>= &#123;&#125;</span><br><span class="line">  config.setdefault(<span class="string">'learning_rate'</span>, 1e-2)</span><br><span class="line">  config.setdefault(<span class="string">'momentum'</span>, 0.9)</span><br><span class="line">  v = config.<span class="builtin-name">get</span>(<span class="string">'velocity'</span>, np.zeros_like(w))</span><br><span class="line">  </span><br><span class="line">  next_w = None</span><br><span class="line">  v = config[<span class="string">'momentum'</span>] * v - config[<span class="string">'learning_rate'</span>] * dw</span><br><span class="line">  next_w = w + v</span><br><span class="line">  config[<span class="string">'velocity'</span>] = v</span><br><span class="line"></span><br><span class="line">  return next_w, config</span><br></pre></td></tr></table></figure></p>
<h4 id="SGD与SGD-momentum比较"><a href="#SGD与SGD-momentum比较" class="headerlink" title="SGD与SGD+momentum比较"></a>SGD与SGD+momentum比较</h4><p>使用以上两种参数更新方法分别训练一个6层神经网络进行比较<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">num_train = 4000</span><br><span class="line">small_data = &#123;</span><br><span class="line">  <span class="string">'X_train'</span>: data[<span class="string">'X_train'</span>][:num_train],</span><br><span class="line">  <span class="string">'y_train'</span>: data[<span class="string">'y_train'</span>][:num_train],</span><br><span class="line">  <span class="string">'X_val'</span>: data[<span class="string">'X_val'</span>],</span><br><span class="line">  <span class="string">'y_val'</span>: data[<span class="string">'y_val'</span>],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">solvers = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> update_rule <span class="keyword">in</span> [<span class="string">'sgd'</span>, <span class="string">'sgd_momentum'</span>]:</span><br><span class="line">  <span class="builtin-name">print</span> <span class="string">'running with '</span>, update_rule</span><br><span class="line">  model = FullyConnectedNet([100, 100, 100, 100, 100], <span class="attribute">weight_scale</span>=5e-2)</span><br><span class="line"></span><br><span class="line">  solver = Solver(model, small_data,</span><br><span class="line">                  <span class="attribute">num_epochs</span>=5, <span class="attribute">batch_size</span>=100,</span><br><span class="line">                  <span class="attribute">update_rule</span>=update_rule,</span><br><span class="line">                  optim_config=&#123;</span><br><span class="line">                    <span class="string">'learning_rate'</span>: 1e-2,</span><br><span class="line">                  &#125;,</span><br><span class="line">                  <span class="attribute">verbose</span>=<span class="literal">True</span>)</span><br><span class="line">  solvers[update_rule] = solver</span><br><span class="line">  solver.train()</span><br><span class="line">  print</span><br><span class="line"></span><br><span class="line">plt.subplot(3, 1, 1)</span><br><span class="line">plt.title(<span class="string">'Training loss'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Iteration'</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(3, 1, 2)</span><br><span class="line">plt.title(<span class="string">'Training accuracy'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Epoch'</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(3, 1, 3)</span><br><span class="line">plt.title(<span class="string">'Validation accuracy'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Epoch'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> update_rule, solver <span class="keyword">in</span> solvers.iteritems():</span><br><span class="line">  plt.subplot(3, 1, 1)</span><br><span class="line">  plt.plot(solver.loss_history, <span class="string">'o'</span>, <span class="attribute">label</span>=update_rule)</span><br><span class="line">  </span><br><span class="line">  plt.subplot(3, 1, 2)</span><br><span class="line">  plt.plot(solver.train_acc_history, <span class="string">'-o'</span>, <span class="attribute">label</span>=update_rule)</span><br><span class="line"></span><br><span class="line">  plt.subplot(3, 1, 3)</span><br><span class="line">  plt.plot(solver.val_acc_history, <span class="string">'-o'</span>, <span class="attribute">label</span>=update_rule)</span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> [1, 2, 3]:</span><br><span class="line">  plt.subplot(3, 1, i)</span><br><span class="line">  plt.legend(<span class="attribute">loc</span>=<span class="string">'upper center'</span>, <span class="attribute">ncol</span>=4)</span><br><span class="line">plt.gcf().set_size_inches(15, 15)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p>
<p>如下图所示，动量法来更新参数可以更加快速的达到收敛，同时训练效果也更好<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/cs231n/chapter1/p4.png" alt></p>
<h4 id="Adagrad"><a href="#Adagrad" class="headerlink" title="Adagrad"></a>Adagrad</h4><p>Adagrad是一个由Duchi等提出的适应性学习率算法<br>其主要形式如下<br><figure class="highlight gams"><table><tr><td class="code"><pre><span class="line">假设有梯度和参数向量x</span><br><span class="line">cache += dx**<span class="number">2</span></span><br><span class="line">x += - learning_rate * dx / (np.<span class="built-in">sqrt</span>(cache) + <span class="literal">eps</span>)</span><br></pre></td></tr></table></figure></p>
<p>注意，变量cache的尺寸和梯度矩阵的尺寸是一样的，还跟踪了每个参数的梯度的平方和。这个一会儿将用来归一化参数更新步长，归一化是逐元素进行的。注意，接收到高梯度值的权重更新的效果被减弱，而接收到低梯度值的权重的更新效果将会增强。有趣的是平方根的操作非常重要，如果去掉，算法的表现将会糟糕很多。用于平滑的式子eps（一般设为1e-4到1e-8之间）是防止出现除以0的情况。Adagrad的一个缺点是，在深度学习中单调的学习率被证明通常过于激进且过早停止学习。</p>
<h4 id="RMSprop"><a href="#RMSprop" class="headerlink" title="RMSprop"></a>RMSprop</h4><p>是一个非常高效，但没有公开发表的适应性学习率方法。有趣的是，每个使用这个方法的人在他们的论文中都引用自Geoff Hinton的Coursera课程的第六课的第29页PPT。这个方法用一种很简单的方式修改了Adagrad方法，让它不那么激进，单调地降低了学习率。具体说来，就是它使用了一个梯度平方的滑动平均。<br>其主要形式如下：<br><figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">cache =  decay_rate * cache + (<span class="number">1</span> - decay_rate) * dx**2</span><br><span class="line">x += - learning_rate * dx / (<span class="name">np</span>.sqrt(<span class="name">cache</span>) + eps)</span><br></pre></td></tr></table></figure></p>
<p>在上面的代码中，decay_rate是一个超参数，常用的值是[0.9,0.99,0.999]。其中x+=和Adagrad中是一样的，但是cache变量是不同的。因此，RMSProp仍然是基于梯度的大小来对每个权重的学习率进行修改，这同样效果不错。但是和Adagrad不同，其更新不会让学习率单调变小。<br>实现如下：<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">def rmsprop(x, dx, <span class="attribute">config</span>=None):</span><br><span class="line">  <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">  Uses the RMSProp update rule, which uses a moving average of squared gradient</span></span><br><span class="line"><span class="string">  values to set adaptive per-parameter learning rates.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  config format:</span></span><br><span class="line"><span class="string">  - learning_rate: Scalar learning rate.</span></span><br><span class="line"><span class="string">  - decay_rate: Scalar between 0 and 1 giving the decay rate for the squared</span></span><br><span class="line"><span class="string">    gradient cache.</span></span><br><span class="line"><span class="string">  - epsilon: Small scalar used for smoothing to avoid dividing by zero.</span></span><br><span class="line"><span class="string">  - cache: Moving average of second moments of gradients.</span></span><br><span class="line"><span class="string">  "</span><span class="string">""</span></span><br><span class="line">  <span class="keyword">if</span><span class="built_in"> config </span>is None:<span class="built_in"> config </span>= &#123;&#125;</span><br><span class="line">  config.setdefault(<span class="string">'learning_rate'</span>, 1e-2)</span><br><span class="line">  config.setdefault(<span class="string">'decay_rate'</span>, 0.99)</span><br><span class="line">  config.setdefault(<span class="string">'epsilon'</span>, 1e-8)</span><br><span class="line">  config.setdefault(<span class="string">'cache'</span>, np.zeros_like(x))</span><br><span class="line"></span><br><span class="line">  next_x = None</span><br><span class="line">  config[<span class="string">'cache'</span>] = config[<span class="string">'decay_rate'</span>] * config[<span class="string">'cache'</span>] + (1 - config[<span class="string">'decay_rate'</span>]) * (dx*<span class="number">*2</span>)</span><br><span class="line">  next_x = x - config[<span class="string">'learning_rate'</span>] * dx / (np.sqrt(config[<span class="string">'cache'</span>]) + config[<span class="string">'epsilon'</span>])</span><br><span class="line">  return next_x, config</span><br></pre></td></tr></table></figure></p>
<h4 id="Adam"><a href="#Adam" class="headerlink" title="Adam"></a>Adam</h4><p>Adam是最近才提出的一种更新方法，它看起来像是RMSProp的动量版。简化的代码是下面这样：<br><figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">m = beta1*m + (<span class="number">1</span>-beta1)*dx</span><br><span class="line">v = beta2*v + (<span class="number">1</span>-beta2)*(<span class="name">dx**2</span>)</span><br><span class="line">x += - learning_rate * m / (<span class="name">np</span>.sqrt(<span class="name">v</span>) + eps)</span><br></pre></td></tr></table></figure></p>
<p>注意这个更新方法看起来真的和RMSProp很像，除了使用的是平滑版的梯度m，而不是用的原始梯度向量dx。论文中推荐的参数值eps=1e-8, beta1=0.9, beta2=0.999。在实际操作中，我们推荐Adam作为默认的算法，一般而言跑起来比RMSProp要好一点。但是也可以试试SGD+Nesterov动量。完整的Adam更新算法也包含了一个偏置（bias）矫正机制，因为m,v两个矩阵初始为0，在没有完全热身之前存在偏差，需要采取一些补偿措施。</p>
<p>实现如下：<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">def adam(x, dx, <span class="attribute">config</span>=None):</span><br><span class="line">  <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">  Uses the Adam update rule, which incorporates moving averages of both the</span></span><br><span class="line"><span class="string">  gradient and its square and a bias correction term.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  config format:</span></span><br><span class="line"><span class="string">  - learning_rate: Scalar learning rate.</span></span><br><span class="line"><span class="string">  - beta1: Decay rate for moving average of first moment of gradient.</span></span><br><span class="line"><span class="string">  - beta2: Decay rate for moving average of second moment of gradient.</span></span><br><span class="line"><span class="string">  - epsilon: Small scalar used for smoothing to avoid dividing by zero.</span></span><br><span class="line"><span class="string">  - m: Moving average of gradient.</span></span><br><span class="line"><span class="string">  - v: Moving average of squared gradient.</span></span><br><span class="line"><span class="string">  - t: Iteration number.</span></span><br><span class="line"><span class="string">  "</span><span class="string">""</span></span><br><span class="line">  <span class="keyword">if</span><span class="built_in"> config </span>is None:<span class="built_in"> config </span>= &#123;&#125;</span><br><span class="line">  config.setdefault(<span class="string">'learning_rate'</span>, 1e-3)</span><br><span class="line">  config.setdefault(<span class="string">'beta1'</span>, 0.9)</span><br><span class="line">  config.setdefault(<span class="string">'beta2'</span>, 0.999)</span><br><span class="line">  config.setdefault(<span class="string">'epsilon'</span>, 1e-8)</span><br><span class="line">  config.setdefault(<span class="string">'m'</span>, np.zeros_like(x))</span><br><span class="line">  config.setdefault(<span class="string">'v'</span>, np.zeros_like(x))</span><br><span class="line">  config.setdefault(<span class="string">'t'</span>, 0)</span><br><span class="line">  </span><br><span class="line">  next_x = None</span><br><span class="line">  config[<span class="string">'t'</span>] += 1</span><br><span class="line">  config[<span class="string">'m'</span>] = config[<span class="string">'beta1'</span>] * config[<span class="string">'m'</span>] + (1 - config[<span class="string">'beta1'</span>]) * dx</span><br><span class="line">  config[<span class="string">'v'</span>] = config[<span class="string">'beta2'</span>] * config[<span class="string">'v'</span>] + (1 - config[<span class="string">'beta2'</span>]) * (dx*<span class="number">*2</span>)</span><br><span class="line">  mb = config[<span class="string">'m'</span>] / (1 - config[<span class="string">'beta1'</span>]*<span class="number">*c</span>onfig[<span class="string">'t'</span>])</span><br><span class="line">  vb = config[<span class="string">'v'</span>] / (1 - config[<span class="string">'beta2'</span>]*<span class="number">*c</span>onfig[<span class="string">'t'</span>])</span><br><span class="line">  next_x = x - config[<span class="string">'learning_rate'</span>] * mb / (np.sqrt(vb) + config[<span class="string">'epsilon'</span>])  </span><br><span class="line">  return next_x, config</span><br></pre></td></tr></table></figure></p>
<h4 id="上述更新方法的比较"><a href="#上述更新方法的比较" class="headerlink" title="上述更新方法的比较"></a>上述更新方法的比较</h4><p>将上述四种更新方式进行比较<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">learning_rates = &#123;<span class="string">'rmsprop'</span>: 1e-4, <span class="string">'adam'</span>: 1e-3&#125;</span><br><span class="line"><span class="keyword">for</span> update_rule <span class="keyword">in</span> [<span class="string">'adam'</span>, <span class="string">'rmsprop'</span>]:</span><br><span class="line">  <span class="builtin-name">print</span> <span class="string">'running with '</span>, update_rule</span><br><span class="line">  model = FullyConnectedNet([100, 100, 100, 100, 100], <span class="attribute">weight_scale</span>=5e-2)</span><br><span class="line"></span><br><span class="line">  solver = Solver(model, small_data,</span><br><span class="line">                  <span class="attribute">num_epochs</span>=5, <span class="attribute">batch_size</span>=100,</span><br><span class="line">                  <span class="attribute">update_rule</span>=update_rule,</span><br><span class="line">                  optim_config=&#123;</span><br><span class="line">                    <span class="string">'learning_rate'</span>: learning_rates[update_rule]</span><br><span class="line">                  &#125;,</span><br><span class="line">                  <span class="attribute">verbose</span>=<span class="literal">True</span>)</span><br><span class="line">  solvers[update_rule] = solver</span><br><span class="line">  solver.train()</span><br><span class="line">  print</span><br><span class="line"></span><br><span class="line">plt.subplot(3, 1, 1)</span><br><span class="line">plt.title(<span class="string">'Training loss'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Iteration'</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(3, 1, 2)</span><br><span class="line">plt.title(<span class="string">'Training accuracy'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Epoch'</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(3, 1, 3)</span><br><span class="line">plt.title(<span class="string">'Validation accuracy'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Epoch'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> update_rule, solver <span class="keyword">in</span> solvers.iteritems():</span><br><span class="line">  plt.subplot(3, 1, 1)</span><br><span class="line">  plt.plot(solver.loss_history, <span class="string">'o'</span>, <span class="attribute">label</span>=update_rule)</span><br><span class="line">  </span><br><span class="line">  plt.subplot(3, 1, 2)</span><br><span class="line">  plt.plot(solver.train_acc_history, <span class="string">'-o'</span>, <span class="attribute">label</span>=update_rule)</span><br><span class="line"></span><br><span class="line">  plt.subplot(3, 1, 3)</span><br><span class="line">  plt.plot(solver.val_acc_history, <span class="string">'-o'</span>, <span class="attribute">label</span>=update_rule)</span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> [1, 2, 3]:</span><br><span class="line">  plt.subplot(3, 1, i)</span><br><span class="line">  plt.legend(<span class="attribute">loc</span>=<span class="string">'upper center'</span>, <span class="attribute">ncol</span>=4)</span><br><span class="line">plt.gcf().set_size_inches(15, 15)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/cs231n/chapter1/p5.png" alt></p>
<h3 id="训练一个好的模型"><a href="#训练一个好的模型" class="headerlink" title="训练一个好的模型"></a>训练一个好的模型</h3><p>我们可以利用CIFAR-10数据集来训练模型，看看我们的准确率究竟如何，使用BatchNormalization和DroupOut会使我们的模型表现更好，但这里我们先省略。<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">best_model = None</span><br><span class="line">X_val= data[<span class="string">'X_val'</span>]</span><br><span class="line">y_val= data[<span class="string">'y_val'</span>]</span><br><span class="line">X_test= data[<span class="string">'X_test'</span>]</span><br><span class="line">y_test= data[<span class="string">'y_test'</span>]</span><br><span class="line"></span><br><span class="line">learning_rate = 3.1e-4</span><br><span class="line">weight_scale = 2.5e-2 #1e-5</span><br><span class="line">model = FullyConnectedNet([600, 500, 400, 300, 200, 100],</span><br><span class="line">                <span class="attribute">weight_scale</span>=weight_scale, <span class="attribute">dtype</span>=np.float64,reg=1e-2)</span><br><span class="line">solver = Solver(model, data,</span><br><span class="line">                <span class="attribute">print_every</span>=500, <span class="attribute">num_epochs</span>=30, <span class="attribute">batch_size</span>=100,</span><br><span class="line">                <span class="attribute">update_rule</span>=<span class="string">'adam'</span>,</span><br><span class="line">                optim_config=&#123;</span><br><span class="line">                  <span class="string">'learning_rate'</span>: learning_rate,</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attribute">lr_decay</span>=0.9</span><br><span class="line">         )</span><br><span class="line"></span><br><span class="line">solver.train()</span><br><span class="line">scores = model.loss(data[<span class="string">'X_test'</span>])</span><br><span class="line">y_pred = np.argmax(scores, axis = 1)</span><br><span class="line">acc = np.mean(y_pred == data[<span class="string">'y_test'</span>])</span><br><span class="line"><span class="builtin-name">print</span> <span class="string">'test acc: %f'</span> %(acc)</span><br><span class="line">best_model = model</span><br><span class="line"></span><br><span class="line">plt.subplot(2, 1, 1)</span><br><span class="line">plt.plot(solver.loss_history)</span><br><span class="line">plt.title(<span class="string">'Loss history'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Iteration'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Loss'</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(2, 1, 2)</span><br><span class="line">plt.plot(solver.train_acc_history, <span class="attribute">label</span>=<span class="string">'train'</span>)</span><br><span class="line">plt.plot(solver.val_acc_history, <span class="attribute">label</span>=<span class="string">'val'</span>)</span><br><span class="line">plt.title(<span class="string">'Classification accuracy history'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Epoch'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Clasification accuracy'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p>
<p>上述用了一个七层神经网络，使用adam为参数更新方法，通过30次迭代后，训练集的准确率可以达到惊人的87%，而测试集则稳定在55%左右。<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/cs231n/chapter1/p6.png" alt></p>
]]></content>
      <tags>
        <tag>计算机视觉</tag>
      </tags>
  </entry>
  <entry>
    <title>Batch Normalization学习</title>
    <url>/blog/2017/05/batch-normaalize-learn.html</url>
    <content><![CDATA[<p>Batch Normalization，简称BN，来源于《<a href="http://arxiv.org/pdf/1502.03167.pdf" target="_blank" rel="noopener">Batch Normalization: Accelerating Deep Network Training by Reducing Internal Covariate Shift</a>》</p>
<h3 id="Batch-Normalization的意义"><a href="#Batch-Normalization的意义" class="headerlink" title="Batch Normalization的意义"></a>Batch Normalization的意义</h3><p>作者认为：网络训练过程中参数不断改变导致后续每一层输入的分布也发生变化，而学习的过程又要使每一层适应输入的分布，因此我们不得不降低学习率、小心地初始化。作者将分布发生变化称之为 internal covariate shift。</p>
<p>大家应该都知道，我们一般在训练网络的时会将输入减去均值，还有些人甚至会对输入做白化等操作，目的是为了加快训练。为什么减均值、白化可以加快训练呢，这里做一个简单地说明：<br>首先，图像数据是高度相关的，假设其分布如下图a所示(简化为2维)。由于初始化的时候，我们的参数一般都是0均值的，因此开始的拟合y=Wx+b，基本过原点附近，如图b红色虚线。因此，网络需要经过多次学习才能逐步达到如紫色实线的拟合，即收敛的比较慢。如果我们对输入数据先作减均值操作，如图c，显然可以加快学习。更进一步的，我们对数据再进行去相关操作，使得数据更加容易区分，这样又会加快训练，如图d。<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/cs231n/chapter2/p1.jpg" alt></p>
<h3 id="初识BN-Batch-Normalization"><a href="#初识BN-Batch-Normalization" class="headerlink" title="初识BN(Batch  Normalization)"></a>初识BN(Batch  Normalization)</h3><h4 id="BN概述"><a href="#BN概述" class="headerlink" title="BN概述"></a>BN概述</h4><p>就像激活函数层、卷积层、全连接层、池化层一样，BN(Batch Normalization)也属于网络的一层。在前面我们提到网络除了输出层外，其它层因为低层网络在训练的时候更新了参数，而引起后面层输入数据分布的变化。这个时候我们可能就会想，如果在每一层输入的时候，再加个预处理操作那该有多好啊，比如网络第三层输入数据X3(X3表示网络第三层的输入数据)把它归一化至：均值0、方差为1，然后再输入第三层计算，这样我们就可以解决前面所提到的“Internal Covariate Shift”的问题了。<br>而事实上，paper的算法本质原理就是这样：在网络的每一层输入的时候，又插入了一个归一化层，也就是先做一个归一化处理，然后再进入网络的下一层。不过文献归一化层，可不像我们想象的那么简单，它是一个可学习、有参数的网络层。既然说到数据预处理，下面就先来复习一下最强的预处理方法：白化。</p>
<h4 id="预处理操作选择"><a href="#预处理操作选择" class="headerlink" title="预处理操作选择"></a>预处理操作选择</h4><p>说到神经网络输入数据预处理，最好的算法莫过于白化预处理。然而白化计算量太大了，很不划算，还有就是白化不是处处可微的，所以在深度学习中，其实很少用到白化。经过白化预处理后，数据满足条件：a、特征之间的相关性降低，这个就相当于pca；b、数据均值、标准差归一化，也就是使得每一维特征均值为0，标准差为1。如果数据特征维数比较大，要进行PCA，也就是实现白化的第1个要求，是需要计算特征向量，计算量非常大，于是为了简化计算，作者忽略了第1个要求，仅仅使用了下面的公式进行预处理，也就是近似白化预处理：<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/cs231n/chapter2/p1.png" alt></p>
<h4 id="算法概述"><a href="#算法概述" class="headerlink" title="算法概述"></a>算法概述</h4><p>经过前面简单介绍，这个时候可能我们会想当然的以为：好像很简单的样子，不就是在网络中间层数据做一个归一化处理嘛，这么简单的想法，为什么之前没人用呢？然而其实实现起来并不是那么简单的。其实如果是仅仅使用上面的归一化公式，对网络某一层A的输出数据做归一化，然后送入网络下一层B，这样是会影响到本层网络A所学习到的特征的。打个比方，比如我网络中间某一层学习到特征数据本身就分布在S型激活函数的两侧，你强制把它给我归一化处理、标准差也限制在了1，把数据变换成分布于s函数的中间部分，这样就相当于我这一层网络所学习到的特征分布被你搞坏了，这可怎么办？<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/cs231n/chapter2/p2.png" alt><br>为此，作者又为BN增加了2个参数，用来保持模型的表达能力。<br>于是最后的输出为：<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/cs231n/chapter2/p3.png" alt><br>上述公式中用到了均值E和方差Var，需要注意的是理想情况下E和Var应该是针对整个数据集的，但显然这是不现实的。因此，作者做了简化，用一个Batch的均值和方差作为对整个数据集均值和方差的估计。<br>整个BN的前向传播算法如下：<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/cs231n/chapter2/p4.png" alt><br>可能学完了上面的算法，你只是知道它的一个训练过程，一个网络一旦训练完了，就没有了min-batch这个概念了。测试阶段我们一般只输入一个测试样本，看看结果而已。因此测试样本，前向传导的时候，上面的均值u、标准差σ 要哪里来？其实网络一旦训练完毕，参数都是固定的，这个时候即使是每批训练样本进入网络，那么BN层计算的均值u、和标准差都是固定不变的。我们可以采用这些数值来作为测试样本所需要的均值、标准差，于是最后测试阶段的u和σ 计算公式如下：<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/cs231n/chapter2/p6.png" alt></p>
<h4 id="反向传播求导"><a href="#反向传播求导" class="headerlink" title="反向传播求导"></a>反向传播求导</h4><p>在反向传播时，我们需要对gamma,beta,x进行求导，主要公式如下<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/cs231n/chapter2/p5.png" alt><br>针对上面这些方式，写出来的代码如下：<br><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">def batchnorm_backward(dout, cache):</span><br><span class="line">  <span class="string">""</span>"</span><br><span class="line">  Backward pass <span class="keyword">for</span> batch normalization.</span><br><span class="line"></span><br><span class="line">  <span class="keyword">For</span> this implementation, you should write <span class="keyword">out</span> a computation <span class="keyword">graph</span> <span class="keyword">for</span></span><br><span class="line">  batch normalization <span class="keyword">on</span> paper and propagate gradients backward through</span><br><span class="line">  intermediate nodes.</span><br><span class="line"></span><br><span class="line">  Inputs:</span><br><span class="line">  - dout: Upstream derivatives, of shape (<span class="keyword">N</span>, <span class="keyword">D</span>)</span><br><span class="line">  - cache: Variable of intermediates from batchnorm_forward.</span><br><span class="line"></span><br><span class="line">  Returns a tuple of:</span><br><span class="line">  - dx: Gradient with respect to inputs x, of shape (<span class="keyword">N</span>, <span class="keyword">D</span>)</span><br><span class="line">  - dgamma: Gradient with respect to scale parameter <span class="keyword">gamma</span>, of shape (<span class="keyword">D</span>,)</span><br><span class="line">  - <span class="keyword">dbeta</span>: Gradient with respect to shift parameter beta, of shape (<span class="keyword">D</span>,)</span><br><span class="line">  <span class="string">""</span>"</span><br><span class="line">  dx, dgamma, <span class="keyword">dbeta</span> = None, None, None</span><br><span class="line"></span><br><span class="line">  x, <span class="keyword">gamma</span>, beta, <span class="keyword">var</span>, miu, x_hat, eps = cache</span><br><span class="line">  <span class="keyword">m</span> = len(x)</span><br><span class="line">  dx_hat = dout * <span class="keyword">gamma</span></span><br><span class="line">  dvar = np.<span class="built_in">sum</span>(dx_hat * (x-miu), axis=0) * -0.5 * (<span class="keyword">var</span> + eps) ** (-1.5)</span><br><span class="line">  dmiu = np.<span class="built_in">sum</span>(dx_hat * (-1) / np.<span class="built_in">sqrt</span>(<span class="keyword">var</span>+eps), axis=0) + dvar * np.<span class="keyword">mean</span>(-2 * (x - miu), axis=0)</span><br><span class="line">  dx = dx_hat / np.<span class="built_in">sqrt</span>(<span class="keyword">var</span> + eps) + dvar * 2 * (x - miu) / <span class="keyword">m</span> + dmiu / <span class="keyword">m</span></span><br><span class="line">  dgamma = np.<span class="built_in">sum</span>(dout * x_hat, axis=0)</span><br><span class="line">  <span class="keyword">dbeta</span> = np.<span class="built_in">sum</span>(dout, axis=0)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dx, dgamma, <span class="keyword">dbeta</span></span><br></pre></td></tr></table></figure></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://blog.csdn.net/elaine_bao/article/details/50890491" target="_blank" rel="noopener">解读Batch Normalization</a><br><a href="http://blog.csdn.net/hjimce/article/details/50866313" target="_blank" rel="noopener">Batch Normalization 学习笔记</a><br><a href="http://www.jianshu.com/p/4270f5acc066" target="_blank" rel="noopener">GoogLeNet的心路历程:BN反向传播实现</a></p>
]]></content>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>linux下opencv安装</title>
    <url>/blog/2017/05/linux-opencv-install.html</url>
    <content><![CDATA[<p>在linux下安装opencv的步骤如下：</p>
<h4 id="安装依赖库"><a href="#安装依赖库" class="headerlink" title="安装依赖库"></a>安装依赖库</h4><figure class="highlight q"><table><tr><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> install --assume-yes build-essential cmake git</span><br><span class="line">sudo apt-<span class="built_in">get</span> install --assume-yes build-essential pkg-config unzip ffmpeg qtbase5-<span class="built_in">dev</span> python-<span class="built_in">dev</span> python3-<span class="built_in">dev</span> python-numpy python3-numpy</span><br><span class="line">sudo apt-<span class="built_in">get</span> install --assume-yes libopencv-<span class="built_in">dev</span> libgtk<span class="number">-3</span>-<span class="built_in">dev</span> libdc1394<span class="number">-22</span> libdc1394<span class="number">-22</span>-<span class="built_in">dev</span> libjpeg-<span class="built_in">dev</span> libpng12-<span class="built_in">dev</span> libtiff5-<span class="built_in">dev</span> libjasper-<span class="built_in">dev</span></span><br><span class="line">sudo apt-<span class="built_in">get</span> install --assume-yes libavcodec-<span class="built_in">dev</span> libavformat-<span class="built_in">dev</span> libswscale-<span class="built_in">dev</span> libxine2-<span class="built_in">dev</span> libgstreamer0<span class="number">.10</span>-<span class="built_in">dev</span> libgstreamer-plugins-base0<span class="number">.10</span>-<span class="built_in">dev</span></span><br><span class="line">sudo apt-<span class="built_in">get</span> install --assume-yes libv4l-<span class="built_in">dev</span> libtbb-<span class="built_in">dev</span> libfaac-<span class="built_in">dev</span> libmp3lame-<span class="built_in">dev</span> libopencore-amrnb-<span class="built_in">dev</span> libopencore-amrwb-<span class="built_in">dev</span> libtheora-<span class="built_in">dev</span></span><br><span class="line">sudo apt-<span class="built_in">get</span> install --assume-yes libvorbis-<span class="built_in">dev</span> libxvidcore-<span class="built_in">dev</span> v4l-utils</span><br></pre></td></tr></table></figure>
<h4 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h4><p>从<a href="https://github.com/opencv/opencv" target="_blank" rel="noopener">https://github.com/opencv/opencv</a>下载最新版本的opencv。</p>
<h4 id="编译openncv"><a href="#编译openncv" class="headerlink" title="编译openncv"></a>编译openncv</h4><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">cd opencv-3.1.0</span><br><span class="line">mkdir build</span><br><span class="line">cmake -D <span class="attribute">CMAKE_BUILD_TYPE</span>=RELEASE -D <span class="attribute">CMAKE_INSTALL_PREFIX</span>=/usr/local -D <span class="attribute">WITH_TBB</span>=ON -D <span class="attribute">WITH_V4L</span>=ON -D <span class="attribute">WITH_QT</span>=ON -D <span class="attribute">WITH_OPENGL</span>=ON -D <span class="attribute">WITH_CUBLAS</span>=ON <span class="attribute">-DCUDA_NVCC_FLAGS</span>=<span class="string">"-D_FORCE_INLINES"</span> <span class="built_in">..</span>    </span><br><span class="line">make -j $(($(nproc) + 1))</span><br></pre></td></tr></table></figure>
<h4 id="安装opencv"><a href="#安装opencv" class="headerlink" title="安装opencv"></a>安装opencv</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">sudo make <span class="keyword">install</span></span><br><span class="line">sudo /<span class="keyword">bin</span>/bash -c <span class="string">'echo "/usr/local/lib" &gt; /etc/ld.so.conf.d/opencv.conf'</span></span><br><span class="line">sudo ldconfig</span><br><span class="line">sudo apt-<span class="keyword">get</span> <span class="keyword">update</span></span><br></pre></td></tr></table></figure>
<h4 id="安装QT"><a href="#安装QT" class="headerlink" title="安装QT"></a>安装QT</h4><p>安装完Opencv后，发现opencv也需要QT库的支持，对于opencv3.1,对应的版本为qt5.6.1,而opencv3.2对应的QT库为5.6.2.从官网下载对应版本后安装如下：<br><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">chmod +x qt-opensource-linux-x64<span class="number">-5.6</span><span class="number">.2</span>.run</span><br><span class="line">./qt-opensource-linux-x64<span class="number">-5.6</span><span class="number">.2</span>.run</span><br></pre></td></tr></table></figure></p>
<p>在安装好之后，需要在环境变量中配置，在.bashrc中添加一行<br>export LD_LIBRARY_PATH=/home/jjx/Qt5.6.2/5.6/gcc_64/lib/</p>
<h4 id="测试opencv是否安装成功"><a href="#测试opencv是否安装成功" class="headerlink" title="测试opencv是否安装成功"></a>测试opencv是否安装成功</h4><p>test.cpp<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt; //头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv; <span class="comment">//包含cv命名空间</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 【1】读入一张图片</span></span><br><span class="line">	Mat img=imread(<span class="string">"1.jpg"</span>);</span><br><span class="line">	<span class="comment">// 【2】在窗口中显示载入的图片</span></span><br><span class="line">	imshow(<span class="string">"【载入的图片】"</span>,img);</span><br><span class="line">	<span class="comment">// 【3】等待6000 ms后窗口自动关闭</span></span><br><span class="line">	waitKey(<span class="number">6000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编写CMakeLists.txt<br><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">project</span>(mytest)                                       <span class="comment"># 工程项目名,编译出来的可执行文件名字</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">2.8</span>)                 <span class="comment"># CMake工具最低版本要求</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">aux_source_directory</span>(. SRC_LIST)                    <span class="comment"># 源文件列表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#include_directories(./header/)                     # 头文件目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#link_directories(/usr/local/lib)                   # 库文件的目录</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> <span class="variable">$&#123;SRC_LIST&#125;</span>)         <span class="comment"># 工程项目名和我们要编译的文件名</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>(OpenCV REQUIRED)                       <span class="comment"># 搜索指定的外部依赖库头文件和库文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> <span class="variable">$&#123;OpenCV_LIBS&#125;</span>)   <span class="comment"># 链接到OpenCV库</span></span><br></pre></td></tr></table></figure></p>
<p>编译程序<br><figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line">//目录结构：</span><br><span class="line">/*</span><br><span class="line"><span class="keyword">test </span>- text.cpp             //cpp文件</span><br><span class="line">       - CMakeLists.txt     //cmake生成文件</span><br><span class="line">       - 1.jpg            //测试图像</span><br><span class="line">*/</span><br><span class="line">cd test</span><br><span class="line">cmake .</span><br><span class="line">    // 生成makefile， “.”表示在当前目录生成</span><br><span class="line">make</span><br><span class="line">    // 编译</span><br><span class="line">./mytest</span><br><span class="line">    //运行程序</span><br></pre></td></tr></table></figure></p>
<p>效果如下：<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/cs231n/chapter2/p9.png" alt></p>
<h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="http://lib.csdn.net/article/opencv/25737" target="_blank" rel="noopener">ubuntu16.04安装opencv3.1.0+Qt5.6.0</a><br><a href="https://github.com/BVLC/caffe/wiki/OpenCV-3.1-Installation-Guide-on-Ubuntu-16.04" target="_blank" rel="noopener">OpenCV 3.1 Installation Guide on Ubuntu 16.04</a><br><a href="http://www.cnblogs.com/guiguzhixing/p/6347602.html" target="_blank" rel="noopener">在Linux下用CMAKE编译安装OpenCV3.2.0</a><br><a href="http://sourcedigit.com/19858-how-to-install-qt-5-6-1-on-ubuntu-16-04/" target="_blank" rel="noopener">How To Install QT 5.6.1 On Ubuntu 16.04</a></p>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>卷积神经网络之卷积层</title>
    <url>/blog/2017/05/convolution-learn-start.html</url>
    <content><![CDATA[<h3 id="卷积神经网络概述"><a href="#卷积神经网络概述" class="headerlink" title="卷积神经网络概述"></a>卷积神经网络概述</h3><p>卷积神经网络一般假定输入就是图片数据，也正是因为输入是图片数据，我们可以利用它的像素结构特性，去做一些假设来简化神经网络的训练复杂度(减少训练参数个数)。<br>卷积神经网络结构比较固定的原因之一，是图片数据本身的合理结构，类图像结构(200<em>200</em>3)，我们也把卷积神经网络的神经元排布成 width<em>height</em>depth的结构，也就是说这一层总共有width<em>height</em>depth个神经元，如下图所示。举个例子说，CIFAR-10的输出层就是1<em>1</em>10维的。另外我们后面会说到，每一层的神经元，其实只和上一层里某些小区域进行连接，而不是和上一层每个神经元全连接。 </p>
<p>为什么要发明卷积层这种神经层？能不能用全连接层代替卷积层？<br>很显然，用全连接层代替卷积层是完全没有问题的，但是这样做的代价实在太大了。原始图像的维度相对而言比较大，如果采用全连接的话参数将会有爆炸式的增长，参数的数量可能对于现在的电脑来说是一个灾难。试想一下对于MNist的数据，如果第一层是全连接层，即使把1<em>28</em>28数据映射到1*1024这样的输出上，其中的参数已经达到800万。而曾经的经典模型Lenet呢？<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/cs231n/chapter3/p1.png" alt><br>从上面的图可以看出（此处）：</p>
<p>第一层卷积的参数数量为：1<em>6</em>(5<em>5+1)=156，却可以得到6</em>28*28的输出。</p>
<p>两者的参数数量差距几万倍，而实际上两者效果绝对不会有如此大的差距。</p>
<p>既然如此，参数数量如此少的卷积层为什么可以有用？识别这样的问题总体来说是一种比较宏观的问题。像MNist这样的问题，每张图片上有784个像素，理论上可以有256^{784}种组合，而实际的类别只有10种，基本上可以断定提供的信息是远远多于满足搜索需求的数量的。那么多出来的像素信息是以什么样的形式展现呢？在图像处理上，有一个词叫“局部相关性”就是指这样的问题。<br>我们是如何识别出一个数字的呢？当然是因为这个数字不同于别的数字的特点，对于像MNist这样的数据，特点自然来自于明暗交界的地方。一片黑的区域不会告诉我们任何有用的信息，同样地，一片白的区域也不会告诉我们任何有用的信息。同样，数字的笔画粗细对我们的识别也没有太大的作用。这些都是我们识别过程中会遇到的问题，而其中临近像素之间有规律地出现相似的状态就是局部相关性。<br>那么如何消除这些局部相关性呢，使我们的特征变得少而精呢？卷积就是一种很好地方法。它只考虑附近一块区域的内容，分析这一小片区域的特点，这样针对小区域的算法可以很容易地分析出区域内的内容是否相似。如果再加上Pooling层（可以理解为汇集，聚集的意思，后面不做翻译），从附近的卷积结果中再采样选择一些高价值的合成信息，丢弃一些重复低质量的合成信息，就可以做到对特征信息的进一步处理过滤，让特征向少而精的方向前进。</p>
<h3 id="卷积层综述"><a href="#卷积层综述" class="headerlink" title="卷积层综述"></a>卷积层综述</h3><p>直观看来，卷积层的参数其实可以看做，一系列的可训练/学习的过滤器。在前向计算过程中，我们输入一定区域大小(width*height)的数据，和过滤器点乘后等到新的二维数据，然后滑过一个个滤波器，组成新的3维输出数据。而我们可以理解成每个过滤器都只关心过滤数据小平面内的部分特征，当出现它学习到的特征的时候，就会呈现激活/activate态<br>在CNN中，滤波器filter（带着一组固定权重的神经元）对局部输入数据进行卷积计算。每计算完一个数据窗口内的局部数据后，数据窗口不断平移滑动，直到计算完所有数据。这个过程中，有这么几个参数：<br>a. 深度depth：神经元个数，决定输出的depth厚度。同时代表滤波器个数。<br>b. 步长stride：决定滑动多少步可以到边缘。<br>c. 填充值zero-padding：在外围边缘补充若干圈0，方便从初始位置以步长为单位可以刚好滑倒末尾位置，通俗地讲就是为了总长能被步长整除。<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/cs231n/chapter3/p2.png" alt><br>计算卷积的前向传播过程大概如下，如下GIF图所示：<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/cs231n/chapter3/p3.gif" alt><br>可以看到：</p>
<ul>
<li>两个神经元，即depth=2，意味着有两个滤波器。</li>
<li>数据窗口每次移动两个步长取3*3的局部数据，即stride=2。</li>
<li>zero-padding=1。</li>
</ul>
<p>然后分别以两个滤波器filter为轴滑动数组进行卷积计算，得到两组不同的结果。</p>
<ul>
<li>左边是输入（7<em>7</em>3中，7*7代表图像的像素/长宽，3代表R、G、B 三个颜色通道）</li>
<li>中间部分是两个不同的滤波器Filter w0、Filter w1</li>
<li>最右边则是两个不同的输出</li>
</ul>
<p>随着左边数据窗口的平移滑动，滤波器Filter w0 / Filter w1对不同的局部数据进行卷积计算。<br>值得一提的是：<br>1、左边数据在变化，每次滤波器都是针对某一局部的数据窗口进行卷积，这就是所谓的CNN中的局部感知机制。<br>打个比方，滤波器就像一双眼睛，人类视角有限，一眼望去，只能看到这世界的局部。如果一眼就看到全世界，你会累死，而且一下子接受全世界所有信息，你大脑接收不过来。当然，即便是看局部，针对局部里的信息人类双眼也是有偏重、偏好的。<br>2、与此同时，数据窗口滑动，导致输入在变化，但中间滤波器Filter，w0的权重（即每个神经元连接数据窗口的权重）是固定不变的，这个权重不变即所谓的CNN中的参数（权重）共享机制。<br>再打个比方，某人环游全世界，所看到的信息在变，但采集信息的双眼不变。btw，不同人的双眼看同一个局部信息所感受到的不同，即一千个读者有一千个哈姆雷特，所以不同的滤波器 就像不同的双眼，不同的人有着不同的反馈结果。</p>
<h3 id="卷积层的计算方法"><a href="#卷积层的计算方法" class="headerlink" title="卷积层的计算方法"></a>卷积层的计算方法</h3><p>这里需要一个小例子，我们假定一个1<em>5</em>5的输入，卷积层的维度是1<em>1</em>3<em>3，同时stride=1,padding=0。最终的输出是1</em>3*3。</p>
<p>这里先画个详细的图，图像中对其中的变量做了定义：<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/cs231n/chapter3/p1.jpg" alt><br>其中：</p>
<p>X表示输入的矩阵，我们用一维的0-24表示下标。</p>
<p>K表示卷积核的矩阵，我们用一维的0-8表示下标。</p>
<p>Z表示卷积的结果，我们用一维的0-8表示下标。</p>
<p>由于前面我们提到操作中stride=1,padding=0，所以我们可以给出简单版和复杂版的输出维度计算公式：<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/cs231n/chapter3/p3.png" alt></p>
]]></content>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Dropout学习与实现</title>
    <url>/blog/2017/05/dropout-learn-achieve.html</url>
    <content><![CDATA[<h3 id="Dropout介绍"><a href="#Dropout介绍" class="headerlink" title="Dropout介绍"></a>Dropout介绍</h3><p>Dropout是我们实际神经网络训练中，用的非常多的一种正则化手段，同时也相当有效。Srivastava等人的论文Dropout: A Simple Way to Prevent Neural Networks from Overfitting最早提到用dropout这种方式作为正则化手段。一句话概括它，就是：在训练过程中，我们对每个神经元，都以概率p保持它是激活状态，1-p的概率直接关闭它。在训练的时候，随机失活的实现方法是让神经元以超参数p的概率被激活或者被设置为0。<br>下图是一个3层的神经网络的dropout示意图：<br><img src="https://raw.githubusercontent.com/whuhan2013/myImage/master/cs231n/chapter6/p6.jpeg" alt><br>可以这么理解，在训练过程中呢，我们对全体神经元，以概率p做了一个采样，只有选出的神经元要进行参数更新。所以最后就从左图的全连接到右图的Dropout过后神经元连接图了。需要多说一句的是，在测试阶段，我们不用dropout，而是直接从概率的角度，对权重配以一个概率值。</p>
<h4 id="Dropout简单实现"><a href="#Dropout简单实现" class="headerlink" title="Dropout简单实现"></a>Dropout简单实现</h4><p>简单的Dropout代码如下(这是简易实现版本，但是不建议使用）<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">""" 普通版随机失活: 不推荐实现 (看下面笔记) """</span></span><br><span class="line"></span><br><span class="line">p = <span class="number">0.5</span> <span class="comment"># 激活神经元的概率. p值更高 = 随机失活更弱</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_step</span><span class="params">(X)</span>:</span></span><br><span class="line">  <span class="string">""" X中是输入数据 """</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment"># 3层neural network的前向传播</span></span><br><span class="line">  H1 = np.maximum(<span class="number">0</span>, np.dot(W1, X) + b1)</span><br><span class="line">  U1 = np.random.rand(*H1.shape) &lt; p <span class="comment"># 第一个随机失活遮罩</span></span><br><span class="line">  H1 *= U1 <span class="comment"># drop!</span></span><br><span class="line">  H2 = np.maximum(<span class="number">0</span>, np.dot(W2, H1) + b2)</span><br><span class="line">  U2 = np.random.rand(*H2.shape) &lt; p <span class="comment"># 第二个随机失活遮罩</span></span><br><span class="line">  H2 *= U2 <span class="comment"># drop!</span></span><br><span class="line">  out = np.dot(W3, H2) + b3</span><br><span class="line">  </span><br><span class="line">  <span class="comment"># 反向传播:计算梯度... (略)</span></span><br><span class="line">  <span class="comment"># 进行参数更新... (略)</span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(X)</span>:</span></span><br><span class="line">  <span class="comment"># 前向传播时模型集成</span></span><br><span class="line">  H1 = np.maximum(<span class="number">0</span>, np.dot(W1, X) + b1) * p <span class="comment"># 注意：激活数据要乘以p</span></span><br><span class="line">  H2 = np.maximum(<span class="number">0</span>, np.dot(W2, H1) + b2) * p <span class="comment"># 注意：激活数据要乘以p</span></span><br><span class="line">  out = np.dot(W3, H2) + b3</span><br></pre></td></tr></table></figure></p>
<h4 id="Dropout改进实现"><a href="#Dropout改进实现" class="headerlink" title="Dropout改进实现"></a>Dropout改进实现</h4><p>上述代码中，在train_step函数中，我们做了2次Dropout。我们甚至可以在输入层做一次dropout。反向传播过程保持不变，除了我们要考虑一下U1,U2</p>
<p>很重要的一点是，大家仔细看predict函数部分，我们不再dropout了，而是对于每个隐层的输出，都用概率p做了一个幅度变换。可以从数学期望的角度去理解这个做法，我们考虑一个神经元的输出为x(没有dropout的情况下)，它的输出的数学期望为px+(1−p)0，那我们在测试阶段，如果直接把每个输出x都做变换x→px，其实是可以保持一样的数学期望的。</p>
<p>上述代码的写法有一些缺陷，我们必须在测试阶段对每个神经的输出都以p的概率输出。考虑到实际应用中，测试阶段对于时间的要求非常高，我们可以考虑反着来，代码实现的时候用inverted dropout，即在训练阶段就做相反的幅度变换/scaling(除以p)，这样在测试阶段，我们可以直接把权重拿来使用，而不用附加很多步用p做scaling的过程。inverted dropout的示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">""" </span></span><br><span class="line"><span class="string">Inverted Dropout的版本，把本该花在测试阶段的时间，转移到训练阶段，从而提高testing部分的速度</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">p = <span class="number">0.5</span> <span class="comment"># dropout的概率，也就是保持一个神经元激活状态的概率</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_step</span><span class="params">(X)</span>:</span></span><br><span class="line">  <span class="comment"># f3层神经网络前向计算</span></span><br><span class="line">  H1 = np.maximum(<span class="number">0</span>, np.dot(W1, X) + b1)</span><br><span class="line">  U1 = (np.random.rand(*H1.shape) &lt; p) / p <span class="comment"># 注意到这个dropout中我们除以p，做了一个inverted dropout</span></span><br><span class="line">  H1 *= U1 <span class="comment"># drop!</span></span><br><span class="line">  H2 = np.maximum(<span class="number">0</span>, np.dot(W2, H1) + b2)</span><br><span class="line">  U2 = (np.random.rand(*H2.shape) &lt; p) / p <span class="comment"># 这个dropout中我们除以p，做了一个inverted dropout</span></span><br><span class="line">  H2 *= U2 <span class="comment"># drop!</span></span><br><span class="line">  out = np.dot(W3, H2) + b3</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 反向传播: 计算梯度... (这里省略)</span></span><br><span class="line">  <span class="comment"># 参数更新... (这里省略)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(X)</span>:</span></span><br><span class="line">  <span class="comment"># 直接前向计算，无需再乘以p</span></span><br><span class="line">  H1 = np.maximum(<span class="number">0</span>, np.dot(W1, X) + b1) </span><br><span class="line">  H2 = np.maximum(<span class="number">0</span>, np.dot(W2, H1) + b2)</span><br><span class="line">  out = np.dot(W3, H2) + b3</span><br></pre></td></tr></table></figure>
<h3 id="Dropout具体实现"><a href="#Dropout具体实现" class="headerlink" title="Dropout具体实现"></a>Dropout具体实现</h3><h4 id="Dropout前向传播"><a href="#Dropout前向传播" class="headerlink" title="Dropout前向传播"></a>Dropout前向传播</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dropout_forward</span><span class="params">(x, dropout_param)</span>:</span></span><br><span class="line">  <span class="string">"""</span></span><br><span class="line"><span class="string">  Performs the forward pass for (inverted) dropout.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  Inputs:</span></span><br><span class="line"><span class="string">  - x: Input data, of any shape</span></span><br><span class="line"><span class="string">  - dropout_param: A dictionary with the following keys:</span></span><br><span class="line"><span class="string">    - p: Dropout parameter. We drop each neuron output with probability p.</span></span><br><span class="line"><span class="string">    - mode: 'test' or 'train'. If the mode is train, then perform dropout;</span></span><br><span class="line"><span class="string">      if the mode is test, then just return the input.</span></span><br><span class="line"><span class="string">    - seed: Seed for the random number generator. Passing seed makes this</span></span><br><span class="line"><span class="string">      function deterministic, which is needed for gradient checking but not in</span></span><br><span class="line"><span class="string">      real networks.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  Outputs:</span></span><br><span class="line"><span class="string">  - out: Array of the same shape as x.</span></span><br><span class="line"><span class="string">  - cache: A tuple (dropout_param, mask). In training mode, mask is the dropout</span></span><br><span class="line"><span class="string">    mask that was used to multiply the input; in test mode, mask is None.</span></span><br><span class="line"><span class="string">  """</span></span><br><span class="line">  p, mode = dropout_param[<span class="string">'p'</span>], dropout_param[<span class="string">'mode'</span>]</span><br><span class="line">  <span class="keyword">if</span> <span class="string">'seed'</span> <span class="keyword">in</span> dropout_param:</span><br><span class="line">    np.random.seed(dropout_param[<span class="string">'seed'</span>])</span><br><span class="line"></span><br><span class="line">  mask = <span class="literal">None</span></span><br><span class="line">  out = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> mode == <span class="string">'train'</span>:</span><br><span class="line">    mask = (np.random.rand(*x.shape) &gt;= p) / (<span class="number">1</span> - p)</span><br><span class="line">    <span class="comment">#mask = (np.random.rand(x.shape[1]) &gt;= p) / (1 - p)</span></span><br><span class="line">    out = x * mask</span><br><span class="line">  <span class="keyword">elif</span> mode == <span class="string">'test'</span>:</span><br><span class="line">    out = x</span><br><span class="line"></span><br><span class="line">  cache = (dropout_param, mask)</span><br><span class="line">  out = out.astype(x.dtype, copy=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> out, cache</span><br></pre></td></tr></table></figure>
<h4 id="Dropout反向传播"><a href="#Dropout反向传播" class="headerlink" title="Dropout反向传播"></a>Dropout反向传播</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dropout_backward</span><span class="params">(dout, cache)</span>:</span></span><br><span class="line">  <span class="string">"""</span></span><br><span class="line"><span class="string">  Perform the backward pass for (inverted) dropout.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  Inputs:</span></span><br><span class="line"><span class="string">  - dout: Upstream derivatives, of any shape</span></span><br><span class="line"><span class="string">  - cache: (dropout_param, mask) from dropout_forward.</span></span><br><span class="line"><span class="string">  """</span></span><br><span class="line">  dropout_param, mask = cache</span><br><span class="line">  mode = dropout_param[<span class="string">'mode'</span>]</span><br><span class="line">  </span><br><span class="line">  dx = <span class="literal">None</span></span><br><span class="line">  <span class="keyword">if</span> mode == <span class="string">'train'</span>:</span><br><span class="line">    dx = dout * mask</span><br><span class="line">  <span class="keyword">elif</span> mode == <span class="string">'test'</span>:</span><br><span class="line">    dx = dout</span><br><span class="line">  <span class="keyword">return</span> dx</span><br></pre></td></tr></table></figure>
<h4 id="Dropout与全连接层结合"><a href="#Dropout与全连接层结合" class="headerlink" title="Dropout与全连接层结合"></a>Dropout与全连接层结合</h4><p>Dropout位于ReLU层的背后，当P&gt;0时，就对相应参数使用DropOut操作<br>在计算loss时，在ReLU后添加如下<br><figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">self</span>.<span class="symbol">use_dropout:</span></span><br><span class="line">            <span class="keyword">out</span>[i+<span class="number">1</span>], cache4[i] = dropout_forward(<span class="keyword">out</span>[i+<span class="number">1</span>], <span class="keyword">self</span>.dropout_param)</span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure></p>
<p>在计算grad时，在ReLU前添加<br><figure class="highlight excel"><table><tr><td class="code"><pre><span class="line"><span class="built_in">if</span> self.use_dropo<span class="symbol">ut:</span></span><br><span class="line">            dout[<span class="built_in">t</span>-i] = dropout_backward(dout[<span class="built_in">t</span>-i] ,cache4[<span class="built_in">t</span>-<span class="number">1</span>-i])</span><br></pre></td></tr></table></figure></p>
<h4 id="Dropout效果测试"><a href="#Dropout效果测试" class="headerlink" title="Dropout效果测试"></a>Dropout效果测试</h4><p>在一个小的两层神经网络上，输入500个样本，查看有Dropout与没有Dropout的效果差异<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Train two identical nets, one with dropout and one without</span></span><br><span class="line"></span><br><span class="line">num_train = 500</span><br><span class="line">small_data = &#123;</span><br><span class="line">  <span class="string">'X_train'</span>: data[<span class="string">'X_train'</span>][:num_train],</span><br><span class="line">  <span class="string">'y_train'</span>: data[<span class="string">'y_train'</span>][:num_train],</span><br><span class="line">  <span class="string">'X_val'</span>: data[<span class="string">'X_val'</span>],</span><br><span class="line">  <span class="string">'y_val'</span>: data[<span class="string">'y_val'</span>],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">solvers = &#123;&#125;</span><br><span class="line">dropout_choices = [0, 0.25, 0.5, 0.75, 0.8, 0.9, 0.99]</span><br><span class="line"><span class="keyword">for</span> dropout <span class="keyword">in</span> dropout_choices:</span><br><span class="line">  model = FullyConnectedNet([500], <span class="attribute">dropout</span>=dropout)</span><br><span class="line">  <span class="builtin-name">print</span> dropout</span><br><span class="line"></span><br><span class="line">  solver = Solver(model, small_data,</span><br><span class="line">                  <span class="attribute">num_epochs</span>=25, <span class="attribute">batch_size</span>=100,</span><br><span class="line">                  <span class="attribute">update_rule</span>=<span class="string">'adam'</span>,</span><br><span class="line">                  optim_config=&#123;</span><br><span class="line">                    <span class="string">'learning_rate'</span>: 5e-4,</span><br><span class="line">                  &#125;,</span><br><span class="line">                  <span class="attribute">verbose</span>=<span class="literal">True</span>, <span class="attribute">print_every</span>=100)</span><br><span class="line">  solver.train()</span><br><span class="line">  solvers[dropout] = solver</span><br><span class="line"></span><br><span class="line"><span class="comment"># Plot train and validation accuracies of the two models</span></span><br><span class="line"></span><br><span class="line">train_accs = []</span><br><span class="line">val_accs = []</span><br><span class="line"><span class="keyword">for</span> dropout <span class="keyword">in</span> dropout_choices:</span><br><span class="line">  solver = solvers[dropout]</span><br><span class="line">  train_accs.append(solver.train_acc_history[-1])</span><br><span class="line">  val_accs.append(solver.val_acc_history[-1])</span><br><span class="line"></span><br><span class="line">plt.subplot(3, 1, 1)</span><br><span class="line"><span class="keyword">for</span> dropout <span class="keyword">in</span> dropout_choices:</span><br><span class="line">  plt.plot(solvers[dropout].train_acc_history, <span class="string">'o'</span>, <span class="attribute">label</span>=<span class="string">'%.2f dropout'</span> % dropout)</span><br><span class="line">plt.title(<span class="string">'Train accuracy'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Epoch'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Accuracy'</span>)</span><br><span class="line">plt.legend(<span class="attribute">ncol</span>=2, <span class="attribute">loc</span>=<span class="string">'lower right'</span>)</span><br><span class="line">  </span><br><span class="line">plt.subplot(3, 1, 2)</span><br><span class="line"><span class="keyword">for</span> dropout <span class="keyword">in</span> dropout_choices:</span><br><span class="line">  plt.plot(solvers[dropout].val_acc_history, <span class="string">'o'</span>, <span class="attribute">label</span>=<span class="string">'%.2f dropout'</span> % dropout)</span><br><span class="line">plt.title(<span class="string">'Val accuracy'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Epoch'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Accuracy'</span>)</span><br><span class="line">plt.legend(<span class="attribute">ncol</span>=2, <span class="attribute">loc</span>=<span class="string">'lower right'</span>)</span><br><span class="line"></span><br><span class="line">plt.gcf().set_size_inches(15, 15)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p>
<p>效果如下<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/cs231n/chapter2/p10.png" alt><br>可以看出使用Drouout后可以有效防止我们的模型过拟合，在没有使用Dropout时，train与validation的差距可以达到65%，但同时如果Dropuout的概率过大，也会导致模型的表达能力下降，当P过大时，拟合数据的能力就不是很强了。</p>
]]></content>
      <tags>
        <tag>计算机视觉</tag>
      </tags>
  </entry>
  <entry>
    <title>python下opencv开始</title>
    <url>/blog/2017/05/python-opencv-start.html</url>
    <content><![CDATA[<h3 id="python下安装opencv"><a href="#python下安装opencv" class="headerlink" title="python下安装opencv"></a>python下安装opencv</h3><p>python2可以通过把cv2.pyd拷到C:\Users\wdf\Anaconda2\Lib\site-packages目录即可<br>python3的话,可以conda安装 conda install -c <a href="https://conda.binstar.org/menpo" target="_blank" rel="noopener">https://conda.binstar.org/menpo</a> opencv3<br>但对网络环境好像有一定要求<br>推荐使用whl安装，（CMD pip install .whl）但要注意版本号 <a href="http://www.lfd.uci.edu/~gohlke/pythonlibs/" target="_blank" rel="noopener">Python Extension Packages for Windows</a></p>
<p>安装成功后试验代码如下：<br><figure class="highlight elm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="title">img</span> = cv2.imread(<span class="string">"p1.png"</span>)</span><br><span class="line"><span class="title">cv2</span>.imshow(<span class="string">"lena"</span>,img)</span><br><span class="line"><span class="title">cv2</span>.waitKey(<span class="number">10000</span>)</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>计算机视觉</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习资源总结</title>
    <url>/blog/2017/05/deep-learning-summary.html</url>
    <content><![CDATA[<ul>
<li>这是一个系列，包括CNN,RNN,LSTM等，讲解的非常清楚：<a href="https://www.zybuluo.com/hanbingtao/note/541458" target="_blank" rel="noopener">零基础入门深度学习</a></li>
<li>RNN实现作唐诗：<a href="http://www.lai18.com/content/10409608.html" target="_blank" rel="noopener">RNN实践之唐诗创作</a>、<a href="http://www.jianshu.com/p/938a0aff8840" target="_blank" rel="noopener">RNN学习并生成古诗</a></li>
</ul>
]]></content>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>卷积神经网络实现</title>
    <url>/blog/2017/05/convolution-network-achieve.html</url>
    <content><![CDATA[<p>前面我们已经尝试实现了多层全连接网络，并且尝试了不同的优化策略与网络结构。全连接神经网络是一种非常好的试验网络，因为其计算的高效性。但是在实际运用中，常常使用卷积神经网络。</p>
<h3 id="卷积神经网络的构造"><a href="#卷积神经网络的构造" class="headerlink" title="卷积神经网络的构造"></a>卷积神经网络的构造</h3><h4 id="卷积层"><a href="#卷积层" class="headerlink" title="卷积层"></a>卷积层</h4><p>卷积层的前向传播<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">def conv_forward_naive(x, w, b, conv_param):</span><br><span class="line">  """</span><br><span class="line">  A naive implementation of the forward pass for a convolutional layer.</span><br><span class="line"></span><br><span class="line">  The input consists of N data points, each <span class="keyword">with</span> C channels, height H <span class="keyword">and</span> width</span><br><span class="line">  W. We convolve <span class="keyword">each</span> <span class="keyword">input</span> <span class="keyword">with</span> F different filters, <span class="keyword">where</span> <span class="keyword">each</span> filter spans</span><br><span class="line">  <span class="keyword">all</span> C channels <span class="keyword">and</span> has height HH <span class="keyword">and</span> width HH.</span><br><span class="line"></span><br><span class="line">  <span class="keyword">Input</span>:</span><br><span class="line">  - x: <span class="keyword">Input</span> <span class="keyword">data</span> <span class="keyword">of</span> shape (N, C, H, W)</span><br><span class="line">  - w: Filter weights <span class="keyword">of</span> shape (F, C, HH, WW)</span><br><span class="line">  - b: Biases, <span class="keyword">of</span> shape (F,)</span><br><span class="line">  - conv_param: A dictionary <span class="keyword">with</span> the <span class="keyword">following</span> <span class="keyword">keys</span>:</span><br><span class="line">    - <span class="string">'stride'</span>: The <span class="built_in">number</span> <span class="keyword">of</span> pixels <span class="keyword">between</span> adjacent receptive <span class="keyword">fields</span> <span class="keyword">in</span> the</span><br><span class="line">      horizontal <span class="keyword">and</span> vertical directions.</span><br><span class="line">    - <span class="string">'pad'</span>: The <span class="built_in">number</span> <span class="keyword">of</span> pixels that will be used <span class="keyword">to</span> zero-<span class="keyword">pad</span> the input.</span><br><span class="line"></span><br><span class="line">  <span class="keyword">Returns</span> a tuple <span class="keyword">of</span>:</span><br><span class="line">  - <span class="keyword">out</span>: <span class="keyword">Output</span> <span class="keyword">data</span>, <span class="keyword">of</span> shape (N, F, H<span class="string">', W'</span>) <span class="keyword">where</span> H<span class="string">' and W'</span> <span class="keyword">are</span> given <span class="keyword">by</span></span><br><span class="line">    H<span class="string">' = 1 + (H + 2 * pad - HH) / stride</span></span><br><span class="line"><span class="string">    W'</span> = <span class="number">1</span> + (W + <span class="number">2</span> * <span class="keyword">pad</span> - WW) / stride</span><br><span class="line">  - <span class="keyword">cache</span>: (x, w, b, conv_param)</span><br><span class="line">  <span class="string">"""</span></span><br><span class="line"><span class="string">  out = None</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  N, C, H, W = x.shape</span></span><br><span class="line"><span class="string">  F, _, HH, WW = w.shape</span></span><br><span class="line"><span class="string">  stride, pad = conv_param['stride'], conv_param['pad']</span></span><br><span class="line"><span class="string">  H_out = 1 + (H + 2 * pad - HH) / stride</span></span><br><span class="line"><span class="string">  W_out = 1 + (W + 2 * pad - WW) / stride</span></span><br><span class="line"><span class="string">  out = np.zeros((N , F , H_out, W_out))</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  x_pad = np.pad(x, ((0,), (0,), (pad,), (pad,)), mode='constant', constant_values=0)</span></span><br><span class="line"><span class="string">  for i in range(H_out):</span></span><br><span class="line"><span class="string">      for j in range(W_out):</span></span><br><span class="line"><span class="string">          x_pad_masked = x_pad[:, :, i*stride:i*stride+HH, j*stride:j*stride+WW]</span></span><br><span class="line"><span class="string">          for k in range(F):</span></span><br><span class="line"><span class="string">              out[:, k , i, j] = np.sum(x_pad_masked * w[k, :, :, :], axis=(1,2,3))</span></span><br><span class="line"><span class="string">          </span></span><br><span class="line"><span class="string">  out = out + (b)[None, :, None, None]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  cache = (x, w, b, conv_param)</span></span><br><span class="line"><span class="string">  return out, cache</span></span><br></pre></td></tr></table></figure></p>
<p>卷积层的后向传播<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">def conv_backward_naive(dout, <span class="keyword">cache</span>):</span><br><span class="line">  <span class="string">"""</span></span><br><span class="line"><span class="string">  A naive implementation of the backward pass for a convolutional layer.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  Inputs:</span></span><br><span class="line"><span class="string">  - dout: Upstream derivatives.</span></span><br><span class="line"><span class="string">  - cache: A tuple of (x, w, b, conv_param) as in conv_forward_naive</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  Returns a tuple of:</span></span><br><span class="line"><span class="string">  - dx: Gradient with respect to x</span></span><br><span class="line"><span class="string">  - dw: Gradient with respect to w</span></span><br><span class="line"><span class="string">  - db: Gradient with respect to b</span></span><br><span class="line"><span class="string">  """</span></span><br><span class="line">  dx, dw, db = <span class="keyword">None</span>, <span class="keyword">None</span>, <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">  x, w, b, conv_param = <span class="keyword">cache</span></span><br><span class="line">  </span><br><span class="line">  N, C, H, W = x.shape</span><br><span class="line">  F, _, HH, WW = w.shape</span><br><span class="line">  stride, <span class="keyword">pad</span> = conv_param[<span class="string">'stride'</span>], conv_param[<span class="string">'pad'</span>]</span><br><span class="line">  H_out = <span class="number">1</span> + (H + <span class="number">2</span> * <span class="keyword">pad</span> - HH) / stride</span><br><span class="line">  W_out = <span class="number">1</span> + (W + <span class="number">2</span> * <span class="keyword">pad</span> - WW) / stride</span><br><span class="line">  </span><br><span class="line">  x_pad = np.pad(x, ((<span class="number">0</span>,), (<span class="number">0</span>,), (<span class="keyword">pad</span>,), (<span class="keyword">pad</span>,)), <span class="keyword">mode</span>=<span class="string">'constant'</span>, constant_values=<span class="number">0</span>)</span><br><span class="line">  dx = np.zeros_like(x)</span><br><span class="line">  dx_pad = np.zeros_like(x_pad)</span><br><span class="line">  dw = np.zeros_like(w)</span><br><span class="line">  db = np.zeros_like(b)</span><br><span class="line">  </span><br><span class="line">  db = np.sum(dout, axis = (<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line">  </span><br><span class="line">  x_pad = np.pad(x, ((<span class="number">0</span>,), (<span class="number">0</span>,), (<span class="keyword">pad</span>,), (<span class="keyword">pad</span>,)), <span class="keyword">mode</span>=<span class="string">'constant'</span>, constant_values=<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="keyword">range</span>(H_out):</span><br><span class="line">      <span class="keyword">for</span> j <span class="keyword">in</span> <span class="keyword">range</span>(W_out):</span><br><span class="line">          x_pad_masked = x_pad[:, :, i*stride:i*stride+HH, j*stride:j*stride+WW]</span><br><span class="line">          <span class="keyword">for</span> k <span class="keyword">in</span> <span class="keyword">range</span>(F): <span class="comment">#compute dw</span></span><br><span class="line">              dw[k ,: ,: ,:] += np.sum(x_pad_masked * (dout[:, k, i, j])[:, <span class="keyword">None</span>, <span class="keyword">None</span>, <span class="keyword">None</span>], axis=<span class="number">0</span>)</span><br><span class="line">          <span class="keyword">for</span> n <span class="keyword">in</span> <span class="keyword">range</span>(N): <span class="comment">#compute dx_pad</span></span><br><span class="line">              dx_pad[n, :, i*stride:i*stride+HH, j*stride:j*stride+WW] += np.sum((w[:, :, :, :] * </span><br><span class="line">                                                 (dout[n, :, i, j])[:,<span class="keyword">None</span> ,<span class="keyword">None</span>, <span class="keyword">None</span>]), axis=<span class="number">0</span>)</span><br><span class="line">  dx = dx_pad[:,:,<span class="keyword">pad</span>:-<span class="keyword">pad</span>,<span class="keyword">pad</span>:-<span class="keyword">pad</span>]</span><br><span class="line">  <span class="keyword">return</span> dx, dw, db</span><br></pre></td></tr></table></figure></p>
<h4 id="通过卷积进行图像处理"><a href="#通过卷积进行图像处理" class="headerlink" title="通过卷积进行图像处理"></a>通过卷积进行图像处理</h4><p>为了更好的理解卷积的效果同时检测我们的实现是否正确，我们将设定两个卷积模块，灰度化与边缘检测，可以看到通过前向卷积后效果如下：<br><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">from</span> <span class="string">scipy.misc</span> <span class="string">import</span> <span class="string">imread,</span> <span class="string">imresize</span></span><br><span class="line"></span><br><span class="line"><span class="string">kitten,</span> <span class="string">puppy</span> <span class="string">=</span> <span class="string">imread('kitten.jpg'),</span> <span class="string">imread('puppy.jpg')</span></span><br><span class="line"><span class="comment"># kitten is wide, and puppy is already square</span></span><br><span class="line"><span class="string">d</span> <span class="string">=</span> <span class="string">kitten.shape[1]</span> <span class="bullet">-</span> <span class="string">kitten.shape[0]</span></span><br><span class="line"><span class="string">kitten_cropped</span> <span class="string">=</span> <span class="string">kitten[:,</span> <span class="string">d/2:-d/2,</span> <span class="string">:]</span></span><br><span class="line"></span><br><span class="line"><span class="string">img_size</span> <span class="string">=</span> <span class="number">200</span>   <span class="comment"># Make this smaller if it runs too slow</span></span><br><span class="line"><span class="string">x</span> <span class="string">=</span> <span class="string">np.zeros((2,</span> <span class="number">3</span><span class="string">,</span> <span class="string">img_size,</span> <span class="string">img_size))</span></span><br><span class="line"><span class="string">x[0,</span> <span class="string">:,</span> <span class="string">:,</span> <span class="string">:]</span> <span class="string">=</span> <span class="string">imresize(puppy,</span> <span class="string">(img_size,</span> <span class="string">img_size)).transpose((2,</span> <span class="number">0</span><span class="string">,</span> <span class="number">1</span><span class="string">))</span></span><br><span class="line"><span class="string">x[1,</span> <span class="string">:,</span> <span class="string">:,</span> <span class="string">:]</span> <span class="string">=</span> <span class="string">imresize(kitten_cropped,</span> <span class="string">(img_size,</span> <span class="string">img_size)).transpose((2,</span> <span class="number">0</span><span class="string">,</span> <span class="number">1</span><span class="string">))</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set up a convolutional weights holding 2 filters, each 3x3</span></span><br><span class="line"><span class="string">w</span> <span class="string">=</span> <span class="string">np.zeros((2,</span> <span class="number">3</span><span class="string">,</span> <span class="number">3</span><span class="string">,</span> <span class="number">3</span><span class="string">))</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The first filter converts the image to grayscale.</span></span><br><span class="line"><span class="comment"># Set up the red, green, and blue channels of the filter.</span></span><br><span class="line"><span class="string">w[0,</span> <span class="number">0</span><span class="string">,</span> <span class="string">:,</span> <span class="string">:]</span> <span class="string">=</span> <span class="string">[[0,</span> <span class="number">0</span><span class="string">,</span> <span class="number">0</span><span class="string">],</span> <span class="string">[0,</span> <span class="number">0.3</span><span class="string">,</span> <span class="number">0</span><span class="string">],</span> <span class="string">[0,</span> <span class="number">0</span><span class="string">,</span> <span class="number">0</span><span class="string">]]</span></span><br><span class="line"><span class="string">w[0,</span> <span class="number">1</span><span class="string">,</span> <span class="string">:,</span> <span class="string">:]</span> <span class="string">=</span> <span class="string">[[0,</span> <span class="number">0</span><span class="string">,</span> <span class="number">0</span><span class="string">],</span> <span class="string">[0,</span> <span class="number">0.6</span><span class="string">,</span> <span class="number">0</span><span class="string">],</span> <span class="string">[0,</span> <span class="number">0</span><span class="string">,</span> <span class="number">0</span><span class="string">]]</span></span><br><span class="line"><span class="string">w[0,</span> <span class="number">2</span><span class="string">,</span> <span class="string">:,</span> <span class="string">:]</span> <span class="string">=</span> <span class="string">[[0,</span> <span class="number">0</span><span class="string">,</span> <span class="number">0</span><span class="string">],</span> <span class="string">[0,</span> <span class="number">0.1</span><span class="string">,</span> <span class="number">0</span><span class="string">],</span> <span class="string">[0,</span> <span class="number">0</span><span class="string">,</span> <span class="number">0</span><span class="string">]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Second filter detects horizontal edges in the blue channel.</span></span><br><span class="line"><span class="string">w[1,</span> <span class="number">2</span><span class="string">,</span> <span class="string">:,</span> <span class="string">:]</span> <span class="string">=</span> <span class="string">[[1,</span> <span class="number">2</span><span class="string">,</span> <span class="number">1</span><span class="string">],</span> <span class="string">[0,</span> <span class="number">0</span><span class="string">,</span> <span class="number">0</span><span class="string">],</span> <span class="string">[-1,</span> <span class="number">-2</span><span class="string">,</span> <span class="number">-1</span><span class="string">]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Vector of biases. We don't need any bias for the grayscale</span></span><br><span class="line"><span class="comment"># filter, but for the edge detection filter we want to add 128</span></span><br><span class="line"><span class="comment"># to each output so that nothing is negative.</span></span><br><span class="line"><span class="string">b</span> <span class="string">=</span> <span class="string">np.array([0,</span> <span class="number">128</span><span class="string">])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Compute the result of convolving each input in x with each filter in w,</span></span><br><span class="line"><span class="comment"># offsetting by b, and storing the results in out.</span></span><br><span class="line"><span class="string">out,</span> <span class="string">_</span> <span class="string">=</span> <span class="string">conv_forward_naive(x,</span> <span class="string">w,</span> <span class="string">b,</span> <span class="string">&#123;'stride':</span> <span class="number">1</span><span class="string">,</span> <span class="attr">'pad':</span> <span class="number">1</span><span class="string">&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="string">def</span> <span class="string">imshow_noax(img,</span> <span class="string">normalize=True):</span></span><br><span class="line">    <span class="string">""</span><span class="string">" Tiny helper to show images as uint8 and remove axis labels "</span><span class="string">""</span></span><br><span class="line">    <span class="attr">if normalize:</span></span><br><span class="line">        <span class="string">img_max,</span> <span class="string">img_min</span> <span class="string">=</span> <span class="string">np.max(img),</span> <span class="string">np.min(img)</span></span><br><span class="line">        <span class="string">img</span> <span class="string">=</span> <span class="number">255.0</span> <span class="string">*</span> <span class="string">(img</span> <span class="bullet">-</span> <span class="string">img_min)</span> <span class="string">/</span> <span class="string">(img_max</span> <span class="bullet">-</span> <span class="string">img_min)</span></span><br><span class="line">    <span class="string">plt.imshow(img.astype('uint8'))</span></span><br><span class="line">    <span class="string">plt.gca().axis('off')</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Show the original images and the results of the conv operation</span></span><br><span class="line"><span class="string">plt.subplot(2,</span> <span class="number">3</span><span class="string">,</span> <span class="number">1</span><span class="string">)</span></span><br><span class="line"><span class="string">imshow_noax(puppy,</span> <span class="string">normalize=False)</span></span><br><span class="line"><span class="string">plt.title('Original</span> <span class="string">image')</span></span><br><span class="line"><span class="string">plt.subplot(2,</span> <span class="number">3</span><span class="string">,</span> <span class="number">2</span><span class="string">)</span></span><br><span class="line"><span class="string">imshow_noax(out[0,</span> <span class="number">0</span><span class="string">])</span></span><br><span class="line"><span class="string">plt.title('Grayscale')</span></span><br><span class="line"><span class="string">plt.subplot(2,</span> <span class="number">3</span><span class="string">,</span> <span class="number">3</span><span class="string">)</span></span><br><span class="line"><span class="string">imshow_noax(out[0,</span> <span class="number">1</span><span class="string">])</span></span><br><span class="line"><span class="string">plt.title('Edges')</span></span><br><span class="line"><span class="string">plt.subplot(2,</span> <span class="number">3</span><span class="string">,</span> <span class="number">4</span><span class="string">)</span></span><br><span class="line"><span class="string">imshow_noax(kitten_cropped,</span> <span class="string">normalize=False)</span></span><br><span class="line"><span class="string">plt.subplot(2,</span> <span class="number">3</span><span class="string">,</span> <span class="number">5</span><span class="string">)</span></span><br><span class="line"><span class="string">imshow_noax(out[1,</span> <span class="number">0</span><span class="string">])</span></span><br><span class="line"><span class="string">plt.subplot(2,</span> <span class="number">3</span><span class="string">,</span> <span class="number">6</span><span class="string">)</span></span><br><span class="line"><span class="string">imshow_noax(out[1,</span> <span class="number">1</span><span class="string">])</span></span><br><span class="line"><span class="string">plt.show()</span></span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/cs231n/chapter3/p4.png" alt></p>
<h4 id="池化层"><a href="#池化层" class="headerlink" title="池化层"></a>池化层</h4><p>Pooling层做的操作也非常简单，就是将原数据上的区域压缩成一个值(区域最大值/MAX或者平均值/AVERAGE),最常见的Pooling设定是，将原数据切成2*2的小块，每块里面取最大值作为输出，这样我们就自然而然减少了75%的数据量.<br>池化层逐步地压缩/减少数据和参数的量，也在一定程度上减小过拟合的现象。<br>池化层前向传播<br><figure class="highlight ceylon"><table><tr><td class="code"><pre><span class="line">def max<span class="number">_p</span>ool<span class="number">_f</span>orward<span class="number">_n</span>aive(x, pool<span class="number">_p</span>aram):</span><br><span class="line">  <span class="string">"""</span></span><br><span class="line"><span class="string">  A naive implementation of the forward pass for a max pooling layer.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  Inputs:</span></span><br><span class="line"><span class="string">  - x: Input data, of shape (N, C, H, W)</span></span><br><span class="line"><span class="string">  - pool_param: dictionary with the following keys:</span></span><br><span class="line"><span class="string">    - 'pool_height': The height of each pooling region</span></span><br><span class="line"><span class="string">    - 'pool_width': The width of each pooling region</span></span><br><span class="line"><span class="string">    - 'stride': The distance between adjacent pooling regions</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  Returns a tuple of:</span></span><br><span class="line"><span class="string">  - out: Output data</span></span><br><span class="line"><span class="string">  - cache: (x, pool_param)</span></span><br><span class="line"><span class="string">  """</span></span><br><span class="line">  <span class="keyword">out</span> = None</span><br><span class="line">  N, C, H, W = x.shape</span><br><span class="line">  HH, WW, stride = pool<span class="number">_p</span>aram[<span class="string">'pool_height'</span>], pool<span class="number">_p</span>aram[<span class="string">'pool_width'</span>], pool<span class="number">_p</span>aram[<span class="string">'stride'</span>]</span><br><span class="line">  H<span class="number">_</span><span class="keyword">out</span> = (H-HH)/stride+<span class="number">1</span></span><br><span class="line">  W<span class="number">_</span><span class="keyword">out</span> = (W-WW)/stride+<span class="number">1</span></span><br><span class="line">  <span class="keyword">out</span> = np.zeros((N,C,H<span class="number">_</span><span class="keyword">out</span>,W<span class="number">_</span><span class="keyword">out</span>))</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> xrange(H<span class="number">_</span><span class="keyword">out</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> xrange(W<span class="number">_</span><span class="keyword">out</span>):</span><br><span class="line">            x<span class="number">_m</span>asked = x[:,:,i*stride : i*stride+HH, j*stride : j*stride+WW]</span><br><span class="line">            <span class="keyword">out</span>[:,:,i,j] = np.max(x<span class="number">_m</span>asked, axis=(<span class="number">2</span>,<span class="number">3</span>)) </span><br><span class="line"></span><br><span class="line">  cache = (x, pool<span class="number">_p</span>aram)</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">out</span>, cache</span><br></pre></td></tr></table></figure></p>
<p>池化层反向传播<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max_pool_backward_naive</span><span class="params">(dout, cache)</span>:</span></span><br><span class="line">  <span class="string">"""</span></span><br><span class="line"><span class="string">  A naive implementation of the backward pass for a max pooling layer.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  Inputs:</span></span><br><span class="line"><span class="string">  - dout: Upstream derivatives</span></span><br><span class="line"><span class="string">  - cache: A tuple of (x, pool_param) as in the forward pass.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  Returns:</span></span><br><span class="line"><span class="string">  - dx: Gradient with respect to x</span></span><br><span class="line"><span class="string">  """</span></span><br><span class="line">  dx = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">  x, pool_param = cache</span><br><span class="line">  N, C, H, W = x.shape</span><br><span class="line">  HH, WW, stride = pool_param[<span class="string">'pool_height'</span>], pool_param[<span class="string">'pool_width'</span>], pool_param[<span class="string">'stride'</span>]</span><br><span class="line">  H_out = (H-HH)/stride+<span class="number">1</span></span><br><span class="line">  W_out = (W-WW)/stride+<span class="number">1</span></span><br><span class="line">  dx = np.zeros_like(x)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> xrange(H_out):</span><br><span class="line">     <span class="keyword">for</span> j <span class="keyword">in</span> xrange(W_out):</span><br><span class="line">        x_masked = x[:,:,i*stride : i*stride+HH, j*stride : j*stride+WW]</span><br><span class="line">        max_x_masked = np.max(x_masked,axis=(<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line">        temp_binary_mask = (x_masked == (max_x_masked)[:,:,<span class="literal">None</span>,<span class="literal">None</span>])</span><br><span class="line">        dx[:,:,i*stride : i*stride+HH, j*stride : j*stride+WW] += temp_binary_mask * (dout[:,:,i,j])[:,:,<span class="literal">None</span>,<span class="literal">None</span>]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dx</span><br></pre></td></tr></table></figure></p>
<h4 id="卷积三明治层"><a href="#卷积三明治层" class="headerlink" title="卷积三明治层"></a>卷积三明治层</h4><p>将一些层结合起来，形成三明治结构，方便以后调用<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conv_relu_forward</span><span class="params">(x, w, b, conv_param)</span>:</span></span><br><span class="line">  <span class="string">"""</span></span><br><span class="line"><span class="string">  A convenience layer that performs a convolution followed by a ReLU.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  Inputs:</span></span><br><span class="line"><span class="string">  - x: Input to the convolutional layer</span></span><br><span class="line"><span class="string">  - w, b, conv_param: Weights and parameters for the convolutional layer</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  Returns a tuple of:</span></span><br><span class="line"><span class="string">  - out: Output from the ReLU</span></span><br><span class="line"><span class="string">  - cache: Object to give to the backward pass</span></span><br><span class="line"><span class="string">  """</span></span><br><span class="line">  a, conv_cache = conv_forward_fast(x, w, b, conv_param)</span><br><span class="line">  out, relu_cache = relu_forward(a)</span><br><span class="line">  cache = (conv_cache, relu_cache)</span><br><span class="line">  <span class="keyword">return</span> out, cache</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conv_relu_backward</span><span class="params">(dout, cache)</span>:</span></span><br><span class="line">  <span class="string">"""</span></span><br><span class="line"><span class="string">  Backward pass for the conv-relu convenience layer.</span></span><br><span class="line"><span class="string">  """</span></span><br><span class="line">  conv_cache, relu_cache = cache</span><br><span class="line">  da = relu_backward(dout, relu_cache)</span><br><span class="line">  dx, dw, db = conv_backward_fast(da, conv_cache)</span><br><span class="line">  <span class="keyword">return</span> dx, dw, db</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conv_relu_pool_forward</span><span class="params">(x, w, b, conv_param, pool_param)</span>:</span></span><br><span class="line">  <span class="string">"""</span></span><br><span class="line"><span class="string">  Convenience layer that performs a convolution, a ReLU, and a pool.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  Inputs:</span></span><br><span class="line"><span class="string">  - x: Input to the convolutional layer</span></span><br><span class="line"><span class="string">  - w, b, conv_param: Weights and parameters for the convolutional layer</span></span><br><span class="line"><span class="string">  - pool_param: Parameters for the pooling layer</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  Returns a tuple of:</span></span><br><span class="line"><span class="string">  - out: Output from the pooling layer</span></span><br><span class="line"><span class="string">  - cache: Object to give to the backward pass</span></span><br><span class="line"><span class="string">  """</span></span><br><span class="line">  a, conv_cache = conv_forward_fast(x, w, b, conv_param)</span><br><span class="line">  s, relu_cache = relu_forward(a)</span><br><span class="line">  out, pool_cache = max_pool_forward_fast(s, pool_param)</span><br><span class="line">  cache = (conv_cache, relu_cache, pool_cache)</span><br><span class="line">  <span class="keyword">return</span> out, cache</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conv_relu_pool_backward</span><span class="params">(dout, cache)</span>:</span></span><br><span class="line">  <span class="string">"""</span></span><br><span class="line"><span class="string">  Backward pass for the conv-relu-pool convenience layer</span></span><br><span class="line"><span class="string">  """</span></span><br><span class="line">  conv_cache, relu_cache, pool_cache = cache</span><br><span class="line">  ds = max_pool_backward_fast(dout, pool_cache)</span><br><span class="line">  da = relu_backward(ds, relu_cache)</span><br><span class="line">  dx, dw, db = conv_backward_fast(da, conv_cache)</span><br><span class="line">  <span class="keyword">return</span> dx, dw, db</span><br></pre></td></tr></table></figure></p>
<h3 id="三层卷积神经网络"><a href="#三层卷积神经网络" class="headerlink" title="三层卷积神经网络"></a>三层卷积神经网络</h3><p>结合以上已经实现的层，构造一个简单的三层卷积神经网络,其结构如下所示：<br>conv - relu - 2x2 max pool - affine - relu - affine - softmax<br><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreeLayerConvNet</span>(<span class="title">object</span>):</span></span><br><span class="line">  <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">  A three-layer convolutional network with the following architecture:</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  conv - relu - 2x2 max pool - affine - relu - affine - softmax</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  The network operates on minibatches of data that have shape (N, C, H, W)</span></span><br><span class="line"><span class="string">  consisting of N images, each with height H and width W and with C input</span></span><br><span class="line"><span class="string">  channels.</span></span><br><span class="line"><span class="string">  "</span><span class="string">""</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, input_dim=(<span class="number">3</span>, <span class="number">32</span>, <span class="number">32</span>)</span></span>, num_filters=<span class="number">32</span>, filter_size=<span class="number">7</span>,</span><br><span class="line">               hidden_dim=<span class="number">100</span>, num_classes=<span class="number">10</span>, weight_scale=<span class="number">1</span>e-<span class="number">3</span>, reg=<span class="number">0</span>.<span class="number">0</span>,</span><br><span class="line">               dtype=np.float32)<span class="symbol">:</span></span><br><span class="line">    <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">    Initialize a new network.</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Inputs:</span></span><br><span class="line"><span class="string">    - input_dim: Tuple (C, H, W) giving size of input data</span></span><br><span class="line"><span class="string">    - num_filters: Number of filters to use in the convolutional layer</span></span><br><span class="line"><span class="string">    - filter_size: Size of filters to use in the convolutional layer</span></span><br><span class="line"><span class="string">    - hidden_dim: Number of units to use in the fully-connected hidden layer</span></span><br><span class="line"><span class="string">    - num_classes: Number of scores to produce from the final affine layer.</span></span><br><span class="line"><span class="string">    - weight_scale: Scalar giving standard deviation for random initialization</span></span><br><span class="line"><span class="string">      of weights.</span></span><br><span class="line"><span class="string">    - reg: Scalar giving L2 regularization strength</span></span><br><span class="line"><span class="string">    - dtype: numpy datatype to use for computation.</span></span><br><span class="line"><span class="string">    "</span><span class="string">""</span></span><br><span class="line">    <span class="keyword">self</span>.params = &#123;&#125;</span><br><span class="line">    <span class="keyword">self</span>.reg = reg</span><br><span class="line">    <span class="keyword">self</span>.dtype = dtype</span><br><span class="line">    </span><br><span class="line">    C, H, W = input_dim</span><br><span class="line">    <span class="keyword">self</span>.params[<span class="string">'W1'</span>] = weight_scale * np.random.randn(num_filters, C, filter_size, filter_size)</span><br><span class="line">    <span class="keyword">self</span>.params[<span class="string">'b1'</span>] = np.zeros(num_filters)</span><br><span class="line">    <span class="keyword">self</span>.params[<span class="string">'W2'</span>] = weight_scale * np.random.randn((H / <span class="number">2</span>)*(W / <span class="number">2</span>)*num_filters, hidden_dim)</span><br><span class="line">    <span class="keyword">self</span>.params[<span class="string">'b2'</span>] = np.zeros(hidden_dim)</span><br><span class="line">    <span class="keyword">self</span>.params[<span class="string">'W3'</span>] = weight_scale * np.random.randn(hidden_dim, num_classes)</span><br><span class="line">    <span class="keyword">self</span>.params[<span class="string">'b3'</span>] = np.zeros(num_classes)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="keyword">self</span>.params.iteritems()<span class="symbol">:</span></span><br><span class="line">      <span class="keyword">self</span>.params[k] = v.astype(dtype)</span><br><span class="line">     </span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">loss</span><span class="params">(<span class="keyword">self</span>, X, y=None)</span></span><span class="symbol">:</span></span><br><span class="line">    <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">    Evaluate loss and gradient for the three-layer convolutional network.</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Input / output: Same API as TwoLayerNet in fc_net.py.</span></span><br><span class="line"><span class="string">    "</span><span class="string">""</span></span><br><span class="line">    W1, b1 = <span class="keyword">self</span>.params[<span class="string">'W1'</span>], <span class="keyword">self</span>.params[<span class="string">'b1'</span>]</span><br><span class="line">    W2, b2 = <span class="keyword">self</span>.params[<span class="string">'W2'</span>], <span class="keyword">self</span>.params[<span class="string">'b2'</span>]</span><br><span class="line">    W3, b3 = <span class="keyword">self</span>.params[<span class="string">'W3'</span>], <span class="keyword">self</span>.params[<span class="string">'b3'</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># pass conv_param to the forward pass for the convolutional layer</span></span><br><span class="line">    filter_size = W1.shape[<span class="number">2</span>]</span><br><span class="line">    conv_param = &#123;<span class="string">'stride'</span>: <span class="number">1</span>, <span class="string">'pad'</span>: (filter_size - <span class="number">1</span>) / <span class="number">2</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># pass pool_param to the forward pass for the max-pooling layer</span></span><br><span class="line">    pool_param = &#123;<span class="string">'pool_height'</span>: <span class="number">2</span>, <span class="string">'pool_width'</span>: <span class="number">2</span>, <span class="string">'stride'</span>: <span class="number">2</span>&#125;</span><br><span class="line"></span><br><span class="line">    scores = None</span><br><span class="line">    <span class="comment">############################################################################</span></span><br><span class="line">    <span class="comment"># <span class="doctag">TODO:</span> Implement the forward pass for the three-layer convolutional net,  #</span></span><br><span class="line">    <span class="comment"># computing the class scores for X and storing them in the scores          #</span></span><br><span class="line">    <span class="comment"># variable.                                                                #</span></span><br><span class="line">    <span class="comment">############################################################################</span></span><br><span class="line">    conv_forward_out_1, cache_forward_1 = conv_relu_pool_forward(X, <span class="keyword">self</span>.params[<span class="string">'W1'</span>], <span class="keyword">self</span>.params[<span class="string">'b1'</span>], conv_param, pool_param)</span><br><span class="line">    affine_forward_out_2, cache_forward_2 = affine_forward(conv_forward_out_1, <span class="keyword">self</span>.params[<span class="string">'W2'</span>], <span class="keyword">self</span>.params[<span class="string">'b2'</span>])</span><br><span class="line">    affine_relu_2, cache_relu_2 = relu_forward(affine_forward_out_2)</span><br><span class="line">    scores, cache_forward_3 = affine_forward(affine_relu_2, <span class="keyword">self</span>.params[<span class="string">'W3'</span>], <span class="keyword">self</span>.params[<span class="string">'b3'</span>])</span><br><span class="line">    <span class="comment">############################################################################</span></span><br><span class="line">    <span class="comment">#                             END OF YOUR CODE                             #</span></span><br><span class="line">    <span class="comment">############################################################################</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> y is <span class="symbol">None:</span></span><br><span class="line">      <span class="keyword">return</span> scores</span><br><span class="line">    </span><br><span class="line">    loss, grads = <span class="number">0</span>, &#123;&#125;</span><br><span class="line">    <span class="comment">############################################################################</span></span><br><span class="line">    <span class="comment"># <span class="doctag">TODO:</span> Implement the backward pass for the three-layer convolutional net, #</span></span><br><span class="line">    <span class="comment"># storing the loss and gradients in the loss and grads variables. Compute  #</span></span><br><span class="line">    <span class="comment"># data loss using softmax, and make sure that grads[k] holds the gradients #</span></span><br><span class="line">    <span class="comment"># for self.params[k]. Don't forget to add L2 regularization!               #</span></span><br><span class="line">    <span class="comment">############################################################################</span></span><br><span class="line">    loss, dout = softmax_loss(scores, y)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Add regularization</span></span><br><span class="line">    loss += <span class="keyword">self</span>.reg * <span class="number">0</span>.<span class="number">5</span> * (np.sum(<span class="keyword">self</span>.params[<span class="string">'W1'</span>] ** <span class="number">2</span>) + np.sum(<span class="keyword">self</span>.params[<span class="string">'W2'</span>] ** <span class="number">2</span>) + np.sum(<span class="keyword">self</span>.params[<span class="string">'W1'</span>] ** <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">    dX3, grads[<span class="string">'W3'</span>], grads[<span class="string">'b3'</span>] = affine_backward(dout, cache_forward_3)</span><br><span class="line">    dX2 = relu_backward(dX3, cache_relu_2)</span><br><span class="line">    dX2, grads[<span class="string">'W2'</span>], grads[<span class="string">'b2'</span>] = affine_backward(dX2, cache_forward_2)</span><br><span class="line">    dX1, grads[<span class="string">'W1'</span>], grads[<span class="string">'b1'</span>] = conv_relu_pool_backward(dX2, cache_forward_1)</span><br><span class="line"></span><br><span class="line">    grads[<span class="string">'W3'</span>] = grads[<span class="string">'W3'</span>] + <span class="keyword">self</span>.reg * <span class="keyword">self</span>.params[<span class="string">'W3'</span>]</span><br><span class="line">    grads[<span class="string">'W2'</span>] = grads[<span class="string">'W2'</span>] + <span class="keyword">self</span>.reg * <span class="keyword">self</span>.params[<span class="string">'W2'</span>]</span><br><span class="line">    grads[<span class="string">'W1'</span>] = grads[<span class="string">'W1'</span>] + <span class="keyword">self</span>.reg * <span class="keyword">self</span>.params[<span class="string">'W1'</span>]</span><br><span class="line">    <span class="comment">############################################################################</span></span><br><span class="line">    <span class="comment">#                             END OF YOUR CODE                             #</span></span><br><span class="line">    <span class="comment">############################################################################</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> loss, grads</span><br></pre></td></tr></table></figure></p>
<h4 id="过拟合小数据"><a href="#过拟合小数据" class="headerlink" title="过拟合小数据"></a>过拟合小数据</h4><p>使用上面的三层卷积网络来过拟合一个较小的数据集，这将导致一个非常高的训练集准确度与一个较小的测试准确度。<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">num_train = 100</span><br><span class="line">small_data = &#123;</span><br><span class="line">  <span class="string">'X_train'</span>: data[<span class="string">'X_train'</span>][:num_train],</span><br><span class="line">  <span class="string">'y_train'</span>: data[<span class="string">'y_train'</span>][:num_train],</span><br><span class="line">  <span class="string">'X_val'</span>: data[<span class="string">'X_val'</span>],</span><br><span class="line">  <span class="string">'y_val'</span>: data[<span class="string">'y_val'</span>],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">model = ThreeLayerConvNet(<span class="attribute">weight_scale</span>=1e-2)</span><br><span class="line"></span><br><span class="line">solver = Solver(model, small_data,</span><br><span class="line">                <span class="attribute">num_epochs</span>=10, <span class="attribute">batch_size</span>=50,</span><br><span class="line">                <span class="attribute">update_rule</span>=<span class="string">'adam'</span>,</span><br><span class="line">                optim_config=&#123;</span><br><span class="line">                  <span class="string">'learning_rate'</span>: 1e-3,</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attribute">verbose</span>=<span class="literal">True</span>, <span class="attribute">print_every</span>=1)</span><br><span class="line">solver.train()</span><br></pre></td></tr></table></figure></p>
<p>上面的运行结果为：train acc: 0.880000; val_acc: 0.198000<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/cs231n/chapter3/p5.png" alt></p>
<h4 id="训练网络"><a href="#训练网络" class="headerlink" title="训练网络"></a>训练网络</h4><p>用大量数据集训练以上网络一个epoch，可以在训练集上得到超过40%的准确率<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">model = ThreeLayerConvNet(<span class="attribute">weight_scale</span>=0.001, <span class="attribute">hidden_dim</span>=500, <span class="attribute">reg</span>=0.001)</span><br><span class="line"></span><br><span class="line">solver = Solver(model, data,</span><br><span class="line">                <span class="attribute">num_epochs</span>=1, <span class="attribute">batch_size</span>=50,</span><br><span class="line">                <span class="attribute">update_rule</span>=<span class="string">'adam'</span>,</span><br><span class="line">                optim_config=&#123;</span><br><span class="line">                  <span class="string">'learning_rate'</span>: 1e-3,</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attribute">verbose</span>=<span class="literal">True</span>, <span class="attribute">print_every</span>=20)</span><br><span class="line">solver.train()</span><br></pre></td></tr></table></figure></p>
<p>准确率：(Epoch 1 / 1) train acc: 0.437000; val_acc: 0.478000</p>
<h4 id="可视化过滤器"><a href="#可视化过滤器" class="headerlink" title="可视化过滤器"></a>可视化过滤器</h4><p>我们可以可视化训练后的卷积层过滤器<br><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line"><span class="built_in">from</span> cs231n.vis_utils import visualize_grid</span><br><span class="line"></span><br><span class="line">grid = visualize_grid(model.<span class="built_in">params</span>[<span class="string">'W1'</span>].<span class="built_in">transpose</span>(<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>))</span><br><span class="line">plt.imshow(grid.astype(<span class="string">'uint8'</span>))</span><br><span class="line">plt.axis(<span class="string">'off'</span>)</span><br><span class="line">plt.gcf().set_size_inches(<span class="number">5</span>, <span class="number">5</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/cs231n/chapter3/p6.png" alt></p>
<h3 id="Spatial-Batch-Normalization"><a href="#Spatial-Batch-Normalization" class="headerlink" title="Spatial Batch Normalization"></a>Spatial Batch Normalization</h3><p>我们在前文中已经为全连接层实现了Bathch Normalization,BN也可以用在卷积层上，但也做出一点改变，变成Spatial Batch Normalization</p>
<p>BN层是对于每个神经元做归一化处理，甚至只需要对某一个神经元进行归一化，而不是对一整层网络的神经元进行归一化。既然BN是对单个神经元的运算，那么在CNN中卷积层上要怎么搞？假如某一层卷积层有6个特征图，每个特征图的大小是100<em>100，这样就相当于这一层网络有6</em>100<em>100个神经元，如果采用BN，就会有6</em>100<em>100个参数γ、β，这样岂不是太恐怖了。因此卷积层上的BN使用，其实也是使用了类似权值共享的策略，把一整张特征图当做一个神经元进行处理。<br>卷积神经网络经过卷积后得到的是一系列的特征图，如果min-batch sizes为m，那么网络某一层输入数据可以表示为四维矩阵(m,f,p,q)，m为min-batch sizes，f为特征图个数，p、q分别为特征图的宽高。在cnn中我们可以把每个特征图看成是一个特征处理（一个神经元），因此在使用Batch Normalization，mini-batch size 的大小就是：m</em>p*q，于是对于每个特征图都只有一对可学习参数：γ、β。说白了吧，这就是相当于求取所有样本所对应的一个特征图的所有神经元的平均值、方差，然后对这个特征图神经元做归一化。</p>
<p>Spatial batch normalization: forward<br><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">def spatial_batchnorm_forward(x, <span class="keyword">gamma</span>, beta, bn_param):</span><br><span class="line">  <span class="string">""</span>"</span><br><span class="line">  Computes the forward pass <span class="keyword">for</span> spatial batch normalization.</span><br><span class="line">  </span><br><span class="line">  Inputs:</span><br><span class="line">  - x: <span class="keyword">Input</span> data of shape (<span class="keyword">N</span>, C, <span class="keyword">H</span>, W)</span><br><span class="line">  - <span class="keyword">gamma</span>: Scale parameter, of shape (C,)</span><br><span class="line">  - beta: Shift parameter, of shape (C,)</span><br><span class="line">  - bn_param: Dictionary with the following keys:</span><br><span class="line">    - mode: 'train' or '<span class="keyword">test</span>'; required</span><br><span class="line">    - eps: Constant <span class="keyword">for</span> numeric stability</span><br><span class="line">    - momentum: Constant <span class="keyword">for</span> running <span class="keyword">mean</span> / variance. momentum=0 <span class="keyword">means</span> that</span><br><span class="line">      old information is discarded completely at every time step, <span class="keyword">while</span></span><br><span class="line">      momentum=1 <span class="keyword">means</span> that new information is never incorporated. The</span><br><span class="line">      default of momentum=0.9 should work well <span class="keyword">in</span> most situations.</span><br><span class="line">    - running_mean: Array of shape (<span class="keyword">D</span>,) giving running <span class="keyword">mean</span> of features</span><br><span class="line">    - running_var Array of shape (<span class="keyword">D</span>,) giving running variance of features</span><br><span class="line">    </span><br><span class="line">  Returns a tuple of:</span><br><span class="line">  - <span class="keyword">out</span>: Output data, of shape (<span class="keyword">N</span>, C, <span class="keyword">H</span>, W)</span><br><span class="line">  - cache: Values needed <span class="keyword">for</span> the backward pass</span><br><span class="line">  <span class="string">""</span>"</span><br><span class="line">  <span class="keyword">out</span>, cache = None, None</span><br><span class="line"></span><br><span class="line">  <span class="keyword">N</span>, C, <span class="keyword">H</span>, W = x.shape</span><br><span class="line">  temp_output, cache = batchnorm_forward(x.transpose(0,3,2,1).<span class="keyword">reshape</span>((<span class="keyword">N</span>*<span class="keyword">H</span>*W,C)), <span class="keyword">gamma</span>, beta, bn_param)</span><br><span class="line">  <span class="keyword">out</span> = temp_output.<span class="keyword">reshape</span>(<span class="keyword">N</span>,W,<span class="keyword">H</span>,C).transpose(0,3,2,1)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">out</span>, cache</span><br></pre></td></tr></table></figure></p>
<p>Spatial batch normalization: backward</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spatial_batchnorm_backward</span><span class="params">(dout, cache)</span>:</span></span><br><span class="line">  <span class="string">"""</span></span><br><span class="line"><span class="string">  Computes the backward pass for spatial batch normalization.</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  Inputs:</span></span><br><span class="line"><span class="string">  - dout: Upstream derivatives, of shape (N, C, H, W)</span></span><br><span class="line"><span class="string">  - cache: Values from the forward pass</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  Returns a tuple of:</span></span><br><span class="line"><span class="string">  - dx: Gradient with respect to inputs, of shape (N, C, H, W)</span></span><br><span class="line"><span class="string">  - dgamma: Gradient with respect to scale parameter, of shape (C,)</span></span><br><span class="line"><span class="string">  - dbeta: Gradient with respect to shift parameter, of shape (C,)</span></span><br><span class="line"><span class="string">  """</span></span><br><span class="line">  dx, dgamma, dbeta = <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">  N,C,H,W = dout.shape</span><br><span class="line">  dx_temp, dgamma, dbeta = batchnorm_backward_alt(dout.transpose(<span class="number">0</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>).reshape((N*H*W,C)),cache)</span><br><span class="line">  dx = dx_temp.reshape(N,W,H,C).transpose(<span class="number">0</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dx, dgamma, dbeta</span><br></pre></td></tr></table></figure>
<h3 id="训练最好的ConvNet"><a href="#训练最好的ConvNet" class="headerlink" title="训练最好的ConvNet"></a>训练最好的ConvNet</h3><h4 id="Things-you-should-try"><a href="#Things-you-should-try" class="headerlink" title="Things you should try:"></a>Things you should try:</h4><ul>
<li>Filter size: Above we used 7x7; this makes pretty pictures but smaller filters may be more efficient</li>
<li>Number of filters: Above we used 32 filters. Do more or fewer do better?</li>
<li>Batch normalization: Try adding spatial batch normalization after convolution layers and vanilla batch normalization aafter affine layers. Do your networks train faster?</li>
<li>Network architecture: The network above has two layers of trainable parameters. Can you do better with a deeper network? You can implement alternative architectures in the file cs231n/classifiers/convnet.py. Some good architectures to try include:<ul>
<li>[conv-relu-pool]xN - conv - relu - [affine]xM - [softmax or SVM]</li>
<li>[conv-relu-pool]XN - [affine]XM - [softmax or SVM]</li>
<li>[conv-relu-conv-relu-pool]xN - [affine]xM - [softmax or SVM]</li>
</ul>
</li>
</ul>
<h4 id="Tips-for-training"><a href="#Tips-for-training" class="headerlink" title="Tips for training"></a>Tips for training</h4><p>For each network architecture that you try, you should tune the learning rate and regularization strength. When doing this there are a couple important things to keep in mind:</p>
<ul>
<li>If the parameters are working well, you should see improvement within a few hundred iterations</li>
<li>Remember the course-to-fine approach for hyperparameter tuning: start by testing a large range of hyperparameters for just a few training iterations to find the combinations of parameters that are working at all.</li>
<li>Once you have found some sets of parameters that seem to work, search more finely around these parameters. You may need to train for more epochs.</li>
</ul>
<h4 id="训练代码"><a href="#训练代码" class="headerlink" title="训练代码"></a>训练代码</h4><p>尝试一<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Train a really good model on CIFAR-10</span></span><br><span class="line"></span><br><span class="line">model = ThreeLayerConvNet(<span class="attribute">weight_scale</span>=0.001, <span class="attribute">hidden_dim</span>=500, <span class="attribute">reg</span>=0.001)</span><br><span class="line"></span><br><span class="line">solver = Solver(model, data,</span><br><span class="line">                <span class="attribute">num_epochs</span>=5, <span class="attribute">batch_size</span>=100,</span><br><span class="line">                <span class="attribute">update_rule</span>=<span class="string">'adam'</span>,</span><br><span class="line">                optim_config=&#123;</span><br><span class="line">                  <span class="string">'learning_rate'</span>: 1e-3,</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attribute">verbose</span>=<span class="literal">True</span>, <span class="attribute">print_every</span>=50)</span><br><span class="line">solver.train()</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> cs231n.vis_utils import visualize_grid</span><br><span class="line"></span><br><span class="line">grid = visualize_grid(model.params[<span class="string">'W1'</span>].transpose(0, 2, 3, 1))</span><br><span class="line">plt.imshow(grid.astype(<span class="string">'uint8'</span>))</span><br><span class="line">plt.axis(<span class="string">'off'</span>)</span><br><span class="line">plt.gcf().set_size_inches(5, 5)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p>
<p>准确度：(Epoch 5 / 5) train acc: 0.649000; val_acc: 0.620000<br>过滤器可视化如下：<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/cs231n/chapter3/p7.png" alt></p>
<p>尝试二<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Train a really good model on CIFAR-10</span></span><br><span class="line">model = ThreeLayerConvNet(<span class="attribute">weight_scale</span>=0.001, <span class="attribute">num_filters</span>=100, <span class="attribute">hidden_dim</span>=800, <span class="attribute">reg</span>=0.003)</span><br><span class="line"></span><br><span class="line">solver = Solver(model, data,</span><br><span class="line">                <span class="attribute">num_epochs</span>=7, <span class="attribute">batch_size</span>=100,</span><br><span class="line">                <span class="attribute">update_rule</span>=<span class="string">'adam'</span>,</span><br><span class="line">                optim_config=&#123;</span><br><span class="line">                  <span class="string">'learning_rate'</span>: 3e-4, </span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attribute">verbose</span>=<span class="literal">True</span>, <span class="attribute">print_every</span>=30)</span><br><span class="line">solver.train()</span><br><span class="line"><span class="keyword">from</span> cs231n.vis_utils import visualize_grid</span><br><span class="line"></span><br><span class="line">grid = visualize_grid(model.params[<span class="string">'W1'</span>].transpose(0, 2, 3, 1))</span><br><span class="line">plt.imshow(grid.astype(<span class="string">'uint8'</span>))</span><br><span class="line">plt.axis(<span class="string">'off'</span>)</span><br><span class="line">plt.gcf().set_size_inches(5, 5)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p>
<p>准确率：(Epoch 7 / 7) train acc: 0.766000; val_acc: 0.649000<br>过滤器可视化如下：<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/cs231n/chapter3/p8.png" alt></p>
<p>训练过程中loss与Accuracy变化如下：<br><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">plt</span><span class="selector-class">.subplot</span>(<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"><span class="selector-tag">plt</span><span class="selector-class">.plot</span>(solver.loss_history, <span class="string">'o'</span>)</span><br><span class="line"><span class="selector-tag">plt</span><span class="selector-class">.xlabel</span>(<span class="string">'iteration'</span>)</span><br><span class="line"><span class="selector-tag">plt</span><span class="selector-class">.ylabel</span>(<span class="string">'loss'</span>)</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">plt</span><span class="selector-class">.subplot</span>(<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="selector-tag">plt</span><span class="selector-class">.plot</span>(solver.train_acc_history, <span class="string">'-o'</span>)</span><br><span class="line"><span class="selector-tag">plt</span><span class="selector-class">.plot</span>(solver.val_acc_history, <span class="string">'-o'</span>)</span><br><span class="line"><span class="selector-tag">plt</span><span class="selector-class">.legend</span>([<span class="string">'train'</span>, <span class="string">'val'</span>], loc=<span class="string">'upper left'</span>)</span><br><span class="line"><span class="selector-tag">plt</span><span class="selector-class">.xlabel</span>(<span class="string">'epoch'</span>)</span><br><span class="line"><span class="selector-tag">plt</span><span class="selector-class">.ylabel</span>(<span class="string">'accuracy'</span>)</span><br><span class="line"><span class="selector-tag">plt</span><span class="selector-class">.show</span>()</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/cs231n/chapter3/p9.png" alt><br>可以看到训练准确率最终达到了76%以上，validation准确率在64%左右。</p>
]]></content>
      <tags>
        <tag>计算机视觉</tag>
      </tags>
  </entry>
  <entry>
    <title>循环神经网络学习</title>
    <url>/blog/2017/05/recurrent-neural-network.html</url>
    <content><![CDATA[<h3 id="RNN简介"><a href="#RNN简介" class="headerlink" title="RNN简介"></a>RNN简介</h3><p>在前文我们介绍了全连接神经网络和卷积神经网络，以及它们的训练和使用。他们都只能单独的取处理一个个的输入，前一个输入和后一个输入是完全没有关系的。但是，某些任务需要能够更好的处理序列的信息，即前面的输入和后面的输入是有关系的。比如，当我们在理解一句话意思时，孤立的理解这句话的每个词是不够的，我们需要处理这些词连接起来的整个序列；当我们处理视频的时候，我们也不能只单独的去分析每一帧，而要分析这些帧连接起来的整个序列。这时，就需要用到深度学习领域中另一类非常重要神经网络：循环神经网络(Recurrent Neural Network)。</p>
<h3 id="语言模型"><a href="#语言模型" class="headerlink" title="语言模型"></a>语言模型</h3><p>RNN是在自然语言处理领域中最先被用起来的，比如，RNN可以为语言模型来建模。那么，什么是语言模型呢？</p>
<p>我们可以和电脑玩一个游戏，我们写出一个句子前面的一些词，然后，让电脑帮我们写下接下来的一个词。比如下面这句：</p>
<blockquote>
<p>我昨天上学迟到了，老师批评了____。</p>
</blockquote>
<p>我们给电脑展示了这句话前面这些词，然后，让电脑写下接下来的一个词。在这个例子中，接下来的这个词最有可能是『我』，而不太可能是『小明』，甚至是『吃饭』。</p>
<p>语言模型就是这样的东西：给定一个一句话前面的部分，预测接下来最有可能的一个词是什么。</p>
<p>语言模型是对一种语言的特征进行建模，它有很多很多用处。比如在语音转文本(STT)的应用中，声学模型输出的结果，往往是若干个可能的候选词，这时候就需要语言模型来从这些候选词中选择一个最可能的。当然，它同样也可以用在图像到文本的识别中(OCR)。</p>
<p>使用RNN之前，语言模型主要是采用N-Gram。N可以是一个自然数，比如2或者3。它的含义是，假设一个词出现的概率只与前面N个词相关。我们以2-Gram为例。首先，对前面的一句话进行切词：</p>
<blockquote>
<p>我 昨天 上学 迟到 了 ，老师 批评 了 ____。</p>
</blockquote>
<p>如果用2-Gram进行建模，那么电脑在预测的时候，只会看到前面的『了』，然后，电脑会在语料库中，搜索『了』后面最可能的一个词。不管最后电脑选的是不是『我』，我们都知道这个模型是不靠谱的，因为『了』前面说了那么一大堆实际上是没有用到的。如果是3-Gram模型呢，会搜索『批评了』后面最可能的词，感觉上比2-Gram靠谱了不少，但还是远远不够的。因为这句话最关键的信息『我』，远在9个词之前！</p>
<p>现在读者可能会想，可以提升继续提升N的值呀，比如4-Gram、5-Gram…….。实际上，这个想法是没有实用性的。因为我们想处理任意长度的句子，N设为多少都不合适；另外，模型的大小和N的关系是指数级的，4-Gram模型就会占用海量的存储空间。</p>
<p>所以，该轮到RNN出场了，RNN理论上可以往前看(往后看)任意多个词。</p>
<h3 id="循环神经网络分类"><a href="#循环神经网络分类" class="headerlink" title="循环神经网络分类"></a>循环神经网络分类</h3><h4 id="基本循环神经网络"><a href="#基本循环神经网络" class="headerlink" title="基本循环神经网络"></a>基本循环神经网络</h4><p>下图是一个简单的循环神经网络如，它由输入层、一个隐藏层和一个输出层组成：<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/cs231n/chapter4/p3.jpg" alt><br>在这里，x是一个向量，它表示输入层的值（这里面没有画出来表示神经元节点的圆圈）；s是一个向量，它表示隐藏层的值（这里隐藏层面画了一个节点，你也可以想象这一层其实是多个节点，节点数与向量s的维度相同）；U是输入层到隐藏层的权重矩阵。o也是一个向量，它表示输出层的值；V是隐藏层到输出层的权重矩阵。那么，现在我们来看看W是什么。循环神经网络的隐藏层的值s不仅仅取决于当前这次的输入x，还取决于上一次隐藏层的值s。权重矩阵 W就是隐藏层上一次的值作为这一次的输入的权重。<br>如果我们把上面的图展开，循环神经网络也可以画成下面这个样子：<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/cs231n/chapter4/p4.jpg" alt><br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/cs231n/chapter4/p1.png" alt><br>从上面的公式我们可以看出，循环层和全连接层的区别就是循环层多了一个权重矩阵 W<br>如果反复把式2带入到式1，我们将得到：<br>$$<br>\begin{align}<br>\mathrm{o}_t&amp;=g(V\mathrm{s}_t)\<br>&amp;=Vf(U\mathrm{x}<em>t+W\mathrm{s}</em>{t-1})\<br>&amp;=Vf(U\mathrm{x}<em>t+Wf(U\mathrm{x}</em>{t-1}+W\mathrm{s}_{t-2}))\<br>&amp;=Vf(U\mathrm{x}<em>t+Wf(U\mathrm{x}</em>{t-1}+Wf(U\mathrm{x}<em>{t-2}+W\mathrm{s}</em>{t-3})))\<br>&amp;=Vf(U\mathrm{x}<em>t+Wf(U\mathrm{x}</em>{t-1}+Wf(U\mathrm{x}<em>{t-2}+Wf(U\mathrm{x}</em>{t-3}+…))))<br>\end{align}<br>$$</p>
<p>从上面可以看出，循环神经网络的输出值$O_t$，是受前面历次输入值$X_t$、$X_{t-1}$、$X_{t-2}$、$X_{t-3}$、…影响的，这就是为什么循环神经网络可以往前看任意多个输入值的原因。</p>
<h4 id="双向循环神经网络"><a href="#双向循环神经网络" class="headerlink" title="双向循环神经网络"></a>双向循环神经网络</h4><p>对于语言模型来说，很多时候光看前面的词是不够的，比如下面这句话：</p>
<blockquote>
<p>我的手机坏了，我打算____一部新手机。</p>
</blockquote>
<p>可以想象，如果我们只看横线前面的词，手机坏了，那么我是打算修一修？换一部新的？还是大哭一场？这些都是无法确定的。但如果我们也看到了横线后面的词是『一部新手机』，那么，横线上的词填『买』的概率就大得多了。</p>
<p>在上一小节中的基本循环神经网络是无法对此进行建模的，因此，我们需要双向循环神经网络，如下图所示：<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/cs231n/chapter4/p2.png" alt><br>当遇到这种从未来穿越回来的场景时，难免处于懵逼的状态。不过我们还是可以用屡试不爽的老办法：先分析一个特殊场景，然后再总结一般规律。我们先考虑上图中$y_2$的计算。<br>从上图可以看出，双向卷积神经网络的隐藏层要保存两个值，一个A参与正向计算，另一个值A’参与反向计算。最终的输出值$y_2$取决于$A_2$和$A_2^{‘}$。其计算方法为：<br>$$<br>\mathrm{y}_2=g(VA_2+V’A_2’)<br>$$<br>$A_2$和$A_2^{‘}$则分别计算：<br>$$<br>\begin{align}<br>A_2&amp;=f(WA_1+U\mathrm{x}_2)\<br>A_2’&amp;=f(W’A_3’+U’\mathrm{x}_2)\<br>\end{align}<br>$$<br>现在，我们已经可以看出一般的规律：正向计算时，隐藏层的值$S_t$与$S_{t-1}$有关；反向计算时，隐藏层的值$S_{t}^{‘}$与$S_{t+1}^{‘}$有关；最终的输出取决于正向和反向计算的加和。现在，我们仿照式1和式2，写出双向循环神经网络的计算方法：<br>$$<br>\begin{align}<br>\mathrm{o}_t&amp;=g(V\mathrm{s}_t+V’\mathrm{s}_t’)\<br>\mathrm{s}_t&amp;=f(U\mathrm{x}<em>t+W\mathrm{s}</em>{t-1})\<br>\mathrm{s}_t’&amp;=f(U’\mathrm{x}<em>t+W’\mathrm{s}</em>{t+1}’)\<br>\end{align}<br>$$</p>
<p>从上面三个公式我们可以看到，正向计算和反向计算不共享权重，也就是说U和U’、W和W’、V和V’都是不同的权重矩阵。</p>
<h4 id="深度循环神经网络"><a href="#深度循环神经网络" class="headerlink" title="深度循环神经网络"></a>深度循环神经网络</h4><p>前面我们介绍的循环神经网络只有一个隐藏层，我们当然也可以堆叠两个以上的隐藏层，这样就得到了深度循环神经网络。如下图所示：<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/cs231n/chapter4/p3.png" alt><br>我们把第i个隐藏层的值表示为$\mathrm{s}_t^{(i)}$、$\mathrm{s}_t’^{(i)}$，则深度循环神经网络的计算方式可以表示为：<br>$$<br>\begin{align}<br>\mathrm{o}_t&amp;=g(V^{(i)}\mathrm{s}_t^{(i)}+V’^{(i)}\mathrm{s}_t’^{(i)})\<br>\mathrm{s}_t^{(i)}&amp;=f(U^{(i)}\mathrm{s}<em>t^{(i-1)}+W^{(i)}\mathrm{s}</em>{t-1})\<br>\mathrm{s}_t’^{(i)}&amp;=f(U’^{(i)}\mathrm{s}<em>t’^{(i-1)}+W’^{(i)}\mathrm{s}</em>{t+1}’)\<br>…\<br>\mathrm{s}_t^{(1)}&amp;=f(U^{(1)}\mathrm{x}<em>t+W^{(1)}\mathrm{s}</em>{t-1})\<br>\mathrm{s}_t’^{(1)}&amp;=f(U’^{(1)}\mathrm{x}<em>t+W’^{(1)}\mathrm{s}</em>{t+1}’)\<br>\end{align}<br>$$</p>
<h3 id="循环神经网络的训练"><a href="#循环神经网络的训练" class="headerlink" title="循环神经网络的训练"></a>循环神经网络的训练</h3><h4 id="循环神经网络的训练算法：BPTT"><a href="#循环神经网络的训练算法：BPTT" class="headerlink" title="循环神经网络的训练算法：BPTT"></a>循环神经网络的训练算法：BPTT</h4><p>BPTT算法是针对循环层的训练算法，它的基本原理和BP算法是一样的，也包含同样的三个步骤：</p>
<p>1.前向计算每个神经元的输出值；<br>2.反向计算每个神经元的误差项$\delta_j$值，它是误差函数E对神经元j的加权输入$net_j$的偏导数；<br>3.计算每个权重的梯度。<br>最后再用随机梯度下降算法更新权重。</p>
<p>循环层如下图所示：<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/cs231n/chapter4/p4.png" alt></p>
<h5 id="前向计算"><a href="#前向计算" class="headerlink" title="前向计算"></a>前向计算</h5><p>使用前面的式2对循环层进行前向计算：<br>$$<br>\mathrm{s}_t=f(U\mathrm{x}<em>t+W\mathrm{s}</em>{t-1})<br>$$<br>注意，上面的$S_t$、$X_t$、$S_{t-1}$都是向量，用黑体字母表示；而U、V是矩阵，用大写字母表示。向量的下标表示时刻，例如，$S_t$表示在t时刻向量s的值。<br>我们假设输入向量x的维度是m，输出向量s的维度是n，则矩阵U的维度是$n\times m$，矩阵W的维度是$n\times n$。下面是上式展开成矩阵的样子，看起来更直观一些：<br>$$<br>\begin{align}<br>\begin{bmatrix}<br>s_1^t\<br>s_2^t\<br>.\.\<br>s_n^t\<br>\end{bmatrix}=f(<br>\begin{bmatrix}<br>u_{11} u_{12} … u_{1m}\<br>u_{21} u_{22} … u_{2m}\<br>.\.\<br>u_{n1} u_{n2} … u_{nm}\<br>\end{bmatrix}<br>\begin{bmatrix}<br>x_1\<br>x_2\<br>.\.\<br>x_m\<br>\end{bmatrix}+<br>\begin{bmatrix}<br>w_{11} w_{12} … w_{1n}\<br>w_{21} w_{22} … w_{2n}\<br>.\.\<br>w_{n1} w_{n2} … w_{nn}\<br>\end{bmatrix}<br>\begin{bmatrix}<br>s_1^{t-1}\<br>s_2^{t-1}\<br>.\.\<br>s_n^{t-1}\<br>\end{bmatrix})<br>\end{align}<br>$$</p>
<p>在这里我们用手写体字母表示向量的一个元素，它的下标表示它是这个向量的第几个元素，它的上标表示第几个时刻。例如，$s_j^t$表示向量s的第j个元素在t时刻的值。$u_{ji}$表示输入层第i个神经元到循环层第j个神经元的权重。$w_{ji}$表示循环层第t-1时刻的第i个神经元到循环层第t个时刻的第j个神经元的权重。</p>
<h5 id="误差项的计算"><a href="#误差项的计算" class="headerlink" title="误差项的计算"></a>误差项的计算</h5><p>BTPP算法将第l层t时刻的误差项值$\delta_t^l$沿两个方向传播，一个方向是其传递到上一层网络，得到\delta_t^{l-1}，这部分只和权重矩阵U有关；另一个是方向是将其沿时间线传递到初始$t_1$时刻，得到$\delta_1^l$，这部分只和权重矩阵W有关<br>我们用向量$net_t$表示神经元在t时刻的加权输入，因为：<br>$$<br>\begin{align}<br>\mathrm{net}_t&amp;=U\mathrm{x}<em>t+W\mathrm{s}</em>{t-1}\<br>\mathrm{s}<em>{t-1}&amp;=f(\mathrm{net}</em>{t-1})\<br>\end{align}<br>$$<br>因此<br>$$<br>\begin{align}<br>\frac{\partial{\mathrm{net}<em>t}}{\partial{\mathrm{net}</em>{t-1}}}&amp;=\frac{\partial{\mathrm{net}<em>t}}{\partial{\mathrm{s}</em>{t-1}}}\frac{\partial{\mathrm{s}<em>{t-1}}}{\partial{\mathrm{net}</em>{t-1}}}\<br>\end{align}<br>$$<br>我们用a表示列向量，用$a^T$表示行向量。上式的第一项是向量函数对向量求导，其结果为Jacobian矩阵：<br>$$<br>\begin{align}<br>\frac{\partial{\mathrm{net}<em>t}}{\partial{\mathrm{s}</em>{t-1}}}&amp;=<br>\begin{bmatrix}<br>\frac{\partial{net_1^t}}{\partial{s_1^{t-1}}}&amp; \frac{\partial{net_1^t}}{\partial{s_2^{t-1}}}&amp; …&amp;  \frac{\partial{net_1^t}}{\partial{s_n^{t-1}}}\<br>\frac{\partial{net_2^t}}{\partial{s_1^{t-1}}}&amp; \frac{\partial{net_2^t}}{\partial{s_2^{t-1}}}&amp; …&amp;  \frac{\partial{net_2^t}}{\partial{s_n^{t-1}}}\<br>&amp;.\&amp;.\<br>\frac{\partial{net_n^t}}{\partial{s_1^{t-1}}}&amp; \frac{\partial{net_n^t}}{\partial{s_2^{t-1}}}&amp; …&amp;  \frac{\partial{net_n^t}}{\partial{s_n^{t-1}}}\<br>\end{bmatrix}\<br>&amp;=\begin{bmatrix}<br>w_{11} &amp; w_{12} &amp; … &amp; w_{1n}\<br>w_{21} &amp; w_{22} &amp; … &amp; w_{2n}\<br>&amp;.\&amp;.\<br>w_{n1} &amp; w_{n2} &amp; … &amp; w_{nn}\<br>\end{bmatrix}\<br>&amp;=W<br>\end{align}<br>$$<br>同理，上式第二项也是一个Jacobian矩阵：<br>$$<br>\begin{align}<br>\frac{\partial{\mathrm{s}<em>{t-1}}}{\partial{\mathrm{net}</em>{t-1}}}&amp;=<br>\begin{bmatrix}<br>\frac{\partial{s_1^{t-1}}}{\partial{net_1^{t-1}}}&amp; \frac{\partial{s_1^{t-1}}}{\partial{net_2^{t-1}}}&amp; …&amp;  \frac{\partial{s_1^{t-1}}}{\partial{net_n^{t-1}}}\<br>\frac{\partial{s_2^{t-1}}}{\partial{net_1^{t-1}}}&amp; \frac{\partial{s_2^{t-1}}}{\partial{net_2^{t-1}}}&amp; …&amp;  \frac{\partial{s_2^{t-1}}}{\partial{net_n^{t-1}}}\<br>&amp;.\&amp;.\<br>\frac{\partial{s_n^{t-1}}}{\partial{net_1^{t-1}}}&amp; \frac{\partial{s_n^{t-1}}}{\partial{net_2^{t-1}}}&amp; …&amp;  \frac{\partial{s_n^{t-1}}}{\partial{net_n^{t-1}}}\<br>\end{bmatrix}\<br>&amp;=\begin{bmatrix}<br>f’(net_1^{t-1}) &amp; 0 &amp; … &amp; 0\<br>0 &amp; f’(net_2^{t-1}) &amp; … &amp; 0\<br>&amp;.\&amp;.\<br>0 &amp; 0 &amp; … &amp; f’(net_n^{t-1})\<br>\end{bmatrix}\<br>&amp;=diag[f’(\mathrm{net}_{t-1})]<br>\end{align}<br>$$<br>其中，diag[a]表示根据向量a创建一个对角矩阵，即<br>$$<br>diag(\mathrm{a})=\begin{bmatrix}<br>a_1 &amp; 0 &amp; … &amp; 0\<br>0 &amp; a_2 &amp; … &amp; 0\<br>&amp;.\&amp;.\<br>0 &amp; 0 &amp; … &amp; a_n\<br>\end{bmatrix}\<br>$$<br>最后，将两项合在一起，可得：<br>$$<br>\begin{align}<br>\frac{\partial{\mathrm{net}<em>t}}{\partial{\mathrm{net}</em>{t-1}}}&amp;=\frac{\partial{\mathrm{net}<em>t}}{\partial{\mathrm{s}</em>{t-1}}}\frac{\partial{\mathrm{s}<em>{t-1}}}{\partial{\mathrm{net}</em>{t-1}}}\<br>&amp;=Wdiag[f’(\mathrm{net}<em>{t-1})]\<br>&amp;=\begin{bmatrix}<br>w</em>{11}f’(net_1^{t-1}) &amp; w_{12}f’(net_2^{t-1}) &amp; … &amp; w_{1n}f(net_n^{t-1})\<br>w_{21}f’(net_1^{t-1}) &amp; w_{22} f’(net_2^{t-1}) &amp; … &amp; w_{2n}f(net_n^{t-1})\<br>&amp;.\&amp;.\<br>w_{n1}f’(net_1^{t-1}) &amp; w_{n2} f’(net_2^{t-1}) &amp; … &amp; w_{nn} f’(net_n^{t-1})\<br>\end{bmatrix}\<br>\end{align}<br>$$<br>上式描述了将$\delta$沿时间往前传递一个时刻的规律，有了这个规律，我们就可以求得任意时刻k的误差项$\delta_k$：<br>$$<br>\begin{align}<br>\delta_k^T=&amp;\frac{\partial{E}}{\partial{\mathrm{net}_k}}\<br>=&amp;\frac{\partial{E}}{\partial{\mathrm{net}_t}}\frac{\partial{\mathrm{net}_t}}{\partial{\mathrm{net}_k}}\<br>=&amp;\frac{\partial{E}}{\partial{\mathrm{net}_t}}\frac{\partial{\mathrm{net}<em>t}}{\partial{\mathrm{net}</em>{t-1}}}\frac{\partial{\mathrm{net}<em>{t-1}}}{\partial{\mathrm{net}</em>{t-2}}}…\frac{\partial{\mathrm{net}<em>{k+1}}}{\partial{\mathrm{net}</em>{k}}}\<br>=&amp;Wdiag[f’(\mathrm{net}<em>{t-1})]<br>Wdiag[f’(\mathrm{net}</em>{t-2})]<br>…<br>Wdiag[f’(\mathrm{net}_{k})]<br>\delta_t^l\<br>=&amp;\delta_t^T\prod_{i=k}^{t-1}Wdiag[f’(\mathrm{net}_{i})]\qquad(式3)<br>\end{align}<br>$$</p>
<p>式3就是将误差项沿时间反向传播的算法。</p>
<p>循环层将误差项反向传递到上一层网络，与普通的全连接层是完全一样的，这在前面的文章<a href="https://www.zybuluo.com/hanbingtao/note/476663" target="_blank" rel="noopener">零基础入门深度学习(3) - 神经网络和反向传播算法</a>中已经详细讲过了，在此仅简要描述一下。<br>循环层的加权输入$net^l$与上一层的加权输入$net^{l-1}$关系如下：<br>$$<br>\begin{align}<br>\mathrm{net}_t^l=&amp;U\mathrm{a}<em>t^{l-1}+W\mathrm{s}</em>{t-1}\<br>\mathrm{a}_t^{l-1}=&amp;f^{l-1}(\mathrm{net}_t^{l-1})<br>\end{align}<br>$$<br>上式中\mathrm{net}_t^l是第l层神经元的加权输入(假设第l层是循环层)；$\mathrm{net}_t^{l-1}$是第l-1层神经元的加权输入；$\mathrm{a}_t^{l-1}$是第l-1层神经元的输出；$f^{l-1}$是第l-1层的激活函数。<br>$$<br>\begin{align}<br>\frac{\partial{\mathrm{net}_t^l}}{\partial{\mathrm{net}_t^{l-1}}}=&amp;\frac{\partial{\mathrm{net}^l}}{\partial{\mathrm{a}_t^{l-1}}}\frac{\partial{\mathrm{a}_t^{l-1}}}{\partial{\mathrm{net}_t^{l-1}}}\<br>=&amp;Udiag[f’^{l-1}(\mathrm{net}_t^{l-1})]<br>\end{align}<br>$$<br>所以，<br>$$<br>\begin{align}<br>(\delta_t^{l-1})^T=&amp;\frac{\partial{E}}{\partial{\mathrm{net}_t^{l-1}}}\<br>=&amp;\frac{\partial{E}}{\partial{\mathrm{net}_t^l}}\frac{\partial{\mathrm{net}_t^l}}{\partial{\mathrm{net}_t^{l-1}}}\<br>=&amp;(\delta_t^l)^TUdiag[f’^{l-1}(\mathrm{net}_t^{l-1})]\qquad(式4)<br>\end{align}<br>$$<br>式4就是将误差项传递到上一层算法。</p>
<h5 id="权重梯度的计算"><a href="#权重梯度的计算" class="headerlink" title="权重梯度的计算"></a>权重梯度的计算</h5><p>现在，我们终于来到了BPTT算法的最后一步：计算每个权重的梯度。</p>
<p>首先，我们计算误差函数E对权重矩阵W的梯度$\frac{\partial{E}}{\partial{W}}$。<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/cs231n/chapter4/p5.png" alt><br>上图展示了我们到目前为止，在前两步中已经计算得到的量，包括每个时刻t 循环层的输出值$S_t$，以及误差项$\delta_t$。<br>回忆一下我们在文章<a href="https://www.zybuluo.com/hanbingtao/note/476663" target="_blank" rel="noopener">零基础入门深度学习(3) - 神经网络和反向传播算法</a>介绍的全连接网络的权重梯度计算算法：只要知道了任意一个时刻的误差项$\delta_t$，以及上一个时刻循环层的输出值$\mathrm{s}<em>{t-1}$，就可以按照下面的公式求出权重矩阵在t时刻的梯度$\nabla</em>{Wt}E$<br>$$<br>\nabla_{W_t}E=\begin{bmatrix}<br>\delta_1^ts_1^{t-1} &amp; \delta_1^ts_2^{t-1} &amp; … &amp;  \delta_1^ts_n^{t-1}\<br>\delta_2^ts_1^{t-1} &amp; \delta_2^ts_2^{t-1} &amp; … &amp;  \delta_2^ts_n^{t-1}\<br>.\.\<br>\delta_n^ts_1^{t-1} &amp; \delta_n^ts_2^{t-1} &amp; … &amp;  \delta_n^ts_n^{t-1}\<br>\end{bmatrix}\qquad(式5)<br>$$<br>在式5中，$\delta_i^t$表示t时刻误差项向量的第i个分量；$s_i^{t-1}$表示t-1时刻循环层第i个神经元的输出值。</p>
<p>我们下面可以简单推导一下式5。</p>
<p>我们知道：<br>$$<br>\begin{align}<br>\mathrm{net}_t=&amp;U\mathrm{x}<em>t+W\mathrm{s}</em>{t-1}\<br>\begin{bmatrix}<br>net_1^t\<br>net_2^t\<br>.\.\<br>net_n^t\<br>\end{bmatrix}=&amp;U\mathrm{x}<em>t+<br>\begin{bmatrix}<br>w</em>{11} &amp; w_{12} &amp; … &amp; w_{1n}\<br>w_{21} &amp; w_{22} &amp; … &amp; w_{2n}\<br>.\.\<br>w_{n1} &amp; w_{n2} &amp; … &amp; w_{nn}\<br>\end{bmatrix}<br>\begin{bmatrix}<br>s_1^{t-1}\<br>s_2^{t-1}\<br>.\.\<br>s_n^{t-1}\<br>\end{bmatrix}\<br>=&amp;U\mathrm{x}<em>t+<br>\begin{bmatrix}<br>w</em>{11}s_1^{t-1}+w_{12}s_2^{t-1}…w_{1n}s_n^{t-1}\<br>w_{21}s_1^{t-1}+w_{22}s_2^{t-1}…w_{2n}s_n^{t-1}\<br>.\.\<br>w_{n1}s_1^{t-1}+w_{n2}s_2^{t-1}…w_{nn}s_n^{t-1}\<br>\end{bmatrix}\<br>\end{align}<br>$$<br>因为对W求导与$U\mathrm{x}<em>t$无关，我们不再考虑。现在，我们考虑对权重项$w</em>{ji}$求导。通过观察上式我们可以看到$w_{ji}$只与$net_j^t$有关，所以：<br>$$<br>\begin{align}<br>\frac{\partial{E}}{\partial{w_{ji}}}=&amp;\frac{\partial{E}}{\partial{net_j^t}}\frac{\partial{net_j^t}}{\partial{w_{ji}}}\<br>=&amp;\delta_j^ts_i^{t-1}<br>\end{align}<br>$$<br>按照上面的规律就可以生成式5里面的矩阵。</p>
<p>我们已经求得了权重矩阵W在t时刻的梯度$\nabla_{Wt}E$，最终的梯度$\nabla_{Wt}E$是各个时刻的梯度之和<br>$$<br>\begin{align}<br>\nabla_WE=&amp;\sum_{i=1}^t\nabla_{W_i}E\<br>=&amp;\begin{bmatrix}<br>\delta_1^ts_1^{t-1} &amp; \delta_1^ts_2^{t-1} &amp; … &amp;  \delta_1^ts_n^{t-1}\<br>\delta_2^ts_1^{t-1} &amp; \delta_2^ts_2^{t-1} &amp; … &amp;  \delta_2^ts_n^{t-1}\<br>.\.\<br>\delta_n^ts_1^{t-1} &amp; \delta_n^ts_2^{t-1} &amp; … &amp;  \delta_n^ts_n^{t-1}\<br>\end{bmatrix}<br>+…+<br>\begin{bmatrix}<br>\delta_1^1s_1^0 &amp; \delta_1^1s_2^0 &amp; … &amp;  \delta_1^1s_n^0\<br>\delta_2^1s_1^0 &amp; \delta_2^1s_2^0 &amp; … &amp;  \delta_2^1s_n^0\<br>.\.\<br>\delta_n^1s_1^0 &amp; \delta_n^1s_2^0 &amp; … &amp;  \delta_n^1s_n^0\<br>\end{bmatrix}\qquad(式6)<br>\end{align}<br>$$</p>
<p>式6就是计算循环层权重矩阵W的梯度的公式。<br>同权重矩阵W类似，我们可以得到权重矩阵U的计算方法。<br>$$<br>\nabla_{U_t}E=\begin{bmatrix}<br>\delta_1^tx_1^t &amp; \delta_1^tx_2^t &amp; … &amp;  \delta_1^tx_m^t\<br>\delta_2^tx_1^t &amp; \delta_2^tx_2^t &amp; … &amp;  \delta_2^tx_m^t\<br>.\.\<br>\delta_n^tx_1^t &amp; \delta_n^tx_2^t &amp; … &amp;  \delta_n^tx_m^t\<br>\end{bmatrix}\qquad(式8)<br>$$<br>式8是误差函数在t时刻对权重矩阵U的梯度。和权重矩阵W一样，最终的梯度也是各个时刻的梯度之和：<br>$$<br>\nabla_UE=\sum_{i=1}^t\nabla_{U_i}E<br>$$</p>
<h3 id="RNN的梯度爆炸和消失问题"><a href="#RNN的梯度爆炸和消失问题" class="headerlink" title="RNN的梯度爆炸和消失问题"></a>RNN的梯度爆炸和消失问题</h3><p>不幸的是，实践中前面介绍的几种RNNs并不能很好的处理较长的序列。一个主要的原因是，RNN在训练中很容易发生梯度爆炸和梯度消失，这导致训练时梯度不能在较长序列中一直传递下去，从而使RNN无法捕捉到长距离的影响。</p>
<p>为什么RNN会产生梯度爆炸和消失问题呢？我们接下来将详细分析一下原因。我们根据式3可得：<br>$$<br>\begin{align}<br>\delta_k^T=&amp;\delta_t^T\prod_{i=k}^{t-1}Wdiag[f’(\mathrm{net}_{i})]\<br>|\delta_k^T|\leqslant&amp;|\delta_t^T|\prod_{i=k}^{t-1}|W||diag[f’(\mathrm{net}_{i})]|\<br>\leqslant&amp;|\delta_t^T|(\beta_W\beta_f)^{t-k}<br>\end{align}<br>$$<br>上式的$\beta$定义为矩阵的模的上界。因为上式是一个指数函数，如果t-k很大的话（也就是向前看很远的时候），会导致对应的误差项的值增长或缩小的非常快，这样就会导致相应的梯度爆炸和梯度消失问题（取决于$\beta$大于1还是小于1）。</p>
<p>通常来说，梯度爆炸更容易处理一些。因为梯度爆炸的时候，我们的程序会收到NaN错误。我们也可以设置一个梯度阈值，当梯度超过这个阈值的时候可以直接截取。</p>
<p>梯度消失更难检测，而且也更难处理一些。总的来说，我们有三种方法应对梯度消失问题：<br>1.合理的初始化权重值。初始化权重，使每个神经元尽可能不要取极大或极小值，以躲开梯度消失的区域。<br>2.使用relu代替sigmoid和tanh作为激活函数。原理请参考上一篇文章<a href="https://www.zybuluo.com/hanbingtao/note/485480" target="_blank" rel="noopener">零基础入门深度学习(4) - 卷积神经网络</a>的激活函数一节。<br>3.使用其他结构的RNNs，比如长短时记忆网络（LTSM）和Gated Recurrent Unit（GRU），这是最流行的做法。我们将在以后的文章中介绍这两种网络。</p>
<h3 id="RNN的应用举例——基于RNN的语言模型"><a href="#RNN的应用举例——基于RNN的语言模型" class="headerlink" title="RNN的应用举例——基于RNN的语言模型"></a>RNN的应用举例——基于RNN的语言模型</h3><p>现在，我们介绍一下基于RNN语言模型。我们首先把词依次输入到循环神经网络中，每输入一个词，循环神经网络就输出截止到目前为止，下一个最可能的词。例如，当我们依次输入：</p>
<blockquote>
<p>我 昨天 上学 迟到 了</p>
</blockquote>
<p>神经网络的输出如下图所示：<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/cs231n/chapter4/p6.png" alt><br>其中，s和e是两个特殊的词，分别表示一个序列的开始和结束。</p>
<h4 id="向量化"><a href="#向量化" class="headerlink" title="向量化"></a>向量化</h4><p>我们知道，神经网络的输入和输出都是向量，为了让语言模型能够被神经网络处理，我们必须把词表达为向量的形式，这样神经网络才能处理它。</p>
<p>神经网络的输入是词，我们可以用下面的步骤对输入进行向量化：</p>
<p>1.建立一个包含所有词的词典，每个词在词典里面有一个唯一的编号。<br>2.任意一个词都可以用一个N维的one-hot向量来表示。其中，N是词典中包含的词的个数。假设一个词在词典中的编号是i，v是表示这个词的向量，$v_j$是向量的第j个元素，则：<br>$$<br>v_j=\begin{equation}\begin{cases}1\qquad j=i\0\qquad j\ne i\end{cases}\end{equation}<br>$$</p>
<p>上面这个公式的含义，可以用下面的图来直观的表示：<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/cs231n/chapter4/p7.png" alt><br>使用这种向量化方法，我们就得到了一个高维、稀疏的向量（稀疏是指绝大部分元素的值都是0）。处理这样的向量会导致我们的神经网络有很多的参数，带来庞大的计算量。因此，往往会需要使用一些降维方法，将高维的稀疏向量转变为低维的稠密向量。不过这个话题我们就不再这篇文章中讨论了。</p>
<p>语言模型要求的输出是下一个最可能的词，我们可以让循环神经网络计算计算词典中每个词是下一个词的概率，这样，概率最大的词就是下一个最可能的词。因此，神经网络的输出向量也是一个N维向量，向量中的每个元素对应着词典中相应的词是下一个词的概率。如下图所示：<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/cs231n/chapter4/p8.png" alt></p>
<h4 id="Softmax层"><a href="#Softmax层" class="headerlink" title="Softmax层"></a>Softmax层</h4><p>前面提到，语言模型是对下一个词出现的概率进行建模。那么，怎样让神经网络输出概率呢？方法就是用softmax层作为神经网络的输出层。</p>
<p>我们先来看一下softmax函数的定义：<br>$$<br>g(z_i)=\frac{e^{z_i}}{\sum_{k}e^{z_k}}<br>$$<br>这个公式看起来可能很晕，我们举一个例子。Softmax层如下图所示：<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/cs231n/chapter4/p9.png" alt><br>从上图我们可以看到，softmax layer的输入是一个向量，输出也是一个向量，两个向量的维度是一样的（在这个例子里面是4）。输入向量x=[1 2 3 4]经过softmax层之后，经过上面的softmax函数计算，转变为输出向量y=[0.03 0.09 0.24 0.64]。计算过程为：<br>$$<br>\begin{align}<br>y_1&amp;=\frac{e^{x_1}}{\sum_{k}e^{x_k}}\<br>&amp;=\frac{e^1}{e^1+e^2+e^3+e^4}\<br>&amp;=0.03\<br>y_2&amp;=\frac{e^2}{e^1+e^2+e^3+e^4}\<br>&amp;=0.09\<br>y_3&amp;=\frac{e^3}{e^1+e^2+e^3+e^4}\<br>&amp;=0.24\<br>y_4&amp;=\frac{e^4}{e^1+e^2+e^3+e^4}\<br>&amp;=0.64\<br>\end{align}<br>$$<br>我们来看看输出向量y的特征：</p>
<p>1.每一项为取值为0-1之间的正数；<br>2.所有项的总和是1。<br>我们不难发现，这些特征和概率的特征是一样的，因此我们可以把它们看做是概率。对于语言模型来说，我们可以认为模型预测下一个词是词典中第一个词的概率是0.03，是词典中第二个词的概率是0.09，以此类推。</p>
<h4 id="语言模型的训练"><a href="#语言模型的训练" class="headerlink" title="语言模型的训练"></a>语言模型的训练</h4><p>可以使用监督学习的方法对语言模型进行训练，首先，需要准备训练数据集。接下来，我们介绍怎样把语料</p>
<blockquote>
<p>我 昨天 上学 迟到 了</p>
</blockquote>
<p>转换成语言模型的训练数据集。</p>
<p>首先，我们获取输入-标签对：<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/cs231n/chapter4/p10.png" alt><br>然后，使用前面介绍过的向量化方法，对输入x和标签y进行向量化。这里面有意思的是，对标签y进行向量化，其结果也是一个one-hot向量。例如，我们对标签『我』进行向量化，得到的向量中，只有第2019个元素的值是1，其他位置的元素的值都是0。它的含义就是下一个词是『我』的概率是1，是其它词的概率都是0。</p>
<p>最后，我们使用交叉熵误差函数作为优化目标，对模型进行优化。</p>
<p>在实际工程中，我们可以使用大量的语料来对模型进行训练，获取训练数据和训练的方法都是相同的。</p>
<h4 id="交叉熵误差"><a href="#交叉熵误差" class="headerlink" title="交叉熵误差"></a>交叉熵误差</h4><p>一般来说，当神经网络的输出层是softmax层时，对应的误差函数E通常选择交叉熵误差函数，其定义如下：<br>$$<br>L(y,o)=-\frac{1}{N}\sum_{n\in{N}}{y_nlogo_n}<br>$$<br>在上式中，N是训练样本的个数，向量$y_n$是样本的标记，向量$O_n$是网络的输出。标记$y_n$是一个one-hot向量，例如$y_1=[1,0,0,0]$，如果网络的输出$o=[0.03,0.09,0.24,0.64]$，那么，交叉熵误差是（假设只有一个训练样本，即N=1）：</p>
<p>$$<br>\begin{align}<br>L&amp;=-\frac{1}{N}\sum_{n\in{N}}{y_nlogo_n}\<br>&amp;=-{y_1}{logo_1}\<br>&amp;=-(1\times log0.03+0\times  log0.09+0\times log0.24+0\times log0.64)\<br>&amp;=3.51<br>\end{align}<br>$$</p>
<p>我们当然可以选择其他函数作为我们的误差函数，比如最小平方误差函数(MSE)。不过对概率进行建模时，选择交叉熵误差函数更make sense</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://www.zybuluo.com/hanbingtao/note/541458" target="_blank" rel="noopener">零基础入门深度学习(5) - 循环神经网络</a></p>
]]></content>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客支持latex</title>
    <url>/blog/2017/05/hexo-latex-blog.html</url>
    <content><![CDATA[<h3 id="开户mathJax"><a href="#开户mathJax" class="headerlink" title="开户mathJax"></a>开户mathJax</h3><p>使用next主题开启支持mathJax写数学公式很简单，只要将mathjax设为true就可以了<br><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mathjax:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">per_page:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></p>
<p>我们通过新建一个公式来看一下效果<br><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="formula">$$</span></span><br><span class="line"><span class="formula"><span class="tag">\<span class="name">begin</span><span class="string">&#123;align&#125;</span></span></span></span><br><span class="line"><span class="formula"><span class="tag">\<span class="name">mathrm</span><span class="string">&#123;o&#125;</span></span>_t&amp;=g(V<span class="tag">\<span class="name">mathrm</span><span class="string">&#123;s&#125;</span></span>_t)<span class="tag">\<span class="name">\</span></span></span></span><br><span class="line"><span class="formula">&amp;=Vf(U<span class="tag">\<span class="name">mathrm</span><span class="string">&#123;x&#125;</span></span>_t+W<span class="tag">\<span class="name">mathrm</span><span class="string">&#123;s&#125;</span></span>_&#123;t-1&#125;)<span class="tag">\<span class="name">\</span></span></span></span><br><span class="line"><span class="formula">&amp;=Vf(U<span class="tag">\<span class="name">mathrm</span><span class="string">&#123;x&#125;</span></span>_t+Wf(U<span class="tag">\<span class="name">mathrm</span><span class="string">&#123;x&#125;</span></span>_&#123;t-1&#125;+W<span class="tag">\<span class="name">mathrm</span><span class="string">&#123;s&#125;</span></span>_&#123;t-2&#125;))<span class="tag">\<span class="name">\</span></span></span></span><br><span class="line"><span class="formula">&amp;=Vf(U<span class="tag">\<span class="name">mathrm</span><span class="string">&#123;x&#125;</span></span>_t+Wf(U<span class="tag">\<span class="name">mathrm</span><span class="string">&#123;x&#125;</span></span>_&#123;t-1&#125;+Wf(U<span class="tag">\<span class="name">mathrm</span><span class="string">&#123;x&#125;</span></span>_&#123;t-2&#125;+W<span class="tag">\<span class="name">mathrm</span><span class="string">&#123;s&#125;</span></span>_&#123;t-3&#125;)))<span class="tag">\<span class="name">\</span></span></span></span><br><span class="line"><span class="formula">&amp;=Vf(U<span class="tag">\<span class="name">mathrm</span><span class="string">&#123;x&#125;</span></span>_t+Wf(U<span class="tag">\<span class="name">mathrm</span><span class="string">&#123;x&#125;</span></span>_&#123;t-1&#125;+Wf(U<span class="tag">\<span class="name">mathrm</span><span class="string">&#123;x&#125;</span></span>_&#123;t-2&#125;+Wf(U<span class="tag">\<span class="name">mathrm</span><span class="string">&#123;x&#125;</span></span>_&#123;t-3&#125;+...))))</span></span><br><span class="line"><span class="formula"><span class="tag">\<span class="name">end</span><span class="string">&#123;align&#125;</span></span></span></span><br><span class="line"><span class="formula">$$</span></span><br></pre></td></tr></table></figure></p>
<p>$$<br>\begin{align}<br>\mathrm{o}_t&amp;=g(V\mathrm{s}_t)\<br>&amp;=Vf(U\mathrm{x}<em>t+W\mathrm{s}</em>{t-1})\<br>&amp;=Vf(U\mathrm{x}<em>t+Wf(U\mathrm{x}</em>{t-1}+W\mathrm{s}_{t-2}))\<br>&amp;=Vf(U\mathrm{x}<em>t+Wf(U\mathrm{x}</em>{t-1}+Wf(U\mathrm{x}<em>{t-2}+W\mathrm{s}</em>{t-3})))\<br>&amp;=Vf(U\mathrm{x}<em>t+Wf(U\mathrm{x}</em>{t-1}+Wf(U\mathrm{x}<em>{t-2}+Wf(U\mathrm{x}</em>{t-3}+…))))<br>\end{align}<br>$$</p>
<p>这时你会发现出了一些问题，原因是hexo先用marked.js渲染，然后再交给MathJax渲染。在marked.js渲染的时候下划线_是被escape掉并且换成了<em>标签，即斜体字，另外LaTeX中的\也会被转义成一个\，这样会导致MathJax渲染时不认为它是一个换行符了。</em></p>
<h3 id="使Marked-js与MathJax共存"><a href="#使Marked-js与MathJax共存" class="headerlink" title="使Marked.js与MathJax共存"></a>使Marked.js与MathJax共存</h3><p>我们的解决方法是使Marked.js与MathJax共存。因此我提供一个修改marked.js源码的方式来避开这些问题 </p>
<ul>
<li>针对下划线的问题，我决定取消<em>作为斜体转义，因为marked.js中*也是斜体的意思，所以取消掉</em>的转义并不影响我们使用markdown，只要我们习惯用*作为斜体字标记就行了。 </li>
<li>针对marked.js与Mathjax对于个别字符二次转义的问题，我们只要不让marked.js去转义\,{,}在MathJax中有特殊用途的字符就行了。<br>具体修改方式，用编辑器打开marked.js（在./node_modules/marked/lib/中）</li>
</ul>
<p>Step 1:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">escape: /^\\([<span class="string">\\`*&#123;&#125;\[\</span>](<span class="link"></span>)# +\-.!_&gt;])/,</span><br></pre></td></tr></table></figure>
<p>替换成<br><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">escape: /^\\([<span class="string">`*\[\</span>](<span class="link"></span>)# +\-.!_&gt;])/,</span><br></pre></td></tr></table></figure></p>
<p>这一步是在原基础上取消了对\,{,}的转义(escape)</p>
<p>Step 2:<br><figure class="highlight taggerscript"><table><tr><td class="code"><pre><span class="line">em: /^<span class="symbol">\b</span>_((?:[^_]|__)+?)_<span class="symbol">\b</span>|^<span class="symbol">\*</span>((?:<span class="symbol">\*</span><span class="symbol">\*</span>|[<span class="symbol">\s</span><span class="symbol">\S</span>])+?)<span class="symbol">\*</span>(?!<span class="symbol">\*</span>)/,</span><br></pre></td></tr></table></figure></p>
<p>替换成<br><figure class="highlight taggerscript"><table><tr><td class="code"><pre><span class="line">em:/^<span class="symbol">\*</span>((?:<span class="symbol">\*</span><span class="symbol">\*</span>|[<span class="symbol">\s</span><span class="symbol">\S</span>])+?)<span class="symbol">\*</span>(?!<span class="symbol">\*</span>)/,</span><br></pre></td></tr></table></figure></p>
<p>这样一来MathJax就能与marked.js共存了。重启一下hexo看一下吧<br>注意，在写博客时需要在开头加入mathjax: true</p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="http://blog.csdn.net/emptyset110/article/details/50123231" target="_blank" rel="noopener">搭建一个支持LaTEX的hexo博客</a><br><a href="http://www.jianshu.com/p/7ab21c7f0674" target="_blank" rel="noopener">在Hexo中渲染MathJax数学公式</a></p>
]]></content>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>长短时记忆网络(LSTM)</title>
    <url>/blog/2017/05/lstm-learn-start.html</url>
    <content><![CDATA[<p>在上一篇文章中，我们介绍了循环神经网络以及它的训练算法。我们也介绍了循环神经网络很难训练的原因，这导致了它在实际应用中，很难处理长距离的依赖。在本文中，我们将介绍一种改进之后的循环神经网络：长短时记忆网络(Long Short Term Memory Network, LSTM)，它成功的解决了原始循环神经网络的缺陷，成为当前最流行的RNN，在语音识别、图片描述、自然语言处理等许多领域中成功应用。但不幸的一面是，LSTM的结构很复杂，因此，我们需要花上一些力气，才能把LSTM以及它的训练算法弄明白。在搞清楚LSTM之后，我们再介绍一种LSTM的变体：GRU (Gated Recurrent Unit)。 它的结构比LSTM简单，而效果却和LSTM一样好，因此，它正在逐渐流行起来。</p>
<h3 id="LSTM简介"><a href="#LSTM简介" class="headerlink" title="LSTM简介"></a>LSTM简介</h3><p>在前文中我们得到了RNN的误差项沿时间反向传播的公式：<br>$$<br>\begin{align}<br>\delta_k^T=&amp;\delta_t^T\prod_{i=k}^{t-1}diag[f’(\mathbf{net}_{i})]W\<br>\end{align}<br>$$</p>
<p>我们可以根据下面的不等式，来获取$\delta_k^T$的模的上界（模可以看做对$\delta_k^T$中每一项值的大小的度量）：<br>$$<br>\begin{align}<br>|\delta_k^T|\leqslant&amp;|\delta_t^T|\prod_{i=k}^{t-1}|diag[f’(\mathbf{net}_{i})]||W|\<br>\leqslant&amp;|\delta_t^T|(\beta_f\beta_W)^{t-k}<br>\end{align}<br>$$<br>我们可以看到，误差项$\delta$从t时刻传递到k时刻，其值的上界是$\beta_f\beta_w$的指数函数。$\beta_f\beta_w$分别是对角矩阵$diag[f’(\mathbf{net}_{i})]$和矩阵W模的上界。显然，除非$\beta_f\beta_w$乘积的值位于1附近，否则，当t-k很大时（也就是误差传递很多个时刻时），整个式子的值就会变得极小（当$\beta_f\beta_w$乘积小于1）或者极大（当$\beta_f\beta_w$乘积大于1），前者就是梯度消失，后者就是梯度爆炸。虽然科学家们搞出了很多技巧（比如怎样初始化权重），让$\beta_f\beta_w$的值尽可能贴近于1，终究还是难以抵挡指数函数的威力。</p>
<p>在循环神经网络中我们已经证明，权重数组W最终的梯度是各个时刻的梯度之和，即：<br>$$<br>\begin{align}<br>\nabla_WE&amp;=\sum_{k=1}^t\nabla_{Wk}E\<br>&amp;=\nabla_{Wt}E+\nabla_{Wt-1}E+\nabla_{Wt-2}E+…+\nabla_{W1}E<br>\end{align}<br>$$<br>假设某轮训练中，各时刻的梯度以及最终的梯度之和如下图：<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/cs231n/chapter5/p1.png" alt><br>我们就可以看到，从上图的t-3时刻开始，梯度已经几乎减少到0了。那么，从这个时刻开始再往之前走，得到的梯度（几乎为零）就不会对最终的梯度值有任何贡献，这就相当于无论t-3时刻之前的网络状态h是什么，在训练中都不会对权重数组W的更新产生影响，也就是网络事实上已经忽略了t-3时刻之前的状态。这就是原始RNN无法处理长距离依赖的原因。</p>
<p>既然找到了问题的原因，那么我们就能解决它。从问题的定位到解决，科学家们大概花了7、8年时间。终于有一天，Hochreiter和Schmidhuber两位科学家发明出长短时记忆网络，一举解决这个问题。</p>
<p>其实，长短时记忆网络的思路比较简单。原始RNN的隐藏层只有一个状态，即h，它对于短期的输入非常敏感。那么，假如我们再增加一个状态，即c，让它来保存长期的状态，那么问题不就解决了么？如下图所示：<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/cs231n/chapter5/p2.png" alt><br>新增加的状态c，称为单元状态(cell state)。我们把上图按照时间维度展开：<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/cs231n/chapter5/p3.png" alt><br>上图仅仅是一个示意图，我们可以看出，在t时刻，LSTM的输入有三个：当前时刻网络的输入值$X_t$、上一时刻LSTM的输出值$h_{t-1}$、以及上一时刻的单元状态$C_{t-1}$；LSTM的输出有两个：当前时刻LSTM输出值$h_t$、和当前时刻的单元状态$C_t$。注意X、h、C都是向量。<br>LSTM的关键，就是怎样控制长期状态c。在这里，LSTM的思路是使用三个控制开关。第一个开关，负责控制继续保存长期状态c；第二个开关，负责控制把即时状态输入到长期状态c；第三个开关，负责控制是否把长期状态c作为当前的LSTM的输出。三个开关的作用如下图所示：<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/cs231n/chapter5/p4.png" alt></p>
<h3 id="LSTM的前向传播"><a href="#LSTM的前向传播" class="headerlink" title="LSTM的前向传播"></a>LSTM的前向传播</h3><p>前面描述的开关是怎样在算法中实现的呢？这就用到了门（gate）的概念。门实际上就是一层全连接层，它的输入是一个向量，输出是一个0到1之间的实数向量。假设W是门的权重向量，b是偏置项，那么门可以表示为：<br>$$<br>g(\mathbf{x})=\sigma(W\mathbf{x}+\mathbf{b})<br>$$<br>门的使用，就是用门的输出向量按元素乘以我们需要控制的那个向量。因为门的输出是0到1之间的实数向量，那么，当门输出为0时，任何向量与之相乘都会得到0向量，这就相当于啥都不能通过；输出为1时，任何向量与之相乘都不会有任何改变，这就相当于啥都可以通过。因为$\sigma$（也就是sigmoid函数）的值域是(0,1)，所以门的状态都是半开半闭的。</p>
<p>LSTM用两个门来控制单元状态c的内容，一个是遗忘门（forget gate），它决定了上一时刻的单元状态$c_{t-1}$有多少保留到当前时刻$c_t$；另一个是输入门（input gate），它决定了当前时刻网络的输入$X_t$有多少保存到单元状态$c_t$。LSTM用输出门（output gate）来控制单元状态$c_t$有多少输出到LSTM的当前输出值$h_t$。</p>
<h4 id="遗忘门"><a href="#遗忘门" class="headerlink" title="遗忘门"></a>遗忘门</h4><p>我们先来看一下遗忘门：<br>$$<br>\mathbf{f}_t=\sigma(W_f\cdot[\mathbf{h}_{t-1},\mathbf{x}_t]+\mathbf{b}_f)\qquad\quad(式1)<br>$$<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/cs231n/chapter5/p5.png" alt><br>下图显示了遗忘门的计算：<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/cs231n/chapter5/p6.png" alt></p>
<h4 id="输入门"><a href="#输入门" class="headerlink" title="输入门"></a>输入门</h4><p>接下来看看输入门：<br>$$<br>\mathbf{i}_t=\sigma(W_i\cdot[\mathbf{h}_{t-1},\mathbf{x}_t]+\mathbf{b}_i)\qquad\quad(式2)<br>$$<br>上式中，$W_i$是输入门的权重矩阵，$b_i$是输入门的偏置项。下图表示了输入门的计算：<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/cs231n/chapter5/p7.png" alt><br>接下来，我们计算用于描述当前输入的单元状态$\mathbf{\tilde{c}}_t$，它是根据上一次的输出和本次输入来计算的：<br>$$<br>\mathbf{\tilde{c}}_t=\tanh(W_c\cdot[\mathbf{h}_{t-1},\mathbf{x}_t]+\mathbf{b}_c)\qquad\quad(式3)<br>$$<br>下图是$\mathbf{\tilde{c}}_t$的计算：<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/cs231n/chapter5/p8.png" alt><br>现在，我们计算当前时刻的单元状态$c_t$。它是由上一次的单元状态$c_{t-1}$按元素乘以遗忘门$f_t$，再用当前输入的单元状态$\mathbf{\tilde{c}}_t$按元素乘以输入门$i_t$，再将两个积加和产生的：<br>$$<br>\mathbf{c}_t=f_t\circ{\mathbf{c}_{t-1}}+i_t\circ{\mathbf{\tilde{c}}_t}\qquad\quad(式4)<br>$$<br>符号$\circ$表示按元素乘。下图是$c_t$的计算<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/cs231n/chapter5/p9.png" alt><br>这样，我们就把LSTM关于当前的记忆$\mathbf{\tilde{c}}<em>t$和长期的记忆$c</em>{t-1}$组合在一起，形成了新的单元状态$c_t$。由于遗忘门的控制，它可以保存很久很久之前的信息，由于输入门的控制，它又可以避免当前无关紧要的内容进入记忆。</p>
<h4 id="输出门"><a href="#输出门" class="headerlink" title="输出门"></a>输出门</h4><p>下面，我们要看看输出门，它控制了长期记忆对当前输出的影响：<br>$$<br>\mathbf{o}_t=\sigma(W_o\cdot[\mathbf{h}_{t-1},\mathbf{x}_t]+\mathbf{b}_o)\qquad\quad(式5)<br>$$<br>下图表示输出门的计算:<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/cs231n/chapter5/p10.png" alt><br>LSTM最终的输出，是由输出门和单元状态共同确定的：<br>$$<br>\mathbf{h}_t=\mathbf{o}_t\circ \tanh(\mathbf{c}_t)\qquad\quad(式6)<br>$$<br>下图表示LSTM最终输出的计算：<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/cs231n/chapter5/p11.png" alt><br>式1到式6就是LSTM前向计算的全部公式。至此，我们就把LSTM前向计算讲完了</p>
<h3 id="LSTM的训练"><a href="#LSTM的训练" class="headerlink" title="LSTM的训练"></a>LSTM的训练</h3><h4 id="LSTM训练算法框架"><a href="#LSTM训练算法框架" class="headerlink" title="LSTM训练算法框架"></a>LSTM训练算法框架</h4><p>LSTM的训练算法仍然是反向传播算法，对于这个算法，我们已经非常熟悉了。主要有下面三个步骤：</p>
<p>1.前向计算每个神经元的输出值，对于LSTM来说，即$\mathbf{f}_t$、$\mathbf{i}_t$、$\mathbf{c}_t$、$\mathbf{o}_t$、$\mathbf{h}_t$五个向量的值。计算方法已经在上一节中描述过了。<br>2.反向计算每个神经元的误差项值。与循环神经网络一样，LSTM误差项的反向传播也是包括两个方向：一个是沿时间的反向传播，即从当前t时刻开始，计算每个时刻的误差项；一个是将误差项向上一层传播。<br>3.根据相应的误差项，计算每个权重的梯度</p>
<h4 id="关于公式和符号的说明"><a href="#关于公式和符号的说明" class="headerlink" title="关于公式和符号的说明"></a>关于公式和符号的说明</h4><p>首先，我们对推导中用到的一些公式、符号做一下必要的说明。</p>
<p>接下来的推导中，我们设定gate的激活函数为sigmoid函数，输出的激活函数为tanh函数。他们的导数分别为：<br>$$<br>\begin{align}<br>\sigma(z)&amp;=y=\frac{1}{1+e^{-z}}\<br>\sigma’(z)&amp;=y(1-y)\<br>\tanh(z)&amp;=y=\frac{e^z-e^{-z}}{e^z+e^{-z}}\<br>\tanh’(z)&amp;=1-y^2<br>\end{align}<br>$$<br>从上面可以看出，sigmoid和tanh函数的导数都是原函数的函数。这样，我们一旦计算原函数的值，就可以用它来计算出导数的值。<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/cs231n/chapter5/p12.png" alt><br>我们解释一下按元素乘$\circ$符号。当$\circ$作用于两个向量时，运算如下：<br>$$<br>\mathbf{a}\circ\mathbf{b}=\begin{bmatrix}<br>a_1\a_2\a_3\…\a_n<br>\end{bmatrix}\circ\begin{bmatrix}<br>b_1\b_2\b_3\…\b_n<br>\end{bmatrix}=\begin{bmatrix}<br>a_1b_1\a_2b_2\a_3b_3\…\a_nb_n<br>\end{bmatrix}<br>$$<br>当$\circ$作用于一个向量和一个矩阵时，运算如下：<br>$$<br>\begin{align}<br>\mathbf{a}\circ X&amp;=\begin{bmatrix}<br>a_1\a_2\a_3\…\a_n<br>\end{bmatrix}\circ\begin{bmatrix}<br>x_{11} &amp; x_{12} &amp; x_{13} &amp; … &amp; x_{1n}\<br>x_{21} &amp; x_{22} &amp; x_{23} &amp; … &amp; x_{2n}\<br>x_{31} &amp; x_{32} &amp; x_{33} &amp; … &amp; x_{3n}\<br>&amp; &amp; …\<br>x_{n1} &amp; x_{n2} &amp; x_{n3} &amp; … &amp; x_{nn}\<br>\end{bmatrix}\<br>&amp;=\begin{bmatrix}<br>a_1x_{11} &amp; a_1x_{12} &amp; a_1x_{13} &amp; … &amp; a_1x_{1n}\<br>a_2x_{21} &amp; a_2x_{22} &amp; a_2x_{23} &amp; … &amp; a_2x_{2n}\<br>a_3x_{31} &amp; a_3x_{32} &amp; a_3x_{33} &amp; … &amp; a_3x_{3n}\<br>&amp; &amp; …\<br>a_nx_{n1} &amp; a_nx_{n2} &amp; a_nx_{n3} &amp; … &amp; a_nx_{nn}\<br>\end{bmatrix}<br>\end{align}<br>$$</p>
<p>当$\circ$作用于两个矩阵时，两个矩阵对应位置的元素相乘。按元素乘可以在某些情况下简化矩阵和向量运算。例如，当一个对角矩阵右乘一个矩阵时，相当于用对角矩阵的对角线组成的向量按元素乘那个矩阵：<br>$$<br>diag[\mathbf{a}]X=\mathbf{a}\circ X<br>$$<br>当一个行向量右乘一个对角矩阵时，相当于这个行向量按元素乘那个矩阵对角线组成的向量：<br>$$<br>\mathbf{a}^Tdiag[\mathbf{b}]=\mathbf{a}\circ\mathbf{b}<br>$$<br>上面这两点，在我们后续推导中会多次用到。</p>
<p>在t时刻，LSTM的输出值为$h_t$。我们定义t时刻的误差项$\delta_t$为：<br>$$\delta_t\overset{def}{=}\frac{\partial{E}}{\partial{\mathbf{h}_t}}$$<br>注意，和前面几篇文章不同，我们这里假设误差项是损失函数对输出值的导数，而不是对加权输入$net_t^l$的导数。因为LSTM有四个加权输入，分别对应$\mathbf{f}_t$、$\mathbf{i}_t$、$\mathbf{c}_t$、$\mathbf{o}_t$，我们希望往上一层传递一个误差项而不是四个。但我们仍然需要定义出这四个加权输入，以及他们对应的误差项。</p>
<p>$$<br>\begin{align}<br>\mathbf{net}_{f,t}&amp;=W_f[\mathbf{h}_{t-1},\mathbf{x}_t]+\mathbf{b}<em>f\<br>&amp;=W</em>{fh}\mathbf{h}<em>{t-1}+W</em>{fx}\mathbf{x}_t+\mathbf{b}<em>f\<br>\mathbf{net}</em>{i,t}&amp;=W_i[\mathbf{h}_{t-1},\mathbf{x}_t]+\mathbf{b}<em>i\<br>&amp;=W</em>{ih}\mathbf{h}<em>{t-1}+W</em>{ix}\mathbf{x}_t+\mathbf{b}<em>i\<br>\mathbf{net}</em>{\tilde{c},t}&amp;=W_c[\mathbf{h}_{t-1},\mathbf{x}_t]+\mathbf{b}<em>c\<br>&amp;=W</em>{ch}\mathbf{h}<em>{t-1}+W</em>{cx}\mathbf{x}_t+\mathbf{b}<em>c\<br>\mathbf{net}</em>{o,t}&amp;=W_o[\mathbf{h}_{t-1},\mathbf{x}_t]+\mathbf{b}<em>o\<br>&amp;=W</em>{oh}\mathbf{h}<em>{t-1}+W</em>{ox}\mathbf{x}_t+\mathbf{b}<em>o\<br>\delta</em>{f,t}&amp;\overset{def}{=}\frac{\partial{E}}{\partial{\mathbf{net}<em>{f,t}}}\<br>\delta</em>{i,t}&amp;\overset{def}{=}\frac{\partial{E}}{\partial{\mathbf{net}<em>{i,t}}}\<br>\delta</em>{\tilde{c},t}&amp;\overset{def}{=}\frac{\partial{E}}{\partial{\mathbf{net}<em>{\tilde{c},t}}}\<br>\delta</em>{o,t}&amp;\overset{def}{=}\frac{\partial{E}}{\partial{\mathbf{net}_{o,t}}}\<br>\end{align}<br>$$</p>
<h4 id="误差项沿时间的反向传递"><a href="#误差项沿时间的反向传递" class="headerlink" title="误差项沿时间的反向传递"></a>误差项沿时间的反向传递</h4><p>沿时间反向传递误差项，就是要计算出t-1时刻的误差项$\delta_{t-1}$<br>$$<br>\begin{align}<br>\delta_{t-1}^T&amp;=\frac{\partial{E}}{\partial{\mathbf{h_{t-1}}}}\<br>&amp;=\frac{\partial{E}}{\partial{\mathbf{h_t}}}\frac{\partial{\mathbf{h_t}}}{\partial{\mathbf{h_{t-1}}}}\<br>&amp;=\delta_{t}^T\frac{\partial{\mathbf{h_t}}}{\partial{\mathbf{h_{t-1}}}}<br>\end{align}<br>$$</p>
<p>根据一系列推导可得出一个将误差项向前传递到任意k时刻的公式：<br>$$<br>\delta_k^T=\prod_{j=k}^{t-1}\delta_{o,j}^TW_{oh}<br>+\delta_{f,j}^TW_{fh}<br>+\delta_{i,j}^TW_{ih}<br>+\delta_{\tilde{c},j}^TW_{ch}\qquad\quad(式13)<br>$$</p>
<h4 id="将误差项传递到上一层"><a href="#将误差项传递到上一层" class="headerlink" title="将误差项传递到上一层"></a>将误差项传递到上一层</h4><p>我们假设当前为第l层，定义l-1层的误差项是误差函数对l-1层加权输入的导数，即：<br>$$<br>\delta_t^{l-1}\overset{def}{=}\frac{\partial{E}}{\mathbf{net}_t^{l-1}}<br>$$</p>
<p>根据一系列推导可得E对$\mathbf{net}_t^{l-1}$的导数：<br>$$<br>\begin{align}<br>\frac{\partial{E}}{\partial{\mathbf{net}<em>t^{l-1}}}&amp;=\frac{\partial{E}}{\partial{\mathbf{\mathbf{net}</em>{f,t}^l}}}\frac{\partial{\mathbf{\mathbf{net}_{f,t}^l}}}{\partial{\mathbf{x}_t^l}}\frac{\partial{\mathbf{x}_t^l}}{\partial{\mathbf{\mathbf{net}<em>t^{l-1}}}}<br>+\frac{\partial{E}}{\partial{\mathbf{\mathbf{net}</em>{i,t}^l}}}\frac{\partial{\mathbf{\mathbf{net}_{i,t}^l}}}{\partial{\mathbf{x}_t^l}}\frac{\partial{\mathbf{x}_t^l}}{\partial{\mathbf{\mathbf{net}<em>t^{l-1}}}}<br>+\frac{\partial{E}}{\partial{\mathbf{\mathbf{net}</em>{\tilde{c},t}^l}}}\frac{\partial{\mathbf{\mathbf{net}_{\tilde{c},t}^l}}}{\partial{\mathbf{x}_t^l}}\frac{\partial{\mathbf{x}_t^l}}{\partial{\mathbf{\mathbf{net}<em>t^{l-1}}}}<br>+\frac{\partial{E}}{\partial{\mathbf{\mathbf{net}</em>{o,t}^l}}}\frac{\partial{\mathbf{\mathbf{net}_{o,t}^l}}}{\partial{\mathbf{x}_t^l}}\frac{\partial{\mathbf{x}_t^l}}{\partial{\mathbf{\mathbf{net}<em>t^{l-1}}}}\<br>&amp;=\delta</em>{f,t}^TW_{fx}\circ f’(\mathbf{net}<em>t^{l-1})+\delta</em>{i,t}^TW_{ix}\circ f’(\mathbf{net}<em>t^{l-1})+\delta</em>{\tilde{c},t}^TW_{cx}\circ f’(\mathbf{net}<em>t^{l-1})+\delta</em>{o,t}^TW_{ox}\circ f’(\mathbf{net}<em>t^{l-1})\<br>&amp;=(\delta</em>{f,t}^TW_{fx}+\delta_{i,t}^TW_{ix}+\delta_{\tilde{c},t}^TW_{cx}+\delta_{o,t}^TW_{ox})\circ f’(\mathbf{net}_t^{l-1})\qquad\quad(式14)<br>\end{align}<br>$$</p>
<p>式14就是将误差传递到上一层的公式。</p>
<h4 id="权重梯度的计算"><a href="#权重梯度的计算" class="headerlink" title="权重梯度的计算"></a>权重梯度的计算</h4><p>根据一系列推导，可以求出对于$W_{fh}$、$W_{ih}$、$W_{ch}$、$W_{oh}$的权重梯度<br>$$<br>\begin{align}<br>\frac{\partial{E}}{\partial{W_{oh}}}&amp;=\sum_{j=1}^t\delta_{o,j}\mathbf{h}<em>{j-1}^T\<br>\frac{\partial{E}}{\partial{W</em>{fh}}}&amp;=\sum_{j=1}^t\delta_{f,j}\mathbf{h}<em>{j-1}^T\<br>\frac{\partial{E}}{\partial{W</em>{ih}}}&amp;=\sum_{j=1}^t\delta_{i,j}\mathbf{h}<em>{j-1}^T\<br>\frac{\partial{E}}{\partial{W</em>{ch}}}&amp;=\sum_{j=1}^t\delta_{\tilde{c},j}\mathbf{h}_{j-1}^T\<br>\end{align}<br>$$</p>
<p>同时可以求出最终的偏置项梯度，即将各个时刻的偏置项梯度加在一起：<br>$$<br>\begin{align}<br>\frac{\partial{E}}{\partial{\mathbf{b}<em>o}}&amp;=\sum</em>{j=1}^t\delta_{o,j}\<br>\frac{\partial{E}}{\partial{\mathbf{b}<em>i}}&amp;=\sum</em>{j=1}^t\delta_{i,j}\<br>\frac{\partial{E}}{\partial{\mathbf{b}<em>f}}&amp;=\sum</em>{j=1}^t\delta_{f,j}\<br>\frac{\partial{E}}{\partial{\mathbf{b}<em>c}}&amp;=\sum</em>{j=1}^t\delta_{\tilde{c},j}\<br>\end{align}<br>$$</p>
<p>对于$W_{fx}$、$W_{ix}$、$W_{cx}$、$W_{ox}$的权重梯度，只需要根据相应的误差项直接计算即可：<br>$$<br>\begin{align}<br>\frac{\partial{E}}{\partial{W_{ox}}}&amp;=\frac{\partial{E}}{\partial{\mathbf{net}<em>{o,t}}}\frac{\partial{\mathbf{net}</em>{o,t}}}{\partial{W_{ox}}}\<br>&amp;=\delta_{o,t}\mathbf{x}<em>{t}^T\\<br>\frac{\partial{E}}{\partial{W</em>{fx}}}&amp;=\frac{\partial{E}}{\partial{\mathbf{net}<em>{f,t}}}\frac{\partial{\mathbf{net}</em>{f,t}}}{\partial{W_{fx}}}\<br>&amp;=\delta_{f,t}\mathbf{x}<em>{t}^T\\<br>\frac{\partial{E}}{\partial{W</em>{ix}}}&amp;=\frac{\partial{E}}{\partial{\mathbf{net}<em>{i,t}}}\frac{\partial{\mathbf{net}</em>{i,t}}}{\partial{W_{ix}}}\<br>&amp;=\delta_{i,t}\mathbf{x}<em>{t}^T\\<br>\frac{\partial{E}}{\partial{W</em>{cx}}}&amp;=\frac{\partial{E}}{\partial{\mathbf{net}<em>{\tilde{c},t}}}\frac{\partial{\mathbf{net}</em>{\tilde{c},t}}}{\partial{W_{cx}}}\<br>&amp;=\delta_{\tilde{c},t}\mathbf{x}_{t}^T\<br>\end{align}<br>$$</p>
<h3 id="GRU"><a href="#GRU" class="headerlink" title="GRU"></a>GRU</h3><p>前面我们讲了一种普通的LSTM，事实上LSTM存在很多变体，许多论文中的LSTM都或多或少的不太一样。在众多的LSTM变体中，GRU (Gated Recurrent Unit)也许是最成功的一种。它对LSTM做了很多简化，同时却保持着和LSTM相同的效果。因此，GRU最近变得越来越流行。</p>
<p>GRU对LSTM做了两个大改动：<br>1.将输入门、遗忘门、输出门变为两个门：更新门（Update Gate）$\mathbf{z}_t$和重置门（Reset Gate）$r_t$。<br>2.将单元状态与输出合并为一个状态：h<br>GRU的前向计算公式为：</p>
<p>$$<br>\begin{align}<br>\mathbf{z}_t&amp;=\sigma(W_z\cdot[\mathbf{h}_{t-1},\mathbf{x}_t])\<br>\mathbf{r}_t&amp;=\sigma(W_r\cdot[\mathbf{h}_{t-1},\mathbf{x}_t])\<br>\mathbf{\tilde{h}}_t&amp;=\tanh(W\cdot[\mathbf{r}<em>t\circ\mathbf{h}</em>{t-1},\mathbf{x}_t])\<br>\mathbf{h}&amp;=(1-\mathbf{z}<em>t)\circ\mathbf{h}</em>{t-1}+\mathbf{z}_t\circ\mathbf{\tilde{h}}_t<br>\end{align}<br>$$</p>
<p>下图是GRU的示意图：<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/cs231n/chapter5/p13.png" alt></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://zybuluo.com/hanbingtao/note/581764" target="_blank" rel="noopener">零基础入门深度学习(6) - 长短时记忆网络(LSTM)</a></p>
]]></content>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>TensorFlow开始</title>
    <url>/blog/2017/05/tensorflow-new-start.html</url>
    <content><![CDATA[<h3 id="什么是TensorFlow"><a href="#什么是TensorFlow" class="headerlink" title="什么是TensorFlow?"></a>什么是TensorFlow?</h3><p>TensorFlow是Google开发的一款神经网络的Python外部的结构包, 也是一个采用数据流图来进行数值计算的开源软件库.TensorFlow 让我们可以先绘制计算结构图, 也可以称是一系列可人机交互的计算操作, 然后把编辑好的Python文件 转换成 更高效的C++, 并在后端进行计算.</p>
<h3 id="为什么要使用TensorFlow"><a href="#为什么要使用TensorFlow" class="headerlink" title="为什么要使用TensorFlow?"></a>为什么要使用TensorFlow?</h3><p>TensorFlow 无可厚非地能被认定为 神经网络中最好用的库之一. 它擅长的任务就是训练深度神经网络.通过使用TensorFlow我们就可以快速的入门神经网络, 大大降低了深度学习（也就是深度神经网络）的开发成本和开发难度. TensorFlow 的开源性, 让所有人都能使用并且维护, 巩固它. 使它能迅速更新, 提升.</p>
<h3 id="TensorFlow安装"><a href="#TensorFlow安装" class="headerlink" title="TensorFlow安装"></a>TensorFlow安装</h3><p>基于Ubuntu16.04安装,Tensorflow (0.12) 刚刚做了更新, 绕过了复杂的安装步骤, 如果你只需要安装 CPU 版本的 Tensorflow, 运行下面这个就好了:<br><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># python 2+ 的用户:</span></span><br><span class="line">$ pip <span class="keyword">install</span> tensorflow</span><br><span class="line"></span><br><span class="line"><span class="comment"># python 3+ 的用户:</span></span><br><span class="line">$ pip3 <span class="keyword">install</span> tensorflow</span><br></pre></td></tr></table></figure></p>
<p>注意: 你需要8.1或更高版的 pip 才能顺利安装.</p>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>然后打开你的 python 编辑器, 输入<br><figure class="highlight elm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow</span><br></pre></td></tr></table></figure></p>
<p>看看是否成功导入tensorflow包</p>
<h4 id="更新-Tensorflow"><a href="#更新-Tensorflow" class="headerlink" title="更新 Tensorflow"></a>更新 Tensorflow</h4><p>最后, 如果你需要升级 Tensorflow 的版本, 推荐的方式是:</p>
<p>根据你的 python 版本, 在 terminal 中删除原有的版本<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如果你是 Python 2, 请复制下面</span></span><br><span class="line">pip <span class="keyword">uninstall</span> tensorflow</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果你是 Python 3, 请复制下面</span></span><br><span class="line">pip3 <span class="keyword">uninstall</span> tensorflow</span><br></pre></td></tr></table></figure></p>
<p>然后重复这个安装教程的步骤, 从头安装新版本.</p>
<h4 id="小问题"><a href="#小问题" class="headerlink" title="小问题"></a>小问题</h4><p>通过这种方法安装，运行时会有一些警告<br><figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">W tensorflow/core/platform/cpu_feature_guard.cc:<span class="number">45</span>] The TensorFlow <span class="keyword">library</span> wasn<span class="symbol">'t</span> compiled <span class="keyword">to</span> <span class="keyword">use</span> SSE4.<span class="number">1</span> instructions, but these are available <span class="keyword">on</span> your machine <span class="keyword">and</span> could speed up CPU computations.</span><br><span class="line">W tensorflow/core/platform/cpu_feature_guard.cc:<span class="number">45</span>] The TensorFlow <span class="keyword">library</span> wasn<span class="symbol">'t</span> compiled <span class="keyword">to</span> <span class="keyword">use</span> SSE4.<span class="number">2</span> instructions, but these are available <span class="keyword">on</span> your machine <span class="keyword">and</span> could speed up CPU computations.</span><br><span class="line">W tensorflow/core/platform/cpu_feature_guard.cc:<span class="number">45</span>] The TensorFlow <span class="keyword">library</span> wasn<span class="symbol">'t</span> compiled <span class="keyword">to</span> <span class="keyword">use</span> AVX instructions, but these are available <span class="keyword">on</span> your machine <span class="keyword">and</span> could speed up CPU computations.</span><br><span class="line">W tensorflow/core/platform/cpu_feature_guard.cc:<span class="number">45</span>] The TensorFlow <span class="keyword">library</span> wasn<span class="symbol">'t</span> compiled <span class="keyword">to</span> <span class="keyword">use</span> AVX2 instructions, but these are available <span class="keyword">on</span> your machine <span class="keyword">and</span> could speed up CPU computations.</span><br><span class="line">W tensorflow/core/platform/cpu_feature_guard.cc:<span class="number">45</span>] The TensorFlow <span class="keyword">library</span> wasn<span class="symbol">'t</span> compiled <span class="keyword">to</span> <span class="keyword">use</span> FMA instructions, but these are available <span class="keyword">on</span> your machine <span class="keyword">and</span> could speed up CPU computations.</span><br></pre></td></tr></table></figure></p>
<p>解决方法如下：<br><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">If you want <span class="built_in">to</span> silence <span class="keyword">the</span> warnings though you can <span class="built_in">set</span> TF_CPP_MIN_LOG_LEVEL <span class="built_in">to</span> <span class="number">2</span> <span class="keyword">as</span>: </span><br><span class="line">import os</span><br><span class="line">os.environ[<span class="string">'TF_CPP_MIN_LOG_LEVEL'</span>]=<span class="string">'2'</span></span><br><span class="line">import tensorflow <span class="keyword">as</span> tf</span><br></pre></td></tr></table></figure></p>
<p><a href="http://stackoverflow.com/questions/43335531/how-to-use-sse4-1-instructions-without-install-tensorflow-from-source" target="_blank" rel="noopener">Sign up<br>How to use SSE4.1 instructions without install tensorflow from source?</a></p>
<h3 id="GPU版Tensorflow安装"><a href="#GPU版Tensorflow安装" class="headerlink" title="GPU版Tensorflow安装"></a>GPU版Tensorflow安装</h3><p>安装GPU版tensorflow并通过CUDA加速<br><a href="https://www.cnblogs.com/fanfzj/p/8521728.html" target="_blank" rel="noopener">tensoflow-gpu安装</a><br><a href="https://blog.csdn.net/weixin_39290638/article/details/80045236" target="_blank" rel="noopener">Win10下Tensorflow(GPU版)安装趟坑实录</a></p>
]]></content>
      <tags>
        <tag>tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title>RNN实现图像标注</title>
    <url>/blog/2017/05/rnn-caption-achieve.html</url>
    <content><![CDATA[<p>本文主要实现通过循环神经网络实现图像标注。<br>主要使用Microsoft COCO数据集，这个数据集包括80,000 个训练数据与40,000个验证数据，每张图片都有5个标注。<br>对于图像的标注，用<start>开始，用<end>结束,空用<null>,对于 生僻字用<unk>表示<br>数据可视化如下所示：<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/cs231n/chapter6/p1.png" alt></unk></null></end></start></p>
<h3 id="RNN各层的实现"><a href="#RNN各层的实现" class="headerlink" title="RNN各层的实现"></a>RNN各层的实现</h3><h4 id="step-forward"><a href="#step-forward" class="headerlink" title="step forward"></a>step forward</h4><p>step forward是为单一timestep实现的前向传播过程<br><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">def rnn_step_forward(<span class="keyword">x</span>, prev_h, Wx, Wh, <span class="keyword">b</span>):</span><br><span class="line">  <span class="string">""</span><span class="comment">"</span></span><br><span class="line">  Run the forward pass <span class="keyword">for</span> <span class="keyword">a</span> single timestep of <span class="keyword">a</span> vanilla RNN that uses <span class="keyword">a</span> <span class="built_in">tanh</span></span><br><span class="line">  activation <span class="function"><span class="keyword">function</span>.</span></span><br><span class="line"></span><br><span class="line">  The <span class="built_in">input</span> data <span class="built_in">has</span> dimension D, the hidden state <span class="built_in">has</span> dimension H, <span class="built_in">and</span> we use</span><br><span class="line">  <span class="keyword">a</span> minibatch size of <span class="keyword">N</span>.</span><br><span class="line"></span><br><span class="line">  Input<span class="variable">s:</span></span><br><span class="line">  - <span class="keyword">x</span>: Input data <span class="keyword">for</span> this timestep, of shape (<span class="keyword">N</span>, D).</span><br><span class="line">  - prev_h: Hidden state from <span class="keyword">previous</span> timestep, of shape (<span class="keyword">N</span>, H)</span><br><span class="line">  - Wx: Weight matrix <span class="keyword">for</span> <span class="built_in">input</span>-<span class="keyword">to</span>-hidden connections, of shape (D, H)</span><br><span class="line">  - Wh: Weight matrix <span class="keyword">for</span> hidden-<span class="keyword">to</span>-hidden connections, of shape (H, H)</span><br><span class="line">  - <span class="variable">b:</span> Biases of shape (H,)</span><br><span class="line"></span><br><span class="line">  Returns <span class="keyword">a</span> tuple of:</span><br><span class="line">  - next_h: <span class="keyword">Next</span> hidden state, of shape (<span class="keyword">N</span>, H)</span><br><span class="line">  - cache: Tuple of <span class="built_in">values</span> needed <span class="keyword">for</span> the backward pass.</span><br><span class="line">  <span class="string">""</span><span class="comment">"</span></span><br><span class="line">  next_h, cache = None, None</span><br><span class="line">  <span class="keyword">a</span> = prev_h.dot(Wh) + <span class="keyword">x</span>.dot(Wx) + <span class="keyword">b</span></span><br><span class="line">  next_h = np.<span class="built_in">tanh</span>(<span class="keyword">a</span>)</span><br><span class="line">  cache = (<span class="keyword">x</span>, prev_h, Wh, Wx, <span class="keyword">b</span>, next_h)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> next_h, cache</span><br></pre></td></tr></table></figure></p>
<h4 id="step-backward"><a href="#step-backward" class="headerlink" title="step backward"></a>step backward</h4><p>step backward是为单一timestep实现的后向传播过程<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rnn_step_backward</span><span class="params">(dnext_h, cache)</span>:</span></span><br><span class="line">  <span class="string">"""</span></span><br><span class="line"><span class="string">  Backward pass for a single timestep of a vanilla RNN.</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  Inputs:</span></span><br><span class="line"><span class="string">  - dnext_h: Gradient of loss with respect to next hidden state</span></span><br><span class="line"><span class="string">  - cache: Cache object from the forward pass</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  Returns a tuple of:</span></span><br><span class="line"><span class="string">  - dx: Gradients of input data, of shape (N, D)</span></span><br><span class="line"><span class="string">  - dprev_h: Gradients of previous hidden state, of shape (N, H)</span></span><br><span class="line"><span class="string">  - dWx: Gradients of input-to-hidden weights, of shape (N, H)</span></span><br><span class="line"><span class="string">  - dWh: Gradients of hidden-to-hidden weights, of shape (H, H)</span></span><br><span class="line"><span class="string">  - db: Gradients of bias vector, of shape (H,)</span></span><br><span class="line"><span class="string">  """</span></span><br><span class="line">  dx, dprev_h, dWx, dWh, db = <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span></span><br><span class="line">  x, prev_h, Wh, Wx, b, next_h =  cache</span><br><span class="line">  da = dnext_h * (<span class="number">1</span> - next_h * next_h)</span><br><span class="line">  dx = da.dot(Wx.T)</span><br><span class="line">  dprev_h = da.dot(Wh.T)</span><br><span class="line">  dWx = x.T.dot(da)</span><br><span class="line">  dWh = prev_h.T.dot(da)</span><br><span class="line">  db = np.sum(da, axis = <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dx, dprev_h, dWx, dWh, db</span><br></pre></td></tr></table></figure></p>
<h4 id="Vanilla-RNN-forward"><a href="#Vanilla-RNN-forward" class="headerlink" title="Vanilla RNN: forward"></a>Vanilla RNN: forward</h4><p>上文已经实现了单步的前向传播过程，现在实现一系列数据的前向传播过程<br><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">def rnn_forward(x, h0, Wx, <span class="keyword">Wh</span>, b):</span><br><span class="line">  <span class="string">""</span>"</span><br><span class="line">  <span class="keyword">Run</span> a vanilla RNN forward <span class="keyword">on</span> <span class="keyword">an</span> entire sequence of data. We assume <span class="keyword">an</span> <span class="keyword">input</span></span><br><span class="line">  sequence composed of T vectors, each of dimension <span class="keyword">D</span>. The RNN uses a hidden</span><br><span class="line">  size of <span class="keyword">H</span>, and we work over a minibatch containing <span class="keyword">N</span> sequences. After running</span><br><span class="line">  the RNN forward, we <span class="keyword">return</span> the hidden states <span class="keyword">for</span> all timesteps.</span><br><span class="line">  </span><br><span class="line">  Inputs:</span><br><span class="line">  - x: <span class="keyword">Input</span> data <span class="keyword">for</span> the entire timeseries, of shape (<span class="keyword">N</span>, T, <span class="keyword">D</span>).</span><br><span class="line">  - h0: Initial hidden state, of shape (<span class="keyword">N</span>, <span class="keyword">H</span>)</span><br><span class="line">  - Wx: Weight <span class="keyword">matrix</span> <span class="keyword">for</span> <span class="keyword">input</span>-to-hidden connections, of shape (<span class="keyword">D</span>, <span class="keyword">H</span>)</span><br><span class="line">  - <span class="keyword">Wh</span>: Weight <span class="keyword">matrix</span> <span class="keyword">for</span> hidden-to-hidden connections, of shape (<span class="keyword">H</span>, <span class="keyword">H</span>)</span><br><span class="line">  - b: Biases of shape (<span class="keyword">H</span>,)</span><br><span class="line">  </span><br><span class="line">  Returns a tuple of:</span><br><span class="line">  - <span class="keyword">h</span>: Hidden states <span class="keyword">for</span> the entire timeseries, of shape (<span class="keyword">N</span>, T, <span class="keyword">H</span>).</span><br><span class="line">  - cache: Values needed <span class="keyword">in</span> the backward pass</span><br><span class="line">  <span class="string">""</span>"</span><br><span class="line">  <span class="keyword">h</span>, cache = None, None</span><br><span class="line">  <span class="keyword">N</span>, T, <span class="keyword">D</span> = x.shape</span><br><span class="line">  (<span class="keyword">H</span> ,) = b.shape</span><br><span class="line">  <span class="keyword">h</span> = np.zeros((<span class="keyword">N</span>, T, <span class="keyword">H</span>))</span><br><span class="line">  prev_h = h0</span><br><span class="line">  <span class="keyword">for</span> t <span class="keyword">in</span> <span class="keyword">range</span>(T):</span><br><span class="line">    xt = x[:, t, :]</span><br><span class="line">    next_h,_ = rnn_step_forward(xt, prev_h, Wx, <span class="keyword">Wh</span>, b)</span><br><span class="line">    prev_h = next_h</span><br><span class="line">    <span class="keyword">h</span>[:, t, :] = prev_h</span><br><span class="line">  cache = (x, h0, <span class="keyword">Wh</span>, Wx, b, <span class="keyword">h</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">h</span>, cache</span><br></pre></td></tr></table></figure></p>
<h4 id="Vanilla-RNN-backward"><a href="#Vanilla-RNN-backward" class="headerlink" title="Vanilla RNN: backward"></a>Vanilla RNN: backward</h4><p>上文已经实现了单步的后向传播过程，现在实现一系列数据的后向传播过程<br><figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">def rnn_backward(dh, cache):</span><br><span class="line">  <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">  Compute the backward pass for a vanilla RNN over an entire sequence of data.</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  Inputs:</span></span><br><span class="line"><span class="string">  - dh: Upstream gradients of all hidden states, of shape (N, T, H)</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  Returns a tuple of:</span></span><br><span class="line"><span class="string">  - dx: Gradient of inputs, of shape (N, T, D)</span></span><br><span class="line"><span class="string">  - dh0: Gradient of initial hidden state, of shape (N, H)</span></span><br><span class="line"><span class="string">  - dWx: Gradient of input-to-hidden weights, of shape (D, H)</span></span><br><span class="line"><span class="string">  - dWh: Gradient of hidden-to-hidden weights, of shape (H, H)</span></span><br><span class="line"><span class="string">  - db: Gradient of biases, of shape (H,)</span></span><br><span class="line"><span class="string">  "</span><span class="string">""</span></span><br><span class="line">  dx, dh0, dWx, dWh, <span class="attr">db</span> = None, None, None, None, None</span><br><span class="line"></span><br><span class="line">  x, h0, Wh, Wx, b, <span class="attr">h</span> = cache</span><br><span class="line">  N, T, <span class="attr">H</span> = dh.shape</span><br><span class="line">  _, _, <span class="attr">D</span> = x.shape</span><br><span class="line"></span><br><span class="line">  <span class="attr">next_h</span> = h[:,T-<span class="number">1</span>,:]</span><br><span class="line">    </span><br><span class="line">  <span class="attr">dprev_h</span> = np.zeros((N, H))</span><br><span class="line">  <span class="attr">dx</span> = np.zeros((N, T, D))</span><br><span class="line">  <span class="attr">dh0</span> = np.zeros((N, H))</span><br><span class="line">  <span class="attr">dWx=</span> np.zeros((D, H))</span><br><span class="line">  <span class="attr">dWh</span> = np.zeros((H, H))</span><br><span class="line">  <span class="attr">db</span> = np.zeros((H,))</span><br><span class="line">    </span><br><span class="line">  for t <span class="keyword">in</span> range(T):</span><br><span class="line">    <span class="attr">t</span> = T-<span class="number">1</span>-t</span><br><span class="line">    <span class="attr">xt</span> = x[:,t,:]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="attr">t</span> ==<span class="number">0</span>:</span><br><span class="line">        <span class="attr">prev_h</span> = h0</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="attr">prev_h</span> = h[:,t-<span class="number">1</span>,:]</span><br><span class="line">        </span><br><span class="line">    <span class="attr">step_cache</span> = (xt, prev_h, Wh, Wx, b, next_h)</span><br><span class="line">    <span class="attr">next_h</span> = prev_h</span><br><span class="line">    <span class="attr">dnext_h</span> = dh[:,t,:] + dprev_h</span><br><span class="line">    dx[:,t,:], dprev_h, dWxt, dWht, <span class="attr">dbt</span> = rnn_step_backward(dnext_h, step_cache)</span><br><span class="line">    dWx, dWh, <span class="attr">db</span> = dWx+dWxt, dWh+dWht, db+dbt</span><br><span class="line">    </span><br><span class="line">  <span class="attr">dh0</span> = dprev_h</span><br><span class="line"></span><br><span class="line">  return dx, dh0, dWx, dWh, db</span><br></pre></td></tr></table></figure></p>
<h4 id="Word-embedding-forward"><a href="#Word-embedding-forward" class="headerlink" title="Word embedding: forward"></a>Word embedding: forward</h4><p>在我们的输入中，代表词的是它在单词表中的idx,在深度学习过程中，通常用vector代替string<br>convert words (represented by integers) into vectors</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">def word_embedding_forward(<span class="keyword">x</span>, W):</span><br><span class="line">  <span class="string">""</span><span class="comment">"</span></span><br><span class="line">  Forward pass <span class="keyword">for</span> word embeddings. We operate <span class="keyword">on</span> minibatches of size <span class="keyword">N</span> where</span><br><span class="line">  each sequence <span class="built_in">has</span> length T. We assume <span class="keyword">a</span> vocabulary of V words, assigning each</span><br><span class="line">  <span class="keyword">to</span> <span class="keyword">a</span> vector of dimension D.</span><br><span class="line">  </span><br><span class="line">  Input<span class="variable">s:</span></span><br><span class="line">  - <span class="keyword">x</span>: Integer array of shape (<span class="keyword">N</span>, T) giving indices of words. Each element idx</span><br><span class="line">    of <span class="keyword">x</span> muxt <span class="keyword">be</span> in the <span class="built_in">range</span> <span class="number">0</span> &lt;= idx &lt; V.</span><br><span class="line">  - W: Weight matrix of shape (V, D) giving word vectors <span class="keyword">for</span> <span class="keyword">all</span> words.</span><br><span class="line">  </span><br><span class="line">  Returns <span class="keyword">a</span> tuple of:</span><br><span class="line">  - <span class="keyword">ou</span><span class="variable">t:</span> Array of shape (<span class="keyword">N</span>, T, D) giving word vectors <span class="keyword">for</span> <span class="keyword">all</span> <span class="built_in">input</span> words.</span><br><span class="line">  - cache: Values needed <span class="keyword">for</span> the backward pass</span><br><span class="line">  <span class="string">""</span><span class="comment">"</span></span><br><span class="line">  out, cache = None, None</span><br><span class="line"></span><br><span class="line">  <span class="keyword">N</span>, T = <span class="keyword">x</span>.shape</span><br><span class="line">  V, D = W.shape</span><br><span class="line">  out = np.zeros((<span class="keyword">N</span>, T, D))</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> i in <span class="built_in">range</span>(<span class="keyword">N</span>):</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">j</span> in <span class="built_in">range</span>(T):</span><br><span class="line">      out[i, <span class="keyword">j</span>] = W[<span class="keyword">x</span>[i,<span class="keyword">j</span>]]</span><br><span class="line">  </span><br><span class="line">  cache = (<span class="keyword">x</span>, W.shape)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> out, cache</span><br></pre></td></tr></table></figure>
<h4 id="Word-embedding-backward"><a href="#Word-embedding-backward" class="headerlink" title="Word embedding: backward"></a>Word embedding: backward</h4><p>上面word embedding的反向传播过程<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">word_embedding_backward</span><span class="params">(dout, cache)</span>:</span></span><br><span class="line">  <span class="string">"""</span></span><br><span class="line"><span class="string">  Backward pass for word embeddings. We cannot back-propagate into the words</span></span><br><span class="line"><span class="string">  since they are integers, so we only return gradient for the word embedding</span></span><br><span class="line"><span class="string">  matrix.</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  HINT: Look up the function np.add.at</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  Inputs:</span></span><br><span class="line"><span class="string">  - dout: Upstream gradients of shape (N, T, D)</span></span><br><span class="line"><span class="string">  - cache: Values from the forward pass</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  Returns:</span></span><br><span class="line"><span class="string">  - dW: Gradient of word embedding matrix, of shape (V, D).</span></span><br><span class="line"><span class="string">  """</span></span><br><span class="line">  dW = <span class="literal">None</span></span><br><span class="line">  x, W_shape = cache</span><br><span class="line">  dW = np.zeros(W_shape)</span><br><span class="line">  np.add.at(dW, x, dout)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dW</span><br></pre></td></tr></table></figure></p>
<h4 id="Temporal-Affine-layer"><a href="#Temporal-Affine-layer" class="headerlink" title="Temporal Affine layer"></a>Temporal Affine layer</h4><p>At every timestep we use an affine function to transform the RNN hidden vector at that timestep into scores for each word in the vocabulary<br>这是计算RNN的输出的过程<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">def temporal_affine_forward(x, w, b):</span><br><span class="line">  """</span><br><span class="line">  Forward pass for a temporal affine layer. The input is a <span class="keyword">set</span> <span class="keyword">of</span> D-dimensional</span><br><span class="line">  vectors arranged <span class="keyword">into</span> a minibatch <span class="keyword">of</span> N timeseries, <span class="keyword">each</span> <span class="keyword">of</span> <span class="keyword">length</span> T. We <span class="keyword">use</span></span><br><span class="line">  an affine <span class="keyword">function</span> <span class="keyword">to</span> transform <span class="keyword">each</span> <span class="keyword">of</span> those vectors <span class="keyword">into</span> a <span class="keyword">new</span> vector <span class="keyword">of</span></span><br><span class="line">  <span class="keyword">dimension</span> M.</span><br><span class="line"></span><br><span class="line">  Inputs:</span><br><span class="line">  - x: <span class="keyword">Input</span> <span class="keyword">data</span> <span class="keyword">of</span> shape (N, T, D)</span><br><span class="line">  - w: Weights <span class="keyword">of</span> shape (D, M)</span><br><span class="line">  - b: Biases <span class="keyword">of</span> shape (M,)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">Returns</span> a tuple <span class="keyword">of</span>:</span><br><span class="line">  - <span class="keyword">out</span>: <span class="keyword">Output</span> <span class="keyword">data</span> <span class="keyword">of</span> shape (N, T, M)</span><br><span class="line">  - <span class="keyword">cache</span>: <span class="keyword">Values</span> needed <span class="keyword">for</span> the backward pass</span><br><span class="line">  <span class="string">"""</span></span><br><span class="line"><span class="string">  N, T, D = x.shape</span></span><br><span class="line"><span class="string">  M = b.shape[0]</span></span><br><span class="line"><span class="string">  out = x.reshape(N * T, D).dot(w).reshape(N, T, M) + b</span></span><br><span class="line"><span class="string">  cache = x, w, b, out</span></span><br><span class="line"><span class="string">  return out, cache</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">def temporal_affine_backward(dout, cache):</span></span><br><span class="line"><span class="string">  """</span></span><br><span class="line">  Backward pass <span class="keyword">for</span> temporal affine layer.</span><br><span class="line"></span><br><span class="line">  <span class="keyword">Input</span>:</span><br><span class="line">  - dout: Upstream gradients <span class="keyword">of</span> shape (N, T, M)</span><br><span class="line">  - <span class="keyword">cache</span>: <span class="keyword">Values</span> <span class="keyword">from</span> forward pass</span><br><span class="line"></span><br><span class="line">  <span class="keyword">Returns</span> a tuple <span class="keyword">of</span>:</span><br><span class="line">  - dx: Gradient <span class="keyword">of</span> <span class="keyword">input</span>, <span class="keyword">of</span> shape (N, T, D)</span><br><span class="line">  - dw: Gradient <span class="keyword">of</span> weights, <span class="keyword">of</span> shape (D, M)</span><br><span class="line">  - db: Gradient <span class="keyword">of</span> biases, <span class="keyword">of</span> shape (M,)</span><br><span class="line">  <span class="string">"""</span></span><br><span class="line"><span class="string">  x, w, b, out = cache</span></span><br><span class="line"><span class="string">  N, T, D = x.shape</span></span><br><span class="line"><span class="string">  M = b.shape[0]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  dx = dout.reshape(N * T, M).dot(w.T).reshape(N, T, D)</span></span><br><span class="line"><span class="string">  dw = dout.reshape(N * T, M).T.dot(x.reshape(N * T, D)).T</span></span><br><span class="line"><span class="string">  db = dout.sum(axis=(0, 1))</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  return dx, dw, db</span></span><br></pre></td></tr></table></figure></p>
<h4 id="Temporal-Softmax-loss"><a href="#Temporal-Softmax-loss" class="headerlink" title="Temporal Softmax loss"></a>Temporal Softmax loss</h4><p>In an RNN language model, at every timestep we produce a score for each word in the vocabulary. We know the ground-truth word at each timestep, so we use a softmax loss function to compute loss and gradient at each timestep. We sum the losses over time and average them over the minibatch.<br>计算预测值与真实值的loss<br>However there is one wrinke: since we operate over minibatches and different captions may have different lengths, we append <null> tokens to the end of each caption so they all have the same length. We don’t want these <null> tokens to count toward the loss or gradient, so in addition to scores and ground-truth labels our loss function also accepts a mask array that tells it which elements of the scores count towards the loss.</null></null></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">def temporal_softmax_loss(x, y, mask, verbose=False):</span><br><span class="line">  """</span><br><span class="line">  A temporal version of softmax loss for <span class="keyword">use</span> <span class="keyword">in</span> RNNs. We assume that we <span class="keyword">are</span></span><br><span class="line">  making predictions <span class="keyword">over</span> a vocabulary <span class="keyword">of</span> <span class="keyword">size</span> V <span class="keyword">for</span> <span class="keyword">each</span> timestep <span class="keyword">of</span> a</span><br><span class="line">  timeseries <span class="keyword">of</span> <span class="keyword">length</span> T, <span class="keyword">over</span> a minibatch <span class="keyword">of</span> <span class="keyword">size</span> N. The <span class="keyword">input</span> x gives scores</span><br><span class="line">  <span class="keyword">for</span> <span class="keyword">all</span> vocabulary elements <span class="keyword">at</span> <span class="keyword">all</span> timesteps, <span class="keyword">and</span> y gives the <span class="keyword">indices</span> <span class="keyword">of</span> the</span><br><span class="line">  ground-truth <span class="keyword">element</span> <span class="keyword">at</span> <span class="keyword">each</span> timestep. We <span class="keyword">use</span> a <span class="keyword">cross</span>-entropy loss <span class="keyword">at</span> <span class="keyword">each</span></span><br><span class="line">  timestep, summing the loss <span class="keyword">over</span> <span class="keyword">all</span> timesteps <span class="keyword">and</span> averaging across the</span><br><span class="line">  minibatch.</span><br><span class="line"></span><br><span class="line">  <span class="keyword">As</span> an additional complication, we may want <span class="keyword">to</span> <span class="keyword">ignore</span> the <span class="keyword">model</span> <span class="keyword">output</span> <span class="keyword">at</span> <span class="keyword">some</span></span><br><span class="line">  timesteps, since sequences <span class="keyword">of</span> different <span class="keyword">length</span> may have been combined <span class="keyword">into</span> a</span><br><span class="line">  minibatch <span class="keyword">and</span> padded <span class="keyword">with</span> <span class="literal">NULL</span> tokens. The optional <span class="keyword">mask</span> argument tells us</span><br><span class="line">  which elements should contribute <span class="keyword">to</span> the loss.</span><br><span class="line"></span><br><span class="line">  Inputs:</span><br><span class="line">  - x: <span class="keyword">Input</span> scores, <span class="keyword">of</span> shape (N, T, V)</span><br><span class="line">  - y: Ground-truth <span class="keyword">indices</span>, <span class="keyword">of</span> shape (N, T) <span class="keyword">where</span> <span class="keyword">each</span> <span class="keyword">element</span> <span class="keyword">is</span> <span class="keyword">in</span> the <span class="keyword">range</span></span><br><span class="line">       <span class="number">0</span> &lt;= y[i, t] &lt; V</span><br><span class="line">  - <span class="keyword">mask</span>: <span class="built_in">Boolean</span> <span class="built_in">array</span> <span class="keyword">of</span> shape (N, T) <span class="keyword">where</span> <span class="keyword">mask</span>[i, t] tells whether <span class="keyword">or</span> <span class="keyword">not</span></span><br><span class="line">    the scores <span class="keyword">at</span> x[i, t] should contribute <span class="keyword">to</span> the loss.</span><br><span class="line"></span><br><span class="line">  <span class="keyword">Returns</span> a tuple <span class="keyword">of</span>:</span><br><span class="line">  - loss: Scalar giving loss</span><br><span class="line">  - dx: Gradient <span class="keyword">of</span> loss <span class="keyword">with</span> <span class="keyword">respect</span> <span class="keyword">to</span> scores x.</span><br><span class="line">  <span class="string">"""</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  N, T, V = x.shape</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  x_flat = x.reshape(N * T, V)</span></span><br><span class="line"><span class="string">  y_flat = y.reshape(N * T)</span></span><br><span class="line"><span class="string">  mask_flat = mask.reshape(N * T)</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  probs = np.exp(x_flat - np.max(x_flat, axis=1, keepdims=True))</span></span><br><span class="line"><span class="string">  probs /= np.sum(probs, axis=1, keepdims=True)</span></span><br><span class="line"><span class="string">  loss = -np.sum(mask_flat * np.log(probs[np.arange(N * T), y_flat])) / N</span></span><br><span class="line"><span class="string">  dx_flat = probs.copy()</span></span><br><span class="line"><span class="string">  dx_flat[np.arange(N * T), y_flat] -= 1</span></span><br><span class="line"><span class="string">  dx_flat /= N</span></span><br><span class="line"><span class="string">  dx_flat *= mask_flat[:, None]</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  if verbose: print 'dx_flat: ', dx_flat.shape</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  dx = dx_flat.reshape(N, T, V)</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  return loss, dx</span></span><br></pre></td></tr></table></figure>
<h3 id="构建RNN"><a href="#构建RNN" class="headerlink" title="构建RNN"></a>构建RNN</h3><p>现在我们已经实现了RNN的各层，现在可以构建一个RNN模型实现图像标注</p>
<p>A CaptioningRNN produces captions from image features using a recurrent neural network.</p>
<p>The RNN receives input vectors of size D, has a vocab size of V, works on sequences of length T, has an RNN hidden dimension of H, uses word vectors of dimension W, and operates on minibatches of size N.Note that we don’t use any regularization for the CaptioningRNN</p>
<h4 id="loss函数"><a href="#loss函数" class="headerlink" title="loss函数"></a>loss函数</h4><p>计算RNN网络的损失函数<br>其中前向传播过程你需要做以下事情<br>(1) Use an affine transformation to compute the initial hidden state from the image features. This should produce an array of shape (N, H)<br>(2) Use a word embedding layer to transform the words in captions_in from indices to vectors, giving an array of shape (N, T, W).<br>(3) Use either a vanilla RNN or LSTM (depending on self.cell_type) to process the sequence of input word vectors and produce hidden state vectors for all timesteps, producing an array of shape (N, T, H).<br>(4) Use a (temporal) affine transformation to compute scores over the vocabulary at every timestep using the hidden states, giving an  array of shape (N, T, V).<br>(5) Use (temporal) softmax to compute loss using captions_out, ignoring the points where the output word is <null> using the mask above.<br><figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line">def loss(self, features, captions):</span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Compute training-time loss for the RNN. We input image features and</span></span><br><span class="line"><span class="string">    ground-truth captions for those images, and use an RNN (or LSTM) to compute</span></span><br><span class="line"><span class="string">    loss and gradients on all parameters.</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Inputs:</span></span><br><span class="line"><span class="string">    - features: Input image features, of shape (N, D)</span></span><br><span class="line"><span class="string">    - captions: Ground-truth captions; an integer array of shape (N, T) where</span></span><br><span class="line"><span class="string">      each element is in the range 0 &lt;= y[i, t] &lt; V</span></span><br><span class="line"><span class="string">      </span></span><br><span class="line"><span class="string">    Returns a tuple of:</span></span><br><span class="line"><span class="string">    - loss: Scalar loss</span></span><br><span class="line"><span class="string">    - grads: Dictionary of gradients parallel to self.params</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># Cut captions into two pieces: captions_in has everything but the last word</span></span><br><span class="line">    <span class="comment"># and will be input to the RNN; captions_out has everything but the first</span></span><br><span class="line">    <span class="comment"># word and this is what we will expect the RNN to generate. These are offset</span></span><br><span class="line">    <span class="comment"># by one relative to each other because the RNN should produce word (t+1)</span></span><br><span class="line">    <span class="comment"># after receiving word t. The first element of captions_in will be the START</span></span><br><span class="line">    <span class="comment"># token, and the first element of captions_out will be the first word.</span></span><br><span class="line">    captions_in = captions[:, :<span class="number">-1</span>]</span><br><span class="line">    captions_out = captions[:, <span class="number">1</span>:]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># You'll need this </span></span><br><span class="line">    mask = (captions_out != self._null)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Weight and bias for the affine transform from image features to initial</span></span><br><span class="line">    <span class="comment"># hidden state</span></span><br><span class="line">    W_proj, b_proj = self.params[<span class="string">'W_proj'</span>], self.params[<span class="string">'b_proj'</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Word embedding matrix</span></span><br><span class="line">    W_embed = self.params[<span class="string">'W_embed'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Input-to-hidden, hidden-to-hidden, and biases for the RNN</span></span><br><span class="line">    Wx, Wh, b = self.params[<span class="string">'Wx'</span>], self.params[<span class="string">'Wh'</span>], self.params[<span class="string">'b'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Weight and bias for the hidden-to-vocab transformation.</span></span><br><span class="line">    W_vocab, b_vocab = self.params[<span class="string">'W_vocab'</span>], self.params[<span class="string">'b_vocab'</span>]</span><br><span class="line">    </span><br><span class="line">    loss, grads = <span class="number">0.0</span>, &#123;&#125;</span><br><span class="line">    <span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">####</span></span><br><span class="line"><span class="comment">    # <span class="doctag">TODO:</span> Implement the forward and backward passes for the CaptioningRNN.   #</span></span><br><span class="line"><span class="comment">    # In the forward pass you will need to do the following:                   #</span></span><br><span class="line"><span class="comment">    # (1) Use an affine transformation to compute the initial hidden state     #</span></span><br><span class="line"><span class="comment">    #     from the image features. This should produce an array of shape (N, H)#</span></span><br><span class="line"><span class="comment">    # (2) Use a word embedding layer to transform the words in captions_in     #</span></span><br><span class="line"><span class="comment">    #     from indices to vectors, giving an array of shape (N, T, W).         #</span></span><br><span class="line"><span class="comment">    # (3) Use either a vanilla RNN or LSTM (depending on self.cell_type) to    #</span></span><br><span class="line"><span class="comment">    #     process the sequence of input word vectors and produce hidden state  #</span></span><br><span class="line"><span class="comment">    #     vectors for all timesteps, producing an array of shape (N, T, H).    #</span></span><br><span class="line"><span class="comment">    # (4) Use a (temporal) affine transformation to compute scores over the    #</span></span><br><span class="line"><span class="comment">    #     vocabulary at every timestep using the hidden states, giving an      #</span></span><br><span class="line"><span class="comment">    #     array of shape (N, T, V).                                            #</span></span><br><span class="line"><span class="comment">    # (5) Use (temporal) softmax to compute loss using captions_out, ignoring  #</span></span><br><span class="line"><span class="comment">    #     the points where the output word is &lt;NULL&gt; using the mask above.     #</span></span><br><span class="line"><span class="comment">    #                                                                          #</span></span><br><span class="line"><span class="comment">    # In the backward pass you will need to compute the gradient of the loss   #</span></span><br><span class="line"><span class="comment">    # with respect to all model parameters. Use the loss and grads variables   #</span></span><br><span class="line"><span class="comment">    # defined above to store loss and gradients; grads[k] should give the      #</span></span><br><span class="line"><span class="comment">    # gradients for self.params[k].                                            #</span></span><br><span class="line"><span class="comment">    ###</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">#</span></span><br><span class="line">    <span class="comment">#(1)</span></span><br><span class="line">    affine_out, affine_cache = affine_forward(features ,W_proj, b_proj)</span><br><span class="line">    <span class="comment">#(2)</span></span><br><span class="line">    word_embedding_out, word_embedding_cache = word_embedding_forward(captions_in, W_embed)</span><br><span class="line">    <span class="comment">#(3)</span></span><br><span class="line">    <span class="keyword">if</span> self.cell_type == <span class="string">'rnn'</span>:</span><br><span class="line">        rnn_or_lstm_out, rnn_cache = rnn_forward(word_embedding_out, affine_out, Wx, Wh, b)</span><br><span class="line">    elif self.cell_type == <span class="string">'lstm'</span>:</span><br><span class="line">        rnn_or_lstm_out, lstm_cache = lstm_forward(word_embedding_out, affine_out, Wx, Wh, b)</span><br><span class="line">    else:</span><br><span class="line">        raise ValueError(<span class="string">'Invalid cell_type "%s"'</span> % self.cell_type)</span><br><span class="line">    <span class="comment">#(4)</span></span><br><span class="line">    temporal_affine_out, temporal_affine_cache = temporal_affine_forward(rnn_or_lstm_out, W_vocab, b_vocab)</span><br><span class="line">    <span class="comment">#(5)</span></span><br><span class="line">    loss, dtemporal_affine_out = temporal_softmax_loss(temporal_affine_out, captions_out, mask)</span><br><span class="line">    <span class="comment">#(4)</span></span><br><span class="line">    drnn_or_lstm_out, grads[<span class="string">'W_vocab'</span>], grads[<span class="string">'b_vocab'</span>] = temporal_affine_backward(dtemporal_affine_out, temporal_affine_cache)</span><br><span class="line">    <span class="comment">#(3)</span></span><br><span class="line">    <span class="keyword">if</span> self.cell_type == <span class="string">'rnn'</span>:</span><br><span class="line">        dword_embedding_out, daffine_out, grads[<span class="string">'Wx'</span>], grads[<span class="string">'Wh'</span>], grads[<span class="string">'b'</span>] = rnn_backward(drnn_or_lstm_out, rnn_cache)</span><br><span class="line">    elif self.cell_type == <span class="string">'lstm'</span>:</span><br><span class="line">        dword_embedding_out, daffine_out, grads[<span class="string">'Wx'</span>], grads[<span class="string">'Wh'</span>], grads[<span class="string">'b'</span>] = lstm_backward(drnn_or_lstm_out, lstm_cache)</span><br><span class="line">    else:</span><br><span class="line">        raise ValueError(<span class="string">'Invalid cell_type "%s"'</span> % self.cell_type)</span><br><span class="line">    <span class="comment">#(2)</span></span><br><span class="line">    grads[<span class="string">'W_embed'</span>] = word_embedding_backward(dword_embedding_out, word_embedding_cache)</span><br><span class="line">    <span class="comment">#(1)</span></span><br><span class="line">    dfeatures, grads[<span class="string">'W_proj'</span>], grads[<span class="string">'b_proj'</span>] = affine_backward(daffine_out, affine_cache)</span><br><span class="line">    <span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">####</span></span><br><span class="line"><span class="comment">    #                             END OF YOUR CODE                             #</span></span><br><span class="line"><span class="comment">    ###</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">#</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> loss, grads</span><br></pre></td></tr></table></figure></null></p>
<h4 id="Overfit-small-data"><a href="#Overfit-small-data" class="headerlink" title="Overfit small data"></a>Overfit small data</h4><p>我们用上面构建的模型来过拟合一个小数据<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">small_data = load_coco_data(<span class="attribute">max_train</span>=50)</span><br><span class="line"></span><br><span class="line">small_rnn_model = CaptioningRNN(</span><br><span class="line">          <span class="attribute">cell_type</span>=<span class="string">'rnn'</span>,</span><br><span class="line">          <span class="attribute">word_to_idx</span>=data[<span class="string">'word_to_idx'</span>],</span><br><span class="line">          <span class="attribute">input_dim</span>=data[<span class="string">'train_features'</span>].shape[1],</span><br><span class="line">          <span class="attribute">hidden_dim</span>=512,</span><br><span class="line">          <span class="attribute">wordvec_dim</span>=256,</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">small_rnn_solver = CaptioningSolver(small_rnn_model, small_data,</span><br><span class="line">           <span class="attribute">update_rule</span>=<span class="string">'adam'</span>,</span><br><span class="line">           <span class="attribute">num_epochs</span>=50,</span><br><span class="line">           <span class="attribute">batch_size</span>=25,</span><br><span class="line">           optim_config=&#123;</span><br><span class="line">             <span class="string">'learning_rate'</span>: 5e-3,</span><br><span class="line">           &#125;,</span><br><span class="line">           <span class="attribute">lr_decay</span>=0.95,</span><br><span class="line">           <span class="attribute">verbose</span>=<span class="literal">True</span>, <span class="attribute">print_every</span>=10,</span><br><span class="line">         )</span><br><span class="line"></span><br><span class="line">small_rnn_solver.train()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Plot the training losses</span></span><br><span class="line">plt.plot(small_rnn_solver.loss_history)</span><br><span class="line">plt.xlabel(<span class="string">'Iteration'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Loss'</span>)</span><br><span class="line">plt.title(<span class="string">'Training loss history'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p>
<p>可以看出到最后trainloss接近于0<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/cs231n/chapter6/p2.png" alt></p>
<h3 id="Test-time-sampling"><a href="#Test-time-sampling" class="headerlink" title="Test-time sampling"></a>Test-time sampling</h3><p>与分类模型不同，图像标注模型在训练与测试时大不相同。<br>At training time, we have access to the ground-truth caption so we feed ground-truth words as input to the RNN at each timestep. At test time, we sample from the distribution over the vocabulary at each timestep, and feed the sample as input to the RNN at the next timestep.<br>在前向传播过程中需要做以下：<br>(1) Embed the previous word using the learned word embeddings<br>(2) Make an RNN step using the previous hidden state and the embedded current word to get the next hidden state.<br>(3) Apply the learned affine transformation to the next hidden state to get scores for all words in the vocabulary<br>(4) Select the word with the highest score as the next word, writing it to the appropriate slot in the captions variable<br><figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line">def sample(self, features, max_length=<span class="number">30</span>):</span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Run a test-time forward pass for the model, sampling captions for input</span></span><br><span class="line"><span class="string">    feature vectors.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    At each timestep, we embed the current word, pass it and the previous hidden</span></span><br><span class="line"><span class="string">    state to the RNN to get the next hidden state, use the hidden state to get</span></span><br><span class="line"><span class="string">    scores for all vocab words, and choose the word with the highest score as</span></span><br><span class="line"><span class="string">    the next word. The initial hidden state is computed by applying an affine</span></span><br><span class="line"><span class="string">    transform to the input image features, and the initial word is the &lt;START&gt;</span></span><br><span class="line"><span class="string">    token.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    For LSTMs you will also have to keep track of the cell state; in that case</span></span><br><span class="line"><span class="string">    the initial cell state should be zero.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Inputs:</span></span><br><span class="line"><span class="string">    - features: Array of input image features of shape (N, D).</span></span><br><span class="line"><span class="string">    - max_length: Maximum length T of generated captions.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">    - captions: Array of shape (N, max_length) giving sampled captions,</span></span><br><span class="line"><span class="string">      where each element is an integer in the range [0, V). The first element</span></span><br><span class="line"><span class="string">      of captions should be the first sampled word, not the &lt;START&gt; token.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    N = features.shape[<span class="number">0</span>]</span><br><span class="line">    captions = self._null * np.ones((N, max_length), dtype=np.int32)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Unpack parameters</span></span><br><span class="line">    W_proj, b_proj = self.params[<span class="string">'W_proj'</span>], self.params[<span class="string">'b_proj'</span>]</span><br><span class="line">    W_embed = self.params[<span class="string">'W_embed'</span>]</span><br><span class="line">    Wx, Wh, b = self.params[<span class="string">'Wx'</span>], self.params[<span class="string">'Wh'</span>], self.params[<span class="string">'b'</span>]</span><br><span class="line">    W_vocab, b_vocab = self.params[<span class="string">'W_vocab'</span>], self.params[<span class="string">'b_vocab'</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">###</span></span><br><span class="line"><span class="comment">    # <span class="doctag">TODO:</span> Implement test-time sampling for the model. You will need to      #</span></span><br><span class="line"><span class="comment">    # initialize the hidden state of the RNN by applying the learned affine   #</span></span><br><span class="line"><span class="comment">    # transform to the input image features. The first word that you feed to  #</span></span><br><span class="line"><span class="comment">    # the RNN should be the &lt;START&gt; token; its value is stored in the         #</span></span><br><span class="line"><span class="comment">    # variable self._start. At each timestep you will need to do to:          #</span></span><br><span class="line"><span class="comment">    # (1) Embed the previous word using the learned word embeddings           #</span></span><br><span class="line"><span class="comment">    # (2) Make an RNN step using the previous hidden state and the embedded   #</span></span><br><span class="line"><span class="comment">    #     current word to get the next hidden state.                          #</span></span><br><span class="line"><span class="comment">    # (3) Apply the learned affine transformation to the next hidden state to #</span></span><br><span class="line"><span class="comment">    #     get scores for all words in the vocabulary                          #</span></span><br><span class="line"><span class="comment">    # (4) Select the word with the highest score as the next word, writing it #</span></span><br><span class="line"><span class="comment">    #     to the appropriate slot in the captions variable                    #</span></span><br><span class="line"><span class="comment">    #                                                                         #</span></span><br><span class="line"><span class="comment">    # For simplicity, you do not need to stop generating after an &lt;END&gt; token #</span></span><br><span class="line"><span class="comment">    # is sampled, but you can if you want to.                                 #</span></span><br><span class="line"><span class="comment">    #                                                                         #</span></span><br><span class="line"><span class="comment">    # HINT: You will not be able to use the rnn_forward or lstm_forward       #</span></span><br><span class="line"><span class="comment">    # functions; you'll need to call rnn_step_forward or lstm_step_forward in #</span></span><br><span class="line"><span class="comment">    # a loop.                                                                 #</span></span><br><span class="line"><span class="comment">    ###</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span></span><br><span class="line">    N, D = features.shape</span><br><span class="line">    affine_out, affine_cache = affine_forward(features ,W_proj, b_proj)</span><br><span class="line">    </span><br><span class="line">    prev_word_idx = [self._start]*N</span><br><span class="line">    prev_h = affine_out</span><br><span class="line">    prev_c = np.zeros(prev_h.shape)</span><br><span class="line">    captions[:,<span class="number">0</span>] = self._start</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,max_length):</span><br><span class="line">        prev_word_embed  = W_embed[prev_word_idx]</span><br><span class="line">        <span class="keyword">if</span> self.cell_type == <span class="string">'rnn'</span>:</span><br><span class="line">            next_h, rnn_step_cache = rnn_step_forward(prev_word_embed, prev_h, Wx, Wh, b)</span><br><span class="line">        elif self.cell_type == <span class="string">'lstm'</span>:</span><br><span class="line">            next_h, next_c,lstm_step_cache = lstm_step_forward(prev_word_embed, prev_h, prev_c, Wx, Wh, b)</span><br><span class="line">            prev_c = next_c</span><br><span class="line">        else:</span><br><span class="line">            raise ValueError(<span class="string">'Invalid cell_type "%s"'</span> % self.cell_type)</span><br><span class="line">        vocab_affine_out, vocab_affine_out_cache = affine_forward(next_h, W_vocab, b_vocab)</span><br><span class="line">        captions[:,i] = list(np.argmax(vocab_affine_out, axis = <span class="number">1</span>))</span><br><span class="line">        prev_word_idx = captions[:,i]</span><br><span class="line">        prev_h = next_h</span><br><span class="line">    <span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">####</span></span><br><span class="line"><span class="comment">    #                             END OF YOUR CODE                             #</span></span><br><span class="line"><span class="comment">    ###</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">#</span></span><br><span class="line">    <span class="keyword">return</span> captions</span><br></pre></td></tr></table></figure></p>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>在训练集与验证集上分别运行测试，可以发现我们的程序对训练集非常准确，对于validation集则完全不准，这是因为我们在上文对小数据进行了过拟合导致的。<br><figure class="highlight hsp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="keyword">split</span> in [<span class="string">'train'</span>, <span class="string">'val'</span>]:</span><br><span class="line">  minibatch = sample_coco_minibatch(small_data, <span class="keyword">split</span>=<span class="keyword">split</span>, batch_size=<span class="number">2</span>)</span><br><span class="line">  gt_captions, features, urls = minibatch</span><br><span class="line">  gt_captions = decode_captions(gt_captions, data[<span class="string">'idx_to_word'</span>])</span><br><span class="line"></span><br><span class="line">  sample_captions = small_rnn_model.sample(features)</span><br><span class="line">  sample_captions = decode_captions(sample_captions, data[<span class="string">'idx_to_word'</span>])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> gt_caption, sample_caption, url in zip(gt_captions, sample_captions, urls):</span><br><span class="line">    plt.imshow(image_from_url(url))</span><br><span class="line">    plt.title(<span class="string">'%s\n%s\nGT:%s'</span> % (<span class="keyword">split</span>, sample_caption, gt_caption))</span><br><span class="line">    plt.axis(<span class="string">'off'</span>)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure></p>
<p>效果如下<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/cs231n/chapter6/p3.png" alt><br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/cs231n/chapter6/p4.png" alt><br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/cs231n/chapter6/p5.png" alt><br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/cs231n/chapter6/p6.png" alt></p>
]]></content>
      <tags>
        <tag>计算机视觉</tag>
      </tags>
  </entry>
  <entry>
    <title>LSTM实现图像标注</title>
    <url>/blog/2017/05/lstm-caption-achieve.html</url>
    <content><![CDATA[<p>在前文中我们已经提到,RNN存在梯度消失的问题，面对较长的序列会没有什么效果，LSTM正是一个有效的解决方案。<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/cs231n/chapter6/p7.png" alt></p>
<h3 id="LSTM各层的实现"><a href="#LSTM各层的实现" class="headerlink" title="LSTM各层的实现"></a>LSTM各层的实现</h3><h4 id="LSTM-step-forward"><a href="#LSTM-step-forward" class="headerlink" title="LSTM: step forward"></a>LSTM: step forward</h4><p>为单一timestep的LSTM实现前向传播过程<br><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">def lstm_step_forward(<span class="keyword">x</span>, prev_h, prev_c, Wx, Wh, <span class="keyword">b</span>):</span><br><span class="line">  <span class="string">""</span><span class="comment">"</span></span><br><span class="line">  Forward pass <span class="keyword">for</span> <span class="keyword">a</span> single timestep of <span class="keyword">an</span> LSTM.</span><br><span class="line">  </span><br><span class="line">  The <span class="built_in">input</span> data <span class="built_in">has</span> dimension D, the hidden state <span class="built_in">has</span> dimension H, <span class="built_in">and</span> we use</span><br><span class="line">  <span class="keyword">a</span> minibatch size of <span class="keyword">N</span>.</span><br><span class="line">  </span><br><span class="line">  Input<span class="variable">s:</span></span><br><span class="line">  - <span class="keyword">x</span>: Input data, of shape (<span class="keyword">N</span>, D)</span><br><span class="line">  - prev_h: Previous hidden state, of shape (<span class="keyword">N</span>, H)</span><br><span class="line">  - prev_c: <span class="keyword">previous</span> cell state, of shape (<span class="keyword">N</span>, H)</span><br><span class="line">  - Wx: Input-<span class="keyword">to</span>-hidden weights, of shape (D, <span class="number">4</span>H)</span><br><span class="line">  - Wh: Hidden-<span class="keyword">to</span>-hidden weights, of shape (H, <span class="number">4</span>H)</span><br><span class="line">  - <span class="variable">b:</span> Biases, of shape (<span class="number">4</span>H,)</span><br><span class="line">  </span><br><span class="line">  Returns <span class="keyword">a</span> tuple of:</span><br><span class="line">  - next_h: <span class="keyword">Next</span> hidden state, of shape (<span class="keyword">N</span>, H)</span><br><span class="line">  - next_c: <span class="keyword">Next</span> cell state, of shape (<span class="keyword">N</span>, H)</span><br><span class="line">  - cache: Tuple of <span class="built_in">values</span> needed <span class="keyword">for</span> backward pass.</span><br><span class="line">  <span class="string">""</span><span class="comment">"</span></span><br><span class="line">  next_h, next_c, cache = None, None, None</span><br><span class="line"></span><br><span class="line">  H = Wh.shape[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">a</span> = <span class="keyword">x</span>.dot(Wx) + prev_h.dot(Wh) + <span class="keyword">b</span></span><br><span class="line"></span><br><span class="line">  z_i = sigmoid(<span class="keyword">a</span>[:,:H])</span><br><span class="line">  z_f = sigmoid(<span class="keyword">a</span>[:,H:<span class="number">2</span>*H])</span><br><span class="line">  z_o = sigmoid(<span class="keyword">a</span>[:,<span class="number">2</span>*H:<span class="number">3</span>*H])</span><br><span class="line">  z_g = np.<span class="built_in">tanh</span>(<span class="keyword">a</span>[:,<span class="number">3</span>*H:])</span><br><span class="line"></span><br><span class="line">  next_c = z_f * prev_c + z_i * z_g</span><br><span class="line">  z_t = np.<span class="built_in">tanh</span>(next_c)</span><br><span class="line">  next_h = z_o * z_t</span><br><span class="line"></span><br><span class="line">  cache = (z_i, z_f, z_o, z_g, z_t, prev_c, prev_h, Wx, Wh, <span class="keyword">x</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> next_h, next_c, cache</span><br></pre></td></tr></table></figure></p>
<h4 id="LSTM-step-backward"><a href="#LSTM-step-backward" class="headerlink" title="LSTM: step backward"></a>LSTM: step backward</h4><p>step forward的反向传播过程<br><figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">def lstm_step_backward(dnext_h, dnext_c, cache):</span><br><span class="line">  <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">  Backward pass for a single timestep of an LSTM.</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  Inputs:</span></span><br><span class="line"><span class="string">  - dnext_h: Gradients of next hidden state, of shape (N, H)</span></span><br><span class="line"><span class="string">  - dnext_c: Gradients of next cell state, of shape (N, H)</span></span><br><span class="line"><span class="string">  - cache: Values from the forward pass</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  Returns a tuple of:</span></span><br><span class="line"><span class="string">  - dx: Gradient of input data, of shape (N, D)</span></span><br><span class="line"><span class="string">  - dprev_h: Gradient of previous hidden state, of shape (N, H)</span></span><br><span class="line"><span class="string">  - dprev_c: Gradient of previous cell state, of shape (N, H)</span></span><br><span class="line"><span class="string">  - dWx: Gradient of input-to-hidden weights, of shape (D, 4H)</span></span><br><span class="line"><span class="string">  - dWh: Gradient of hidden-to-hidden weights, of shape (H, 4H)</span></span><br><span class="line"><span class="string">  - db: Gradient of biases, of shape (4H,)</span></span><br><span class="line"><span class="string">  "</span><span class="string">""</span></span><br><span class="line">  dx, dh, dc, dWx, dWh, <span class="attr">db</span> = None, None, None, None, None, None</span><br><span class="line"></span><br><span class="line">  <span class="attr">H</span> = dnext_h.shape[<span class="number">1</span>]</span><br><span class="line">  z_i, z_f, z_o, z_g, z_t, prev_c, prev_h, Wx, Wh, <span class="attr">x</span> = cache</span><br><span class="line">  </span><br><span class="line">  <span class="attr">dz_o</span> = z_t * dnext_h</span><br><span class="line">  <span class="attr">dc_t</span> = z_o * (<span class="number">1</span> - z_t * z_t) * dnext_h + dnext_c</span><br><span class="line">  <span class="attr">dz_f</span> = prev_c * dc_t</span><br><span class="line">  <span class="attr">dz_i</span> = z_g * dc_t</span><br><span class="line">  <span class="attr">dprev_c</span> = z_f * dc_t</span><br><span class="line">  <span class="attr">dz_g</span> = z_i * dc_t</span><br><span class="line">    </span><br><span class="line">  <span class="attr">da_i</span> = (<span class="number">1</span> - z_i) * z_i * dz_i</span><br><span class="line">  <span class="attr">da_f</span> = (<span class="number">1</span> - z_f) * z_f * dz_f</span><br><span class="line">  <span class="attr">da_o</span> = (<span class="number">1</span> - z_o) * z_o * dz_o</span><br><span class="line">  <span class="attr">da_g</span> = (<span class="number">1</span> - z_g * z_g) * dz_g</span><br><span class="line">  <span class="attr">da</span> = np.hstack((da_i, da_f, da_o, da_g))</span><br><span class="line">  </span><br><span class="line">  <span class="attr">dWx</span> = x.T.dot(da)</span><br><span class="line">  <span class="attr">dWh</span> = prev_h.T.dot(da)</span><br><span class="line">    </span><br><span class="line">  <span class="attr">db</span> = np.sum(da, <span class="attr">axis</span> = <span class="number">0</span>)</span><br><span class="line">  <span class="attr">dx</span> = da.dot(Wx.T)</span><br><span class="line">  <span class="attr">dprev_h</span> = da.dot(Wh.T)</span><br><span class="line"></span><br><span class="line">  return dx, dprev_h, dprev_c, dWx, dWh, db</span><br></pre></td></tr></table></figure></p>
<h4 id="LSTM-forward"><a href="#LSTM-forward" class="headerlink" title="LSTM: forward"></a>LSTM: forward</h4><p>Implement the forward pass for an LSTM over an entire timeseries.<br><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">def lstm_forward(x, h0, Wx, <span class="keyword">Wh</span>, b):</span><br><span class="line">  <span class="string">""</span>"</span><br><span class="line">  Forward pass <span class="keyword">for</span> <span class="keyword">an</span> LSTM over <span class="keyword">an</span> entire sequence of data. We assume <span class="keyword">an</span> <span class="keyword">input</span></span><br><span class="line">  sequence composed of T vectors, each of dimension <span class="keyword">D</span>. The LSTM uses a hidden</span><br><span class="line">  size of <span class="keyword">H</span>, and we work over a minibatch containing <span class="keyword">N</span> sequences. After running</span><br><span class="line">  the LSTM forward, we <span class="keyword">return</span> the hidden states <span class="keyword">for</span> all timesteps.</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">Note</span> that the initial cell state is passed <span class="keyword">as</span> <span class="keyword">input</span>, but the initial cell</span><br><span class="line">  state is <span class="keyword">set</span> to zero. Also <span class="keyword">note</span> that the cell state is not returned; it is</span><br><span class="line">  <span class="keyword">an</span> internal variable to the LSTM and is not accessed from outside.</span><br><span class="line">  </span><br><span class="line">  Inputs:</span><br><span class="line">  - x: <span class="keyword">Input</span> data of shape (<span class="keyword">N</span>, T, <span class="keyword">D</span>)</span><br><span class="line">  - h0: Initial hidden state of shape (<span class="keyword">N</span>, <span class="keyword">H</span>)</span><br><span class="line">  - Wx: Weights <span class="keyword">for</span> <span class="keyword">input</span>-to-hidden connections, of shape (<span class="keyword">D</span>, 4H)</span><br><span class="line">  - <span class="keyword">Wh</span>: Weights <span class="keyword">for</span> hidden-to-hidden connections, of shape (<span class="keyword">H</span>, 4H)</span><br><span class="line">  - b: Biases of shape (4H,)</span><br><span class="line">  </span><br><span class="line">  Returns a tuple of:</span><br><span class="line">  - <span class="keyword">h</span>: Hidden states <span class="keyword">for</span> all timesteps of all sequences, of shape (<span class="keyword">N</span>, T, <span class="keyword">H</span>)</span><br><span class="line">  - cache: Values needed <span class="keyword">for</span> the backward pass.</span><br><span class="line">  <span class="string">""</span>"</span><br><span class="line">  <span class="keyword">h</span>, cache = None, None</span><br><span class="line"></span><br><span class="line">  <span class="keyword">N</span>, T, <span class="keyword">D</span> = x.shape</span><br><span class="line">  <span class="keyword">H</span> = b.shape[0]/4</span><br><span class="line">  <span class="keyword">h</span> = np.zeros((<span class="keyword">N</span>, T, <span class="keyword">H</span>))</span><br><span class="line">  cache = &#123;&#125;</span><br><span class="line">  prev_h = h0</span><br><span class="line">  prev_c = np.zeros((<span class="keyword">N</span>, <span class="keyword">H</span>))</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> t <span class="keyword">in</span> <span class="keyword">range</span>(T):</span><br><span class="line">    xt = x[:, t, :]</span><br><span class="line">    next_h, next_c, cache[t] = lstm_step_forward(xt, prev_h, prev_c, Wx, <span class="keyword">Wh</span>, b)</span><br><span class="line">    prev_h = next_h</span><br><span class="line">    prev_c = next_c</span><br><span class="line">    <span class="keyword">h</span>[:, t, :] = prev_h</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">h</span>, cache</span><br></pre></td></tr></table></figure></p>
<h4 id="LSTM-backward"><a href="#LSTM-backward" class="headerlink" title="LSTM: backward"></a>LSTM: backward</h4><p>Implement the backward pass for an LSTM over an entire timeseries of data<br><figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">def lstm_backward(dh, cache):</span><br><span class="line">  <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">  Backward pass for an LSTM over an entire sequence of data.]</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  Inputs:</span></span><br><span class="line"><span class="string">  - dh: Upstream gradients of hidden states, of shape (N, T, H)</span></span><br><span class="line"><span class="string">  - cache: Values from the forward pass</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  Returns a tuple of:</span></span><br><span class="line"><span class="string">  - dx: Gradient of input data of shape (N, T, D)</span></span><br><span class="line"><span class="string">  - dh0: Gradient of initial hidden state of shape (N, H)</span></span><br><span class="line"><span class="string">  - dWx: Gradient of input-to-hidden weight matrix of shape (D, 4H)</span></span><br><span class="line"><span class="string">  - dWh: Gradient of hidden-to-hidden weight matrix of shape (H, 4H)</span></span><br><span class="line"><span class="string">  - db: Gradient of biases, of shape (4H,)</span></span><br><span class="line"><span class="string">  "</span><span class="string">""</span></span><br><span class="line">  dx, dh0, dWx, dWh, <span class="attr">db</span> = None, None, None, None, None</span><br><span class="line">  </span><br><span class="line">  N, T, <span class="attr">H</span> = dh.shape</span><br><span class="line">  z_i, z_f, z_o, z_g, z_t, prev_c, prev_h, Wx, Wh, <span class="attr">x</span> = cache[T-<span class="number">1</span>]</span><br><span class="line">  <span class="attr">D</span> = x.shape[<span class="number">1</span>]</span><br><span class="line">    </span><br><span class="line">  <span class="attr">dprev_h</span> = np.zeros((N, H))</span><br><span class="line">  <span class="attr">dprev_c</span> = np.zeros((N, H))</span><br><span class="line">  <span class="attr">dx</span> = np.zeros((N, T, D))</span><br><span class="line">  <span class="attr">dh0</span> = np.zeros((N, H))</span><br><span class="line">  <span class="attr">dWx=</span> np.zeros((D, <span class="number">4</span>*H))</span><br><span class="line">  <span class="attr">dWh</span> = np.zeros((H, <span class="number">4</span>*H))</span><br><span class="line">  <span class="attr">db</span> = np.zeros((<span class="number">4</span>*H,))</span><br><span class="line">    </span><br><span class="line">  for t <span class="keyword">in</span> range(T):</span><br><span class="line">    <span class="attr">t</span> = T-<span class="number">1</span>-t</span><br><span class="line">    <span class="attr">step_cache</span> = cache[t]</span><br><span class="line">    <span class="attr">dnext_h</span> = dh[:,t,:] + dprev_h</span><br><span class="line">    <span class="attr">dnext_c</span> = dprev_c</span><br><span class="line">    dx[:,t,:], dprev_h, dprev_c, dWxt, dWht, <span class="attr">dbt</span> = lstm_step_backward(dnext_h, dnext_c, step_cache)</span><br><span class="line">    dWx, dWh, <span class="attr">db</span> = dWx+dWxt, dWh+dWht, db+dbt</span><br><span class="line">    </span><br><span class="line">  <span class="attr">dh0</span> = dprev_h  </span><br><span class="line">  </span><br><span class="line">  return dx, dh0, dWx, dWh, db</span><br></pre></td></tr></table></figure></p>
<h3 id="构建LSTM模型"><a href="#构建LSTM模型" class="headerlink" title="构建LSTM模型"></a>构建LSTM模型</h3><p>LSTM模型的构建与RNN模型大致相同，只有在传播时，根据不同的特点使用不同的前向传播与后向传播函数<br><figure class="highlight ceylon"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> self.cell<span class="number">_</span>type == <span class="string">'rnn'</span>:</span><br><span class="line">    rnn<span class="number">_</span>or<span class="number">_</span>lstm<span class="number">_</span><span class="keyword">out</span>, rnn<span class="number">_</span>cache = rnn<span class="number">_f</span>orward(word<span class="number">_</span>embedding<span class="number">_</span><span class="keyword">out</span>, affine<span class="number">_</span><span class="keyword">out</span>, Wx, Wh, b)</span><br><span class="line">elif self.cell<span class="number">_</span>type == <span class="string">'lstm'</span>:</span><br><span class="line">    rnn<span class="number">_</span>or<span class="number">_</span>lstm<span class="number">_</span><span class="keyword">out</span>, lstm<span class="number">_</span>cache = lstm<span class="number">_f</span>orward(word<span class="number">_</span>embedding<span class="number">_</span><span class="keyword">out</span>, affine<span class="number">_</span><span class="keyword">out</span>, Wx, Wh, b)</span><br></pre></td></tr></table></figure></p>
<h4 id="Overfit-LSTM-captioning-model"><a href="#Overfit-LSTM-captioning-model" class="headerlink" title="Overfit LSTM captioning model"></a>Overfit LSTM captioning model</h4><p>overfit an LSTM captioning model on the same small dataset as we used for the RNN above.<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">small_data = load_coco_data(<span class="attribute">max_train</span>=50)</span><br><span class="line"></span><br><span class="line">small_lstm_model = CaptioningRNN(</span><br><span class="line">          <span class="attribute">cell_type</span>=<span class="string">'lstm'</span>,</span><br><span class="line">          <span class="attribute">word_to_idx</span>=data[<span class="string">'word_to_idx'</span>],</span><br><span class="line">          <span class="attribute">input_dim</span>=data[<span class="string">'train_features'</span>].shape[1],</span><br><span class="line">          <span class="attribute">hidden_dim</span>=512,</span><br><span class="line">          <span class="attribute">wordvec_dim</span>=256,</span><br><span class="line">          <span class="attribute">dtype</span>=np.float32,</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">small_lstm_solver = CaptioningSolver(small_lstm_model, small_data,</span><br><span class="line">           <span class="attribute">update_rule</span>=<span class="string">'adam'</span>,</span><br><span class="line">           <span class="attribute">num_epochs</span>=50,</span><br><span class="line">           <span class="attribute">batch_size</span>=25,</span><br><span class="line">           optim_config=&#123;</span><br><span class="line">             <span class="string">'learning_rate'</span>: 5e-3,</span><br><span class="line">           &#125;,</span><br><span class="line">           <span class="attribute">lr_decay</span>=0.995,</span><br><span class="line">           <span class="attribute">verbose</span>=<span class="literal">True</span>, <span class="attribute">print_every</span>=10,</span><br><span class="line">         )</span><br><span class="line"></span><br><span class="line">small_lstm_solver.train()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Plot the training losses</span></span><br><span class="line">plt.plot(small_lstm_solver.loss_history)</span><br><span class="line">plt.xlabel(<span class="string">'Iteration'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Loss'</span>)</span><br><span class="line">plt.title(<span class="string">'Training loss history'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p>
<p>经过一系列训练后loss函数降到大概0左右<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/cs231n/chapter6/p8.png" alt></p>
<h4 id="LSTM-test-time-sampling"><a href="#LSTM-test-time-sampling" class="headerlink" title="LSTM test-time sampling"></a>LSTM test-time sampling</h4><p>sample from your overfit LSTM model on some training and validation set samples<br><figure class="highlight hsp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="keyword">split</span> in [<span class="string">'train'</span>, <span class="string">'val'</span>]:</span><br><span class="line">  minibatch = sample_coco_minibatch(small_data, <span class="keyword">split</span>=<span class="keyword">split</span>, batch_size=<span class="number">2</span>)</span><br><span class="line">  gt_captions, features, urls = minibatch</span><br><span class="line">  gt_captions = decode_captions(gt_captions, data[<span class="string">'idx_to_word'</span>])</span><br><span class="line"></span><br><span class="line">  sample_captions = small_lstm_model.sample(features)</span><br><span class="line">  sample_captions = decode_captions(sample_captions, data[<span class="string">'idx_to_word'</span>])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> gt_caption, sample_caption, url in zip(gt_captions, sample_captions, urls):</span><br><span class="line">    plt.imshow(image_from_url(url))</span><br><span class="line">    plt.title(<span class="string">'%s\n%s\nGT:%s'</span> % (<span class="keyword">split</span>, sample_caption, gt_caption))</span><br><span class="line">    plt.axis(<span class="string">'off'</span>)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure></p>
<p>根据结果可知在training上表现良好，在validation上表现不佳，这是因为过拟合的原因。<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/cs231n/chapter6/p9.png" alt><br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/cs231n/chapter6/p10.png" alt></p>
<h4 id="Train-a-good-captioning-model"><a href="#Train-a-good-captioning-model" class="headerlink" title="Train a good captioning model"></a>Train a good captioning model</h4><p>Using the pieces you have implemented in this and the previous notebook, try to train a captioning model that gives decent qualitative results (better than the random garbage you saw with the overfit models) when sampling on the validation set. You can subsample the training set if you want; we just want to see samples on the validatation set that are better than random.<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">small_data2 = load_coco_data(<span class="attribute">max_train</span>=5000)</span><br><span class="line"></span><br><span class="line">good_lstm_model = CaptioningRNN(</span><br><span class="line">          <span class="attribute">cell_type</span>=<span class="string">'lstm'</span>,</span><br><span class="line">          <span class="attribute">word_to_idx</span>=data[<span class="string">'word_to_idx'</span>],</span><br><span class="line">          <span class="attribute">input_dim</span>=data[<span class="string">'train_features'</span>].shape[1],</span><br><span class="line">          <span class="attribute">hidden_dim</span>=512,</span><br><span class="line">          <span class="attribute">wordvec_dim</span>=256,</span><br><span class="line">          <span class="attribute">dtype</span>=np.float32,</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">good_lstm_solver = CaptioningSolver(good_lstm_model, small_data2,</span><br><span class="line">           <span class="attribute">update_rule</span>=<span class="string">'adam'</span>,</span><br><span class="line">           <span class="attribute">num_epochs</span>=50,</span><br><span class="line">           <span class="attribute">batch_size</span>=25,</span><br><span class="line">           optim_config=&#123;</span><br><span class="line">             <span class="string">'learning_rate'</span>: 5e-3,</span><br><span class="line">           &#125;,</span><br><span class="line">           <span class="attribute">lr_decay</span>=0.995,</span><br><span class="line">           <span class="attribute">verbose</span>=<span class="literal">True</span>, <span class="attribute">print_every</span>=10,</span><br><span class="line">         )</span><br><span class="line"></span><br><span class="line">good_lstm_solver.train()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Plot the training losses</span></span><br><span class="line">plt.plot(good_lstm_solver.loss_history)</span><br><span class="line">plt.xlabel(<span class="string">'Iteration'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Loss'</span>)</span><br><span class="line">plt.title(<span class="string">'Training loss history'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p>
<p>使用一个5000的训练集，使我们的模型不那么容易过拟合，loss history如下：<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/cs231n/chapter6/p11.png" alt><br>将上面得到的模型在训练集与测试集上都进行测试<br><figure class="highlight hsp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="keyword">split</span> in [<span class="string">'train'</span>, <span class="string">'val'</span>]:</span><br><span class="line">  minibatch = sample_coco_minibatch(small_data2, <span class="keyword">split</span>=<span class="keyword">split</span>, batch_size=<span class="number">2</span>)</span><br><span class="line">  gt_captions, features, urls = minibatch</span><br><span class="line">  gt_captions = decode_captions(gt_captions, data[<span class="string">'idx_to_word'</span>])</span><br><span class="line"></span><br><span class="line">  sample_captions = good_lstm_model.sample(features)</span><br><span class="line">  sample_captions = decode_captions(sample_captions, data[<span class="string">'idx_to_word'</span>])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> gt_caption, sample_caption, url in zip(gt_captions, sample_captions, urls):</span><br><span class="line">    plt.imshow(image_from_url(url))</span><br><span class="line">    plt.title(<span class="string">'%s\n%s\nGT:%s'</span> % (<span class="keyword">split</span>, sample_caption, gt_caption))</span><br><span class="line">    plt.axis(<span class="string">'off'</span>)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure></p>
<p>从图中可以看出，加大训练集后，不过过拟合了，训练集准确度下降，validation集准确度上升，比起random的情况，还是好一点的，但结果还是相当不理想的。<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/cs231n/chapter6/p12.png" alt><br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/cs231n/chapter6/p13.png" alt></p>
]]></content>
      <tags>
        <tag>计算机视觉</tag>
      </tags>
  </entry>
  <entry>
    <title>tensorflow实现第一个神经网络</title>
    <url>/blog/2017/05/tensorflow-first-layer.html</url>
    <content><![CDATA[<p>本文实现利用tensorflow实现一个简单的三层神经网络</p>
<h3 id="添加层"><a href="#添加层" class="headerlink" title="添加层"></a>添加层</h3><p>构造添加一个神经层的函数<br>在 Tensorflow 里定义一个添加层的函数可以很容易的添加神经层,为之后的添加省下不少时间.<br>神经层里常见的参数通常有weights、biases和激励函数。<br>定义添加神经层的函数def add_layer(),它有四个参数：输入值、输入的大小、输出的大小和激励函数，我们设定默认的激励函数是None<br>接下来，我们开始定义weights和biases。</p>
<p>因为在生成初始参数时，随机变量(normal distribution)会比全部为0要好很多，所以我们这里的weights为一个in_size行, out_size列的随机变量矩阵。<br>在机器学习中，biases的推荐值不为0，所以我们这里是在0向量的基础上又加了0.1<br>具体代码如下：<br><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">def add_layer(inputs, in_size, out_size, activation_function=None):</span><br><span class="line">    Weights = <span class="keyword">tf</span>.Variable(<span class="keyword">tf</span>.random_normal([in_size, out_size]))</span><br><span class="line">    biases = <span class="keyword">tf</span>.Variable(<span class="keyword">tf</span>.zeros([<span class="number">1</span>, out_size]) + <span class="number">0.1</span>)</span><br><span class="line">    Wx_plus_b = <span class="keyword">tf</span>.matmul(inputs, Weights) + biases</span><br><span class="line">    <span class="keyword">if</span> activation_function <span class="keyword">is</span> None:</span><br><span class="line">        outputs = Wx_plus_b</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        outputs = activation_function(Wx_plus_b)</span><br><span class="line">    <span class="keyword">return</span> outputs</span><br></pre></td></tr></table></figure></p>
<h3 id="构建数据"><a href="#构建数据" class="headerlink" title="构建数据"></a>构建数据</h3><p>构建所需的数据。 这里的x_data和y_data并不是严格的一元二次函数的关系，因为我们多加了一个noise,这样看起来会更像真实情况。<br><figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">x_data = <span class="built_in">np</span>.linspace(-<span class="number">1</span>,<span class="number">1</span>,<span class="number">300</span>, dtype=<span class="built_in">np</span>.float32)[:, <span class="built_in">np</span>.newaxis]</span><br><span class="line">noise = <span class="built_in">np</span>.<span class="built_in">random</span>.normal(<span class="number">0</span>, <span class="number">0.05</span>, x_data.shape).astype(<span class="built_in">np</span>.float32)</span><br><span class="line">y_data = <span class="built_in">np</span>.square(x_data) - <span class="number">0.5</span> + noise</span><br></pre></td></tr></table></figure></p>
<p>利用占位符定义我们所需的神经网络的输入。 tf.placeholder()就是代表占位符，这里的None代表无论输入有多少都可以，因为输入只有一个特征，所以这里是1。<br><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">xs</span> = tf.placeholder(tf.float32, [None, <span class="number">1</span>])</span><br><span class="line"><span class="attr">ys</span> = tf.placeholder(tf.float32, [None, <span class="number">1</span>])</span><br></pre></td></tr></table></figure></p>
<h3 id="定义神经层"><a href="#定义神经层" class="headerlink" title="定义神经层"></a>定义神经层</h3><p>接下来，我们就可以开始定义神经层了。 通常神经层都包括输入层、隐藏层和输出层。这里的输入层只有一个属性， 所以我们就只有一个输入；隐藏层我们可以自己假设，这里我们假设隐藏层有10个神经元； 输出层和输入层的结构是一样的，所以我们的输出层也是只有一层。 所以，我们构建的是——输入层1个、隐藏层10个、输出层1个的神经网络。</p>
<p>下面，我们开始定义隐藏层,利用之前的add_layer()函数，这里使用 Tensorflow 自带的激励函数tf.nn.relu。<br><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">l1</span> = add_layer(xs, <span class="number">1</span>, <span class="number">10</span>, activation_function=tf.nn.relu)</span><br></pre></td></tr></table></figure></p>
<p>接着，定义输出层。此时的输入就是隐藏层的输出——l1，输入有10层（隐藏层的输出层），输出有1层。<br><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">prediction</span> = add_layer(l1, <span class="number">10</span>, <span class="number">1</span>, activation_function=None)</span><br></pre></td></tr></table></figure></p>
<p>计算预测值prediction和真实值的误差，对二者差的平方求和再取平均。<br><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">loss = <span class="keyword">tf</span>.reduce_mean(<span class="keyword">tf</span>.reduce_sum(<span class="keyword">tf</span>.square(ys - prediction),</span><br><span class="line">                     reduction_indices=[<span class="number">1</span>]))</span><br></pre></td></tr></table></figure></p>
<p>接下来，是很关键的一步，如何让机器学习提升它的准确率。tf.train.GradientDescentOptimizer()中的值通常都小于1，这里取的是0.1，代表以0.1的效率来最小化误差loss。<br><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">train_step</span> = tf.train.GradientDescentOptimizer(<span class="number">0.1</span>).minimize(loss)</span><br></pre></td></tr></table></figure></p>
<p>使用变量时，都要对它进行初始化，这是必不可少的。<br><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment"># init = tf.initialize_all_variables() # tf 马上就要废弃这种写法</span></span><br><span class="line"><span class="attr">init</span> = tf.global_variables_initializer()  <span class="comment"># 替换成这样就好</span></span><br></pre></td></tr></table></figure></p>
<p>定义Session，并用 Session 来执行 init 初始化步骤。 （注意：在tensorflow中，只有session.run()才会执行我们定义的运算。）<br><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">sess = tf.Session()</span><br><span class="line">sess.<span class="keyword">run</span><span class="bash">(init)</span></span><br></pre></td></tr></table></figure></p>
<h3 id="开始学习"><a href="#开始学习" class="headerlink" title="开始学习"></a>开始学习</h3><p>比如这里，我们让机器学习1000次。机器学习的内容是train_step, 用 Session 来 run 每一次 training 的数据，逐步提升神经网络的预测准确性。 (注意：当运算要用到placeholder时，就需要feed_dict这个字典来指定输入。)<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(1000):</span><br><span class="line">    # training</span><br><span class="line">    sess.<span class="builtin-name">run</span>(train_step, feed_dict=&#123;xs: x_data, ys: y_data&#125;)</span><br><span class="line">每50步我们输出一下机器学习的误差。</span><br><span class="line">    <span class="keyword">if</span> i % 50 == 0:</span><br><span class="line">        # <span class="keyword">to</span> see the <span class="keyword">step</span> improvement</span><br><span class="line">        <span class="builtin-name">print</span>(sess.<span class="builtin-name">run</span>(loss, feed_dict=&#123;xs: x_data, ys: y_data&#125;))</span><br></pre></td></tr></table></figure></p>
<p>在电脑上运行本次代码的结果为：<br>可以看出随着迭代次数的增加，loss越来越小，这说明训练还是有效的<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/chapter3/p2.png" alt></p>
<h3 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h3><p>构建图形，用散点图描述真实数据之间的关系。 （注意：plt.ion()用于连续显示。）<br><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># plot the real data</span></span><br><span class="line">fig = plt.figure()</span><br><span class="line">ax = fig.add_subplot(1,1,1)</span><br><span class="line">ax.scatter(x_data, y_data)</span><br><span class="line">plt.ion()<span class="comment">#本次运行请注释，全局运行不要注释</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p>
<p>散点图的结果为：<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/chapter3/p4.png" alt><br>接下来，我们来显示预测数据。</p>
<p>每隔50次训练刷新一次图形，用红色、宽度为5的线来显示我们的预测数据和输入之间的关系，并暂停0.1s。<br><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">for i in range(<span class="number">1000</span>):</span><br><span class="line">    <span class="comment"># training</span></span><br><span class="line">    sess.<span class="keyword">run</span><span class="bash">(train_step, feed_dict=&#123;xs: x_data, ys: y_data&#125;)</span></span><br><span class="line">    if i % <span class="number">50</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># to visualize the result and improvement</span></span><br><span class="line">        try:</span><br><span class="line">            ax.lines.remove(lines[<span class="number">0</span>])</span><br><span class="line">        except Exception:</span><br><span class="line">            pass</span><br><span class="line">        prediction_value = sess.<span class="keyword">run</span><span class="bash">(prediction, feed_dict=&#123;xs: x_data&#125;)</span></span><br><span class="line">        <span class="comment"># plot the prediction</span></span><br><span class="line">        lines = ax.plot(x_data, prediction_value, <span class="string">'r-'</span>, lw=<span class="number">5</span>)</span><br><span class="line">        plt.pause(<span class="number">0.1</span>)</span><br></pre></td></tr></table></figure></p>
<p>最后，机器学习的结果为：<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/chapter3/p3.png" alt></p>
<p>完整代码如下：<br><figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">from __future__ <span class="built_in">import</span> print_function</span><br><span class="line"><span class="built_in">import</span> tensorflow as tf</span><br><span class="line"><span class="built_in">import</span> numpy as np</span><br><span class="line"><span class="built_in">import</span> matplotlib.pyplot as plt</span><br><span class="line"></span><br><span class="line">def add_layer(inputs, in_size, out_size, <span class="attr">activation_function=None):</span></span><br><span class="line">    <span class="attr">Weights</span> = tf.Variable(tf.random_normal([in_size, out_size]))</span><br><span class="line">    <span class="attr">biases</span> = tf.Variable(tf.zeros([<span class="number">1</span>, out_size]) + <span class="number">0.1</span>)</span><br><span class="line">    <span class="attr">Wx_plus_b</span> = tf.matmul(inputs, Weights) + biases</span><br><span class="line">    <span class="keyword">if</span> activation_function is None:</span><br><span class="line">        <span class="attr">outputs</span> = Wx_plus_b</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="attr">outputs</span> = activation_function(Wx_plus_b)</span><br><span class="line">    return outputs</span><br><span class="line"></span><br><span class="line"><span class="comment"># Make up some real data</span></span><br><span class="line"><span class="attr">x_data</span> = np.linspace(-<span class="number">1</span>, <span class="number">1</span>, <span class="number">300</span>)[:, np.newaxis]</span><br><span class="line"><span class="attr">noise</span> = np.random.normal(<span class="number">0</span>, <span class="number">0.05</span>, x_data.shape)</span><br><span class="line"><span class="attr">y_data</span> = np.square(x_data) - <span class="number">0.5</span> + noise</span><br><span class="line"></span><br><span class="line"><span class="comment">##plt.scatter(x_data, y_data)</span></span><br><span class="line"><span class="comment">##plt.show()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># define placeholder for inputs to network</span></span><br><span class="line"><span class="attr">xs</span> = tf.placeholder(tf.float32, [None, <span class="number">1</span>])</span><br><span class="line"><span class="attr">ys</span> = tf.placeholder(tf.float32, [None, <span class="number">1</span>])</span><br><span class="line"><span class="comment"># add hidden layer</span></span><br><span class="line"><span class="attr">l1</span> = add_layer(xs, <span class="number">1</span>, <span class="number">10</span>, <span class="attr">activation_function=tf.nn.relu)</span></span><br><span class="line"><span class="comment"># add output layer</span></span><br><span class="line"><span class="attr">prediction</span> = add_layer(l1, <span class="number">10</span>, <span class="number">1</span>, <span class="attr">activation_function=None)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># the error between prediction and real data</span></span><br><span class="line"><span class="attr">loss</span> = tf.reduce_mean(tf.reduce_sum(tf.square(ys-prediction), <span class="attr">reduction_indices=[1]))</span></span><br><span class="line"><span class="attr">train_step</span> = tf.train.GradientDescentOptimizer(<span class="number">0.1</span>).minimize(loss)</span><br><span class="line"><span class="comment"># important step</span></span><br><span class="line"><span class="attr">sess</span> = tf.Session()</span><br><span class="line"><span class="comment"># tf.initialize_all_variables() no long valid from</span></span><br><span class="line"><span class="comment"># 2017-03-02 if using tensorflow &gt;= 0.12</span></span><br><span class="line"><span class="keyword">if</span> int((tf.__version__).split('.')[<span class="number">1</span>]) &lt; <span class="number">12</span> <span class="literal">and</span> int((tf.__version__).split('.')[<span class="number">0</span>]) &lt; <span class="number">1</span>:</span><br><span class="line">    <span class="attr">init</span> = tf.initialize_all_variables()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="attr">init</span> = tf.global_variables_initializer()</span><br><span class="line">sess.run(init)</span><br><span class="line"></span><br><span class="line"><span class="comment"># plot the real data</span></span><br><span class="line"><span class="attr">fig</span> = plt.figure()</span><br><span class="line"><span class="attr">ax</span> = fig.add_subplot(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">ax.scatter(x_data, y_data)</span><br><span class="line">plt.ion()</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for i <span class="keyword">in</span> range(<span class="number">1000</span>):</span><br><span class="line">    <span class="comment"># training</span></span><br><span class="line">    sess.run(train_step, <span class="attr">feed_dict=&#123;xs:</span> x_data, ys: y_data&#125;)</span><br><span class="line">    <span class="keyword">if</span> i % <span class="number">50</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># to visualize the result and improvement</span></span><br><span class="line">        try:</span><br><span class="line">            ax.lines.remove(lines[<span class="number">0</span>])</span><br><span class="line">        except Exception:</span><br><span class="line">            pass</span><br><span class="line">        <span class="attr">prediction_value</span> = sess.run(prediction, <span class="attr">feed_dict=&#123;xs:</span> x_data&#125;)</span><br><span class="line">        <span class="comment"># plot the prediction</span></span><br><span class="line">        <span class="attr">lines</span> = ax.plot(x_data, prediction_value, 'r-', <span class="attr">lw=5)</span></span><br><span class="line">        plt.pause(<span class="number">1</span>)</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title>读《Lean In》</title>
    <url>/blog/2017/05/lean-in-read.html</url>
    <content><![CDATA[<blockquote>
<p>命运偏爱勇者，向前一步。</p>
</blockquote>
<p>&emsp;&emsp;《Lean In》，中文名译作《向前一步》，作者是Facebook首席运营官谢丽尔·桑德伯格，据说是硅谷最有影响力的女人。在我的印象中，以前好像看过她在伯克利大学毕业典礼的演讲，当时的主题是我从死亡中所学到的，讲述了丈夫的死去对她的影响，而看完本书，也就了解他们夫妻二人的深厚感情与彼此的默契，Dave的确是一个好丈夫，作者在本书的扉页上写到：致养育我的父母，他们让我相信一切皆有可能。致我的丈夫，他让一切变成可能。</p>
<p><center><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/blog/p1.jpg"></center><br>&emsp;&emsp;《Lean In》的主要观点其实可以用一句话来说明，作者认为更多的女性进入政府，公司，学界的高层，可以真正的改善女性的地位。在我看来，作者的观点可以说看到了权力的本质。权力不来源与施舍与同情，也不来源与同情与理解，当越来越多的女性占据高层地位时，权力的天平才会向女性那边倾斜。当然这仅仅是一方面，在当今社会，高层固然大多是男性，但底层社会的男权思想才是最严重的，而这种思想明显来源于底层男性身体，体力上的优势，而不是高层是男性对其产生了什么加持。所以到最后，还是归结到生产力问题上，现在在底层社会，体力仍然是生产力的一个重要因素，如果有一天，生产力科技足够发达，人类个人的体力无足轻重了，或者在劳动时体力不再是一个重要因素了，男女平等才 能真正实现吧。</p>
<p>&emsp;&emsp;在当前这个社会，不需讳言，女性的确处于一种劣势情况。这种劣势不仅是制度上的，也是文化上的，不仅是外在的，有些也是内化于一些女性内心中的，书中提到，有能力的人因自我怀疑而苦恼，这种现象有它的学名——“负担症候群”。无论男女都容易出现这样的症状，但女性会更严重，也会更多地受其限制，女性往往对自身的评论普遍低于实际，而男性则过高地评价自己的表现，男性往往把成功归结于内在的能力与技巧，而女性则会将成功归结于外部因素。在家务活动上，女性的家务工作量比男性多两倍，并且当工作与家庭发生冲突时，做出牺牲的也大部分是女性。在社会层面上，男性的受欢迎程度与他的成功度成正比，对于女性来说，却成反比，过于成功的女性让人感觉不安全。更加值得让人深思的是，在很多时候，阻碍更多女性获得权力的因素，是已经成功的女性，这种现象称为蜂后现象。当然上述说法都不是一定的，还有点像地图炮，但都是基于统计学得到的结论，只能说大部分是这样的。</p>
<p>&emsp;&emsp;作者当然也给出了一些建议，当然也有一些鸡汤，作者鼓励女性也要充满野心，在开会时，勇敢的往前坐，勇敢的问问题与举手。作者也提到，人不应该为还没到来的事担心，不应该因为胆怯与多虑丢失自己的机会，比如有一个新的机会摆在面前时，女性只有认为百分百符合条件才会申请，而男性只要60%，所以不要说我没准备好，而要去想:我想做，而且我可以边做边学。 Alice walkr的一句话:放弃自己的力量最常见的方式是，就是认为自己毫无力量。 当选择一份工作时，只有一个标准最重要，它是否能让你成长。。又比如在一个提拔的机会摆在面前时，有的女性会担心这样会太忙，不利于家庭，或者自己准备要孩子，或者考虑到以后的种种等，作者认为，在问题还没有到来时，不要因为它而烦恼，更不要因它而放弃机会，事实上，有些女性面对工作的机会充满恐惧，恐惧自己不能兼顾家庭生活，如果没有恐惧，女性就能自由的追求职业生涯的成功以及个人生活的幸福，并且能够自由地选择前者或后者。当然，家庭与工作的平衡似乎是成功女性的永恒问题，作者建议当女性需要在工作上发愤图强时，男性就需要在家里发挥更大的作用，要保持工作与家庭的平衡，要维护这样一种脆弱的平衡，需要不停地沟通，保持坦诚和宽容。我们绝不是在任何时候都刻意将家务对半分担，完全的平等是很难定义或维持的，我们允许情况偶尔有所偏向。要维持一种这样的默契与平衡，一个默契与理解的丈夫必不可少，作者的丈夫Dave就是一个这样的人。</p>
<p>&emsp;&emsp;看这本书，可以发现，中国有的很多问题，美国也有，甚至比中国还要严重一点。就比如美国的基础设施对双职工家庭并不友好，好像是因为缺少那种全托的托儿所之类的。一个典型的美国家庭通常也是丈夫在外工作，妻子是家庭主妇，毕竟美国是西方国家中宗教氛围最深厚的国家，并且美国似乎没有法定的产假，比起北欧国家不知道差到哪里去了。一个有趣的现象是，在这几年，女权运动在中国颇为流行，很多人都喜欢标一个女权主义的头衔并且引以为荣，但在美国，女权运动的发展似乎比中国早了一个阶段，在美国人眼中，女权主义者是一群粗鲁，刻薄，厌恶男性，或者通标新立异来吸引人，总而言之，美国的女权主义者并不那种很酷的，可以吸引人加入他们之中的一群人，在如今，只有少于3成的美国人承认自己是女权主义者。在我看来，这才是正常现象，中国的女权主义运动有种被消费的感觉，在通常一场革命中，最具有战斗性与反抗性的往往是被压迫最深的，而这些人往往是社会的Loser或者说边缘人物,毛泽东曾说:革命不是请客吃饭，不是做文章，不是绘画绣花，不能那样雅致，那样从容不迫，文质彬彬，那样温良恭俭让。革命是暴动，是一个阶级推翻一个阶级的暴烈的行动。在改变与反抗社会，与落后势力在做殊死斗争时，还能那样优雅，那样从容，那样温良恭俭让，天下哪有这样的好事。</p>
<p>&emsp;&emsp;最后，用谢丽尔·桑德伯格的欺许结尾吧：我们要摒弃旧观念，为创造一个新世界而努力，不管是男孩还是女孩，都会在未来给予自己更多的选择。</p>
]]></content>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>TensorFlow基础知识</title>
    <url>/blog/2017/05/tensorlfow-foundation-knowledge.html</url>
    <content><![CDATA[<p>Tensorflow 首先要定义神经网络的结构, 然后再把数据放入结构当中去运算和 training.<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/chapter3/tensors_flowing.gif" alt></p>
<p>因为TensorFlow是采用数据流图（data　flow　graphs）来计算, 所以首先我们得创建一个数据流流图, 然后再将我们的数据（数据以张量(tensor)的形式存在）放在数据流图中计算. 节点（Nodes）在图中表示数学操作,图中的线（edges）则表示在节点间相互联系的多维数据数组, 即张量（tensor). 训练模型时tensor会不断的从数据流图中的一个节点flow到另一节点, 这就是TensorFlow名字的由来.</p>
<p>张量（tensor)的定义:<br>张量有多种. 零阶张量为 纯量或标量 (scalar) 也就是一个数值. 比如 [1]<br>一阶张量为 向量 (vector), 比如 一维的 [1, 2, 3]<br>二阶张量为 矩阵 (matrix), 比如 二维的 [[1, 2, 3],[4, 5, 6],[7, 8, 9]]<br>以此类推, 还有 三阶 三维的 …</p>
<h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3><h4 id="Session-会话控制"><a href="#Session-会话控制" class="headerlink" title="Session 会话控制"></a>Session 会话控制</h4><p>Session 是 Tensorflow 为了控制,和输出文件的执行的语句. 运行 session.run() 可以获得你要得知的运算结果, 或者是你所要运算的部分.<br>我们下面示例建立两个 matrix ,输出两个 matrix 矩阵相乘的结果：<br><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">import tensorflow as tf</span><br><span class="line"></span><br><span class="line"># <span class="built_in">create</span> two matrixes</span><br><span class="line"></span><br><span class="line">matrix1 = tf.constant(<span class="string">[[3,3]]</span>)</span><br><span class="line">matrix2 = tf.constant(<span class="string">[[2],</span></span><br><span class="line"><span class="string">                       [2]]</span>)</span><br><span class="line">product = tf.matmul(matrix1,matrix2)</span><br></pre></td></tr></table></figure></p>
<p>因为 product 不是直接计算的步骤, 所以我们会要使用 Session 来激活 product 并的到计算结果. 有两种形式使用会话控制 Session 。<br><figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line"># <span class="function"><span class="keyword">method</span> 1</span></span><br><span class="line"><span class="function"><span class="title">sess</span> = <span class="title">tf</span>.<span class="title">Session</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">result</span> = <span class="title">sess</span>.<span class="title">run</span><span class="params">(product)</span></span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(<span class="keyword">result</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">sess</span>.<span class="title">close</span><span class="params">()</span></span></span><br><span class="line"><span class="function"># [[12]]</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"># <span class="title">method</span> 2</span></span><br><span class="line"><span class="function"><span class="title">with</span> <span class="title">tf</span>.<span class="title">Session</span><span class="params">()</span> <span class="title">as</span> <span class="title">sess</span>:</span></span><br><span class="line">    result2 = sess.run(product)</span><br><span class="line">    print(result2)</span><br><span class="line"># [[<span class="number">12</span>]]</span><br></pre></td></tr></table></figure></p>
<h4 id="Variable-变量"><a href="#Variable-变量" class="headerlink" title="Variable 变量"></a>Variable 变量</h4><p>在 Tensorflow 中，定义了某字符串是变量，它才是变量，这一点是与 Python 所不同的。</p>
<p>定义语法： state = tf.Variable()<br><figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">import tensorflow as tf</span><br><span class="line"></span><br><span class="line"><span class="keyword">state</span> = tf.Variable(<span class="number">0</span>, name='counter')</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义常量 one</span></span><br><span class="line">one = tf.constant(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义加法步骤 (注: 此步并没有直接计算)</span></span><br><span class="line">new_value = tf.add(<span class="keyword">state</span>, one)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 State 更新成 new_value</span></span><br><span class="line">update = tf.assign(<span class="keyword">state</span>, new_value)</span><br></pre></td></tr></table></figure></p>
<p>如果你在 Tensorflow 中设定了变量，那么初始化变量是最重要的！！所以定义了变量以后, 一定要定义 init = tf.global_variables_initializer() .</p>
<p>到这里变量还是没有被激活，需要再在 sess 里, sess.run(init) , 激活 init 这一步.<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如果定义 Variable, 就一定要 initialize</span></span><br><span class="line"><span class="comment"># init = tf.initialize_all_variables() # tf 马上就要废弃这种写法</span></span><br><span class="line">init = tf.global_variables_initializer()  # 替换成这样就好</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 使用 Session</span></span><br><span class="line">with tf.Session() as sess:</span><br><span class="line">    sess.<span class="builtin-name">run</span>(init)</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(3):</span><br><span class="line">        sess.<span class="builtin-name">run</span>(update)</span><br><span class="line">        <span class="builtin-name">print</span>(sess.<span class="builtin-name">run</span>(state))</span><br></pre></td></tr></table></figure></p>
<h4 id="Placeholder-传入值"><a href="#Placeholder-传入值" class="headerlink" title="Placeholder 传入值"></a>Placeholder 传入值</h4><p>placeholder 是 Tensorflow 中的占位符，暂时储存变量.</p>
<p>Tensorflow 如果想要从外部传入data, 那就需要用到 tf.placeholder(), 然后以这种形式传输数据 sess.run(<strong>*, feed_dict={input: </strong>}).<br>示例如下：<br><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">import tensorflow <span class="keyword">as</span> <span class="keyword">tf</span></span><br><span class="line"></span><br><span class="line">#在 Tensorflow 中需要定义 placeholder 的 <span class="built_in">type</span> ，一般为 float32 形式</span><br><span class="line">input1 = <span class="keyword">tf</span>.placeholder(<span class="keyword">tf</span>.float32)</span><br><span class="line">input2 = <span class="keyword">tf</span>.placeholder(<span class="keyword">tf</span>.float32)</span><br><span class="line"></span><br><span class="line"># mul = multiply 是将input1和input2 做乘法运算，并输出为 output </span><br><span class="line">ouput = <span class="keyword">tf</span>.multiply(input1, input2)</span><br></pre></td></tr></table></figure></p>
<p>接下来, 传值的工作交给了 sess.run() , 需要传入的值放在了feed_dict={} 并一一对应每一个 input. placeholder 与 feed_dict={} 是绑定在一起出现的。<br><figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line">with tf.Session() as sess:</span><br><span class="line">    <span class="keyword">print</span>(sess.<span class="keyword">run</span>(ouput, feed_dict=&#123;input1: [<span class="number">7.</span>], input2: [<span class="number">2.</span>]&#125;))</span><br><span class="line"><span class="meta"># [ 14.]</span></span><br></pre></td></tr></table></figure></p>
<h3 id="tf运行结构示例"><a href="#tf运行结构示例" class="headerlink" title="tf运行结构示例"></a>tf运行结构示例</h3><p>我们构建并运行一个结构，实现拟合我们输入数据的过程<br>首先, 我们这次需要加载 tensorflow 和 numpy 两个模块, 并且使用 numpy 来创建我们的数据.<br><figure class="highlight elm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"># create data</span><br><span class="line"><span class="title">x_data</span> = np.random.rand(<span class="number">100</span>).<span class="keyword">as</span><span class="keyword">type</span>(np.float32)</span><br><span class="line"><span class="title">y_data</span> = x_data*<span class="number">0.1</span> + <span class="number">0.3</span></span><br></pre></td></tr></table></figure></p>
<p>接着, 我们用 tf.Variable 来创建描述 y 的参数. 我们可以把 y_data = x_data<em>0.1 + 0.3 想象成 y=Weights </em> x + biases, 然后神经网络也就是学着把 Weights 变成 0.1, biases 变成 0.3.<br><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">Weights</span> = tf.Variable(tf.random_uniform([<span class="number">1</span>], -<span class="number">1.0</span>, <span class="number">1.0</span>))</span><br><span class="line"><span class="attr">biases</span> = tf.Variable(tf.zeros([<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line"><span class="attr">y</span> = Weights*x_data + biases</span><br></pre></td></tr></table></figure></p>
<p>接着就是计算 y 和 y_data 的误差:<br><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">loss</span> = tf.reduce_mean(tf.square(y-y_data))</span><br></pre></td></tr></table></figure></p>
<p>反向传递误差的工作就教给optimizer了, 我们使用的误差传递方法是梯度下降法: Gradient Descent 让后我们使用 optimizer 来进行参数的更新.<br><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">optimizer</span> = tf.train.GradientDescentOptimizer(<span class="number">0.5</span>)</span><br><span class="line"><span class="attr">train</span> = optimizer.minimize(loss)</span><br></pre></td></tr></table></figure></p>
<p>到目前为止, 我们只是建立了神经网络的结构, 还没有使用这个结构. 在使用这个结构之前, 我们必须先初始化所有之前定义的Variable, 所以这一步是很重要的!<br><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment"># init = tf.initialize_all_variables() # tf 马上就要废弃这种写法</span></span><br><span class="line"><span class="attr">init</span> = tf.global_variables_initializer()  <span class="comment"># 替换成这样就好</span></span><br></pre></td></tr></table></figure></p>
<p>接着,我们再创建会话 Session. 我们会在下一节中详细讲解 Session. 我们用 Session 来执行 init 初始化步骤. 并且, 用 Session 来 run 每一次 training 的数据. 逐步提升神经网络的预测准确性.<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">sess = tf.Session()</span><br><span class="line">sess.<span class="builtin-name">run</span>(init)          # Very important</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">step</span> <span class="keyword">in</span> range(201):</span><br><span class="line">    sess.<span class="builtin-name">run</span>(train)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">step</span> % 20 == 0:</span><br><span class="line">        <span class="builtin-name">print</span>(<span class="keyword">step</span>, sess.<span class="builtin-name">run</span>(Weights), sess.<span class="builtin-name">run</span>(biases))</span><br></pre></td></tr></table></figure></p>
<p>效果如下图所示，在训练过程中，weight逐渐接近0.1，bias逐渐接近0.3<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/chapter3/p1.png" alt></p>
]]></content>
      <tags>
        <tag>tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title>Tensorboard实现可视化</title>
    <url>/blog/2017/05/tensorboard-visualization-achieve.html</url>
    <content><![CDATA[<p>使用Tensorflow 自带的 tensorboard 去可视化我们所建造出来的神经网络是一个很好的学习理解方式. 用最直观的流程图告诉我们的神经网络是长怎样,有助于发现编程中间的问题和疑问.</p>
<h3 id="可视化整体结构"><a href="#可视化整体结构" class="headerlink" title="可视化整体结构"></a>可视化整体结构</h3><p>我们主要使用with tf.name_scope这一语句来声明内容，<br>我们需要使用 tf.summary.FileWriter() (tf.train.SummaryWriter() 这种方式已经在 tf &gt;= 0.12 版本中摒弃) 将上面‘绘画’出的图保存到一个目录中，以方便后期在浏览器中可以浏览。 这个方法中的第二个参数需要使用sess.graph ， 因此我们需要把这句话放在获取session的后面。 这里的graph是将前面定义的框架信息收集起来，然后放在logs/目录下面。</p>
<p>代码如下：<br><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">from __future__ import print_function</span><br><span class="line">import tensorflow <span class="keyword">as</span> <span class="keyword">tf</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def add_layer(inputs, in_size, out_size, activation_function=None):</span><br><span class="line">    # <span class="built_in">add</span> one more layer <span class="built_in">and</span> <span class="keyword">return</span> the output of this layer</span><br><span class="line">    with <span class="keyword">tf</span>.name_scope(<span class="string">'layer'</span>):</span><br><span class="line">        with <span class="keyword">tf</span>.name_scope(<span class="string">'weights'</span>):</span><br><span class="line">            Weights = <span class="keyword">tf</span>.Variable(<span class="keyword">tf</span>.random_normal([in_size, out_size]), name=<span class="string">'W'</span>)</span><br><span class="line">        with <span class="keyword">tf</span>.name_scope(<span class="string">'biases'</span>):</span><br><span class="line">            biases = <span class="keyword">tf</span>.Variable(<span class="keyword">tf</span>.zeros([<span class="number">1</span>, out_size]) + <span class="number">0.1</span>, name=<span class="string">'b'</span>)</span><br><span class="line">        with <span class="keyword">tf</span>.name_scope(<span class="string">'Wx_plus_b'</span>):</span><br><span class="line">            Wx_plus_b = <span class="keyword">tf</span>.<span class="built_in">add</span>(<span class="keyword">tf</span>.matmul(inputs, Weights), biases)</span><br><span class="line">        <span class="keyword">if</span> activation_function <span class="keyword">is</span> None:</span><br><span class="line">            outputs = Wx_plus_b</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            outputs = activation_function(Wx_plus_b, )</span><br><span class="line">        <span class="keyword">return</span> outputs</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># define placeholder <span class="keyword">for</span> inputs <span class="keyword">to</span> network</span><br><span class="line">with <span class="keyword">tf</span>.name_scope(<span class="string">'inputs'</span>):</span><br><span class="line">    xs = <span class="keyword">tf</span>.placeholder(<span class="keyword">tf</span>.float32, [None, <span class="number">1</span>], name=<span class="string">'x_input'</span>)</span><br><span class="line">    ys = <span class="keyword">tf</span>.placeholder(<span class="keyword">tf</span>.float32, [None, <span class="number">1</span>], name=<span class="string">'y_input'</span>)</span><br><span class="line"></span><br><span class="line"># <span class="built_in">add</span> hidden layer</span><br><span class="line">l1 = add_layer(xs, <span class="number">1</span>, <span class="number">10</span>, activation_function=<span class="keyword">tf</span>.<span class="keyword">nn</span>.relu)</span><br><span class="line"># <span class="built_in">add</span> output layer</span><br><span class="line">prediction = add_layer(l1, <span class="number">10</span>, <span class="number">1</span>, activation_function=None)</span><br><span class="line"></span><br><span class="line"># the error between prediciton <span class="built_in">and</span> real data</span><br><span class="line">with <span class="keyword">tf</span>.name_scope(<span class="string">'loss'</span>):</span><br><span class="line">    loss = <span class="keyword">tf</span>.reduce_mean(<span class="keyword">tf</span>.reduce_sum(<span class="keyword">tf</span>.square(ys - prediction),</span><br><span class="line">                                        reduction_indices=[<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">with <span class="keyword">tf</span>.name_scope(<span class="string">'train'</span>):</span><br><span class="line">    train_step = <span class="keyword">tf</span>.train.GradientDescentOptimizer(<span class="number">0.1</span>).minimize(loss)</span><br><span class="line"></span><br><span class="line">sess = <span class="keyword">tf</span>.Session()</span><br><span class="line"></span><br><span class="line"># <span class="keyword">tf</span>.train.SummaryWriter soon <span class="keyword">be</span> deprecated, use following</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">int</span>((<span class="keyword">tf</span>.__version__).<span class="keyword">split</span>(<span class="string">'.'</span>)[<span class="number">1</span>]) &lt; <span class="number">12</span> <span class="built_in">and</span> <span class="keyword">int</span>((<span class="keyword">tf</span>.__version__).<span class="keyword">split</span>(<span class="string">'.'</span>)[<span class="number">0</span>]) &lt; <span class="number">1</span>:  # tensorflow <span class="keyword">version</span> &lt; <span class="number">0.12</span></span><br><span class="line">    writer = <span class="keyword">tf</span>.train.SummaryWriter(<span class="string">'logs/'</span>, sess.graph)</span><br><span class="line"><span class="keyword">else</span>: # tensorflow <span class="keyword">version</span> &gt;= <span class="number">0.12</span></span><br><span class="line">    writer = <span class="keyword">tf</span>.summary.FileWriter(<span class="string">"logs/"</span>, sess.graph)</span><br><span class="line"></span><br><span class="line"># <span class="keyword">tf</span>.initialize_all_variables() <span class="keyword">no</span> long valid from</span><br><span class="line"># <span class="number">2017</span>-<span class="number">03</span>-<span class="number">02</span> <span class="keyword">if</span> using tensorflow &gt;= <span class="number">0.12</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">int</span>((<span class="keyword">tf</span>.__version__).<span class="keyword">split</span>(<span class="string">'.'</span>)[<span class="number">1</span>]) &lt; <span class="number">12</span> <span class="built_in">and</span> <span class="keyword">int</span>((<span class="keyword">tf</span>.__version__).<span class="keyword">split</span>(<span class="string">'.'</span>)[<span class="number">0</span>]) &lt; <span class="number">1</span>:</span><br><span class="line">    init = <span class="keyword">tf</span>.initialize_all_variables()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    init = <span class="keyword">tf</span>.global_variables_initializer()</span><br><span class="line">sess.run(init)</span><br><span class="line"></span><br><span class="line"># direct <span class="keyword">to</span> the local dir <span class="built_in">and</span> run this in termina<span class="variable">l:</span></span><br><span class="line"># $ tensorboard --logdir=logs</span><br></pre></td></tr></table></figure></p>
<p>最后在你的terminal（终端）中 ，使用以下命令<br><figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">tensorboard <span class="comment">--logdir logs</span></span><br></pre></td></tr></table></figure></p>
<p>同时将终端中输出的网址复制到浏览器中，便可以看到之前定义的视图框架了。<br>整个网络的结构大致如下所示<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/chapter3/p8.png" alt></p>
<h3 id="可视化训练过程"><a href="#可视化训练过程" class="headerlink" title="可视化训练过程"></a>可视化训练过程</h3><p>TesorBorad不仅可以可视化整个神经网络结构的过程。 其实tensorboard还可以可视化训练过程( biase变化过程)<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/chapter3/p5.png" alt><br>本节主要内容包括</p>
<h4 id="制作输入源"><a href="#制作输入源" class="headerlink" title="制作输入源"></a>制作输入源</h4><figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">x_data= <span class="built_in">np</span>.linspace(-<span class="number">1</span>, <span class="number">1</span>, <span class="number">300</span>, dtype=<span class="built_in">np</span>.float32)[:,<span class="built_in">np</span>.newaxis]</span><br><span class="line">noise=  <span class="built_in">np</span>.<span class="built_in">random</span>.normal(<span class="number">0</span>, <span class="number">0.05</span>, x_data.shape).astype(<span class="built_in">np</span>.float32)</span><br><span class="line">y_data= <span class="built_in">np</span>.square(x_data) -<span class="number">0.5</span>+ noise</span><br></pre></td></tr></table></figure>
<h4 id="在-layer-中为-Weights-biases-设置变化图表"><a href="#在-layer-中为-Weights-biases-设置变化图表" class="headerlink" title="在 layer 中为 Weights, biases 设置变化图表"></a>在 layer 中为 Weights, biases 设置变化图表</h4><p>于是我们在 add_layer() 方法中添加一个参数 n_layer,用来标识层数, 并且用变量 layer_name 代表其每层的名名称, 代码如下:<br><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_layer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    inputs , </span></span></span><br><span class="line"><span class="function"><span class="params">    in_size, </span></span></span><br><span class="line"><span class="function"><span class="params">    out_size,</span></span></span><br><span class="line"><span class="function"><span class="params">    n_layer, </span></span></span><br><span class="line"><span class="function"><span class="params">    activation_function=None)</span></span><span class="symbol">:</span></span><br><span class="line">    <span class="comment">## add one more layer and return the output of this layer</span></span><br><span class="line">    layer_name=<span class="string">'layer%s'</span>%n_layer  <span class="comment">## define a new var</span></span><br><span class="line">    <span class="comment">## and so on ……</span></span><br></pre></td></tr></table></figure></p>
<p>接下来,我们层中的Weights设置变化图, tensorflow中提供了tf.histogram_summary()方法,用来绘制图片, 第一个参数是图表的名称, 第二个参数是图表要记录的变量<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_layer</span><span class="params">(inputs , </span></span></span><br><span class="line"><span class="function"><span class="params">            in_size, </span></span></span><br><span class="line"><span class="function"><span class="params">            out_size,n_layer, </span></span></span><br><span class="line"><span class="function"><span class="params">            activation_function=None)</span>:</span></span><br><span class="line">    <span class="comment">## add one more layer and return the output of this layer</span></span><br><span class="line">    layer_name=<span class="string">'layer%s'</span>%n_layer</span><br><span class="line">    <span class="keyword">with</span> tf.name_scope(<span class="string">'layer'</span>):</span><br><span class="line">         <span class="keyword">with</span> tf.name_scope(<span class="string">'weights'</span>):</span><br><span class="line">              Weights= tf.Variable(tf.random_normal([in_size, out_size]),name=<span class="string">'W'</span>)</span><br><span class="line">              <span class="comment"># tf.histogram_summary(layer_name+'/weights',Weights)   # tensorflow 0.12 以下版的</span></span><br><span class="line">              tf.summary.histogram(layer_name + <span class="string">'/weights'</span>, Weights) <span class="comment"># tensorflow &gt;= 0.12</span></span><br></pre></td></tr></table></figure></p>
<p>同样的方法我们可以对biases进行绘制图标<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/chapter3/p6.png" alt></p>
<h4 id="设置loss的变化图"><a href="#设置loss的变化图" class="headerlink" title="设置loss的变化图"></a>设置loss的变化图</h4><p>Loss 的变化图和之前设置的方法略有不同. loss是在tesnorBorad 的scalar下面的, 这是由于我们使用的是tf.scalar_summary() 方法.<br>观看loss的变化比较重要. 当你的loss呈下降的趋势,说明你的神经网络训练是有效果的.</p>
<p>修改后的代码片段如下：<br><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">with <span class="keyword">tf</span>.name_scope(<span class="string">'loss'</span>):</span><br><span class="line">     loss= <span class="keyword">tf</span>.reduce_mean(<span class="keyword">tf</span>.reduce_sum(</span><br><span class="line">              <span class="keyword">tf</span>.square(ys- prediction), reduction_indices=[<span class="number">1</span>]))</span><br><span class="line">     # <span class="keyword">tf</span>.scalar_summary(<span class="string">'loss'</span>,loss) # tensorflow &lt; <span class="number">0.12</span></span><br><span class="line">     <span class="keyword">tf</span>.summary.scalar(<span class="string">'loss'</span>, loss) # tensorflow &gt;= <span class="number">0.12</span></span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/chapter3/p7.png" alt></p>
<h4 id="给所有训练图‘合并‘"><a href="#给所有训练图‘合并‘" class="headerlink" title="给所有训练图‘合并‘"></a>给所有训练图‘合并‘</h4><p>接下来， 开始合并打包。 tf.merge_all_summaries() 方法会对我们所有的 summaries 合并到一起. 因此在原有代码片段中添加：<br><figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">sess= tf.Session()</span><br><span class="line"></span><br><span class="line"># merged= tf.merge_all_summaries()    # tensorflow &lt; <span class="number">0.12</span></span><br><span class="line">merged = tf.summary.merge_all() # tensorflow &gt;= <span class="number">0.12</span></span><br><span class="line"></span><br><span class="line"># writer = tf.train.SummaryWriter(<span class="string">'logs/'</span>, sess.graph)    # tensorflow &lt; <span class="number">0.12</span></span><br><span class="line">writer = tf.summary.FileWriter(<span class="string">"logs/"</span>, sess.graph) # tensorflow &gt;=<span class="number">0.12</span></span><br><span class="line"></span><br><span class="line"># sess.run(tf.initialize_all_variables()) # tf.initialize_all_variables() # tf 马上就要废弃这种写法</span><br><span class="line">sess.run(tf.global_variables_initializer())  # 替换成这样就好</span><br></pre></td></tr></table></figure></p>
<h4 id="训练数据"><a href="#训练数据" class="headerlink" title="训练数据"></a>训练数据</h4><p>假定给出了x_data,y_data并且训练1000次.<br><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i in <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">   sess.run(train_step, feed_dict=&#123;<span class="keyword">x</span><span class="variable">s:x_data</span>, <span class="keyword">y</span><span class="variable">s:y_data</span>&#125;)</span><br><span class="line">   <span class="keyword">if</span> i%<span class="number">50</span> == <span class="number">0</span>:</span><br><span class="line">      rs = sess.run(merged,feed_dict=&#123;<span class="keyword">x</span><span class="variable">s:x_data</span>,<span class="keyword">y</span><span class="variable">s:y_data</span>&#125;)</span><br><span class="line">      writer.add_summary(rs, i)</span><br></pre></td></tr></table></figure></p>
<h4 id="在-tensorboard-中查看效果"><a href="#在-tensorboard-中查看效果" class="headerlink" title="在 tensorboard 中查看效果"></a>在 tensorboard 中查看效果</h4><p>程序运行完毕之后, 会产生logs目录 , 使用命令 tensorboard –logdir logs</p>
<p>注意: 本节内容会用到浏览器, 而且与 tensorboard 兼容的浏览器是 “Google Chrome”. 使用其他的浏览器不保证所有内容都能正常显示.</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://morvanzhou.github.io/tutorials/machine-learning/tensorflow/" target="_blank" rel="noopener">莫烦 python</a></p>
]]></content>
      <tags>
        <tag>tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title>tensorflow手写数字识别</title>
    <url>/blog/2017/05/tensorflow-digit-recongize.html</url>
    <content><![CDATA[<p>本章实现使用tensorflow实现手写数字识别</p>
<h3 id="手写数字识别实现"><a href="#手写数字识别实现" class="headerlink" title="手写数字识别实现"></a>手写数字识别实现</h3><p>首先准备数据（MNIST库）<br>MNIST库是手写体数字库，差不多是这样子的<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/chapter3/p12.png" alt><br>数据中包含55000张训练图片，每张图片的分辨率是28×28，所以我们的训练网络输入应该是28×28=784个像素数据。<br>我们构造一个简单的，两层神经网络，其中输入数据是784个特征，输出数据是10个特征，激励采用softmax函数，网络结构图是这样子的<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/chapter3/p13.png" alt><br>loss函数（即最优化目标函数）选用交叉熵函数。交叉熵用来衡量预测值和真实值的相似程度，如果完全相同，它们的交叉熵等于零。<br>代码如下所示：<br><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">from __future__ import print_function</span><br><span class="line">import tensorflow <span class="keyword">as</span> <span class="keyword">tf</span></span><br><span class="line">from tensorflow.examples.tutorials.mnist import input_data</span><br><span class="line"># <span class="keyword">number</span> <span class="number">1</span> <span class="keyword">to</span> <span class="number">10</span> data</span><br><span class="line">mnist = input_data.read_data_sets(<span class="string">'MNIST_data'</span>, one_hot=True)</span><br><span class="line"></span><br><span class="line">def add_layer(inputs, in_size, out_size, activation_function=None,):</span><br><span class="line">    # <span class="built_in">add</span> one more layer <span class="built_in">and</span> <span class="keyword">return</span> the output of this layer</span><br><span class="line">    Weights = <span class="keyword">tf</span>.Variable(<span class="keyword">tf</span>.random_normal([in_size, out_size]))</span><br><span class="line">    biases = <span class="keyword">tf</span>.Variable(<span class="keyword">tf</span>.zeros([<span class="number">1</span>, out_size]) + <span class="number">0.1</span>,)</span><br><span class="line">    Wx_plus_b = <span class="keyword">tf</span>.matmul(inputs, Weights) + biases</span><br><span class="line">    <span class="keyword">if</span> activation_function <span class="keyword">is</span> None:</span><br><span class="line">        outputs = Wx_plus_b</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        outputs = activation_function(Wx_plus_b,)</span><br><span class="line">    <span class="keyword">return</span> outputs</span><br><span class="line"></span><br><span class="line">def compute_accuracy(v_xs, v_ys):</span><br><span class="line">    <span class="keyword">global</span> prediction</span><br><span class="line">    y_pre = sess.run(prediction, feed_dict=&#123;<span class="keyword">x</span><span class="variable">s:</span> v_xs&#125;)</span><br><span class="line">    correct_prediction = <span class="keyword">tf</span>.equal(<span class="keyword">tf</span>.argmax(y_pre,<span class="number">1</span>), <span class="keyword">tf</span>.argmax(v_ys,<span class="number">1</span>))</span><br><span class="line">    accuracy = <span class="keyword">tf</span>.reduce_mean(<span class="keyword">tf</span>.cast(correct_prediction, <span class="keyword">tf</span>.float32))</span><br><span class="line">    result = sess.run(accuracy, feed_dict=&#123;<span class="keyword">x</span><span class="variable">s:</span> v_xs, <span class="keyword">y</span><span class="variable">s:</span> v_ys&#125;)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"># define placeholder <span class="keyword">for</span> inputs <span class="keyword">to</span> network</span><br><span class="line">xs = <span class="keyword">tf</span>.placeholder(<span class="keyword">tf</span>.float32, [None, <span class="number">784</span>]) # <span class="number">28</span>x28</span><br><span class="line">ys = <span class="keyword">tf</span>.placeholder(<span class="keyword">tf</span>.float32, [None, <span class="number">10</span>])</span><br><span class="line"></span><br><span class="line"># <span class="built_in">add</span> output layer</span><br><span class="line">prediction = add_layer(xs, <span class="number">784</span>, <span class="number">10</span>,  activation_function=<span class="keyword">tf</span>.<span class="keyword">nn</span>.softmax)</span><br><span class="line"></span><br><span class="line"># the error between prediction <span class="built_in">and</span> real data</span><br><span class="line">cross_entropy = <span class="keyword">tf</span>.reduce_mean(-<span class="keyword">tf</span>.reduce_sum(ys * <span class="keyword">tf</span>.<span class="built_in">log</span>(prediction),</span><br><span class="line">                                              reduction_indices=[<span class="number">1</span>]))       # loss</span><br><span class="line">train_step = <span class="keyword">tf</span>.train.GradientDescentOptimizer(<span class="number">0.5</span>).minimize(cross_entropy)</span><br><span class="line"></span><br><span class="line">sess = <span class="keyword">tf</span>.Session()</span><br><span class="line"># important step</span><br><span class="line"># <span class="keyword">tf</span>.initialize_all_variables() <span class="keyword">no</span> long valid from</span><br><span class="line"># <span class="number">2017</span>-<span class="number">03</span>-<span class="number">02</span> <span class="keyword">if</span> using tensorflow &gt;= <span class="number">0.12</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">int</span>((<span class="keyword">tf</span>.__version__).<span class="keyword">split</span>(<span class="string">'.'</span>)[<span class="number">1</span>]) &lt; <span class="number">12</span> <span class="built_in">and</span> <span class="keyword">int</span>((<span class="keyword">tf</span>.__version__).<span class="keyword">split</span>(<span class="string">'.'</span>)[<span class="number">0</span>]) &lt; <span class="number">1</span>:</span><br><span class="line">    init = <span class="keyword">tf</span>.initialize_all_variables()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    init = <span class="keyword">tf</span>.global_variables_initializer()</span><br><span class="line">sess.run(init)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i in <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">    batch_xs, batch_ys = mnist.train.next_batch(<span class="number">100</span>)</span><br><span class="line">    sess.run(train_step, feed_dict=&#123;<span class="keyword">x</span><span class="variable">s:</span> batch_xs, <span class="keyword">y</span><span class="variable">s:</span> batch_ys&#125;)</span><br><span class="line">    <span class="keyword">if</span> i % <span class="number">50</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">print</span>(compute_accuracy(</span><br><span class="line">            mnist.test.images, mnist.test.labels))</span><br></pre></td></tr></table></figure></p>
<p>效果如下：<br>可以看到，如此简单的神经网络结构竟然可以达到这样的图像识别精度<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/chapter3/p9.png" alt></p>
<h3 id="使用dropout防止过拟合"><a href="#使用dropout防止过拟合" class="headerlink" title="使用dropout防止过拟合"></a>使用dropout防止过拟合</h3><p>什么是过拟合<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/chapter3/p14.png" alt><br>图中黑色曲线是正常模型，绿色曲线就是overfitting模型。尽管绿色曲线很精确的区分了所有的训练数据，但是并没有描述数据的整体特征，对新测试数据的适应性较差。<br>实现代码如下<br><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">from __future__ import print_function</span><br><span class="line">import tensorflow <span class="keyword">as</span> <span class="keyword">tf</span></span><br><span class="line">from sklearn.datasets import load_digits</span><br><span class="line">from sklearn.cross_validation import train_test_split</span><br><span class="line">from sklearn.preprocessing import LabelBinarizer</span><br><span class="line"></span><br><span class="line"># load data</span><br><span class="line">digits = load_digits()</span><br><span class="line"><span class="keyword">X</span> = digits.data</span><br><span class="line"><span class="keyword">y</span> = digits.target</span><br><span class="line"><span class="keyword">y</span> = LabelBinarizer().fit_transform(<span class="keyword">y</span>)</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(<span class="keyword">X</span>, <span class="keyword">y</span>, test_size=.<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def add_layer(inputs, in_size, out_size, layer_name, activation_function=None, ):</span><br><span class="line">    # <span class="built_in">add</span> one more layer <span class="built_in">and</span> <span class="keyword">return</span> the output of this layer</span><br><span class="line">    Weights = <span class="keyword">tf</span>.Variable(<span class="keyword">tf</span>.random_normal([in_size, out_size]))</span><br><span class="line">    biases = <span class="keyword">tf</span>.Variable(<span class="keyword">tf</span>.zeros([<span class="number">1</span>, out_size]) + <span class="number">0.1</span>, )</span><br><span class="line">    Wx_plus_b = <span class="keyword">tf</span>.matmul(inputs, Weights) + biases</span><br><span class="line">    # here <span class="keyword">to</span> dropout</span><br><span class="line">    Wx_plus_b = <span class="keyword">tf</span>.<span class="keyword">nn</span>.dropout(Wx_plus_b, keep_prob)</span><br><span class="line">    <span class="keyword">if</span> activation_function <span class="keyword">is</span> None:</span><br><span class="line">        outputs = Wx_plus_b</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        outputs = activation_function(Wx_plus_b, )</span><br><span class="line">    <span class="keyword">tf</span>.summary.histogram(layer_name + <span class="string">'/outputs'</span>, outputs)</span><br><span class="line">    <span class="keyword">return</span> outputs</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># define placeholder <span class="keyword">for</span> inputs <span class="keyword">to</span> network</span><br><span class="line">keep_prob = <span class="keyword">tf</span>.placeholder(<span class="keyword">tf</span>.float32)</span><br><span class="line">xs = <span class="keyword">tf</span>.placeholder(<span class="keyword">tf</span>.float32, [None, <span class="number">64</span>])  # <span class="number">8</span>x8</span><br><span class="line">ys = <span class="keyword">tf</span>.placeholder(<span class="keyword">tf</span>.float32, [None, <span class="number">10</span>])</span><br><span class="line"></span><br><span class="line"># <span class="built_in">add</span> output layer</span><br><span class="line">l1 = add_layer(xs, <span class="number">64</span>, <span class="number">50</span>, <span class="string">'l1'</span>, activation_function=<span class="keyword">tf</span>.<span class="keyword">nn</span>.<span class="built_in">tanh</span>)</span><br><span class="line">prediction = add_layer(l1, <span class="number">50</span>, <span class="number">10</span>, <span class="string">'l2'</span>, activation_function=<span class="keyword">tf</span>.<span class="keyword">nn</span>.softmax)</span><br><span class="line"></span><br><span class="line"># the loss between prediction <span class="built_in">and</span> real data</span><br><span class="line">cross_entropy = <span class="keyword">tf</span>.reduce_mean(-<span class="keyword">tf</span>.reduce_sum(ys * <span class="keyword">tf</span>.<span class="built_in">log</span>(prediction),</span><br><span class="line">                                              reduction_indices=[<span class="number">1</span>]))  # loss</span><br><span class="line"><span class="keyword">tf</span>.summary.scalar(<span class="string">'loss'</span>, cross_entropy)</span><br><span class="line">train_step = <span class="keyword">tf</span>.train.GradientDescentOptimizer(<span class="number">0.5</span>).minimize(cross_entropy)</span><br><span class="line"></span><br><span class="line">sess = <span class="keyword">tf</span>.Session()</span><br><span class="line">merged = <span class="keyword">tf</span>.summary.merge_all()</span><br><span class="line"># summary writer goes in here</span><br><span class="line">train_writer = <span class="keyword">tf</span>.summary.FileWriter(<span class="string">"logs/train"</span>, sess.graph)</span><br><span class="line">test_writer = <span class="keyword">tf</span>.summary.FileWriter(<span class="string">"logs/test"</span>, sess.graph)</span><br><span class="line"></span><br><span class="line"># <span class="keyword">tf</span>.initialize_all_variables() <span class="keyword">no</span> long valid from</span><br><span class="line"># <span class="number">2017</span>-<span class="number">03</span>-<span class="number">02</span> <span class="keyword">if</span> using tensorflow &gt;= <span class="number">0.12</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">int</span>((<span class="keyword">tf</span>.__version__).<span class="keyword">split</span>(<span class="string">'.'</span>)[<span class="number">1</span>]) &lt; <span class="number">12</span> <span class="built_in">and</span> <span class="keyword">int</span>((<span class="keyword">tf</span>.__version__).<span class="keyword">split</span>(<span class="string">'.'</span>)[<span class="number">0</span>]) &lt; <span class="number">1</span>:</span><br><span class="line">    init = <span class="keyword">tf</span>.initialize_all_variables()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    init = <span class="keyword">tf</span>.global_variables_initializer()</span><br><span class="line">sess.run(init)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i in <span class="built_in">range</span>(<span class="number">500</span>):</span><br><span class="line">    # here <span class="keyword">to</span> determine the keeping probability</span><br><span class="line">    sess.run(train_step, feed_dict=&#123;<span class="keyword">x</span><span class="variable">s:</span> X_train, <span class="keyword">y</span><span class="variable">s:</span> y_train, keep_pro<span class="variable">b:</span> <span class="number">0.5</span>&#125;)</span><br><span class="line">    <span class="keyword">if</span> i % <span class="number">50</span> == <span class="number">0</span>:</span><br><span class="line">        # record loss</span><br><span class="line">        train_result = sess.run(merged, feed_dict=&#123;<span class="keyword">x</span><span class="variable">s:</span> X_train, <span class="keyword">y</span><span class="variable">s:</span> y_train, keep_pro<span class="variable">b:</span> <span class="number">1</span>&#125;)</span><br><span class="line">        test_result = sess.run(merged, feed_dict=&#123;<span class="keyword">x</span><span class="variable">s:</span> X_test, <span class="keyword">y</span><span class="variable">s:</span> y_test, keep_pro<span class="variable">b:</span> <span class="number">1</span>&#125;)</span><br><span class="line">        train_writer.add_summary(train_result, i)</span><br><span class="line">        test_writer.add_summary(test_result, i)</span><br></pre></td></tr></table></figure></p>
<p>keep_prob为0.5时：<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/chapter3/p10.png" alt><br>keep_prob为1时：<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/chapter3/p11.png" alt><br>可以看出当keep_prob为1时，测试集的精确度明显低于训练集，训练集存在过拟合现象</p>
]]></content>
      <tags>
        <tag>tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title>tensorflow实现CNN</title>
    <url>/blog/2017/05/tensorflow-cnn-achieve.html</url>
    <content><![CDATA[<p>tensorflow实现卷积神经网络。</p>
<h3 id="卷积神经网络简介"><a href="#卷积神经网络简介" class="headerlink" title="卷积神经网络简介"></a>卷积神经网络简介</h3><p>卷积神经网络包含输入层、隐藏层和输出层，隐藏层又包含卷积层和pooling层，图像输入到卷积神经网络后通过卷积来不断的提取特征，每提取一个特征就会增加一个feature map，同时可以使用pooling层来下采样，稀疏化参数，通常采用的是最大值pooling和平均值pooling。</p>
<h3 id="卷积神经网络构造"><a href="#卷积神经网络构造" class="headerlink" title="卷积神经网络构造"></a>卷积神经网络构造</h3><p>我们在代码中实现一个基于MNIST数据集的例子</p>
<h4 id="基本函数"><a href="#基本函数" class="headerlink" title="基本函数"></a>基本函数</h4><p>1.我们定义Weight变量，输入shape，返回变量的参数。其中我们使用tf.truncted_normal产生随机变量来进行初始化:<br><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">weight_variable</span><span class="params">(shape)</span></span>: </span><br><span class="line">	inital=tf.truncted_normal(shape,stddev=<span class="number">0</span>.<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">return</span> tf.Variable(initial)</span><br></pre></td></tr></table></figure></p>
<p>2.同样的定义biase变量，输入shape ,返回变量的一些参数。其中我们使用tf.constant常量函数来进行初始化:<br><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bias_variable</span><span class="params">(shape)</span></span>: </span><br><span class="line">	initial=tf.constant(<span class="number">0</span>.<span class="number">1</span>,shape=shape) </span><br><span class="line">	<span class="keyword">return</span> tf.Variable(initial)</span><br></pre></td></tr></table></figure></p>
<p>3.定义卷积，tf.nn.conv2d函数是tensoflow里面的二维的卷积函数，x是图片的所有参数，W是此卷积层的权重，然后定义步长strides=[1,1,1,1]值，strides[0]和strides[3]的两个1是默认值，中间两个1代表padding时在x方向运动一步，y方向运动一步，padding采用的方式是SAME。<br><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conv2d</span><span class="params">(x,W)</span></span><span class="symbol">:</span></span><br><span class="line">	<span class="keyword">return</span> tf.nn.conv2d(x,W,strides=[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]，padding=<span class="string">'SAME'</span>)</span><br></pre></td></tr></table></figure></p>
<p>4.接着定义池化pooling，为了得到更多的图片信息，padding时我们选的是一次一步，也就是strides[1]=strides[2]=1，这样得到的图片尺寸没有变化，而我们希望压缩一下图片也就是参数能少一些从而减小系统的复杂度，因此我们采用pooling来稀疏化参数，也就是卷积神经网络中所谓的下采样层。pooling 有两种，一种是最大值池化，一种是平均值池化，本例采用的是最大值池化tf.max_pool()。池化的核函数大小为2x2，因此ksize=[1,2,2,1]，步长为2，因此strides=[1,2,2,1]:<br><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max_poo_2x2</span><span class="params">(x)</span></span>: </span><br><span class="line">	<span class="keyword">return</span> tf.nn.max_pool(x,ksize=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>],strides=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>])</span><br></pre></td></tr></table></figure></p>
<h4 id="构造神经网络的结构"><a href="#构造神经网络的结构" class="headerlink" title="构造神经网络的结构"></a>构造神经网络的结构</h4><p>1.convolutional layer1 + max pooling;<br>2.convolutional layer2 + max pooling;<br>3.fully connected layer1 + dropout;<br>4.fully connected layer2 to prediction.</p>
<p>具体实现如下：<br>1.处理我们的xs，把xs的形状变成[-1,28,28,1]，-1代表先不考虑输入的图片例子多少这个维度，后面的1是channel的数量，因为我们输入的图片是黑白的，因此channel是1，例如如果是RGB图像，那么channel就是3。<br><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">x_image=tf.reshape(xs,[<span class="number">-1</span>,<span class="number">28</span>,<span class="number">28</span>,<span class="number">1</span>])</span><br></pre></td></tr></table></figure></p>
<p>2.接着我们定义第一层卷积,先定义本层的Weight,本层我们的卷积核patch的大小是5x5，因为黑白图片channel是1所以输入是1，输出是32个featuremap<br><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">W_conv1=weight_variable([<span class="number">5</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">32</span>])</span><br></pre></td></tr></table></figure></p>
<p>接着定义bias，它的大小是32个长度，因此我们传入它的shape为[32]<br><figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">b_co<span class="symbol">nv1</span>=bias_variable<span class="comment">([32])</span></span><br></pre></td></tr></table></figure></p>
<p>定义好了Weight和bias，我们就可以定义卷积神经网络的第一个卷积层h_conv1=conv2d(x_image,W_conv1)+b_conv1,同时我们对h_conv1进行非线性处理，也就是激活函数来处理喽，这里我们用的是tf.nn.relu（修正线性单元）来处理，要注意的是，因为采用了SAME的padding方式，输出图片的大小没有变化依然是28x28，只是厚度变厚了，因此现在的输出大小就变成了28x28x32<br><figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">h_conv1=tf.nn.relu(conv2d(x_image,W_conv1)+b_conv1)</span><br></pre></td></tr></table></figure></p>
<p>最后我们再进行pooling的处理就ok啦，经过pooling的处理，输出大小就变为了14x14x32<br><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">h_pool</span>=max_pool_2x2(h_conv1)</span><br></pre></td></tr></table></figure></p>
<p>3.同样的形式我们定义第二层卷积，本层我们的输入就是上一层的输出，本层我们的卷积核patch的大小是5x5，有32个featuremap所以输入就是32，输出呢我们定为64<br><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">W_conv2=weight_variable([<span class="number">5</span>,<span class="number">5</span>,<span class="number">32</span>,<span class="number">64</span>])</span><br><span class="line">b_conv2=bias_variable([<span class="number">64</span>])</span><br></pre></td></tr></table></figure></p>
<p>接着我们就可以定义卷积神经网络的第二个卷积层，这时的输出的大小就是14x14x64<br><figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">h_conv2=tf.nn.relu(conv2d(h_pool1,W_conv2)+b_conv2)</span><br></pre></td></tr></table></figure></p>
<p>最后也是一个pooling处理，输出大小为7x7x64<br><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">h_pool2</span>=max_pool_2x2(h_conv2)</span><br></pre></td></tr></table></figure></p>
<p>4.接下来我们定义我们的 fully connected layer,<br>进入全连接层时, 我们通过tf.reshape()将h_pool2的输出值从一个三维的变为一维的数据, -1表示先不考虑输入图片例子维度, 将上一个输出结果展平.<br><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">h_pool2_flat=tf.reshape(h_pool2,[<span class="number">-1</span>,<span class="number">7</span>*<span class="number">7</span>*<span class="number">64</span>])</span><br></pre></td></tr></table></figure></p>
<p>此时weight_variable的shape输入就是第二个卷积层展平了的输出大小: 7x7x64， 后面的输出size我们继续扩大，定为1024<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="attribute">W_fc1</span>=weight_variable([7<span class="number">*7</span><span class="number">*64</span>,1024]) </span><br><span class="line"><span class="attribute">b_fc1</span>=bias_variable([1024])</span><br></pre></td></tr></table></figure></p>
<p>然后将展平后的h_pool2_flat与本层的W_fc1相乘（注意这个时候不是卷积了）<br><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">h_fc1=<span class="keyword">tf</span>.<span class="keyword">nn</span>.relu(<span class="keyword">tf</span>.matmul(h_pool2_flat,W_fc1)+b_fc1)</span><br></pre></td></tr></table></figure></p>
<p>如果我们考虑过拟合问题，可以加一个dropout的处理<br><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">h_fc1_drop</span>=tf.nn.dropout(h_fc1,keep_drop)</span><br></pre></td></tr></table></figure></p>
<p>5.接下来我们就可以进行最后一层的构建了，好激动啊, 输入是1024，最后的输出是10个 (因为mnist数据集就是[0-9]十个类)，prediction就是我们最后的预测值<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="attribute">W_fc2</span>=weight_variable([1024,10]) <span class="attribute">b_fc2</span>=bias_variable([10])</span><br></pre></td></tr></table></figure></p>
<p>6.然后呢我们用softmax分类器（多分类，输出是各个类的概率）,对我们的输出进行分类<br><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">prediction=<span class="keyword">tf</span>.<span class="keyword">nn</span>.softmax(<span class="keyword">tf</span>.matmul(h_fc1_dropt,W_fc2),b_fc2)</span><br></pre></td></tr></table></figure></p>
<p>7.接着呢我们利用交叉熵损失函数来定义我们的cost function<br><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">cross_entropy=<span class="keyword">tf</span>.reduce_mean(</span><br><span class="line">    -<span class="keyword">tf</span>.reduce_sum(ys*<span class="keyword">tf</span>.<span class="built_in">log</span>(prediction),</span><br><span class="line">    reduction_indices=[<span class="number">1</span>]))</span><br></pre></td></tr></table></figure></p>
<p>8.我们用tf.train.AdamOptimizer()作为我们的优化器进行优化，使我们的cross_entropy最小<br><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">train_step</span>=tf.train.AdamOptimizer(<span class="number">1</span>e-<span class="number">4</span>).minimize(cross_entropy)</span><br></pre></td></tr></table></figure></p>
<p>全部代码如下所示：<br><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">from __future__ import print_function</span><br><span class="line">import tensorflow <span class="keyword">as</span> <span class="keyword">tf</span></span><br><span class="line">from tensorflow.examples.tutorials.mnist import input_data</span><br><span class="line"># <span class="keyword">number</span> <span class="number">1</span> <span class="keyword">to</span> <span class="number">10</span> data</span><br><span class="line">mnist = input_data.read_data_sets(<span class="string">'MNIST_data'</span>, one_hot=True)</span><br><span class="line"></span><br><span class="line">def compute_accuracy(v_xs, v_ys):</span><br><span class="line">    <span class="keyword">global</span> prediction</span><br><span class="line">    y_pre = sess.run(prediction, feed_dict=&#123;<span class="keyword">x</span><span class="variable">s:</span> v_xs, keep_pro<span class="variable">b:</span> <span class="number">1</span>&#125;)</span><br><span class="line">    correct_prediction = <span class="keyword">tf</span>.equal(<span class="keyword">tf</span>.argmax(y_pre,<span class="number">1</span>), <span class="keyword">tf</span>.argmax(v_ys,<span class="number">1</span>))</span><br><span class="line">    accuracy = <span class="keyword">tf</span>.reduce_mean(<span class="keyword">tf</span>.cast(correct_prediction, <span class="keyword">tf</span>.float32))</span><br><span class="line">    result = sess.run(accuracy, feed_dict=&#123;<span class="keyword">x</span><span class="variable">s:</span> v_xs, <span class="keyword">y</span><span class="variable">s:</span> v_ys, keep_pro<span class="variable">b:</span> <span class="number">1</span>&#125;)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">def weight_variable(shape):</span><br><span class="line">    initial = <span class="keyword">tf</span>.truncated_normal(shape, stddev=<span class="number">0.1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">tf</span>.Variable(initial)</span><br><span class="line"></span><br><span class="line">def bias_variable(shape):</span><br><span class="line">    initial = <span class="keyword">tf</span>.constant(<span class="number">0.1</span>, shape=shape)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">tf</span>.Variable(initial)</span><br><span class="line"></span><br><span class="line">def conv2d(<span class="keyword">x</span>, W):</span><br><span class="line">    # stride [<span class="number">1</span>, x_movement, y_movement, <span class="number">1</span>]</span><br><span class="line">    # Must have strides[<span class="number">0</span>] = strides[<span class="number">3</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">tf</span>.<span class="keyword">nn</span>.conv2d(<span class="keyword">x</span>, W, strides=[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>], padding=<span class="string">'SAME'</span>)</span><br><span class="line"></span><br><span class="line">def max_pool_2x2(<span class="keyword">x</span>):</span><br><span class="line">    # stride [<span class="number">1</span>, x_movement, y_movement, <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">tf</span>.<span class="keyword">nn</span>.max_pool(<span class="keyword">x</span>, ksize=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>], strides=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>], padding=<span class="string">'SAME'</span>)</span><br><span class="line"></span><br><span class="line"># define placeholder <span class="keyword">for</span> inputs <span class="keyword">to</span> network</span><br><span class="line">xs = <span class="keyword">tf</span>.placeholder(<span class="keyword">tf</span>.float32, [None, <span class="number">784</span>])/<span class="number">255</span>.   # <span class="number">28</span>x28</span><br><span class="line">ys = <span class="keyword">tf</span>.placeholder(<span class="keyword">tf</span>.float32, [None, <span class="number">10</span>])</span><br><span class="line">keep_prob = <span class="keyword">tf</span>.placeholder(<span class="keyword">tf</span>.float32)</span><br><span class="line">x_image = <span class="keyword">tf</span>.reshape(xs, [-<span class="number">1</span>, <span class="number">28</span>, <span class="number">28</span>, <span class="number">1</span>])</span><br><span class="line"># <span class="keyword">print</span>(x_image.shape)  # [n_samples, <span class="number">28</span>,<span class="number">28</span>,<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">## conv1 layer ##</span><br><span class="line">W_conv1 = weight_variable([<span class="number">5</span>,<span class="number">5</span>, <span class="number">1</span>,<span class="number">32</span>]) # patch <span class="number">5</span>x5, in size <span class="number">1</span>, out size <span class="number">32</span></span><br><span class="line">b_conv1 = bias_variable([<span class="number">32</span>])</span><br><span class="line">h_conv1 = <span class="keyword">tf</span>.<span class="keyword">nn</span>.relu(conv2d(x_image, W_conv1) + b_conv1) # output size <span class="number">28</span>x28x32</span><br><span class="line">h_pool1 = max_pool_2x2(h_conv1)                                         # output size <span class="number">14</span>x14x32</span><br><span class="line"></span><br><span class="line">## conv2 layer ##</span><br><span class="line">W_conv2 = weight_variable([<span class="number">5</span>,<span class="number">5</span>, <span class="number">32</span>, <span class="number">64</span>]) # patch <span class="number">5</span>x5, in size <span class="number">32</span>, out size <span class="number">64</span></span><br><span class="line">b_conv2 = bias_variable([<span class="number">64</span>])</span><br><span class="line">h_conv2 = <span class="keyword">tf</span>.<span class="keyword">nn</span>.relu(conv2d(h_pool1, W_conv2) + b_conv2) # output size <span class="number">14</span>x14x64</span><br><span class="line">h_pool2 = max_pool_2x2(h_conv2)                                         # output size <span class="number">7</span>x7x64</span><br><span class="line"></span><br><span class="line">## fc1 layer ##</span><br><span class="line">W_fc1 = weight_variable([<span class="number">7</span>*<span class="number">7</span>*<span class="number">64</span>, <span class="number">1024</span>])</span><br><span class="line">b_fc1 = bias_variable([<span class="number">1024</span>])</span><br><span class="line"># [n_samples, <span class="number">7</span>, <span class="number">7</span>, <span class="number">64</span>] -&gt;&gt; [n_samples, <span class="number">7</span>*<span class="number">7</span>*<span class="number">64</span>]</span><br><span class="line">h_pool2_flat = <span class="keyword">tf</span>.reshape(h_pool2, [-<span class="number">1</span>, <span class="number">7</span>*<span class="number">7</span>*<span class="number">64</span>])</span><br><span class="line">h_fc1 = <span class="keyword">tf</span>.<span class="keyword">nn</span>.relu(<span class="keyword">tf</span>.matmul(h_pool2_flat, W_fc1) + b_fc1)</span><br><span class="line">h_fc1_drop = <span class="keyword">tf</span>.<span class="keyword">nn</span>.dropout(h_fc1, keep_prob)</span><br><span class="line"></span><br><span class="line">## fc2 layer ##</span><br><span class="line">W_fc2 = weight_variable([<span class="number">1024</span>, <span class="number">10</span>])</span><br><span class="line">b_fc2 = bias_variable([<span class="number">10</span>])</span><br><span class="line">prediction = <span class="keyword">tf</span>.<span class="keyword">nn</span>.softmax(<span class="keyword">tf</span>.matmul(h_fc1_drop, W_fc2) + b_fc2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># the error between prediction <span class="built_in">and</span> real data</span><br><span class="line">cross_entropy = <span class="keyword">tf</span>.reduce_mean(-<span class="keyword">tf</span>.reduce_sum(ys * <span class="keyword">tf</span>.<span class="built_in">log</span>(prediction),</span><br><span class="line">                                              reduction_indices=[<span class="number">1</span>]))       # loss</span><br><span class="line">train_step = <span class="keyword">tf</span>.train.AdamOptimizer(<span class="number">1</span><span class="keyword">e</span>-<span class="number">4</span>).minimize(cross_entropy)</span><br><span class="line"></span><br><span class="line">sess = <span class="keyword">tf</span>.Session()</span><br><span class="line"># important step</span><br><span class="line"># <span class="keyword">tf</span>.initialize_all_variables() <span class="keyword">no</span> long valid from</span><br><span class="line"># <span class="number">2017</span>-<span class="number">03</span>-<span class="number">02</span> <span class="keyword">if</span> using tensorflow &gt;= <span class="number">0.12</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">int</span>((<span class="keyword">tf</span>.__version__).<span class="keyword">split</span>(<span class="string">'.'</span>)[<span class="number">1</span>]) &lt; <span class="number">12</span> <span class="built_in">and</span> <span class="keyword">int</span>((<span class="keyword">tf</span>.__version__).<span class="keyword">split</span>(<span class="string">'.'</span>)[<span class="number">0</span>]) &lt; <span class="number">1</span>:</span><br><span class="line">    init = <span class="keyword">tf</span>.initialize_all_variables()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    init = <span class="keyword">tf</span>.global_variables_initializer()</span><br><span class="line">sess.run(init)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i in <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">    batch_xs, batch_ys = mnist.train.next_batch(<span class="number">100</span>)</span><br><span class="line">    sess.run(train_step, feed_dict=&#123;<span class="keyword">x</span><span class="variable">s:</span> batch_xs, <span class="keyword">y</span><span class="variable">s:</span> batch_ys, keep_pro<span class="variable">b:</span> <span class="number">0.5</span>&#125;)</span><br><span class="line">    <span class="keyword">if</span> i % <span class="number">50</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">print</span>(compute_accuracy(</span><br><span class="line">            mnist.test.images, mnist.test.labels))</span><br></pre></td></tr></table></figure></p>
<p>通过卷积神经网络，对于mnist数据集的准确率可以达到96%<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/chapter3/p15.png" alt></p>
<h3 id="Saver-保存读取"><a href="#Saver-保存读取" class="headerlink" title="Saver 保存读取"></a>Saver 保存读取</h3><p>在我们上面训练了网络之后，需要存储网络，等到下次使用，不然每次都白训练了。</p>
<h4 id="保存"><a href="#保存" class="headerlink" title="保存"></a>保存</h4><p>import所需的模块, 然后建立神经网络当中的 W 和 b, 并初始化变量.<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">import tensorflow as tf</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line"><span class="comment">## Save to file</span></span><br><span class="line"><span class="comment"># remember to define the same dtype and shape when restore</span></span><br><span class="line">W = tf.Variable([[1,2,3],[3,4,5]], <span class="attribute">dtype</span>=tf.float32, <span class="attribute">name</span>=<span class="string">'weights'</span>)</span><br><span class="line">b = tf.Variable([[1,2,3]], <span class="attribute">dtype</span>=tf.float32, <span class="attribute">name</span>=<span class="string">'biases'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># init= tf.initialize_all_variables() # tf 马上就要废弃这种写法</span></span><br><span class="line"><span class="comment"># 替换成下面的写法:</span></span><br><span class="line">init = tf.global_variables_initializer()</span><br></pre></td></tr></table></figure></p>
<p>保存时, 首先要建立一个 tf.train.Saver() 用来保存, 提取变量. 再创建一个名为my_net的文件夹, 用这个 saver 来保存变量到这个目录 “my_net/save_net.ckpt”.<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">saver = tf.train.Saver()</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    sess.run(init)</span><br><span class="line">    save_path = saver.save(sess, <span class="string">"my_net/save_net.ckpt"</span>)</span><br><span class="line">    print(<span class="string">"Save to path: "</span>, save_path)</span><br><span class="line"></span><br><span class="line"><span class="string">"""    </span></span><br><span class="line"><span class="string">Save to path:  my_net/save_net.ckpt</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure></p>
<h4 id="提取"><a href="#提取" class="headerlink" title="提取"></a>提取</h4><p>提取时, 先建立零时的W 和 b容器. 找到文件目录, 并用saver.restore()我们放在这个目录的变量.<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 先建立 W, b 的容器</span></span><br><span class="line">W = tf.Variable(np.arange(6).reshape((2, 3)), <span class="attribute">dtype</span>=tf.float32, <span class="attribute">name</span>=<span class="string">"weights"</span>)</span><br><span class="line">b = tf.Variable(np.arange(3).reshape((1, 3)), <span class="attribute">dtype</span>=tf.float32, <span class="attribute">name</span>=<span class="string">"biases"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里不需要初始化步骤 init= tf.initialize_all_variables()</span></span><br><span class="line"></span><br><span class="line">saver = tf.train.Saver()</span><br><span class="line">with tf.Session() as sess:</span><br><span class="line">    # 提取变量</span><br><span class="line">    saver.restore(sess, <span class="string">"my_net/save_net.ckpt"</span>)</span><br><span class="line">    <span class="builtin-name">print</span>(<span class="string">"weights:"</span>, sess.<span class="builtin-name">run</span>(W))</span><br><span class="line">    <span class="builtin-name">print</span>(<span class="string">"biases:"</span>, sess.<span class="builtin-name">run</span>(b))</span><br><span class="line"></span><br><span class="line"><span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">weights: [[ 1.  2.  3.]</span></span><br><span class="line"><span class="string">          [ 3.  4.  5.]]</span></span><br><span class="line"><span class="string">biases: [[ 1.  2.  3.]]</span></span><br><span class="line"><span class="string">"</span><span class="string">""</span></span><br></pre></td></tr></table></figure></p>
<p>提取时，我们通常建立一个同样的网络，只要你搭建了一个一模一样的 CNN, 他会根据你保存是的 model 里的各种 variable_scope 去找你新model 里的这些 scope, 如果对应上了, 他就 assign variable 去你的新 model.<br>比如我们存储上面那个CNN，后使用效果如下：<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/chapter3/p16.png" alt></p>
]]></content>
      <tags>
        <tag>tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title>tensorflow实现rnn</title>
    <url>/blog/2017/05/tensorflow-rnn-achieve.html</url>
    <content><![CDATA[<p>使用tensorflow实现RNN</p>
<h3 id="RNN分类例子"><a href="#RNN分类例子" class="headerlink" title="RNN分类例子"></a>RNN分类例子</h3><p>我们会使用 RNN 来进行分类的训练 (Classification). 会继续使用到手写数字 MNIST 数据集. 让 RNN 从每张图片的第一行像素读到最后一行, 然后再进行分类判断. </p>
<p>1.导入 MNIST 数据并确定 RNN 的各种参数(hyper-parameters):<br><figure class="highlight nix"><table><tr><td class="code"><pre><span class="line"><span class="built_in">import</span> tensorflow as tf</span><br><span class="line">from tensorflow.examples.tutorials.mnist <span class="built_in">import</span> input_data</span><br><span class="line">tf.set_random_seed(<span class="number">1</span>)   <span class="comment"># set random seed</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入数据</span></span><br><span class="line"><span class="attr">mnist</span> = input_data.read_data_sets('MNIST_data', <span class="attr">one_hot=True)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># hyperparameters</span></span><br><span class="line"><span class="attr">lr</span> = <span class="number">0.001</span>                  <span class="comment"># learning rate</span></span><br><span class="line"><span class="attr">training_iters</span> = <span class="number">100000</span>     <span class="comment"># train step 上限</span></span><br><span class="line"><span class="attr">batch_size</span> = <span class="number">128</span>            </span><br><span class="line"><span class="attr">n_inputs</span> = <span class="number">28</span>               <span class="comment"># MNIST data input (img shape: 28*28)</span></span><br><span class="line"><span class="attr">n_steps</span> = <span class="number">28</span>                <span class="comment"># time steps</span></span><br><span class="line"><span class="attr">n_hidden_units</span> = <span class="number">128</span>        <span class="comment"># neurons in hidden layer</span></span><br><span class="line"><span class="attr">n_classes</span> = <span class="number">10</span>              <span class="comment"># MNIST classes (0-9 digits)</span></span><br></pre></td></tr></table></figure></p>
<p>其中，n_inputs等于图片的宽，n_steps等于图片的长<br>2.接着定义 x, y 的 placeholder 和 weights, biases 的初始状况.<br><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"># <span class="keyword">x</span> <span class="keyword">y</span> placeholder</span><br><span class="line"><span class="keyword">x</span> = <span class="keyword">tf</span>.placeholder(<span class="keyword">tf</span>.float32, [None, n_steps, n_inputs])</span><br><span class="line"><span class="keyword">y</span> = <span class="keyword">tf</span>.placeholder(<span class="keyword">tf</span>.float32, [None, n_classes])</span><br><span class="line"></span><br><span class="line"># 对 weights biases 初始值的定义</span><br><span class="line">weights = &#123;</span><br><span class="line">    # shape (<span class="number">28</span>, <span class="number">128</span>)</span><br><span class="line">    <span class="string">'in'</span>: <span class="keyword">tf</span>.Variable(<span class="keyword">tf</span>.random_normal([n_inputs, n_hidden_units])),</span><br><span class="line">    # shape (<span class="number">128</span>, <span class="number">10</span>)</span><br><span class="line">    <span class="string">'out'</span>: <span class="keyword">tf</span>.Variable(<span class="keyword">tf</span>.random_normal([n_hidden_units, n_classes]))</span><br><span class="line">&#125;</span><br><span class="line">biases = &#123;</span><br><span class="line">    # shape (<span class="number">128</span>, )</span><br><span class="line">    <span class="string">'in'</span>: <span class="keyword">tf</span>.Variable(<span class="keyword">tf</span>.constant(<span class="number">0.1</span>, shape=[n_hidden_units, ])),</span><br><span class="line">    # shape (<span class="number">10</span>, )</span><br><span class="line">    <span class="string">'out'</span>: <span class="keyword">tf</span>.Variable(<span class="keyword">tf</span>.constant(<span class="number">0.1</span>, shape=[n_classes, ]))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="定义-RNN-的主体结构"><a href="#定义-RNN-的主体结构" class="headerlink" title="定义 RNN 的主体结构"></a>定义 RNN 的主体结构</h4><p>接着开始定义 RNN 主体结构, 这个 RNN 总共有 3 个组成部分 ( input_layer, cell, output_layer). </p>
<p>1.首先我们先定义 input_layer:<br><figure class="highlight tp"><table><tr><td class="code"><pre><span class="line">def RNN(<span class="keyword">X</span>, weights, biases):</span><br><span class="line">    # 原始的 <span class="keyword">X</span> 是 <span class="number">3</span> 维数据, 我们需要把它变成 <span class="number">2</span> 维数据才能使用 weights 的矩阵乘法</span><br><span class="line">    # <span class="keyword">X</span> ==&gt; (<span class="number">128</span> batches * <span class="number">28</span> steps, <span class="number">28</span> inputs)</span><br><span class="line">    <span class="keyword">X</span> = tf.reshape(<span class="keyword">X</span>, [<span class="number">-1</span>, n_inputs])</span><br><span class="line"></span><br><span class="line">    # X_in = <span class="keyword">W</span>*<span class="keyword">X</span> + b</span><br><span class="line">    X_in = tf.matmul(<span class="keyword">X</span>, weights[<span class="string">'in'</span>]) + biases[<span class="string">'in'</span>]</span><br><span class="line">    # X_in ==&gt; (<span class="number">128</span> batches, <span class="number">28</span> steps, <span class="number">128</span> hidden) 换回<span class="number">3</span>维</span><br><span class="line">    X_in = tf.reshape(X_in, [<span class="number">-1</span>, n_steps, n_hidden_units])</span><br></pre></td></tr></table></figure></p>
<p>2.接着是 cell 中的计算, 有两种途径:</p>
<ul>
<li>使用 tf.nn.rnn(cell, inputs) (不推荐).</li>
<li>使用 tf.nn.dynamic_rnn(cell, inputs) (推荐). 这次的练习将使用这种方式.<br>因 Tensorflow 版本升级原因, state_is_tuple=True 将在之后的版本中变为默认. 对于 lstm 来说, state可被分为(c_state, h_state).<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用 basic LSTM Cell.</span></span><br><span class="line">lstm_cell = tf.contrib.rnn.BasicLSTMCell(n_hidden_units, <span class="attribute">forget_bias</span>=1.0, <span class="attribute">state_is_tuple</span>=<span class="literal">True</span>)</span><br><span class="line">init_state = lstm_cell.zero_state(batch_size, <span class="attribute">dtype</span>=tf.float32) # 初始化全零 state</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>如果使用tf.nn.dynamic_rnn(cell, inputs), 我们要确定 inputs 的格式. tf.nn.dynamic_rnn 中的 time_major 参数会针对不同 inputs 格式有不同的值.</p>
<ul>
<li>如果inputs 为 (batches, steps, inputs) ==&gt; time_major=False;</li>
<li>如果 inputs 为 (steps, batches, inputs) ==&gt; time_major=True;</li>
</ul>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">outputs, final_state = tf.nn.dynamic_rnn(lstm_cell, X_in, <span class="attribute">initial_state</span>=init_state, <span class="attribute">time_major</span>=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<p>3.最后是 output_layer 和 return 的值. 因为这个例子的特殊性, 有两种方法可以求得 results.<br>方式一: 直接调用final_state 中的 h_state (final_state[1]) 来进行运算:<br><figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">results = tf.matmul(final_state[<span class="number">1</span>], weights[<span class="string">'out'</span>]) + biases[<span class="string">'out'</span>]</span><br></pre></td></tr></table></figure></p>
<p>方式二: 调用最后一个 outputs (在这个例子中,和上面的final_state[1]是一样的):<br><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 把 outputs 变成 列表 [(batch, outputs)..] * steps</span></span><br><span class="line"><span class="attr">outputs</span> = tf.unstack(tf.transpose(outputs, [<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>]))</span><br><span class="line"><span class="attr">results</span> = tf.matmul(outputs[-<span class="number">1</span>], weights[<span class="string">'out'</span>]) + biases[<span class="string">'out'</span>]    <span class="comment">#选取最后一个 output</span></span><br></pre></td></tr></table></figure></p>
<p>定义好了 RNN 主体结构后, 我们就可以来计算 cost 和 train_op:<br><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">pred</span> = RNN(x, weights, biases)</span><br><span class="line"><span class="attr">cost</span> = tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(pred, y))</span><br><span class="line"><span class="attr">train_op</span> = tf.train.AdamOptimizer(lr).minimize(cost)</span><br></pre></td></tr></table></figure></p>
<h4 id="训练-RNN"><a href="#训练-RNN" class="headerlink" title="训练 RNN"></a>训练 RNN</h4><p>训练时, 不断输出 accuracy, 观看结果:<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">correct_pred = tf.equal(tf.argmax(pred, 1), tf.argmax(y, 1))</span><br><span class="line">accuracy = tf.reduce_mean(tf.cast(correct_pred, tf.float32))</span><br><span class="line"></span><br><span class="line"><span class="comment"># init= tf.initialize_all_variables() # tf 马上就要废弃这种写法</span></span><br><span class="line"><span class="comment"># 替换成下面的写法:</span></span><br><span class="line">init = tf.global_variables_initializer()</span><br><span class="line"></span><br><span class="line">with tf.Session() as sess:</span><br><span class="line">    sess.<span class="builtin-name">run</span>(init)</span><br><span class="line">    <span class="keyword">step</span> = 0</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">step</span> * batch_size &lt; training_iters:</span><br><span class="line">        batch_xs, batch_ys = mnist.train.next_batch(batch_size)</span><br><span class="line">        batch_xs = batch_xs.reshape([batch_size, n_steps, n_inputs])</span><br><span class="line">        sess.<span class="builtin-name">run</span>([train_op], feed_dict=&#123;</span><br><span class="line">            x: batch_xs,</span><br><span class="line">            y: batch_ys,</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">step</span> % 20 == 0:</span><br><span class="line">            <span class="builtin-name">print</span>(sess.<span class="builtin-name">run</span>(accuracy, feed_dict=&#123;</span><br><span class="line">            x: batch_xs,</span><br><span class="line">            y: batch_ys,</span><br><span class="line">        &#125;))</span><br><span class="line">        <span class="keyword">step</span> += 1</span><br></pre></td></tr></table></figure></p>
<p>结果如图所示：<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/chapter4/p2.png" alt></p>
<h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><p><a href="https://github.com/MorvanZhou/tutorials/tree/master/tensorflowTUT/tf20_RNN2" target="_blank" rel="noopener">分类例子</a></p>
<h3 id="RNN回归例子"><a href="#RNN回归例子" class="headerlink" title="RNN回归例子"></a>RNN回归例子</h3><p>这次我们会使用 RNN 来进行回归的训练 (Regression). 会继续使用到自己创建的 sin 曲线预测一条 cos 曲线. 接下来我们先确定 RNN 的各种参数(super-parameters):<br><figure class="highlight nix"><table><tr><td class="code"><pre><span class="line"><span class="built_in">import</span> tensorflow as tf</span><br><span class="line"><span class="built_in">import</span> numpy as np</span><br><span class="line"><span class="built_in">import</span> matplotlib.pyplot as plt</span><br><span class="line"></span><br><span class="line"><span class="attr">BATCH_START</span> = <span class="number">0</span>     <span class="comment"># 建立 batch data 时候的 index</span></span><br><span class="line"><span class="attr">TIME_STEPS</span> = <span class="number">20</span>     <span class="comment"># backpropagation through time 的 time_steps</span></span><br><span class="line"><span class="attr">BATCH_SIZE</span> = <span class="number">50</span>     </span><br><span class="line"><span class="attr">INPUT_SIZE</span> = <span class="number">1</span>      <span class="comment"># sin 数据输入 size</span></span><br><span class="line"><span class="attr">OUTPUT_SIZE</span> = <span class="number">1</span>     <span class="comment"># cos 数据输出 size</span></span><br><span class="line"><span class="attr">CELL_SIZE</span> = <span class="number">10</span>      <span class="comment"># RNN 的 hidden unit size </span></span><br><span class="line"><span class="attr">LR</span> = <span class="number">0.006</span>          <span class="comment"># learning rate</span></span><br></pre></td></tr></table></figure></p>
<h4 id="数据生成"><a href="#数据生成" class="headerlink" title="数据生成"></a>数据生成</h4><p>定义一个生成数据的 get_batch function:<br><figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">def get_batch():</span><br><span class="line">    global BATCH_START, TIME_STEPS</span><br><span class="line">    # xs shape (50<span class="built_in">batch</span>, 20steps)</span><br><span class="line">    xs = <span class="built_in">np</span>.arange(BATCH_START, BATCH_START+TIME_STEPS*BATCH_SIZE).reshape((BATCH_SIZE, TIME_STEPS)) / (<span class="number">10</span>*<span class="built_in">np</span>.pi)</span><br><span class="line">    seq = <span class="built_in">np</span>.<span class="built_in">sin</span>(xs)</span><br><span class="line">    res = <span class="built_in">np</span>.<span class="built_in">cos</span>(xs)</span><br><span class="line">    BATCH_START += TIME_STEPS</span><br><span class="line">    # returned seq, res <span class="keyword">and</span> xs: shape (<span class="built_in">batch</span>, <span class="keyword">step</span>, input)</span><br><span class="line">    <span class="built_in">return</span> [seq[:, :, <span class="built_in">np</span>.newaxis], res[:, :, <span class="built_in">np</span>.newaxis], xs]</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/chapter4/p3.png" alt></p>
<h4 id="定义-LSTMRNN-的主体结构"><a href="#定义-LSTMRNN-的主体结构" class="headerlink" title="定义 LSTMRNN 的主体结构"></a>定义 LSTMRNN 的主体结构</h4><p>使用一个 class 来定义这次的 LSTMRNN 会更加方便. 第一步定义 class 中的 <strong>init</strong> 传入各种参数:<br><figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> LSTMRNN(object):</span><br><span class="line">    def __init__(<span class="keyword">self</span>, n_steps, input_size, output_size, cell_size, batch_size):</span><br><span class="line">        <span class="keyword">self</span>.n_steps = n_steps</span><br><span class="line">        <span class="keyword">self</span>.input_size = input_size</span><br><span class="line">        <span class="keyword">self</span>.output_size = output_size</span><br><span class="line">        <span class="keyword">self</span>.cell_size = cell_size</span><br><span class="line">        <span class="keyword">self</span>.batch_size = batch_size</span><br><span class="line">        <span class="keyword">with</span> tf.name_scope(<span class="string">'inputs'</span>):</span><br><span class="line">            <span class="keyword">self</span>.xs = tf.placeholder(tf.float32, [None, n_steps, input_size], name=<span class="string">'xs'</span>)</span><br><span class="line">            <span class="keyword">self</span>.ys = tf.placeholder(tf.float32, [None, n_steps, output_size], name=<span class="string">'ys'</span>)</span><br><span class="line">        <span class="keyword">with</span> tf.variable_scope(<span class="string">'in_hidden'</span>):</span><br><span class="line">            <span class="keyword">self</span>.add_input_layer()</span><br><span class="line">        <span class="keyword">with</span> tf.variable_scope(<span class="string">'LSTM_cell'</span>):</span><br><span class="line">            <span class="keyword">self</span>.add_cell()</span><br><span class="line">        <span class="keyword">with</span> tf.variable_scope(<span class="string">'out_hidden'</span>):</span><br><span class="line">            <span class="keyword">self</span>.add_output_layer()</span><br><span class="line">        <span class="keyword">with</span> tf.name_scope(<span class="string">'cost'</span>):</span><br><span class="line">            <span class="keyword">self</span>.compute_cost()</span><br><span class="line">        <span class="keyword">with</span> tf.name_scope(<span class="string">'train'</span>):</span><br><span class="line">            <span class="keyword">self</span>.train_op = tf.train.AdamOptimizer(LR).minimize(<span class="keyword">self</span>.cost)</span><br></pre></td></tr></table></figure></p>
<p>设置 add_input_layer 功能, 添加 input_layer:</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_input_layer</span><span class="params">(<span class="keyword">self</span>,)</span></span><span class="symbol">:</span></span><br><span class="line">    l_in_x = tf.reshape(<span class="keyword">self</span>.xs, [-<span class="number">1</span>, <span class="keyword">self</span>.input_size], name=<span class="string">'2_2D'</span>)  <span class="comment"># (batch*n_step, in_size)</span></span><br><span class="line">    <span class="comment"># Ws (in_size, cell_size)</span></span><br><span class="line">    Ws_in = <span class="keyword">self</span>._weight_variable([<span class="keyword">self</span>.input_size, <span class="keyword">self</span>.cell_size])</span><br><span class="line">    <span class="comment"># bs (cell_size, )</span></span><br><span class="line">    bs_in = <span class="keyword">self</span>._bias_variable([<span class="keyword">self</span>.cell_size,])</span><br><span class="line">    <span class="comment"># l_in_y = (batch * n_steps, cell_size)</span></span><br><span class="line">    with tf.name_scope(<span class="string">'Wx_plus_b'</span>)<span class="symbol">:</span></span><br><span class="line">        l_in_y = tf.matmul(l_in_x, Ws_in) + bs_in</span><br><span class="line">    <span class="comment"># reshape l_in_y ==&gt; (batch, n_steps, cell_size)</span></span><br><span class="line">    <span class="keyword">self</span>.l_in_y = tf.reshape(l_in_y, [-<span class="number">1</span>, <span class="keyword">self</span>.n_steps, <span class="keyword">self</span>.cell_size], name=<span class="string">'2_3D'</span>)</span><br></pre></td></tr></table></figure>
<p>设置 add_cell 功能, 添加 cell, 注意这里的 self.cell_init_state, 因为我们在 training 的时候, 这个地方要特别说明.<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">def add_cell(self):</span><br><span class="line">    lstm_cell = tf.contrib.rnn.BasicLSTMCell(self.cell_size, <span class="attribute">forget_bias</span>=1.0, <span class="attribute">state_is_tuple</span>=<span class="literal">True</span>)</span><br><span class="line">    with tf.name_scope(<span class="string">'initial_state'</span>):</span><br><span class="line">        self.cell_init_state = lstm_cell.zero_state(self.batch_size, <span class="attribute">dtype</span>=tf.float32)</span><br><span class="line">    self.cell_outputs, self.cell_final_state = tf.nn.dynamic_rnn(</span><br><span class="line">        lstm_cell, self.l_in_y, <span class="attribute">initial_state</span>=self.cell_init_state, <span class="attribute">time_major</span>=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure></p>
<p>设置 add_output_layer 功能, 添加 output_layer:<br><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_output_layer</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">    <span class="comment"># shape = (batch * steps, cell_size)</span></span><br><span class="line">    l_out_x = tf.reshape(<span class="keyword">self</span>.cell_outputs, [-<span class="number">1</span>, <span class="keyword">self</span>.cell_size], name=<span class="string">'2_2D'</span>)</span><br><span class="line">    Ws_out = <span class="keyword">self</span>._weight_variable([<span class="keyword">self</span>.cell_size, <span class="keyword">self</span>.output_size])</span><br><span class="line">    bs_out = <span class="keyword">self</span>._bias_variable([<span class="keyword">self</span>.output_size, ])</span><br><span class="line">    <span class="comment"># shape = (batch * steps, output_size)</span></span><br><span class="line">    with tf.name_scope(<span class="string">'Wx_plus_b'</span>)<span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.pred = tf.matmul(l_out_x, Ws_out) + bs_out</span><br></pre></td></tr></table></figure></p>
<h4 id="训练-LSTMRNN"><a href="#训练-LSTMRNN" class="headerlink" title="训练 LSTMRNN"></a>训练 LSTMRNN</h4><figure class="highlight nix"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="attr">__name__</span> == '__main__':</span><br><span class="line">    <span class="comment"># 搭建 LSTMRNN 模型</span></span><br><span class="line">    <span class="attr">model</span> = LSTMRNN(TIME_STEPS, INPUT_SIZE, OUTPUT_SIZE, CELL_SIZE, BATCH_SIZE)</span><br><span class="line">    <span class="attr">sess</span> = tf.Session()</span><br><span class="line">    <span class="comment"># sess.run(tf.initialize_all_variables()) # tf 马上就要废弃这种写法</span></span><br><span class="line">    <span class="comment"># 替换成下面的写法:</span></span><br><span class="line">    sess.run(tf.global_variables_initializer())</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 训练 200 次</span></span><br><span class="line">    for i <span class="keyword">in</span> range(<span class="number">200</span>):</span><br><span class="line">        seq, res, <span class="attr">xs</span> = get_batch()  <span class="comment"># 提取 batch data</span></span><br><span class="line">        <span class="keyword">if</span> <span class="attr">i</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># 初始化 data</span></span><br><span class="line">            <span class="attr">feed_dict</span> = &#123;</span><br><span class="line">                    model.xs: seq,</span><br><span class="line">                    model.ys: res,</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="attr">feed_dict</span> = &#123;</span><br><span class="line">                model.xs: seq,</span><br><span class="line">                model.ys: res,</span><br><span class="line">                model.cell_init_state: state    <span class="comment"># 保持 state 的连续性</span></span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 训练</span></span><br><span class="line">        _, cost, state, <span class="attr">pred</span> = sess.run(</span><br><span class="line">            [model.train_op, model.cost, model.cell_final_state, model.pred],</span><br><span class="line">            <span class="attr">feed_dict=feed_dict)</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 打印 cost 结果</span></span><br><span class="line">        <span class="keyword">if</span> i % <span class="number">20</span> == <span class="number">0</span>:</span><br><span class="line">            print('cost: ', round(cost, <span class="number">4</span>))</span><br></pre></td></tr></table></figure>
<h4 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h4><p><a href="https://github.com/MorvanZhou/tutorials/tree/master/tensorflowTUT/tf20_RNN2.2" target="_blank" rel="noopener">回归例子</a></p>
<h3 id="回归例子可视化"><a href="#回归例子可视化" class="headerlink" title="回归例子可视化"></a>回归例子可视化</h3><p>使用 Matplotlib 模块来进行可视化过程, 在建立好 model 以后, 设置 plt.ion() 使 plt.show()可以连续显示.<br><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">model = LSTMRNN(TIME_STEPS, INPUT_SIZE, OUTPUT_SIZE, CELL_SIZE, BATCH_SIZE)</span><br><span class="line">sess = tf.Session()</span><br><span class="line"><span class="comment"># sess.run(tf.initialize_all_variables()) # tf 马上就要废弃这种写法</span></span><br><span class="line"><span class="comment"># 替换成下面的写法:</span></span><br><span class="line">sess.<span class="keyword">run</span><span class="bash">(tf.global_variables_initializer())</span></span><br><span class="line">plt.ion()   <span class="comment"># 设置连续 plot</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p>
<p>然后在 sess.run() 后面加上plt.draw()的步骤.<br><figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line"><span class="symbol">_</span>, cost, state, <span class="built_in">pred</span> = sess.run(</span><br><span class="line">            [model.train_op, model.cost, model.cell_final_state, model.<span class="built_in">pred</span>],</span><br><span class="line">            feed_dict=feed_dict)</span><br><span class="line"># plotting</span><br><span class="line">plt.plot(xs[<span class="number">0</span>, :], res[<span class="number">0</span>].<span class="built_in">flatten</span>(), 'r', xs[<span class="number">0</span>, :], <span class="built_in">pred</span>.<span class="built_in">flatten</span>()[:TIME_STEPS], 'b--')</span><br><span class="line">plt.ylim((-<span class="number">1.2</span>, <span class="number">1.2</span>))</span><br><span class="line">plt.<span class="built_in">draw</span>()</span><br><span class="line">plt.pause(<span class="number">0.3</span>)  # 每 <span class="number">0.3</span> s 刷新一次</span><br></pre></td></tr></table></figure></p>
<p>最后的结果显示为:</p>
<p><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/chapter4/x.gif" alt></p>
]]></content>
      <tags>
        <tag>tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title>基于RNN生成古诗词</title>
    <url>/blog/2017/05/tensorflow-rnn-poetry.html</url>
    <content><![CDATA[<p>RNN不像传统的神经网络-它们的输出输出是固定的，而RNN允许我们输入输出向量序列。RNN是为了对序列数据进行建模而产生的。<br>例如本帖要使用RNN生成古诗，你给它输入一堆古诗词，它会学着生成和前面相关联的字词。如果你给它输入一堆姓名，它会学着生成姓名；给它输入一堆古典乐/歌词，它会学着生成古典乐/歌词，甚至可以给它输入源代码。</p>
<h3 id="使用的数据集"><a href="#使用的数据集" class="headerlink" title="使用的数据集"></a>使用的数据集</h3><p>全唐诗(43030首)：<a href="https://pan.baidu.com/s/1o7QlUhO" target="_blank" rel="noopener">https://pan.baidu.com/s/1o7QlUhO</a></p>
<h3 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h3><p>主要需要注意的是tensorflow的版本变化较快，API经常会发生变化，本文代码基于tensorflow1.1<br>1.0版本与1.1版本的主要差别在于MultiRNNCell的使用<br>在新版中要这样写<br>cell = tf.contrib.rnn.MultiRNNCell([tf.contrib.rnn.BasicLSTMCell(rnn_size) for _ in range(num_layers)], state_is_tuple=True)</p>
<p>训练的过程如下所示<br>1.首先读取诗集<br>2.把诗转化成向量形式<br>3.定义RNN<br>4.训练<br>5.将训练的模型存储起来</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">import collections</span><br><span class="line">import numpy <span class="keyword">as</span> np</span><br><span class="line">import tensorflow <span class="keyword">as</span> <span class="keyword">tf</span></span><br><span class="line">import os</span><br><span class="line">os.environ[<span class="string">'TF_CPP_MIN_LOG_LEVEL'</span>]=<span class="string">'2'</span></span><br><span class="line"># -------------------------------数据预处理---------------------------#</span><br><span class="line"></span><br><span class="line">poetry_file = <span class="string">'poetry.txt'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 诗集</span><br><span class="line">poetrys = []</span><br><span class="line">with <span class="keyword">open</span>(poetry_file, <span class="string">"r"</span>, encoding=<span class="string">'utf-8'</span>, ) <span class="keyword">as</span> <span class="keyword">f</span>:</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">line</span> in <span class="keyword">f</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            title, content = <span class="built_in">line</span>.strip().<span class="keyword">split</span>(<span class="string">':'</span>)</span><br><span class="line">            content = content.replace(<span class="string">' '</span>, <span class="string">''</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="string">'_'</span> in content <span class="built_in">or</span> <span class="string">'('</span> in content <span class="built_in">or</span> <span class="string">'（'</span> in content <span class="built_in">or</span> <span class="string">'《'</span> in content <span class="built_in">or</span> <span class="string">'['</span> in conten<span class="variable">t:</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(content) &lt; <span class="number">5</span> <span class="built_in">or</span> <span class="built_in">len</span>(content) &gt; <span class="number">79</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            content = <span class="string">'['</span> + content + <span class="string">']'</span></span><br><span class="line">            poetrys.<span class="keyword">append</span>(content)</span><br><span class="line">        except Exception <span class="keyword">as</span> <span class="keyword">e</span>:</span><br><span class="line">            pass</span><br><span class="line"></span><br><span class="line"># 按诗的字数排序</span><br><span class="line">poetrys = sorted(poetrys, key=lambda <span class="built_in">line</span>: <span class="built_in">len</span>(<span class="built_in">line</span>))</span><br><span class="line"><span class="keyword">print</span>(<span class="string">'唐诗总数: '</span>, <span class="built_in">len</span>(poetrys))</span><br><span class="line"></span><br><span class="line"># 统计每个字出现次数</span><br><span class="line">all_words = []</span><br><span class="line"><span class="keyword">for</span> poetry in poetry<span class="variable">s:</span></span><br><span class="line">    all_words += [word <span class="keyword">for</span> word in poetry]</span><br><span class="line">counter = collections.Counter(all_words)</span><br><span class="line">count_pairs = sorted(counter.<span class="built_in">items</span>(), key=lambda <span class="keyword">x</span>: -<span class="keyword">x</span>[<span class="number">1</span>])</span><br><span class="line">words, _ = zip(*count_pairs)</span><br><span class="line"></span><br><span class="line"># 取前多少个常用字</span><br><span class="line">words = words[:<span class="built_in">len</span>(words)] + (<span class="string">' '</span>,)</span><br><span class="line"># 每个字映射为一个数字ID</span><br><span class="line">word_num_map = dict(zip(words, <span class="built_in">range</span>(<span class="built_in">len</span>(words))))</span><br><span class="line"># 把诗转换为向量形式，参考TensorFlow练习<span class="number">1</span></span><br><span class="line">to_num = lambda word: word_num_map.<span class="built_in">get</span>(word, <span class="built_in">len</span>(words))</span><br><span class="line">poetrys_vector = [<span class="keyword">list</span>(<span class="keyword">map</span>(to_num, poetry)) <span class="keyword">for</span> poetry in poetrys]</span><br><span class="line"># [[<span class="number">314</span>, <span class="number">3199</span>, <span class="number">367</span>, <span class="number">1556</span>, <span class="number">26</span>, <span class="number">179</span>, <span class="number">680</span>, <span class="number">0</span>, <span class="number">3199</span>, <span class="number">41</span>, <span class="number">506</span>, <span class="number">40</span>, <span class="number">151</span>, <span class="number">4</span>, <span class="number">98</span>, <span class="number">1</span>],</span><br><span class="line"># [<span class="number">339</span>, <span class="number">3</span>, <span class="number">133</span>, <span class="number">31</span>, <span class="number">302</span>, <span class="number">653</span>, <span class="number">512</span>, <span class="number">0</span>, <span class="number">37</span>, <span class="number">148</span>, <span class="number">294</span>, <span class="number">25</span>, <span class="number">54</span>, <span class="number">833</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">965</span>, <span class="number">1315</span>, <span class="number">377</span>, <span class="number">1700</span>, <span class="number">562</span>, <span class="number">21</span>, <span class="number">37</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1253</span>, <span class="number">21</span>, <span class="number">36</span>, <span class="number">264</span>, <span class="number">877</span>, <span class="number">809</span>, <span class="number">1</span>]</span><br><span class="line"># ....]</span><br><span class="line"></span><br><span class="line"># 每次取<span class="number">64</span>首诗进行训练</span><br><span class="line">batch_size = <span class="number">64</span></span><br><span class="line">n_chunk = <span class="built_in">len</span>(poetrys_vector) // batch_size</span><br><span class="line">x_batches = []</span><br><span class="line">y_batches = []</span><br><span class="line"><span class="keyword">for</span> i in <span class="built_in">range</span>(n_chunk):</span><br><span class="line">    start_index = i * batch_size</span><br><span class="line">    end_index = start_index + batch_size</span><br><span class="line"></span><br><span class="line">    batches = poetrys_vector[start_index:end_index]</span><br><span class="line">    length = <span class="built_in">max</span>(<span class="keyword">map</span>(<span class="built_in">len</span>, batches))</span><br><span class="line">    xdata = np.full((batch_size, length), word_num_map[<span class="string">' '</span>], np.int32)</span><br><span class="line">    <span class="keyword">for</span> row in <span class="built_in">range</span>(batch_size):</span><br><span class="line">        xdata[row, :<span class="built_in">len</span>(batches[row])] = batches[row]</span><br><span class="line">    ydata = np.<span class="keyword">copy</span>(xdata)</span><br><span class="line">    ydata[:, :-<span class="number">1</span>] = xdata[:, <span class="number">1</span>:]</span><br><span class="line">    <span class="string">""</span><span class="comment">"</span></span><br><span class="line">    xdata             ydata</span><br><span class="line">    [<span class="number">6</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">9</span>]       [<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">9</span>]</span><br><span class="line">    [<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">5</span>]       [<span class="number">4</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">5</span>]</span><br><span class="line">    <span class="string">""</span><span class="comment">"</span></span><br><span class="line">    x_batches.<span class="keyword">append</span>(xdata)</span><br><span class="line">    y_batches.<span class="keyword">append</span>(ydata)</span><br><span class="line"></span><br><span class="line"># ---------------------------------------RNN--------------------------------------#</span><br><span class="line"></span><br><span class="line">input_data = <span class="keyword">tf</span>.placeholder(<span class="keyword">tf</span>.int32, [batch_size, None])</span><br><span class="line">output_targets = <span class="keyword">tf</span>.placeholder(<span class="keyword">tf</span>.int32, [batch_size, None])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 定义RNN</span><br><span class="line">def neural_network(model=<span class="string">'lstm'</span>, rnn_size=<span class="number">128</span>, num_layers=<span class="number">2</span>):</span><br><span class="line">    <span class="keyword">if</span> model == <span class="string">'rnn'</span>:</span><br><span class="line">        cell_fun = <span class="keyword">tf</span>.contrib.rnn.BasicRNNCell</span><br><span class="line">    elif model == <span class="string">'gru'</span>:</span><br><span class="line">        cell_fun = <span class="keyword">tf</span>.contrib.rnn.GRUCell</span><br><span class="line">    elif model == <span class="string">'lstm'</span>:</span><br><span class="line">        cell_fun = <span class="keyword">tf</span>.contrib.rnn.BasicLSTMCell</span><br><span class="line"></span><br><span class="line">    # cell = cell_fun(rnn_size, state_is_tuple=True,reuse=<span class="keyword">tf</span>.get_variable_scope().reuse)</span><br><span class="line">    scell = <span class="keyword">tf</span>.contrib.rnn.BasicLSTMCell(rnn_size)</span><br><span class="line">    cell = <span class="keyword">tf</span>.contrib.rnn.MultiRNNCell([<span class="keyword">tf</span>.contrib.rnn.BasicLSTMCell(rnn_size) <span class="keyword">for</span> _ in <span class="built_in">range</span>(num_layers)], state_is_tuple=True)</span><br><span class="line"></span><br><span class="line">    initial_state = cell.zero_state(batch_size, <span class="keyword">tf</span>.float32)</span><br><span class="line"></span><br><span class="line">    with <span class="keyword">tf</span>.variable_scope(<span class="string">'rnnlm'</span>):</span><br><span class="line">        softmax_w = <span class="keyword">tf</span>.get_variable(<span class="string">"softmax_w"</span>, [rnn_size, <span class="built_in">len</span>(words) + <span class="number">1</span>])</span><br><span class="line">        softmax_b = <span class="keyword">tf</span>.get_variable(<span class="string">"softmax_b"</span>, [<span class="built_in">len</span>(words) + <span class="number">1</span>])</span><br><span class="line">        with <span class="keyword">tf</span>.device(<span class="string">"/cpu:0"</span>):</span><br><span class="line">            embedding = <span class="keyword">tf</span>.get_variable(<span class="string">"embedding"</span>, [<span class="built_in">len</span>(words) + <span class="number">1</span>, rnn_size])</span><br><span class="line">            inputs = <span class="keyword">tf</span>.<span class="keyword">nn</span>.embedding_lookup(embedding, input_data)</span><br><span class="line"></span><br><span class="line">    outputs, last_state = <span class="keyword">tf</span>.<span class="keyword">nn</span>.dynamic_rnn(cell, inputs, initial_state=initial_state, scope=<span class="string">'rnnlm'</span>)</span><br><span class="line">    output = <span class="keyword">tf</span>.reshape(outputs, [-<span class="number">1</span>, rnn_size])</span><br><span class="line"></span><br><span class="line">    logits = <span class="keyword">tf</span>.matmul(output, softmax_w) + softmax_b</span><br><span class="line">    probs = <span class="keyword">tf</span>.<span class="keyword">nn</span>.softmax(logits)</span><br><span class="line">    <span class="keyword">return</span> logits, last_state, probs, cell, initial_state</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 训练</span><br><span class="line">def train_neural_network():</span><br><span class="line">    logits, last_state, _, _, _ = neural_network()</span><br><span class="line">    targets = <span class="keyword">tf</span>.reshape(output_targets, [-<span class="number">1</span>])</span><br><span class="line">    loss = <span class="keyword">tf</span>.contrib.legacy_seq2seq.sequence_loss_by_example([logits], [targets], [<span class="keyword">tf</span>.ones_like(targets, dtype=<span class="keyword">tf</span>.float32)],</span><br><span class="line">                                                  <span class="built_in">len</span>(words))</span><br><span class="line">    cost = <span class="keyword">tf</span>.reduce_mean(loss)</span><br><span class="line">    learning_rate = <span class="keyword">tf</span>.Variable(<span class="number">0.0</span>, trainable=False)</span><br><span class="line">    tvars = <span class="keyword">tf</span>.trainable_variables()</span><br><span class="line">    grads, _ = <span class="keyword">tf</span>.clip_by_global_norm(<span class="keyword">tf</span>.gradients(cost, tvars), <span class="number">5</span>)</span><br><span class="line">    optimizer = <span class="keyword">tf</span>.train.AdamOptimizer(learning_rate)</span><br><span class="line">    train_op = optimizer.apply_gradients(zip(grads, tvars))</span><br><span class="line"></span><br><span class="line">    with <span class="keyword">tf</span>.Session() <span class="keyword">as</span> ses<span class="variable">s:</span></span><br><span class="line">        sess.run(<span class="keyword">tf</span>.global_variables_initializer())</span><br><span class="line"></span><br><span class="line">        saver = <span class="keyword">tf</span>.train.Saver(<span class="keyword">tf</span>.global_variables())</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> epoch in <span class="built_in">range</span>(<span class="number">50</span>):</span><br><span class="line">            sess.run(<span class="keyword">tf</span>.assign(learning_rate, <span class="number">0.002</span> * (<span class="number">0.97</span> ** epoch)))</span><br><span class="line">            n = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> batche in <span class="built_in">range</span>(n_chunk):</span><br><span class="line">                train_loss, _, _ = sess.run([cost, last_state, train_op],</span><br><span class="line">                                            feed_dict=&#123;input_dat<span class="variable">a:</span> x_batches[n], output_target<span class="variable">s:</span> y_batches[n]&#125;)</span><br><span class="line">                n += <span class="number">1</span></span><br><span class="line">                <span class="keyword">print</span>(epoch, batche, train_loss)</span><br><span class="line">            <span class="keyword">if</span> epoch % <span class="number">7</span> == <span class="number">0</span>:</span><br><span class="line">                saver.save(sess, <span class="string">'poetry.module'</span>, global_step=epoch)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">train_neural_network()</span><br></pre></td></tr></table></figure>
<h3 id="生成古诗"><a href="#生成古诗" class="headerlink" title="生成古诗"></a>生成古诗</h3><p>生成古诗的步骤较简单<br>1.构造一个与训练时同样的RNN<br>2.读取存储的模型<br>3.输入开始标志[<br>4.循环获得模型输出结果<br>5.直到结束标志]<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">import collections</span><br><span class="line">import numpy as np</span><br><span class="line">import tensorflow as tf</span><br><span class="line">import os</span><br><span class="line">os.environ['TF_CPP_MIN_LOG_LEVEL']='2'</span><br><span class="line"></span><br><span class="line"><span class="comment"># -------------------------------数据预处理---------------------------#</span></span><br><span class="line"></span><br><span class="line">poetry_file = 'poetry.txt'</span><br><span class="line"></span><br><span class="line"><span class="comment"># 诗集</span></span><br><span class="line">poetrys = []</span><br><span class="line"><span class="keyword">with</span> <span class="keyword">open</span>(poetry_file, <span class="string">"r"</span>, <span class="keyword">encoding</span>=<span class="string">'utf-8'</span>, ) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">        try:</span><br><span class="line">            title, <span class="keyword">content</span> = line.strip().split(<span class="string">':'</span>)</span><br><span class="line">            <span class="keyword">content</span> = content.replace(<span class="string">' '</span>, <span class="string">''</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="string">'_'</span> <span class="keyword">in</span> <span class="keyword">content</span> <span class="keyword">or</span> <span class="string">'('</span> <span class="keyword">in</span> <span class="keyword">content</span> <span class="keyword">or</span> <span class="string">'（'</span> <span class="keyword">in</span> <span class="keyword">content</span> <span class="keyword">or</span> <span class="string">'《'</span> <span class="keyword">in</span> <span class="keyword">content</span> <span class="keyword">or</span> <span class="string">'['</span> <span class="keyword">in</span> <span class="keyword">content</span>:</span><br><span class="line">                continue</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">len</span>(<span class="keyword">content</span>) &lt; <span class="number">5</span> <span class="keyword">or</span> <span class="keyword">len</span>(<span class="keyword">content</span>) &gt; <span class="number">79</span>:</span><br><span class="line">                continue</span><br><span class="line">            <span class="keyword">content</span> = <span class="string">'['</span> + <span class="keyword">content</span> + <span class="string">']'</span></span><br><span class="line">            poetrys.append(<span class="keyword">content</span>)</span><br><span class="line">        <span class="keyword">except</span> <span class="keyword">Exception</span> <span class="keyword">as</span> e:</span><br><span class="line">            pass</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按诗的字数排序</span></span><br><span class="line">poetrys = sorted(poetrys, <span class="keyword">key</span>=lambda line: <span class="keyword">len</span>(line))</span><br><span class="line">print(<span class="string">'唐诗总数: '</span>, <span class="keyword">len</span>(poetrys))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计每个字出现次数</span></span><br><span class="line">all_words = []</span><br><span class="line"><span class="keyword">for</span> poetry <span class="keyword">in</span> poetrys:</span><br><span class="line">    all_words += [word <span class="keyword">for</span> word <span class="keyword">in</span> poetry]</span><br><span class="line">counter = collections.Counter(all_words)</span><br><span class="line">count_pairs = sorted(counter.items(), <span class="keyword">key</span>=lambda x: -x[<span class="number">1</span>])</span><br><span class="line">words, _ = zip(*count_pairs)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取前多少个常用字</span></span><br><span class="line">words = words[:<span class="keyword">len</span>(words)] + (<span class="string">' '</span>,)</span><br><span class="line"><span class="comment"># 每个字映射为一个数字ID</span></span><br><span class="line">word_num_map = dict(zip(words, <span class="keyword">range</span>(<span class="keyword">len</span>(words))))</span><br><span class="line"><span class="comment"># 把诗转换为向量形式，参考TensorFlow练习1</span></span><br><span class="line">to_num = lambda word: word_num_map.get(word, <span class="keyword">len</span>(words))</span><br><span class="line">poetrys_vector = [<span class="keyword">list</span>(<span class="keyword">map</span>(to_num, poetry)) <span class="keyword">for</span> poetry <span class="keyword">in</span> poetrys]</span><br><span class="line"><span class="comment"># [[314, 3199, 367, 1556, 26, 179, 680, 0, 3199, 41, 506, 40, 151, 4, 98, 1],</span></span><br><span class="line"><span class="comment"># [339, 3, 133, 31, 302, 653, 512, 0, 37, 148, 294, 25, 54, 833, 3, 1, 965, 1315, 377, 1700, 562, 21, 37, 0, 2, 1253, 21, 36, 264, 877, 809, 1]</span></span><br><span class="line"><span class="comment"># ....]</span></span><br><span class="line"></span><br><span class="line">batch_size = <span class="number">1</span></span><br><span class="line">n_chunk = <span class="keyword">len</span>(poetrys_vector) // batch_size</span><br><span class="line">x_batches = []</span><br><span class="line">y_batches = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="keyword">range</span>(n_chunk):</span><br><span class="line">    start_index = i * batch_size</span><br><span class="line">    end_index = start_index + batch_size</span><br><span class="line"></span><br><span class="line">    batches = poetrys_vector[start_index:end_index]</span><br><span class="line">    <span class="keyword">length</span> = <span class="keyword">max</span>(<span class="keyword">map</span>(<span class="keyword">len</span>, batches))</span><br><span class="line">    xdata = np.full((batch_size, <span class="keyword">length</span>), word_num_map[<span class="string">' '</span>], np.int32)</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">row</span> <span class="keyword">in</span> <span class="keyword">range</span>(batch_size):</span><br><span class="line">        xdata[<span class="keyword">row</span>, :<span class="keyword">len</span>(batches[<span class="keyword">row</span>])] = batches[<span class="keyword">row</span>]</span><br><span class="line">    ydata = np.copy(xdata)</span><br><span class="line">    ydata[:, :<span class="number">-1</span>] = xdata[:, <span class="number">1</span>:]</span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    xdata             ydata</span></span><br><span class="line"><span class="string">    [6,2,4,6,9]       [2,4,6,9,9]</span></span><br><span class="line"><span class="string">    [1,4,2,8,5]       [4,2,8,5,5]</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    x_batches.append(xdata)</span><br><span class="line">    y_batches.append(ydata)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------RNN--------------------------------------#</span></span><br><span class="line"></span><br><span class="line">input_data = tf.placeholder(tf.int32, [batch_size, <span class="keyword">None</span>])</span><br><span class="line">output_targets = tf.placeholder(tf.int32, [batch_size, <span class="keyword">None</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义RNN</span></span><br><span class="line"><span class="keyword">def</span> neural_network(<span class="keyword">model</span>=<span class="string">'lstm'</span>, rnn_size=<span class="number">128</span>, num_layers=<span class="number">2</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">model</span> == <span class="string">'rnn'</span>:</span><br><span class="line">        cell_fun = tf.contrib.rnn.BasicRNNCell</span><br><span class="line">    elif <span class="keyword">model</span> == <span class="string">'gru'</span>:</span><br><span class="line">        cell_fun = tf.contrib.rnn.GRUCell</span><br><span class="line">    elif <span class="keyword">model</span> == <span class="string">'lstm'</span>:</span><br><span class="line">        cell_fun = tf.contrib.rnn.BasicLSTMCell</span><br><span class="line"></span><br><span class="line">    scell = cell_fun(rnn_size, state_is_tuple=<span class="literal">True</span>)</span><br><span class="line">    cell = tf.contrib.rnn.MultiRNNCell([tf.contrib.rnn.BasicLSTMCell(rnn_size) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="keyword">range</span>(num_layers)],</span><br><span class="line">                                       state_is_tuple=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    initial_state = cell.zero_state(batch_size, tf.float32)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> tf.variable_scope(<span class="string">'rnnlm'</span>):</span><br><span class="line">        softmax_w = tf.get_variable(<span class="string">"softmax_w"</span>, [rnn_size, <span class="keyword">len</span>(words) + <span class="number">1</span>])</span><br><span class="line">        softmax_b = tf.get_variable(<span class="string">"softmax_b"</span>, [<span class="keyword">len</span>(words) + <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">with</span> tf.device(<span class="string">"/cpu:0"</span>):</span><br><span class="line">            embedding = tf.get_variable(<span class="string">"embedding"</span>, [<span class="keyword">len</span>(words) + <span class="number">1</span>, rnn_size])</span><br><span class="line">            inputs = tf.nn.embedding_lookup(embedding, input_data)</span><br><span class="line"></span><br><span class="line">    outputs, last_state = tf.nn.dynamic_rnn(cell, inputs, initial_state=initial_state, <span class="keyword">scope</span>=<span class="string">'rnnlm'</span>)</span><br><span class="line">    <span class="keyword">output</span> = tf.reshape(outputs, [<span class="number">-1</span>, rnn_size])</span><br><span class="line"></span><br><span class="line">    logits = tf.matmul(<span class="keyword">output</span>, softmax_w) + softmax_b</span><br><span class="line">    probs = tf.nn.softmax(logits)</span><br><span class="line">    <span class="keyword">return</span> logits, last_state, probs, cell, initial_state</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># -------------------------------生成古诗---------------------------------#</span></span><br><span class="line"><span class="comment"># 使用训练完成的模型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> gen_poetry():</span><br><span class="line">    <span class="keyword">def</span> to_word(weights):</span><br><span class="line">        t = np.cumsum(weights)</span><br><span class="line">        s = np.sum(weights)</span><br><span class="line">        <span class="keyword">sample</span> = <span class="built_in">int</span>(np.searchsorted(t, np.random.rand(<span class="number">1</span>) * s))</span><br><span class="line">        <span class="keyword">return</span> words[<span class="keyword">sample</span>]</span><br><span class="line"></span><br><span class="line">    _, last_state, probs, cell, initial_state = neural_network()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">        sess.run(tf.global_variables_initializer())</span><br><span class="line"></span><br><span class="line">        saver = tf.train.Saver(tf.global_variables())</span><br><span class="line">        saver.restore(sess, <span class="string">'poetry.module-14'</span>)</span><br><span class="line">        <span class="comment"># saver.restore(sess,tf.train.latest_checkpoint('.'))</span></span><br><span class="line">        state_ = sess.run(cell.zero_state(<span class="number">1</span>, tf.float32))</span><br><span class="line"></span><br><span class="line">        x = np.array([<span class="keyword">list</span>(<span class="keyword">map</span>(word_num_map.get, <span class="string">'['</span>))])</span><br><span class="line">        [probs_, state_] = sess.run([probs, last_state], feed_dict=&#123;input_data: x, initial_state: state_&#125;)</span><br><span class="line">        word = to_word(probs_)</span><br><span class="line">        <span class="comment"># word = words[np.argmax(probs_)]</span></span><br><span class="line">        poem = <span class="string">''</span></span><br><span class="line">        <span class="keyword">while</span> word != <span class="string">']'</span>:</span><br><span class="line">            poem += word</span><br><span class="line">            x = np.zeros((<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">            x[<span class="number">0</span>, <span class="number">0</span>] = word_num_map[word]</span><br><span class="line">            [probs_, state_] = sess.run([probs, last_state], feed_dict=&#123;input_data: x, initial_state: state_&#125;)</span><br><span class="line">            word = to_word(probs_)</span><br><span class="line">        <span class="comment"># word = words[np.argmax(probs_)]</span></span><br><span class="line">        <span class="keyword">return</span> poem</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(gen_poetry())</span><br></pre></td></tr></table></figure></p>
<h3 id="结果示例"><a href="#结果示例" class="headerlink" title="结果示例"></a>结果示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">赋田屈窥惆，水邮轻并裾。</span><br><span class="line">山水生菊性，未能凌马色。</span><br><span class="line">花望似依成，旋帛游渚起。</span><br><span class="line">神时休全孤望，鲙路四树。</span><br><span class="line">咿历飞雏陈。还笑积弦乐，</span><br><span class="line">遥知相此时。归软猷受转，</span><br><span class="line">如渡抱古波。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">我肌光天分，飏浴乏山景。</span><br><span class="line">爱悬千外力，全风王气县。</span><br><span class="line">张月吴风笛，羽来太贵光。</span><br><span class="line">洁光别成波，且归空可多。</span><br><span class="line">恰说位水帆，莫知羞转信。</span><br><span class="line">有临洞轸千，拂台合绕阳。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">我觉宫香泽，自遗无遮和。</span><br><span class="line">爱承旌来见，咏北钓梅寒。</span><br><span class="line">张座东嫌语，已喜开五馆。</span><br><span class="line">洁岛色初鼻，期上松间月。</span><br><span class="line">莫教意身小，只与别幽鞍。</span><br><span class="line">闻汤竞心藓，好家遗相归。</span><br><span class="line"></span><br><span class="line">我怅襄飨春，喔西卧剑夏。</span><br><span class="line">爱笑朱雁月，深酒礼造道。</span><br><span class="line">张曝浮痴晓，晼忧度宪行。</span><br><span class="line">洁城钓月药，舟韶桑鱼声。</span><br><span class="line">此地游留鸟，逢仙真我非。</span><br><span class="line">身在栽谁共，忧荷教得女。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">我忆先柔起，安喜水翩度。</span><br><span class="line">爱人羡辽奏，月柳竹山乘。</span><br><span class="line">张结斋津汉，绿叟敷盘甘。</span><br><span class="line">洁文北化处，何作蒙岩尧。</span><br><span class="line">风事饮来夜，深高照白州。</span><br><span class="line">栖忻一又道，袅陌在临摇。</span><br></pre></td></tr></table></figure>
<p>可见RNN模型准确的学习了格式，但语义还是不通的</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://blog.topspeedsnail.com/archives/10542" target="_blank" rel="noopener">TensorFlow练习7: 基于RNN生成古诗词</a><br><a href="https://github.com/shenzhen2017/poetryMachine" target="_blank" rel="noopener">源代码</a></p>
]]></content>
      <tags>
        <tag>tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title>日语五十音图</title>
    <url>/blog/2017/05/japanes-fifty-vows.html</url>
    <content><![CDATA[<p>使用微软自带的日语输入法输入，中日语切换为shift+Alt<br>日语平假名与片假名切换：<br>ctrl+caps lock（平假名）<br>alt+caps lock(片假名)<br>在输入过程中<br>F6 转换为平假名<br>F7 转换为片假名</p>
<h3 id="日语五十音图如下："><a href="#日语五十音图如下：" class="headerlink" title="日语五十音图如下："></a>日语五十音图如下：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">あ行：あア	いイ	うウ	えエ	おオ</span><br><span class="line">か行：かカ	きキ	くク	けケ	こコ</span><br><span class="line">さ行：さサ	しシ	すス	せセ	そソ</span><br><span class="line">た行：たタ	ちチ	つツ	てテ	とト</span><br><span class="line">な行：なナ	にニ	ぬヌ	ねネ	のノ</span><br><span class="line">は行：はハ	ひヒ	ふフ	へヘ	ほホ</span><br><span class="line">ま行：まマ	みミ	むム	めメ	もモ</span><br><span class="line">や行：やヤ		ゆユ		よヨ</span><br><span class="line">ら行：らラ	りリ	るル	れレ	ろロ</span><br><span class="line">わ行：わワ				をヲ</span><br></pre></td></tr></table></figure>
<h3 id="浊音"><a href="#浊音" class="headerlink" title="浊音"></a>浊音</h3><p>日语的浊音共有4行，20个，是由清音假名，か、さ、た、は4行派生出来的<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">が行：	がガ	ぎギ	ぐグ	げゲ	ごゴ</span><br><span class="line">ざ行：	ざザ	じジ	ずズ	ぜゼ	ぞゾ</span><br><span class="line">だ行：	だダ	ぢヂ	づヅ	でデ	どド</span><br><span class="line">ば行：	ばバ	びビ	ぶブ	べベ	ぼボ</span><br></pre></td></tr></table></figure></p>
<h3 id="半浊音"><a href="#半浊音" class="headerlink" title="半浊音"></a>半浊音</h3><p>半浊音只有一行，由は行派生出来<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ぱ	ぴ	ぷ	ぺ	ぽ</span><br><span class="line">パ	ピ	プ	ペ	ポ</span><br></pre></td></tr></table></figure></p>
<h3 id="长音"><a href="#长音" class="headerlink" title="长音"></a>长音</h3><p>将假名的发音时间延长约一倍就成了长音，长音的标记方法如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">あ段假名+	あ</span><br><span class="line">い段假名+	い</span><br><span class="line">う段假名+	う</span><br><span class="line">え段假名+	い、え</span><br><span class="line">お段假名+	う、お</span><br><span class="line">外来语+		一</span><br><span class="line">罗马字		双写元音，或者无意上面加^</span><br></pre></td></tr></table></figure></p>
<h3 id="拗音"><a href="#拗音" class="headerlink" title="拗音"></a>拗音</h3><p>在い段假名后面加上半元音や、ゆ、よ拼成的音叫做拗音，拗音虽有两个假名组成，但要读成一个章节。</p>
<h3 id="促音"><a href="#促音" class="headerlink" title="促音"></a>促音</h3><p>日语的促音是一种特殊的音节，即发音时，形成一个短暂的停顿，然后放开，使气流冲出，发出下一个假名的音<br>促音的书写方法：<br>横写时用小号字体将つ写在靠下一些，竖写时则要靠右一些。罗马字则用双写促音后第一个假名的辅音字母来表示。</p>
]]></content>
      <tags>
        <tag>外语学习</tag>
      </tags>
  </entry>
  <entry>
    <title>照片PS成动漫风格</title>
    <url>/blog/2017/06/your-name-style.html</url>
    <content><![CDATA[<p>将学校大门PS成你的名字动漫风格<br>原图如下,注意我们的图片分辨率要大，才能得到一个较好的结果：<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/ps/chapter1/p1.jpeg" alt><br>动漫风格的天空素材<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/ps/chapter1/p1.jpg" alt><br>同时注意：此方法只适合于处理风景，不适合处理人物。而且风景的处理也不适合车辆、流水等动态的物体</p>
<p>具体实现步骤如下：</p>
<h3 id="油画滤镜"><a href="#油画滤镜" class="headerlink" title="油画滤镜"></a>油画滤镜</h3><p><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/ps/chapter1/p2.jpg" alt><br>如图所示，我现在所使用的 6 个参数分别为「0.1」、「5」、「10」、「0」、「0」、「0」。<br>在使用过程中，如果觉得效果不强，可以多次使用油画滤镜</p>
<h3 id="Camera-Raw-滤镜"><a href="#Camera-Raw-滤镜" class="headerlink" title="Camera Raw 滤镜"></a>Camera Raw 滤镜</h3><p>虽然「油画」滤镜很关键，但此刻你可能还无法察觉什么明显的改变。别急，用「Camera Raw」滤镜以后你就看到效果了。<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/ps/chapter1/p3.jpg" alt><br>如图所示，曝光 +1、对比度拉到最小，阴影、黑色、清晰度、自然饱和度拉到最大</p>
<h3 id="更换天空"><a href="#更换天空" class="headerlink" title="更换天空"></a>更换天空</h3><p>思就是让你把蓝天抠掉，然后换上事先准备好的动漫风格天空素材（继续偷懒用新海诚的云）。抠图方法很多，在此也不赘述。如果你原片的天空蓝得很纯粹或灰得很纯粹（就是没有一朵朵云）的话，用「魔棒」工具至多只需要 10 秒钟吧。</p>
<h3 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h3><p><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/ps/chapter1/p4.jpg" alt></p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://zhuanlan.zhihu.com/p/20038858" target="_blank" rel="noopener">照片动漫风格 PS 教程 · 简单粗暴版</a><br><a href="https://zhuanlan.zhihu.com/p/20026525?columnSlug=spacekid" target="_blank" rel="noopener">如何把一幅照片 PS 成手绘动漫风格</a><br><a href="https://www.zhihu.com/question/29594460" target="_blank" rel="noopener">新海诚风格的画面是手绘的还是 Photoshop 就可以达到的？</a></p>
]]></content>
      <tags>
        <tag>photoshop</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello Mybatis</title>
    <url>/blog/2017/06/hello-my-batis.html</url>
    <content><![CDATA[<p>平时我们都用JDBC访问数据库，除了需要自己写SQL之外，还必须操作Connection, Statment, ResultSet 这些其实只是手段的辅助类。 不仅如此，访问不同的表，还会写很多雷同的代码，显得繁琐和枯燥。 </p>
<p>那么用了Mybatis之后，只需要自己提供SQL语句，其他的工作，诸如建立连接，Statement， JDBC相关异常处理等等都交给Mybatis去做了，那些重复性的工作Mybatis也给做掉了，我们只需要关注在增删改查等操作层面上，而把技术细节都封装在了我们看不见的地方。 </p>
<h3 id="基本原理如下："><a href="#基本原理如下：" class="headerlink" title="基本原理如下："></a>基本原理如下：</h3><ol>
<li>应用程序找Mybatis要数据</li>
<li>mbatis从数据库中找来数据<br>2.1 通过mybatis-config.xml 定位哪个数据库<br>2.2 通过Category.xml执行对应的select语句<br>2.3 基于Catgory.xml把返回的数据库记录封装在Category对象中<br>2.4 把多个Category对象装在一个Category集合中</li>
<li>返回一个Category集合</li>
</ol>
<p><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/java/chapter1/p5.png" alt></p>
<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><h4 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h4><p>首先创建数据库 how2java<br><figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> how2java</span><br></pre></td></tr></table></figure></p>
<h4 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h4><p>接着创建表category_<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">USE how2java;</span><br><span class="line"> </span><br><span class="line">CREATE TABLE category_ (</span><br><span class="line">  id int(11) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  name varchar(32)<span class="built_in"> DEFAULT </span><span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY KEY (id)</span><br><span class="line">) <span class="attribute">ENGINE</span>=MyISAM <span class="attribute">AUTO_INCREMENT</span>=1<span class="built_in"> DEFAULT </span><span class="attribute">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure></p>
<h4 id="导入数据"><a href="#导入数据" class="headerlink" title="导入数据"></a>导入数据</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">USE</span> how2java;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> category_ <span class="keyword">VALUES</span> (<span class="literal">null</span>,<span class="string">'category1'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> category_ <span class="keyword">VALUES</span> (<span class="literal">null</span>,<span class="string">'category2'</span>);</span><br></pre></td></tr></table></figure>
<h4 id="创建实体类"><a href="#创建实体类" class="headerlink" title="创建实体类"></a>创建实体类</h4><p>准备实体类Category，用于映射表category_<br><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">package com.how2java.pojo;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Category</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">String</span> <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(<span class="keyword">String</span> name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="配置文件mybatis-config-xml"><a href="#配置文件mybatis-config-xml" class="headerlink" title="配置文件mybatis-config.xml"></a>配置文件mybatis-config.xml</h4><p>在src目录下创建mybatis的主配置文件mybatis-config.xml (相当于hibernate.cfg.xml)。<br>其作用主要是提供连接数据库用的驱动，数据库名称，编码方式，账号密码<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;property <span class="attribute">name</span>=<span class="string">"driver"</span> <span class="attribute">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span><br><span class="line">&lt;property <span class="attribute">name</span>=<span class="string">"url"</span> <span class="attribute">value</span>=<span class="string">"jdbc:mysql://localhost:3306/how2java?characterEncoding=UTF-8"</span>/&gt;</span><br><span class="line">&lt;property <span class="attribute">name</span>=<span class="string">"username"</span> <span class="attribute">value</span>=<span class="string">"root"</span>/&gt;</span><br><span class="line">&lt;property <span class="attribute">name</span>=<span class="string">"password"</span> <span class="attribute">value</span>=<span class="string">"root"</span>/&gt;</span><br></pre></td></tr></table></figure></p>
<p>以及别名，自动扫描com.how2java.pojo下的类型，使得在后续配置文件Category.xml中使用resultType的时候，可以直接使用Category,而不用写全com.how2java.pojo.Category<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"com.how2java.pojo"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>映射Category.xml<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"com/how2java/pojo/Category.xml"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>完整配置如下：<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">PUBLIC <span class="meta-string">"-//mybatis.org//DTD Config 3.0//EN"</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"com.how2java.pojo"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/how2java?characterEncoding=UTF-8"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"admin"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"com/how2java/pojo/Category.xml"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h4 id="配置文件Category-xml"><a href="#配置文件Category-xml" class="headerlink" title="配置文件Category.xml"></a>配置文件Category.xml</h4><p>在包com.how2java.pojo下，新建文件Category.xml<br><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span>=<span class="string">"com.how2java.pojo"</span></span><br></pre></td></tr></table></figure></p>
<p>表示命名空间是com.how2java.pojo，在后续调用sql语句的时候，会用到它<br>里面定义了一条sql语句<br><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span>   category_</span><br></pre></td></tr></table></figure></p>
<p>这条sql语句用id: listCategory 进行标示以供后续代码调用。resultType=”Category” 表示返回的数据和Category关联起来，这里本应该使用的是 com.how2java.pojo.Category, 但是因为上一步配置了别名，所以直接使用Category就行了<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">    <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span></span><br><span class="line"><span class="meta">    <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.how2java.pojo"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"listCategory"</span> <span class="attr">resultType</span>=<span class="string">"Category"</span>&gt;</span></span><br><span class="line">            select * from   category_      </span><br><span class="line">        <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h4 id="测试类TestMybatis"><a href="#测试类TestMybatis" class="headerlink" title="测试类TestMybatis"></a>测试类TestMybatis</h4><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">package com.how2java;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.io.Resources;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSession;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactoryBuilder;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> com.how2java.pojo.Category;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMybatis</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="type">String</span>[] args) <span class="keyword">throws</span> <span class="type">IOException</span> &#123;</span><br><span class="line">        <span class="type">String</span> resource = <span class="string">"mybatis-config.xml"</span>;</span><br><span class="line">        <span class="type">InputStream</span> inputStream = <span class="type">Resources</span>.getResourceAsStream(resource);</span><br><span class="line">        <span class="type">SqlSessionFactory</span> sqlSessionFactory = new <span class="type">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br><span class="line">        <span class="type">SqlSession</span> session=sqlSessionFactory.openSession();</span><br><span class="line">         </span><br><span class="line">        <span class="type">List</span>&lt;<span class="type">Category</span>&gt; cs=session.selectList(<span class="string">"listCategory"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Category</span> <span class="built_in">c</span> : cs) &#123;</span><br><span class="line">            <span class="type">System</span>.out.<span class="built_in">println</span>(<span class="built_in">c</span>.getName());</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="http://how2j.cn/k/mybatis/mybatis-tutorial/1087.html#nowhere" target="_blank" rel="noopener">Mybatis入门教程</a></p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello Spring MVC</title>
    <url>/blog/2017/05/spring-mvc-start.html</url>
    <content><![CDATA[<p>本文构建一个简单的Spring MVC项目，实现用户访问 /index，即可跳转到页面index.jsp，并传递message数据<br>具体原理如下：</p>
<ol>
<li>用户访问 /index</li>
<li>根据web.xml中的配置 所有的访问都会经过DispatcherServlet</li>
<li>根据配置文件springmvc-servlet.xml ，访问路径/index会进入IndexController类</li>
<li>在IndexController中指定跳转到页面index.jsp，并传递message数据</li>
<li>在index.jsp中显示message信息</li>
</ol>
<p><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/java/chapter1/p1.png" alt></p>
<h3 id="具体实现如下"><a href="#具体实现如下" class="headerlink" title="具体实现如下"></a>具体实现如下</h3><h4 id="创建项目springmvc"><a href="#创建项目springmvc" class="headerlink" title="创建项目springmvc"></a>创建项目springmvc</h4><h4 id="导入springmvc所需要的所有jar包"><a href="#导入springmvc所需要的所有jar包" class="headerlink" title="导入springmvc所需要的所有jar包"></a>导入springmvc所需要的所有jar包</h4><p>下载地址：<a href="http://how2j.cn/k/springmvc/springmvc-springmvc/615.html" target="_blank" rel="noopener">http://how2j.cn/k/springmvc/springmvc-springmvc/615.html</a></p>
<h4 id="修改配置web-xml"><a href="#修改配置web-xml" class="headerlink" title="修改配置web.xml"></a>修改配置web.xml</h4><p>配置Spring MVC的入口 DispatcherServlet，把所有的请求都提交到该Servlet</p>
<p>注意：<servlet-name>springmvc</servlet-name></p>
<p>springmvc这个名字在下一步会用到<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">version</span>=<span class="string">"2.4"</span> <span class="attr">xmlns</span>=<span class="string">"http://java.sun.com/xml/ns/j2ee"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://java.sun.com/xml/ns/j2ee</span></span></span><br><span class="line"><span class="tag"><span class="string">http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">            org.springframework.web.servlet.DispatcherServlet</span><br><span class="line">        <span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h4 id="创建springmvc-servlet-xml"><a href="#创建springmvc-servlet-xml" class="headerlink" title="创建springmvc-servlet.xml"></a>创建springmvc-servlet.xml</h4><p>在WEB-INF目录下创建 springmvc-servlet.xml<br>springmvc-servlet.xml 与上一步中的<br><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">&lt;servlet-<span class="built_in">name</span>&gt;springmvc&lt;/servlet-<span class="built_in">name</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>springmvc对应<br>这是Spring MVC的 映射配置文件<br>表示访问路径/index会交给id=indexController的bean处理<br>id=indexController的bean配置为类：IndexController</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">beans</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//SPRING//DTD BEAN//EN"</span> <span class="meta-string">"http://www.springframework.org/dtd/spring-beans.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"simpleUrlHandlerMapping"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.handler.SimpleUrlHandlerMapping"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mappings"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"/index"</span>&gt;</span>indexController<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"indexController"</span> <span class="attr">class</span>=<span class="string">"controller.IndexController"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="控制类-IndexController"><a href="#控制类-IndexController" class="headerlink" title="控制类 IndexController"></a>控制类 IndexController</h4><p>控制类 IndexController实现接口Controller ，提供方法handleRequest处理请求</p>
<p>SpringMVC通过 ModelAndView 对象把模型和视图结合在一起</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">ModelAndView mav = <span class="keyword">new</span> <span class="type">ModelAndView</span>(<span class="string">"index.jsp"</span>);</span><br><span class="line">mav.addObject(<span class="string">"message"</span>, <span class="string">"Hello Spring MVC"</span>);</span><br></pre></td></tr></table></figure>
<p>表示视图是index.jsp<br>模型数据是 message，内容是 “Hello Spring MVC”</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> controller;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.mvc.Controller;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexController</span> <span class="keyword">implements</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handleRequest</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ModelAndView mav = <span class="keyword">new</span> ModelAndView(<span class="string">"index.jsp"</span>);</span><br><span class="line">        mav.addObject(<span class="string">"message"</span>, <span class="string">"Hello Spring MVC"</span>);</span><br><span class="line">        <span class="keyword">return</span> mav;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="准备index-jsp"><a href="#准备index-jsp" class="headerlink" title="准备index.jsp"></a>准备index.jsp</h4><p>在web目录下创建index.jsp</p>
<p>index.jsp很简单，通过EL表达式显示message的内容<br><figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">%@</span> <span class="attr">page</span> <span class="attr">language</span>=<span class="string">"java"</span> <span class="attr">contentType</span>=<span class="string">"text/html; charset=UTF-8"</span></span></span></span><br><span class="line"><span class="xml">    pageEncoding="UTF-8" isELIgnored="false"%&gt;</span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>$</span><span class="template-variable">&#123;message&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<h4 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h4><p>运行项目，并访问<a href="http://localhost:8080/springmvc/index" target="_blank" rel="noopener">http://localhost:8080/springmvc/index</a><br>可以发现成功跳转到index.jsp并且传递了message信息<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/java/chapter1/p2.png" alt></p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>PS之画笔工具</title>
    <url>/blog/2017/06/litao-ps-note.html</url>
    <content><![CDATA[<h3 id="画笔"><a href="#画笔" class="headerlink" title="画笔"></a>画笔</h3><p>1.理解画笔重要的参数：间距！所有绘画中的线都是用点构成的。形状动态、散度、平滑，是画笔调整面板中使用最广的参数之三。形态中，角度抖动中的根据方向抖动很重要，会根据画笔的方向来抖动。散度，基本上用两轴选项。</p>
<h3 id="画笔工具使用的实例"><a href="#画笔工具使用的实例" class="headerlink" title="画笔工具使用的实例"></a>画笔工具使用的实例</h3><h4 id="将人P在草地里"><a href="#将人P在草地里" class="headerlink" title="将人P在草地里"></a>将人P在草地里</h4><p>首先将人抠图出来，得到一个初步的效果<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/ps/chapter1/p5.jpg" alt><br>接下来要把桶的边缘P掉，使用仿制图张工具实现：<br>在使用橡皮图章工具进行修复图片时，为了保持不破坏原始素材，则可以新建图层，然后勾选样本-当前和下方图层，即可在新建的透明图层上绘制了。<br>效果如下：<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/ps/chapter1/p6.jpg" alt><br>画笔加橡皮图章工具，可以做出很酷的纹理的效果感，如图我们把画笔调成草地形状，可以使仿制图章更加逼真。调间距，开形态，定义压力，角度抖动为方向，开散布<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/ps/chapter1/p7.jpg" alt></p>
<h4 id="利用画笔画头发"><a href="#利用画笔画头发" class="headerlink" title="利用画笔画头发"></a>利用画笔画头发</h4><p>可以自定义画笔，然后定义画笔预设<br>但由于个人水平，画的头发不太逼真，就不放上来了</p>
<h4 id="利用画笔添加气泡"><a href="#利用画笔添加气泡" class="headerlink" title="利用画笔添加气泡"></a>利用画笔添加气泡</h4><p>画笔中，白就是透明的，灰色是半透明度的。可以利用这个特点来做气泡<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/ps/chapter1/p8.jpg" alt></p>
<h4 id="实现聚焦与正反打"><a href="#实现聚焦与正反打" class="headerlink" title="实现聚焦与正反打"></a>实现聚焦与正反打</h4><p>图层编组：ctrl+G。曲线，上弦往上拉是亮度，下弦往下是暗度。<br>.阴影要做到两层或三层才比较逼真。选中主体形状然后填充黑色，按照需要的光源做斜切和透视，然后利用高斯模糊来虚化。下层阴影高斯模糊小一些，上层大一些。<br>通过正反打对画面主体做聚焦，四角暗淡的做法（突出主体），先做选区，新建调整图层-曲线，上弦曲线打亮主体正打，然后选中蒙版，执行滤镜-模糊-高斯模糊，半径选到最大或是稍微小一点；然后再反打（即变暗），同样曲线命令做下弦，可以选择直接将正打蒙版复制过来，然后ctrl+i反向命令。替换图层蒙版：先选中源蒙版，再按alt建，移动到目标位置。复制+替换：则是先按alt健。</p>
]]></content>
      <tags>
        <tag>photoshop</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis开始</title>
    <url>/blog/2017/06/mybatis-start-learn.html</url>
    <content><![CDATA[<h3 id="CRUD"><a href="#CRUD" class="headerlink" title="CRUD"></a>CRUD</h3><p>首先一次性修改配置文件Category.xml，提供CRUD对应的sql语句。<br><figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span></span><br><span class="line"><span class="xml"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span></span><br><span class="line"><span class="xml">    PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"</span></span><br><span class="line"><span class="xml">    "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.how2java.pojo"</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"addCategory"</span> <span class="attr">parameterType</span>=<span class="string">"Category"</span> &gt;</span></span></span><br><span class="line"><span class="xml">            insert into category_ ( name ) values (#</span><span class="template-variable">&#123;name&#125;</span><span class="xml">)    </span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span></span><br><span class="line"><span class="xml">         </span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">"deleteCategory"</span> <span class="attr">parameterType</span>=<span class="string">"Category"</span> &gt;</span></span></span><br><span class="line"><span class="xml">            delete from category_ where id= #</span><span class="template-variable">&#123;id&#125;</span><span class="xml">   </span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span></span><br><span class="line"><span class="xml">         </span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getCategory"</span> <span class="attr">parameterType</span>=<span class="string">"_int"</span> <span class="attr">resultType</span>=<span class="string">"Category"</span>&gt;</span></span></span><br><span class="line"><span class="xml">            select * from   category_  where id= #</span><span class="template-variable">&#123;id&#125;</span><span class="xml">    </span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"updateCategory"</span> <span class="attr">parameterType</span>=<span class="string">"Category"</span> &gt;</span></span></span><br><span class="line"><span class="xml">            update category_ set name=#</span><span class="template-variable">&#123;name&#125;</span><span class="xml"> where id=#</span><span class="template-variable">&#123;id&#125;</span><span class="xml">    </span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"listCategory"</span> <span class="attr">resultType</span>=<span class="string">"Category"</span>&gt;</span></span></span><br><span class="line"><span class="xml">            select * from   category_      </span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">select</span>&gt;</span>     </span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<h4 id="insert操作"><a href="#insert操作" class="headerlink" title="insert操作"></a>insert操作</h4><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">package com.how2java;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.io.Resources;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSession;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactoryBuilder;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> com.how2java.pojo.Category;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMybatis</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="type">String</span>[] args) <span class="keyword">throws</span> <span class="type">IOException</span> &#123;</span><br><span class="line">        <span class="type">String</span> resource = <span class="string">"mybatis-config.xml"</span>;</span><br><span class="line">        <span class="type">InputStream</span> inputStream = <span class="type">Resources</span>.getResourceAsStream(resource);</span><br><span class="line">        <span class="type">SqlSessionFactory</span> sqlSessionFactory = new <span class="type">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br><span class="line">        <span class="type">SqlSession</span> session = sqlSessionFactory.openSession();</span><br><span class="line"> </span><br><span class="line">        <span class="type">Category</span> <span class="built_in">c</span> = new <span class="type">Category</span>();</span><br><span class="line">        <span class="built_in">c</span>.setName(<span class="string">"新增加的Category"</span>);</span><br><span class="line">        session.insert(<span class="string">"addCategory"</span>,<span class="built_in">c</span>);</span><br><span class="line">         </span><br><span class="line">        listAll(session);</span><br><span class="line">         </span><br><span class="line">        session.commit();</span><br><span class="line">        session.close();</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> void listAll(<span class="type">SqlSession</span> session) &#123;</span><br><span class="line">        <span class="type">List</span>&lt;<span class="type">Category</span>&gt; cs = session.selectList(<span class="string">"listCategory"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Category</span> <span class="built_in">c</span> : cs) &#123;</span><br><span class="line">            <span class="type">System</span>.out.<span class="built_in">println</span>(<span class="built_in">c</span>.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMybatis</span> &#123;</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> throws IOException </span>&#123;</span><br><span class="line">        <span class="keyword">String</span> resource = <span class="string">"mybatis-config.xml"</span>;</span><br><span class="line">        InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">        SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">        SqlSession session = sqlSessionFactory.openSession();</span><br><span class="line"> </span><br><span class="line">        Category c = <span class="keyword">new</span> Category();</span><br><span class="line">        c.setId(<span class="number">6</span>);</span><br><span class="line">        session.<span class="keyword">delete</span>(<span class="string">"deleteCategory"</span>,c);</span><br><span class="line">         </span><br><span class="line">        listAll(session);</span><br><span class="line">         </span><br><span class="line">        session.commit();</span><br><span class="line">        session.<span class="built_in">close</span>();</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">listAll</span><span class="params">(SqlSession session)</span> </span>&#123;</span><br><span class="line">        List&lt;Category&gt; cs = session.selectList(<span class="string">"listCategory"</span>);</span><br><span class="line">        <span class="keyword">for</span> (Category c : cs) &#123;</span><br><span class="line">            System.out.<span class="built_in">println</span>(c.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="查询获取"><a href="#查询获取" class="headerlink" title="查询获取"></a>查询获取</h4><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMybatis</span> &#123;</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> throws IOException </span>&#123;</span><br><span class="line">        <span class="keyword">String</span> resource = <span class="string">"mybatis-config.xml"</span>;</span><br><span class="line">        InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">        SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">        SqlSession session = sqlSessionFactory.openSession();</span><br><span class="line"> </span><br><span class="line">        Category c= session.selectOne(<span class="string">"getCategory"</span>,<span class="number">3</span>);</span><br><span class="line">         </span><br><span class="line">        System.out.<span class="built_in">println</span>(c.getName());</span><br><span class="line">         </span><br><span class="line"><span class="comment">//      listAll(session);</span></span><br><span class="line">         </span><br><span class="line">        session.commit();</span><br><span class="line">        session.<span class="built_in">close</span>();</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">listAll</span><span class="params">(SqlSession session)</span> </span>&#123;</span><br><span class="line">        List&lt;Category&gt; cs = session.selectList(<span class="string">"listCategory"</span>);</span><br><span class="line">        <span class="keyword">for</span> (Category c : cs) &#123;</span><br><span class="line">            System.out.<span class="built_in">println</span>(c.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h4><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMybatis</span> &#123;</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> throws IOException </span>&#123;</span><br><span class="line">        <span class="keyword">String</span> resource = <span class="string">"mybatis-config.xml"</span>;</span><br><span class="line">        InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">        SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">        SqlSession session = sqlSessionFactory.openSession();</span><br><span class="line"> </span><br><span class="line">        Category c= session.selectOne(<span class="string">"getCategory"</span>,<span class="number">3</span>);</span><br><span class="line">        c.setName(<span class="string">"修改了的Category名稱"</span>);</span><br><span class="line">        session.update(<span class="string">"updateCategory"</span>,c);</span><br><span class="line">         </span><br><span class="line">        listAll(session);</span><br><span class="line">         </span><br><span class="line">        session.commit();</span><br><span class="line">        session.<span class="built_in">close</span>();</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">listAll</span><span class="params">(SqlSession session)</span> </span>&#123;</span><br><span class="line">        List&lt;Category&gt; cs = session.selectList(<span class="string">"listCategory"</span>);</span><br><span class="line">        <span class="keyword">for</span> (Category c : cs) &#123;</span><br><span class="line">            System.out.<span class="built_in">println</span>(c.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="查询所有"><a href="#查询所有" class="headerlink" title="查询所有"></a>查询所有</h4><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMybatis</span> &#123;</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> throws IOException </span>&#123;</span><br><span class="line">        <span class="keyword">String</span> resource = <span class="string">"mybatis-config.xml"</span>;</span><br><span class="line">        InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">        SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">        SqlSession session = sqlSessionFactory.openSession();</span><br><span class="line"> </span><br><span class="line">        listAll(session);</span><br><span class="line">         </span><br><span class="line">        session.commit();</span><br><span class="line">        session.<span class="built_in">close</span>();</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">listAll</span><span class="params">(SqlSession session)</span> </span>&#123;</span><br><span class="line">        List&lt;Category&gt; cs = session.selectList(<span class="string">"listCategory"</span>);</span><br><span class="line">        <span class="keyword">for</span> (Category c : cs) &#123;</span><br><span class="line">            System.out.<span class="built_in">println</span>(c.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="更多查询"><a href="#更多查询" class="headerlink" title="更多查询"></a>更多查询</h3><h4 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h4><p>首先配置Categroy.xml<br><figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span></span><br><span class="line"><span class="xml"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span></span><br><span class="line"><span class="xml">    PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"</span></span><br><span class="line"><span class="xml">    "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.how2java.pojo"</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"listCategoryByName"</span>  <span class="attr">parameterType</span>=<span class="string">"string"</span> <span class="attr">resultType</span>=<span class="string">"Category"</span>&gt;</span></span></span><br><span class="line"><span class="xml">            select * from   category_  where name like concat('%',#</span><span class="template-variable">&#123;0&#125;</span><span class="xml">,'%')</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">select</span>&gt;</span>     </span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>测试类<br><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMybatis</span> &#123;</span></span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> throws IOException </span>&#123;</span><br><span class="line">        <span class="keyword">String</span> resource = <span class="string">"mybatis-config.xml"</span>;</span><br><span class="line">        InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">        SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">        SqlSession session = sqlSessionFactory.openSession();</span><br><span class="line">  </span><br><span class="line">        List&lt;Category&gt; cs = session.selectList(<span class="string">"listCategoryByName"</span>,<span class="string">"cat"</span>);</span><br><span class="line">        <span class="keyword">for</span> (Category c : cs) &#123;</span><br><span class="line">            System.out.<span class="built_in">println</span>(c.getName());</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        session.commit();</span><br><span class="line">        session.<span class="built_in">close</span>();</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="多条件查询"><a href="#多条件查询" class="headerlink" title="多条件查询"></a>多条件查询</h4><figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span></span><br><span class="line"><span class="xml"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span></span><br><span class="line"><span class="xml">    PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"</span></span><br><span class="line"><span class="xml">    "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.how2java.pojo"</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"listCategoryByName"</span>  <span class="attr">resultType</span>=<span class="string">"Category"</span>&gt;</span></span></span><br><span class="line"><span class="xml">            select * from   category_  where name like concat('%',#</span><span class="template-variable">&#123;0&#125;</span><span class="xml">,'%')</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">select</span>&gt;</span>     </span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"listCategoryByIdAndName"</span>  <span class="attr">parameterType</span>=<span class="string">"map"</span> <span class="attr">resultType</span>=<span class="string">"Category"</span>&gt;</span></span></span><br><span class="line"><span class="xml">            select * from   category_  where id&gt; #</span><span class="template-variable">&#123;id&#125;</span><span class="xml">  and name like concat('%',#</span><span class="template-variable">&#123;name&#125;</span><span class="xml">,'%')</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">select</span>&gt;</span>     </span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>测试类，通过map传递参数<br><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMybatis</span> &#123;</span></span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> throws IOException </span>&#123;</span><br><span class="line">        <span class="keyword">String</span> resource = <span class="string">"mybatis-config.xml"</span>;</span><br><span class="line">        InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">        SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">        SqlSession session = sqlSessionFactory.openSession();</span><br><span class="line">  </span><br><span class="line">        Map&lt;<span class="keyword">String</span>,Object&gt; params = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        params.<span class="built_in">put</span>(<span class="string">"id"</span>, <span class="number">3</span>);</span><br><span class="line">        params.<span class="built_in">put</span>(<span class="string">"name"</span>, <span class="string">"cat"</span>);</span><br><span class="line">         </span><br><span class="line">        List&lt;Category&gt; cs = session.selectList(<span class="string">"listCategoryByIdAndName"</span>,params);</span><br><span class="line">        <span class="keyword">for</span> (Category c : cs) &#123;</span><br><span class="line">            System.out.<span class="built_in">println</span>(c.getName());</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        session.commit();</span><br><span class="line">        session.<span class="built_in">close</span>();</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="一对多查询"><a href="#一对多查询" class="headerlink" title="一对多查询"></a>一对多查询</h3><h4 id="创建产品表"><a href="#创建产品表" class="headerlink" title="创建产品表"></a>创建产品表</h4><p>种类表不变，创建一个新的产品表<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">use how2java;</span><br><span class="line">create table product_(</span><br><span class="line">id int <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">name varchar(30) <span class="built_in"> DEFAULT </span><span class="literal">NULL</span>,</span><br><span class="line">price float <span class="built_in"> DEFAULT </span>0,</span><br><span class="line">cid int ,</span><br><span class="line">PRIMARY KEY (id)</span><br><span class="line">)<span class="attribute">AUTO_INCREMENT</span>=1<span class="built_in"> DEFAULT </span><span class="attribute">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure></p>
<h4 id="准备数据"><a href="#准备数据" class="headerlink" title="准备数据"></a>准备数据</h4><p>清空category_ 和 product_ 表<br>新增2条分类数据，id分别是1,2<br>新增6条产品数据，分辨关联上述2条分类数据<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> how2java;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> category_;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> category_ <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="string">'category1'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> category_ <span class="keyword">VALUES</span> (<span class="number">2</span>,<span class="string">'category2'</span>);</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> product_;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> product_ <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="string">'product a'</span>, <span class="number">88.88</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> product_ <span class="keyword">VALUES</span> (<span class="number">2</span>,<span class="string">'product b'</span>, <span class="number">88.88</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> product_ <span class="keyword">VALUES</span> (<span class="number">3</span>,<span class="string">'product c'</span>, <span class="number">88.88</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> product_ <span class="keyword">VALUES</span> (<span class="number">4</span>,<span class="string">'product x'</span>, <span class="number">88.88</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> product_ <span class="keyword">VALUES</span> (<span class="number">5</span>,<span class="string">'product y'</span>, <span class="number">88.88</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> product_ <span class="keyword">VALUES</span> (<span class="number">6</span>,<span class="string">'product z'</span>, <span class="number">88.88</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure></p>
<h4 id="Product实体类"><a href="#Product实体类" class="headerlink" title="Product实体类"></a>Product实体类</h4><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">package com.how2java.pojo;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> price;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">String</span> <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(<span class="keyword">String</span> name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(<span class="keyword">float</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">String</span> <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Product [id="</span> + id + <span class="string">", name="</span> + name + <span class="string">", price="</span> + price + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="修改Category实体类"><a href="#修改Category实体类" class="headerlink" title="修改Category实体类"></a>修改Category实体类</h4><p>修改Category实体类，提供products的集合<br><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">package com.how2java.pojo;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Category</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> name;</span><br><span class="line">    List&lt;Product&gt; products;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">String</span> <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(<span class="keyword">String</span> name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Product&gt; <span class="title">getProducts</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> products;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProducts</span><span class="params">(List&lt;Product&gt; products)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.products = products;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">String</span> <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Category [id="</span> + id + <span class="string">", name="</span> + name + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="暂时无需-Product-xml"><a href="#暂时无需-Product-xml" class="headerlink" title="暂时无需 Product.xml"></a>暂时无需 Product.xml</h4><p>本例演示通过分类对产品的一对多，暂时无需 Product.xml</p>
<h4 id="修改Category-xml"><a href="#修改Category-xml" class="headerlink" title="修改Category.xml"></a>修改Category.xml</h4><p>通过left join关联查询，对Category和Product表进行关联查询。<br>与前面学习的有所区别，这里不是用的resultType, 而是resultMap，通过resultMap把数据取出来放在对应的 对象属性里<br>注： Category的id 字段 和Product的id字段同名，Mybatis不知道谁是谁的，所以需要通过取别名cid,pid来区分。<br>name字段同理。<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">    <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span></span><br><span class="line"><span class="meta">    <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.how2java.pojo"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"Category"</span> <span class="attr">id</span>=<span class="string">"categoryBean"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"cid"</span> <span class="attr">property</span>=<span class="string">"id"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"cname"</span> <span class="attr">property</span>=<span class="string">"name"</span> /&gt;</span></span><br><span class="line">     </span><br><span class="line">            <span class="comment">&lt;!-- 一对多的关系 --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- property: 指的是集合属性的值, ofType：指的是集合中元素的类型 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"products"</span> <span class="attr">ofType</span>=<span class="string">"Product"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"pid"</span> <span class="attr">property</span>=<span class="string">"id"</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"pname"</span> <span class="attr">property</span>=<span class="string">"name"</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"price"</span> <span class="attr">property</span>=<span class="string">"price"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">     </span><br><span class="line">        <span class="comment">&lt;!-- 根据id查询Person, 关联将Orders查询出来 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"listCategory"</span> <span class="attr">resultMap</span>=<span class="string">"categoryBean"</span>&gt;</span></span><br><span class="line">            select c.*, p.*, c.id 'cid', p.id 'pid', c.name 'cname', p.name 'pname' from category_ c left join product_ p on c.id = p.cid</span><br><span class="line">        <span class="tag">&lt;/<span class="name">select</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h4 id="测试运行TestMybatis"><a href="#测试运行TestMybatis" class="headerlink" title="测试运行TestMybatis"></a>测试运行TestMybatis</h4><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMybatis</span> &#123;</span></span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> throws IOException </span>&#123;</span><br><span class="line">        <span class="keyword">String</span> resource = <span class="string">"mybatis-config.xml"</span>;</span><br><span class="line">        InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">        SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">        SqlSession session = sqlSessionFactory.openSession();</span><br><span class="line">  </span><br><span class="line">        List&lt;Category&gt; cs = session.selectList(<span class="string">"listCategory"</span>);</span><br><span class="line">        <span class="keyword">for</span> (Category c : cs) &#123;</span><br><span class="line">            System.out.<span class="built_in">println</span>(c);</span><br><span class="line">            List&lt;Product&gt; ps = c.getProducts();</span><br><span class="line">            <span class="keyword">for</span> (Product p : ps) &#123;</span><br><span class="line">                System.out.<span class="built_in">println</span>(<span class="string">"\t"</span>+p);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        session.commit();</span><br><span class="line">        session.<span class="built_in">close</span>();</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多对一"><a href="#多对一" class="headerlink" title="多对一"></a>多对一</h3><p>查询出所有的产品，同时对于每个产品，还能看到其所对应的分类</p>
<h4 id="修改Product-java"><a href="#修改Product-java" class="headerlink" title="修改Product.java"></a>修改Product.java</h4><p>为Product增加category属性<br><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">package com.how2java.pojo;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> price;</span><br><span class="line">    <span class="keyword">private</span> Category category;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Category <span class="title">getCategory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> category;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCategory</span><span class="params">(Category category)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.category = category;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">String</span> <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(<span class="keyword">String</span> name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(<span class="keyword">float</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">String</span> <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Product [id="</span> + id + <span class="string">", name="</span> + name + <span class="string">", price="</span> + price + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="Product-xml"><a href="#Product-xml" class="headerlink" title="Product.xml"></a>Product.xml</h4><p>提供Product.xml，通过listProduct配置关联查询的sql语句。<br>然后通过resultMap ，进行字段和属性的对应。<br>使用association 进行多对一关系关联，指定表字段名称与对象属性名称的一一对应关系<br>注： Category的id 字段 和Product的id字段同名，Mybatis不知道谁是谁的，所以需要通过取别名cid,pid来区分。<br>name字段同理。<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">    <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span></span><br><span class="line"><span class="meta">    <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.how2java.pojo"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"Product"</span> <span class="attr">id</span>=<span class="string">"productBean"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"pid"</span> <span class="attr">property</span>=<span class="string">"id"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"pname"</span> <span class="attr">property</span>=<span class="string">"name"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"price"</span> <span class="attr">property</span>=<span class="string">"price"</span> /&gt;</span></span><br><span class="line">     </span><br><span class="line">            <span class="comment">&lt;!-- 多对一的关系 --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- property: 指的是属性名称, javaType：指的是属性的类型 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"category"</span> <span class="attr">javaType</span>=<span class="string">"Category"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"cid"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"cname"</span> <span class="attr">property</span>=<span class="string">"name"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">     </span><br><span class="line">        <span class="comment">&lt;!-- 根据id查询Person, 关联将Orders查询出来 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"listProduct"</span> <span class="attr">resultMap</span>=<span class="string">"productBean"</span>&gt;</span></span><br><span class="line">            select c.*, p.*, c.id 'cid', p.id 'pid', c.name 'cname', p.name 'pname' from category_ c left join product_ p on c.id = p.cid</span><br><span class="line">        <span class="tag">&lt;/<span class="name">select</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h4 id="mybatis-config-xml"><a href="#mybatis-config-xml" class="headerlink" title="mybatis-config.xml"></a>mybatis-config.xml</h4><p>在mybatis-config.xml中增加对于Product.xml的映射<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;mapper <span class="attribute">resource</span>=<span class="string">"com/how2java/pojo/Product.xml"</span>/&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="TestMybatis"><a href="#TestMybatis" class="headerlink" title="TestMybatis"></a>TestMybatis</h4><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMybatis</span> &#123;</span></span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> throws IOException </span>&#123;</span><br><span class="line">        <span class="keyword">String</span> resource = <span class="string">"mybatis-config.xml"</span>;</span><br><span class="line">        InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">        SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">        SqlSession session = sqlSessionFactory.openSession();</span><br><span class="line">  </span><br><span class="line">        List&lt;Product&gt; ps = session.selectList(<span class="string">"listProduct"</span>);</span><br><span class="line">        <span class="keyword">for</span> (Product p : ps) &#123;</span><br><span class="line">            System.out.<span class="built_in">println</span>(p+<span class="string">" 对应的分类是 \t "</span>+ p.getCategory());</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        session.commit();</span><br><span class="line">        session.<span class="built_in">close</span>();</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h3><p>这里以订单Order和产品Product为例：<br>一张订单里 可以包含多种产品<br>一种产品 可以出现在多张订单里<br>这就是多对多关系<br>为了维系多对多关系，必须要一个中间表。 在这里我们使用订单项(OrderItem)表来作为中间表<br>本知识点讲解如何查询多对多关系，建立多对多关系，删除多对多关系。</p>
<h4 id="表结构"><a href="#表结构" class="headerlink" title="表结构"></a>表结构</h4><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">create table order_ (</span><br><span class="line">  id int(11) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  code varchar(32)<span class="built_in"> DEFAULT </span><span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY KEY (id)</span><br><span class="line">) <span class="attribute">ENGINE</span>=MyISAM <span class="attribute">AUTO_INCREMENT</span>=1<span class="built_in"> DEFAULT </span><span class="attribute">CHARSET</span>=utf8;</span><br><span class="line"> </span><br><span class="line">create table order_item_(</span><br><span class="line">  id int(11) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,  </span><br><span class="line">  oid int , </span><br><span class="line">  pid int ,</span><br><span class="line">  number int ,</span><br><span class="line">  PRIMARY KEY(id)</span><br><span class="line">)<span class="attribute">AUTO_INCREMENT</span>=1<span class="built_in"> DEFAULT </span><span class="attribute">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure>
<h4 id="导入数据"><a href="#导入数据" class="headerlink" title="导入数据"></a>导入数据</h4><p>在一对多关系中准备的数据里已经有Product数据里，这里就只准备订单数据和订单项数据：</p>
<ol>
<li>插入两个订单</li>
<li>插入6条订单项数据，建立如下关系<br>2.1 订单1对应产品 1，2，3<br>2.2 订单2对应产品 2，3，4<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> order_ <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="string">'code000A'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> order_ <span class="keyword">VALUES</span> (<span class="number">2</span>,<span class="string">'code000B'</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> order_item_ <span class="keyword">VALUES</span> (<span class="literal">null</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">100</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> order_item_ <span class="keyword">VALUES</span> (<span class="literal">null</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">100</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> order_item_ <span class="keyword">VALUES</span> (<span class="literal">null</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">100</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> order_item_ <span class="keyword">VALUES</span> (<span class="literal">null</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">100</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> order_item_ <span class="keyword">VALUES</span> (<span class="literal">null</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">100</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> order_item_ <span class="keyword">VALUES</span> (<span class="literal">null</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h4><p>建立Order和OrderItem的实体类</p>
<h4 id="映射文件"><a href="#映射文件" class="headerlink" title="映射文件"></a>映射文件</h4><p>Order.xml<br><figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span></span><br><span class="line"><span class="xml"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span></span><br><span class="line"><span class="xml">    PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"</span></span><br><span class="line"><span class="xml">    "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.how2java.pojo"</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"Order"</span> <span class="attr">id</span>=<span class="string">"orderBean"</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"oid"</span> <span class="attr">property</span>=<span class="string">"id"</span> /&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"code"</span> <span class="attr">property</span>=<span class="string">"code"</span> /&gt;</span></span></span><br><span class="line"><span class="xml">             </span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"orderItems"</span> <span class="attr">ofType</span>=<span class="string">"OrderItem"</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"oiid"</span> <span class="attr">property</span>=<span class="string">"id"</span> /&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"number"</span> <span class="attr">property</span>=<span class="string">"number"</span> /&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"product"</span> <span class="attr">javaType</span>=<span class="string">"Product"</span>&gt;</span></span></span><br><span class="line"><span class="xml">                    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"pid"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></span></span><br><span class="line"><span class="xml">                    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"pname"</span> <span class="attr">property</span>=<span class="string">"name"</span>/&gt;</span></span></span><br><span class="line"><span class="xml">                    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"price"</span> <span class="attr">property</span>=<span class="string">"price"</span>/&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;/<span class="name">association</span>&gt;</span>                </span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span></span><br><span class="line"><span class="xml">         </span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"listOrder"</span> <span class="attr">resultMap</span>=<span class="string">"orderBean"</span>&gt;</span></span></span><br><span class="line"><span class="xml">            select o.*,p.*,oi.*, o.id 'oid', p.id 'pid', oi.id 'oiid', p.name 'pname' </span></span><br><span class="line"><span class="xml">                from order_ o </span></span><br><span class="line"><span class="xml">                left join order_item_ oi    on o.id =oi.oid </span></span><br><span class="line"><span class="xml">                left join product_ p on p.id = oi.pid </span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span></span><br><span class="line"><span class="xml">             </span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getOrder"</span> <span class="attr">resultMap</span>=<span class="string">"orderBean"</span>&gt;</span></span></span><br><span class="line"><span class="xml">            select o.*,p.*,oi.*, o.id 'oid', p.id 'pid', oi.id 'oiid', p.name 'pname' </span></span><br><span class="line"><span class="xml">                from order_ o </span></span><br><span class="line"><span class="xml">                left join order_item_ oi on o.id =oi.oid </span></span><br><span class="line"><span class="xml">                left join product_ p on p.id = oi.pid </span></span><br><span class="line"><span class="xml">            where o.id = #</span><span class="template-variable">&#123;id&#125;</span><span class="xml"> </span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>Product.xml<br><figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span></span><br><span class="line"><span class="xml"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span></span><br><span class="line"><span class="xml">    PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"</span></span><br><span class="line"><span class="xml">    "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.how2java.pojo"</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"Product"</span> <span class="attr">id</span>=<span class="string">"productBean"</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"pid"</span> <span class="attr">property</span>=<span class="string">"id"</span> /&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"pname"</span> <span class="attr">property</span>=<span class="string">"name"</span> /&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"price"</span> <span class="attr">property</span>=<span class="string">"price"</span> /&gt;</span></span></span><br><span class="line"><span class="xml">     </span></span><br><span class="line"><span class="xml">            <span class="comment">&lt;!-- 多对一的关系 --&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="comment">&lt;!-- property: 指的是属性名称, javaType：指的是属性的类型 --&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"category"</span> <span class="attr">javaType</span>=<span class="string">"Category"</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"cid"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"cname"</span> <span class="attr">property</span>=<span class="string">"name"</span>/&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span></span><br><span class="line"><span class="xml">     </span></span><br><span class="line"><span class="xml">        <span class="comment">&lt;!-- 根据id查询Person, 关联将Orders查询出来 --&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"listProduct"</span> <span class="attr">resultMap</span>=<span class="string">"productBean"</span>&gt;</span></span></span><br><span class="line"><span class="xml">            select c.*, p.*, c.id 'cid', p.id 'pid', c.name 'cname', p.name 'pname' </span></span><br><span class="line"><span class="xml">                from category_ c </span></span><br><span class="line"><span class="xml">                left join product_ p on c.id = p.cid</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">select</span>&gt;</span>    </span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getProduct"</span> <span class="attr">resultMap</span>=<span class="string">"productBean"</span>&gt;</span></span></span><br><span class="line"><span class="xml">            select c.*, p.*, c.id 'cid', p.id 'pid', c.name 'cname', p.name 'pname' </span></span><br><span class="line"><span class="xml">                from category_ c </span></span><br><span class="line"><span class="xml">                left join product_ p on c.id = p.cid </span></span><br><span class="line"><span class="xml">            where p.id = #</span><span class="template-variable">&#123;id&#125;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">select</span>&gt;</span>    </span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>OrderItem.xml<br><figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span></span><br><span class="line"><span class="xml"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span></span><br><span class="line"><span class="xml">    PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"</span></span><br><span class="line"><span class="xml">    "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.how2java.pojo"</span>&gt;</span></span></span><br><span class="line"><span class="xml">     </span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"addOrderItem"</span> <span class="attr">parameterType</span>=<span class="string">"OrderItem"</span>&gt;</span></span></span><br><span class="line"><span class="xml">            insert into order_item_ </span></span><br><span class="line"><span class="xml">                values(null,#</span><span class="template-variable">&#123;order.id&#125;</span><span class="xml">,#</span><span class="template-variable">&#123;product.id&#125;</span><span class="xml">,#</span><span class="template-variable">&#123;number&#125;</span><span class="xml">)</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">insert</span>&gt;</span>    </span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"deleteOrderItem"</span> <span class="attr">parameterType</span>=<span class="string">"OrderItem"</span>&gt;</span></span></span><br><span class="line"><span class="xml">            delete from order_item_ </span></span><br><span class="line"><span class="xml">                where oid = #</span><span class="template-variable">&#123;order.id&#125;</span><span class="xml"> and pid = #</span><span class="template-variable">&#123;product.id&#125;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">insert</span>&gt;</span>    </span></span><br><span class="line"><span class="xml">     </span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<h4 id="修改mybatis-config-xml"><a href="#修改mybatis-config-xml" class="headerlink" title="修改mybatis-config.xml"></a>修改mybatis-config.xml</h4><p>添加对于Order.xml和OrderItem的映射<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;mapper <span class="attribute">resource</span>=<span class="string">"com/how2java/pojo/Order.xml"</span>/&gt;</span><br><span class="line">&lt;mapper <span class="attribute">resource</span>=<span class="string">"com/how2java/pojo/OrderItem.xml"</span>/&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="查询所有-1"><a href="#查询所有-1" class="headerlink" title="查询所有"></a>查询所有</h4><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMybatis</span> &#123;</span></span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> throws IOException </span>&#123;</span><br><span class="line">        <span class="keyword">String</span> resource = <span class="string">"mybatis-config.xml"</span>;</span><br><span class="line">        InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">        SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">        SqlSession session = sqlSessionFactory.openSession();</span><br><span class="line">  </span><br><span class="line">        listOrder(session);</span><br><span class="line"> </span><br><span class="line">        session.commit();</span><br><span class="line">        session.<span class="built_in">close</span>();</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">listOrder</span><span class="params">(SqlSession session)</span> </span>&#123;</span><br><span class="line">        List&lt;Order&gt; os = session.selectList(<span class="string">"listOrder"</span>);</span><br><span class="line">        <span class="keyword">for</span> (Order o : os) &#123;</span><br><span class="line">            System.out.<span class="built_in">println</span>(o.getCode());</span><br><span class="line">            List&lt;OrderItem&gt; ois= o.getOrderItems();</span><br><span class="line">            <span class="keyword">for</span> (OrderItem oi : ois) &#123;</span><br><span class="line">                System.out.format(<span class="string">"\t%s\t%f\t%d%n"</span>, oi.getProduct().getName(),oi.getProduct().getPrice(),oi.getNumber());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="建立关系"><a href="#建立关系" class="headerlink" title="建立关系"></a>建立关系</h4><p>如图所示，建立了让订单000A和产品z建立了关系<br>首先通过id分别获取Ordre对象和Product对象，然后创建一个新的OrderItem对象，接着设置Order，设置Product，设置数量，最后调用”addOrderItem” 对应的sql语句插入数据。<br><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMybatis</span> &#123;</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> throws IOException </span>&#123;</span><br><span class="line">        <span class="keyword">String</span> resource = <span class="string">"mybatis-config.xml"</span>;</span><br><span class="line">        InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">        SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">        SqlSession session = sqlSessionFactory.openSession();</span><br><span class="line"> </span><br><span class="line">        addOrderItem(session);</span><br><span class="line">        listOrder(session);</span><br><span class="line"> </span><br><span class="line">        session.commit();</span><br><span class="line">        session.<span class="built_in">close</span>();</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addOrderItem</span><span class="params">(SqlSession session)</span> </span>&#123;</span><br><span class="line">        Order o1 = session.selectOne(<span class="string">"getOrder"</span>, <span class="number">1</span>);</span><br><span class="line">        Product p6 = session.selectOne(<span class="string">"getProduct"</span>, <span class="number">6</span>);</span><br><span class="line">        OrderItem oi = <span class="keyword">new</span> OrderItem();</span><br><span class="line">        oi.setProduct(p6);</span><br><span class="line">        oi.setOrder(o1);</span><br><span class="line">        oi.setNumber(<span class="number">200</span>);</span><br><span class="line"> </span><br><span class="line">        session.insert(<span class="string">"addOrderItem"</span>, oi);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">listOrder</span><span class="params">(SqlSession session)</span> </span>&#123;</span><br><span class="line">        List&lt;Order&gt; os = session.selectList(<span class="string">"listOrder"</span>);</span><br><span class="line">        <span class="keyword">for</span> (Order o : os) &#123;</span><br><span class="line">            System.out.<span class="built_in">println</span>(o.getCode());</span><br><span class="line">            List&lt;OrderItem&gt; ois = o.getOrderItems();</span><br><span class="line">            <span class="keyword">for</span> (OrderItem oi : ois) &#123;</span><br><span class="line">                System.out.format(<span class="string">"\t%s\t%f\t%d%n"</span>, oi.getProduct().getName(), oi.getProduct().getPrice(),</span><br><span class="line">                        oi.getNumber());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="删除关系"><a href="#删除关系" class="headerlink" title="删除关系"></a>删除关系</h4><p>如图所示，删除了订单00A和产品z的关系，再次查询，就看不到产品z了。<br>删除关系的时候，通过订单id(1)和产品id(6)进行删除。<br>其实所谓的删除关系，就是删除掉OrderItem记录。<br><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMybatis</span> &#123;</span></span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> throws IOException </span>&#123;</span><br><span class="line">        <span class="keyword">String</span> resource = <span class="string">"mybatis-config.xml"</span>;</span><br><span class="line">        InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">        SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">        SqlSession session = sqlSessionFactory.openSession();</span><br><span class="line">  </span><br><span class="line">        deleteOrderItem(session);</span><br><span class="line"><span class="comment">//        addOrderItem(session);</span></span><br><span class="line">        listOrder(session);</span><br><span class="line"> </span><br><span class="line">        session.commit();</span><br><span class="line">        session.<span class="built_in">close</span>();</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteOrderItem</span><span class="params">(SqlSession session)</span> </span>&#123;</span><br><span class="line">        Order o1 = session.selectOne(<span class="string">"getOrder"</span>,<span class="number">1</span>);</span><br><span class="line">        Product p6 = session.selectOne(<span class="string">"getProduct"</span>,<span class="number">6</span>);</span><br><span class="line">        OrderItem oi = <span class="keyword">new</span> OrderItem();</span><br><span class="line">        oi.setProduct(p6);</span><br><span class="line">        oi.setOrder(o1);</span><br><span class="line">        session.<span class="keyword">delete</span>(<span class="string">"deleteOrderItem"</span>, oi);      </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addOrderItem</span><span class="params">(SqlSession session)</span> </span>&#123;</span><br><span class="line">        Order o1 = session.selectOne(<span class="string">"getOrder"</span>,<span class="number">1</span>);</span><br><span class="line">        Product p6 = session.selectOne(<span class="string">"getProduct"</span>,<span class="number">6</span>);</span><br><span class="line">        OrderItem oi = <span class="keyword">new</span> OrderItem();</span><br><span class="line">        oi.setProduct(p6);</span><br><span class="line">        oi.setOrder(o1);</span><br><span class="line">        oi.setNumber(<span class="number">200</span>);</span><br><span class="line">         </span><br><span class="line">        session.insert(<span class="string">"addOrderItem"</span>, oi);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">listOrder</span><span class="params">(SqlSession session)</span> </span>&#123;</span><br><span class="line">        List&lt;Order&gt; os = session.selectList(<span class="string">"listOrder"</span>);</span><br><span class="line">        <span class="keyword">for</span> (Order o : os) &#123;</span><br><span class="line">            System.out.<span class="built_in">println</span>(o.getCode());</span><br><span class="line">            List&lt;OrderItem&gt; ois= o.getOrderItems();</span><br><span class="line">            <span class="keyword">for</span> (OrderItem oi : ois) &#123;</span><br><span class="line">                System.out.format(<span class="string">"\t%s\t%f\t%d%n"</span>, oi.getProduct().getName(),oi.getProduct().getPrice(),oi.getNumber());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>读《台北人》</title>
    <url>/blog/2017/06/people-in-taipei.html</url>
    <content><![CDATA[<blockquote>
<p>原来姹紫嫣红开遍<br>似这般都付与断井颓垣<br>良辰美景奈何天<br>赏心乐事谁家院</p>
</blockquote>
<p>&emsp;&emsp;名为台北人，实为台北客，一部小说集共十四篇，描绘的多是因为政治原因从大陆逃到台湾的上流社会的遗世孤老，太太小姐交际花，大学教授，也有下层社会的男工，陪酒女，舞女，小店老板娘，小学教员等，无不是在对过往的回忆和美好，现今的挣扎和落寞之间苦苦徘徊，主题也总逃不过几个字：“美人迟暮，英雄末路。”一种感伤黯然的气氛迷漫着整部作品，大概是因为书中的所有人物，最好的都已经过去了，现在只剩下怀念。</p>
<p>&emsp;&emsp;开篇便是永远的尹雪艳，这也大概是全书是冷的一篇，因为尹雪艳总也不老，门前永远的宾客不断，尹雪艳就代表着昔日大上海的繁华。男人们想要抓住他，为了她倾家荡产，王贵生说，如用他家的金条儿能够搭成一道天梯，他愿意爬上天空去把那弯月牙儿掐下来给她，她只是笑着不语，王贵生贪污被枪毙，尹雪艳在百乐门停业一宵，可她的有情有义也就到此便浅尝辄止；女人们嫉妒中伤她，说她八字带着重煞，犯了白虎，沾上的人，轻者家败，重者人亡，她却在这风言风语中万叶丛中过，片花不沾身，依旧故我。徐壮图被建筑工人刺死，被徐家上下骂做狐狸精的她竟胆敢一身素衣，独往灵堂祭拜，还摸了徐家孩子的头，握了徐家遗孀的手，大大方方的来去自如，在场亲友有惊讶者有愤怒者，却无一人有胆识敢拦住她。这就是她，永远的尹雪艳。有人评价《天龙八部》无人不冤，有情皆孽，用这八个字来形容这本书也无不可，这本书中的悲伤并不来源于某个事物，或某个人，而是像空气一样弥漫于天地之间，尽管每个人都尽心竭力的想要挣脱这个牢笼，但最后也都无能为力。而尹雪艳大概是整本书中唯一一个不苦的人，也是唯一一个没有失去往日荣光的人，好像是一个没有心的人，一个神秘的女人，大概是因为一种超脱之感。</p>
<center><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/blog/p2.jpg"></center>

<p>&emsp;&emsp;接下来便是《一把青》，本来见人不敢高声说话的朱青，经过时间的磨砺也可以大方的在众人面前唱歌了，曾经因丈夫的离去心如死灰的朱青，现在面对死亡，也可以坦然笑之了，经过岁月的历练，朱青成长了，岁月的苦难，人生的苦痛，什么都不怕了</p>
<blockquote>
<p>我站在朱青身后，瞅着她，没有说话，朱青脸上没有施脂粉，可是看着还是异样的年轻朗爽，全不像个三十来岁的妇人，大概她的双颊丰腴了，肌肤也紧滑了，岁月在她的脸上好像刻不下痕迹来了似的。我觉得虽然我比朱青还大了一大把年纪，可是我已经找不出什么话来可以开导她的了</p>
</blockquote>
<p>&emsp;&emsp;《金大班的最后一夜》这篇也不错，只在一夜的光景中由眼前情景牵扯出大半辈子的烟云往事。曾经的金兆丽，如今的金大班，没有蓝田玉戏子般悲春伤秋的情怀，也没有达到尹雪艳那般行到水穷处，坐看云起时的气度，她有的是美貌和精明，美貌是她的本钱，精明是她的经营。前半辈子她驰骋百乐门，红透半边天，后半辈子眼瞅着要人老珠黄时，虽不济却也钓着个土财主陈发容。她的人生哲学清晰简单，四个字，荣华富贵。在漫长的岁月中，她什么都经历过了，爱情，单纯，冲动，但她已经四十多了，已经不再年轻了，需要安定下来，四十岁的女人不能等。四十岁的女人没有工夫谈恋爱。凭着她的美貌与她的经营，金大班这辈子总不会过得太差，她过去是百乐门的红舞女金兆丽，现在是夜巴黎的头牌金大班，将来也会是土财主的富太太，总不会太差。</p>
<p>&emsp;&emsp;《游园惊梦》一篇，据说是成就最高的一篇，使用了意识流的写作手法，但可能是由于本来水平的原因，无法欣赏，我最喜欢的却是《冬夜》一篇，从两个久别重逢的教授口中，讲述了解放后留在大陆的、随国民党去台湾的、明智飞去美国的三种大学教授的不同遭遇。一般看来，可能会以为美国的环境条件最好，其次台湾的也能做学术研究，不受政治影响，大陆的显然惨的连命都不能自主。但真相、个人自己的感受并不是别人眼中的那样，都只不过是挣扎自保而已，曾经的五四先锋，现在的苍白老人，有的生活落魄，有的抛弃梦想，有的欺骗自己，有的得过且过，人生常常有许多无奈之处，无能为力，让人感到个人面对时代变迁的渺小。整篇文章就像在冬夜一样寒冷萧瑟寒冷。                    </p>
<p>&emsp;&emsp;作者白先勇，他的父亲就是著名的白崇禧，白先勇以局外人的眼光来见证这段历史，这些国民党遗老们的故事，轰轰烈烈的发展轨迹和穷途末路的残酷结局，是如此震撼人心的凄凉。看了这部小说，也就无怪乎作者喜欢红楼梦，也无怪乎作者作为一个回民却皈依了佛教，众生皆苦，对于人生的苦，佛教的研究是最透彻的了。《台北人》卷首有作者自己题写的一首古诗，就拿来结尾吧：</p>
<blockquote>
<p>朱雀桥边野草花，乌衣巷口夕阳斜。旧时王谢堂前燕，飞入寻常百姓家。</p>
</blockquote>
]]></content>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>标准日本语第二单元</title>
    <url>/blog/2017/06/standard-japanese-second.html</url>
    <content><![CDATA[<h3 id="第五课"><a href="#第五课" class="headerlink" title="第五课"></a>第五课</h3><h4 id="语法解释"><a href="#语法解释" class="headerlink" title="语法解释"></a>语法解释</h4><p>1.いま某じ某ふんです<br>表示现在是几时几分</p>
<p>2.动词<br>动词ます，动词ません<br>动词ました，动词ませんでした<br>分别表示肯定地叙述现在与未来的动作<br>否定的叙述现在与未来的动作<br>肯定表示过去的动作<br>否定表示过去的动作<br>疑问句要在句尾加か</p>
<p>3.时间に动<br>表示动作发生的时间时，要在具体的时间词语后加上助词に<br>注意的是，包含数字的时间后常加助词，而今天，昨天，明天，去年等不加助词，星期后一般加助词，但也可以不加</p>
<p>4.时间から时间まで动<br>表示动作发生在某个期间</p>
<p>5.いつ动ますか<br>询问某动作或者事态进行的时间<br>询问的时间很具体时，在表示时间的词语后加に</p>
<p>6.は<br>は 可以表示对比</p>
<h4 id="表达及词语讲解"><a href="#表达及词语讲解" class="headerlink" title="表达及词语讲解"></a>表达及词语讲解</h4><p>1.当两个名词都是时间时<br>两个名词间不加の<br>2.ごろ<br>表示在时间左右</p>
<h3 id="第六课"><a href="#第六课" class="headerlink" title="第六课"></a>第六课</h3><h4 id="语法解释-1"><a href="#语法解释-1" class="headerlink" title="语法解释"></a>语法解释</h4><p>1.场所へ动<br>表示移动行为的目的的<br>2.场所から动<br>表示移动的起点，从某某某来<br>3.名と动<br>表示共同做某事<br>4.名(交通工具)で动<br>交通工具用助词で表示<br>5.场所から场所まで动<br>表示移动的范围，从起点到终点<br>6.に、で、へ、から、と+は<br>表示对比的意思</p>
<h4 id="表达及词语讲解-1"><a href="#表达及词语讲解-1" class="headerlink" title="表达及词语讲解"></a>表达及词语讲解</h4><p>1.たしか<br>大概</p>
<p>2.いえ、うち<br>都表示家，前面表示建筑，后面着重指家人</p>
<h3 id="第七课"><a href="#第七课" class="headerlink" title="第七课"></a>第七课</h3><h4 id="语法解释-2"><a href="#语法解释-2" class="headerlink" title="语法解释"></a>语法解释</h4><p>1.名を动<br>动作的对象用助词を表示，读作お<br>2.场所で动<br>动作的场所用助词で表示，需要注意的是，存在的场所和动作进行的场所在汉语里都用在来表示，但在日语里前者为に，后者为で<br>3.名か名<br>表示名词间进行选择，即或<br>4.名をください<br>买东西或者在餐厅点菜的时候使用</p>
<h4 id="表达及词语讲解-2"><a href="#表达及词语讲解-2" class="headerlink" title="表达及词语讲解"></a>表达及词语讲解</h4><p>1.何的用法<br>なん、なに，前者是最基本的读音<br>但在助词の以及量词前使用后者，在で前两者皆可<br>2.そうですか<br>读降调时表示理解了所听到到的消息，相当于汉语里的是吗<br>如果读升调，则表示对对方说的内容有疑问<br>3.そうですね<br>表示同意对方的提议，注意ね的发音不能拉长，拉长后语意会发生变化<br>4.じあ<br>那么</p>
<h3 id="第八课"><a href="#第八课" class="headerlink" title="第八课"></a>第八课</h3><h4 id="语法解释-3"><a href="#语法解释-3" class="headerlink" title="语法解释"></a>语法解释</h4><p>1.工具で动<br>第6课学习了表示交通工具的助词で，で还可以用来表示其他手段以及原材料<br>2.人は人に物をあげます<br>某人给某人某东西<br>3.人は人に物をもらいます<br>某人从某人那得到什么<br>4.人にあいます<br>见某某<br>5.よ<br>用于提醒对方注意其不知道，不了解的事情，读升调。</p>
<h4 id="表达及词语讲解-3"><a href="#表达及词语讲解-3" class="headerlink" title="表达及词语讲解"></a>表达及词语讲解</h4><p>1.からもらいます<br>表示从某人那里接受时，一般用に，但在表示从公司或者学校之类的组织那里接受时，则用から<br>2.さつき和たつたいま<br>如果表示离现在特别近用后者，稍前一点则要用前者<br>3.收到电话与打电话<br>でんわ+をもらいます<br>でんわ+をおくります<br>4.请求<br>请求对方做某事时用名词+(を)おねがいします<br>5.わかりました<br>明白了<br>6.も<br>表示“也”或“都”的意思<br>7.まえに时间<br>まえに除了可以表示位置的用法，还可以表示过去，相当于以前的意思。</p>
]]></content>
      <tags>
        <tag>外语学习</tag>
      </tags>
  </entry>
  <entry>
    <title>标准日本语第一单元</title>
    <url>/blog/2017/06/standard-japanses-first.html</url>
    <content><![CDATA[<h3 id="第一课"><a href="#第一课" class="headerlink" title="第一课"></a>第一课</h3><h4 id="语法解释"><a href="#语法解释" class="headerlink" title="语法解释"></a>语法解释</h4><p>1.名は名です<br>意思是~是~</p>
<p>2.名は名ではありません<br>意思是~不是~</p>
<p>3.疑问句及应答<br>(1)名は名ですか<br>相当于汉语的~是~吗？回答时用はい或者いいえ<br>(2)应答<br>回答疑问句的时候，可以只用はい、いいえ，也可以在はい后加上そうです，也可以在いいえ后加上ちがいます<br>不知道时用わかりません</p>
<p>4.名の名<br>相当于汉语：~的~</p>
<h3 id="表达与词语"><a href="#表达与词语" class="headerlink" title="表达与词语"></a>表达与词语</h3><p>1.人称<br>(1)わたし、あなた、あの一人<br>分别是第一，第二，第三人称，注意的是，只有在不知道姓名并且必须要招呼时才用第二人称，因为这个有时显得不礼貌<br>(2)~さん<br>称呼别人时，不分男女，都在其后面加さん<br>称呼小孩时，一般在名字后加ちやん<br>另外，对于 与自己年龄相当，或比自己年轻的男性，也可以用*君来表示(くん)</p>
<p>2.省略<br>在日语中，一般省略通过场景或上下文可以明白的部分，如不省略，听起来会不自然或者不礼貌。<br>在会话中，多省略第一、第二人称的主语。</p>
<p>3.あつ叹词<br>表示吃惊或者有所感触</p>
<p>4.寒暄语<br>どうぞよろしくおねがいします<br>初次见面，请多关照</p>
<h3 id="第二课"><a href="#第二课" class="headerlink" title="第二课"></a>第二课</h3><h4 id="语法解释-1"><a href="#语法解释-1" class="headerlink" title="语法解释"></a>语法解释</h4><p>1.これ、それ、あれは名です<br>分别表示这个，那个，那个（更远）的是~</p>
<p>2.だれですか、何ですか<br>不知道是什么人时用だれ、不知道是什么时物时用なん，分别相当于汉语里的谁和什么</p>
<p>3.名の名<br>助词の连接名词和名词，表示所属</p>
<p>4.この、その、あの名は名です<br>表示的位置关系与上面相同，表示这个，那个，那个（更远）的</p>
<p>5.どれ、どの<br>哪个</p>
<h4 id="100以下的数字"><a href="#100以下的数字" class="headerlink" title="100以下的数字"></a>100以下的数字</h4><h4 id="表达及词语讲解"><a href="#表达及词语讲解" class="headerlink" title="表达及词语讲解"></a>表达及词语讲解</h4><p>1.かだ<br>那位，表示对长辈，工作单位的上司等应该尊敬的对象。<br>2.询问年龄<br>何歳ですか（多在了）<br>或者用更礼貌的语言：おいくつですか（多大年纪了）<br>3.どうぞ<br>用于给对方物品，或者劝对方进餐<br>4.叹词<br>(1)えつ<br>表示吃惊<br>(2)わあ<br>表示感动或吃惊<br>5.はい和ええ<br>都表示肯定，后者比较随便<br>6.非常感谢<br>どうも　ありがとう    ございます</p>
<h3 id="第三课"><a href="#第三课" class="headerlink" title="第三课"></a>第三课</h3><h4 id="语法解释-2"><a href="#语法解释-2" class="headerlink" title="语法解释"></a>语法解释</h4><p>1.ここ、そこ、あそこは名です<br>这里，那里，那儿是什么<br>2.名は名(场所)です<br>表示“名词”存在于“名词”中<br>3.名はどこですか<br>询问在哪<br>4.名も名です<br>助词も相当于汉语里的也<br>5.名は名ですか，名ですか<br>询问多种可能性<br>6.名はいくらですか<br>询问价钱时，用いくら</p>
<h4 id="100以上的数字"><a href="#100以上的数字" class="headerlink" title="100以上的数字"></a>100以上的数字</h4><h4 id="表达及语法讲解"><a href="#表达及语法讲解" class="headerlink" title="表达及语法讲解"></a>表达及语法讲解</h4><p>1.かい<br>楼，量词，与前面的数词搭配<br>2.礼貌语言<br>こちら等是ここ等的礼貌说法<br>3.缩略词<br>4.あのう<br>用于向对方搭话或者想引起对方注意<br>5.ですか<br>用于进一步确认对方所说的信息</p>
<h3 id="第四课"><a href="#第四课" class="headerlink" title="第四课"></a>第四课</h3><h4 id="语法解释-3"><a href="#语法解释-3" class="headerlink" title="语法解释"></a>语法解释</h4><p>1.あります、います<br>表示事物的存在，前者表示花，草，桌子等不具有意志的事物<br>后者表示用于具有意志的人，动物，昆虫等<br>句型主要有以下两种<br>(1)场所に名があります/います<br>相当于汉语的某地方有某某<br>(2)名は场所にあります/います<br>表示什么东西在哪里</p>
<p>用于疑问句时：<br>名はどこにありますか<br>名はどこにいますか</p>
<p>2.名と名<br>表示并列，相当于汉语时的和</p>
<p>3.うえ、した、まえ、うしろ、となり、なか、そと<br>上 ，下，前，后，旁边，里面，外面<br>使用时用名词+の使用</p>
<p>4.ね<br>表示确认，当说话人就某事征求听话人的同意时，句尾用ね</p>
<p>5.疑问词+も+动词(否)<br>表示全面否定</p>
<h4 id="表达及词语讲解-1"><a href="#表达及词语讲解-1" class="headerlink" title="表达及词语讲解"></a>表达及词语讲解</h4><p>1.“上”表示的范围<br>日语里上表示的范围较窄，只表示垂直上方的范围</p>
<p>2.ええと<br>是被别人问及某事，思考该如何回答时说的话</p>
<p>3.ご<br>亲属前加ご表示礼貌，不是所有的名词前都能加的</p>
]]></content>
      <tags>
        <tag>外语学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis学习</title>
    <url>/blog/2017/06/mybatis-learn-two.html</url>
    <content><![CDATA[<h3 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h3><h4 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h4><p>假设需要对Product执行两条sql语句，一个是查询所有，一个是根据名称模糊查询。<br>那么按照现在的方式，必须提供两条sql语句：listProduct和listProductByName<br>然后在调用的时候，分别调用它们来执行。</p>
<p>如果Product的字段比较多的话，为了应付各个字段的查询，那么就需要写多条sql语句，这样就变得难以维护。<br>这个时候，就可以使用Mybatis 动态SQL里的if标签<br><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">select</span> id=<span class="string">"listProduct"</span> resultType=<span class="string">"Product"</span>&gt;</span><br><span class="line">	<span class="keyword">select</span> * <span class="keyword">from</span> product_</span><br><span class="line">	&lt;<span class="keyword">if</span> test=<span class="string">"name!=null"</span>&gt;</span><br><span class="line">		<span class="function"><span class="keyword">where</span> name like <span class="title">concat</span>(<span class="params"><span class="string">'%'</span>,#&#123;name&#125;,<span class="string">'%'</span></span>)</span></span><br><span class="line"><span class="function">	&lt;/<span class="keyword">if</span>&gt;		 	</span></span><br><span class="line"><span class="function">&lt;/<span class="keyword">select</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>如果没有传参数name,那么就查询所有，如果有name参数，那么就进行模糊查询。<br>这样只需要定义一条sql语句即可应付多种情况了，在测试的时候，也只需要调用这么一条sql语句listProduct 即可。</p>
<p>Product.xml<br><figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span></span><br><span class="line"><span class="xml"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span></span><br><span class="line"><span class="xml">    PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"</span></span><br><span class="line"><span class="xml">    "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.how2java.pojo"</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"listProduct"</span> <span class="attr">resultType</span>=<span class="string">"Product"</span>&gt;</span></span></span><br><span class="line"><span class="xml">            select * from product_</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"name!=null"</span>&gt;</span></span></span><br><span class="line"><span class="xml">                where name like concat('%',#</span><span class="template-variable">&#123;name&#125;</span><span class="xml">,'%')</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span>         </span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span></span><br><span class="line"><span class="xml">         </span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>测试程序<br><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMybatis</span> &#123;</span></span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> throws IOException </span>&#123;</span><br><span class="line">        <span class="keyword">String</span> resource = <span class="string">"mybatis-config.xml"</span>;</span><br><span class="line">        InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">        SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">        SqlSession session = sqlSessionFactory.openSession();</span><br><span class="line">  </span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"查询所有的"</span>);</span><br><span class="line">        List&lt;Product&gt; ps = session.selectList(<span class="string">"listProduct"</span>);</span><br><span class="line">        <span class="keyword">for</span> (Product p : ps) &#123;</span><br><span class="line">            System.out.<span class="built_in">println</span>(p);</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"模糊查询"</span>);</span><br><span class="line">        Map&lt;<span class="keyword">String</span>,Object&gt; params = <span class="keyword">new</span> HashMap&lt;&gt;(); </span><br><span class="line">        params.<span class="built_in">put</span>(<span class="string">"name"</span>,<span class="string">"a"</span>);</span><br><span class="line">        List&lt;Product&gt; ps2 = session.selectList(<span class="string">"listProduct"</span>,params);</span><br><span class="line">        <span class="keyword">for</span> (Product p : ps2) &#123;</span><br><span class="line">            System.out.<span class="built_in">println</span>(p);</span><br><span class="line">        &#125;       </span><br><span class="line">         </span><br><span class="line">        session.commit();</span><br><span class="line">        session.<span class="built_in">close</span>();</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="多条件判断"><a href="#多条件判断" class="headerlink" title="多条件判断"></a>多条件判断</h4><p>多条件判断可以用where<br><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">select</span> id=<span class="string">"listProduct"</span> resultType=<span class="string">"Product"</span>&gt;</span><br><span class="line">	<span class="keyword">select</span> * <span class="keyword">from</span> product_</span><br><span class="line">	&lt;<span class="keyword">where</span>&gt;</span><br><span class="line">		&lt;<span class="keyword">if</span> test=<span class="string">"name!=null"</span>&gt;</span><br><span class="line">			<span class="function">and name like <span class="title">concat</span>(<span class="params"><span class="string">'%'</span>,#&#123;name&#125;,<span class="string">'%'</span></span>)</span></span><br><span class="line"><span class="function">		&lt;/<span class="keyword">if</span>&gt;		 	</span></span><br><span class="line"><span class="function">		&lt;<span class="keyword">if</span> test</span>=<span class="string">"price!=null and price!=0"</span>&gt;</span><br><span class="line">			and price &gt; <span class="meta">#&#123;price&#125;</span></span><br><span class="line">		&lt;/<span class="keyword">if</span>&gt;	</span><br><span class="line">	&lt;/<span class="keyword">where</span>&gt;	 	</span><br><span class="line">&lt;/<span class="keyword">select</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>where标签会进行自动判断<br>如果任何条件都不成立，那么就在sql语句里就不会出现where关键字<br>如果有任何条件成立，会自动去掉多出来的 and 或者 or。<br>所以在测试代码里<br><figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Map</span>&lt;<span class="built_in">String</span>,Object&gt; <span class="keyword">params</span> = <span class="literal">new</span> HashMap&lt;&gt;(); </span><br><span class="line"><span class="comment">//params.put("name","a");</span></span><br><span class="line"><span class="keyword">params</span>.put(<span class="string">"price"</span>,<span class="string">"10"</span>);</span><br></pre></td></tr></table></figure></p>
<p>这个参数map，无论是否提供值否都可以正常执行</p>
<p>set标签<br>与where标签类似的，在update语句里也会碰到多个字段相关的问题。 在这种情况下，就可以使用set标签</p>
<p>trim标签<br>trim 用来定制想要的功能，比如where标签就可以用<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">"WHERE"</span> <span class="attr">prefixOverrides</span>=<span class="string">"AND |OR "</span>&gt;</span></span><br><span class="line">  ... </span><br><span class="line"><span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>来替换</p>
<p>set标签就可以用<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">"SET"</span> <span class="attr">suffixOverrides</span>=<span class="string">","</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>来替换</p>
<h4 id="ifelse"><a href="#ifelse" class="headerlink" title="ifelse"></a>ifelse</h4><p>Mybatis里面没有else标签，但是可以使用when otherwise标签来达到这样的效果。<br><figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"listProduct"</span> <span class="attr">resultType</span>=<span class="string">"Product"</span>&gt;</span></span></span><br><span class="line"><span class="xml">	  SELECT * FROM product_ </span></span><br><span class="line"><span class="xml">	  <span class="tag">&lt;<span class="name">where</span>&gt;</span></span></span><br><span class="line"><span class="xml">	  	<span class="tag">&lt;<span class="name">choose</span>&gt;</span></span></span><br><span class="line"><span class="xml">		  <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">"name != null"</span>&gt;</span></span></span><br><span class="line"><span class="xml">		    and name like concat('%',#</span><span class="template-variable">&#123;name&#125;</span><span class="xml">,'%')</span></span><br><span class="line"><span class="xml">		  <span class="tag">&lt;/<span class="name">when</span>&gt;</span>			  </span></span><br><span class="line"><span class="xml">		  <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">"price !=null and price != 0"</span>&gt;</span></span></span><br><span class="line"><span class="xml">		    and price &gt; #</span><span class="template-variable">&#123;price&#125;</span></span><br><span class="line"><span class="xml">		  <span class="tag">&lt;/<span class="name">when</span>&gt;</span>			  		</span></span><br><span class="line"><span class="xml">	  	  <span class="tag">&lt;<span class="name">otherwise</span>&gt;</span></span></span><br><span class="line"><span class="xml">	  	  	and id &gt;1</span></span><br><span class="line"><span class="xml">	  	  <span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span></span><br><span class="line"><span class="xml">	  	<span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span></span><br><span class="line"><span class="xml">	  <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>起作用是： 提供了任何条件，就进行条件查询，否则就使用id&gt;1这个条件。</p>
<h4 id="foreach标签"><a href="#foreach标签" class="headerlink" title="foreach标签"></a>foreach标签</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> product_ </span><br><span class="line">	<span class="keyword">WHERE</span> <span class="keyword">ID</span> <span class="keyword">in</span></span><br><span class="line">		&lt;foreach item=<span class="string">"item"</span> <span class="keyword">index</span>=<span class="string">"index"</span> collection=<span class="string">"list"</span></span><br><span class="line">   			<span class="keyword">open</span>=<span class="string">"("</span> separator=<span class="string">","</span> <span class="keyword">close</span>=<span class="string">")"</span>&gt;</span><br><span class="line">     		             <span class="comment">#&#123;item&#125;</span></span><br><span class="line">		&lt;/foreach&gt;</span><br></pre></td></tr></table></figure>
<p>foreach标签通常用于in 这样的语法</p>
<h4 id="bind标签"><a href="#bind标签" class="headerlink" title="bind标签"></a>bind标签</h4><p>bind标签就像是再做一次字符串拼接，方便后续使用<br>如本例，在模糊查询的基础上，把模糊查询改为bind标签。<br><figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span></span><br><span class="line"><span class="xml"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span></span><br><span class="line"><span class="xml">    PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"</span></span><br><span class="line"><span class="xml">    "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.how2java.pojo"</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="comment">&lt;!-- 本来的模糊查询方式 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--         &lt;select id="listProduct" resultType="Product"&gt; --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--             select * from   product_  where name like concat('%',#</span></span><span class="template-variable">&#123;0&#125;</span><span class="xml"><span class="comment">,'%') --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--         &lt;/select&gt; --&gt;</span></span></span><br><span class="line"><span class="xml">             </span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"listProduct"</span> <span class="attr">resultType</span>=<span class="string">"Product"</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">bind</span> <span class="attr">name</span>=<span class="string">"likename"</span> <span class="attr">value</span>=<span class="string">"'%' + name + '%'"</span> /&gt;</span></span></span><br><span class="line"><span class="xml">            select * from   product_  where name like #</span><span class="template-variable">&#123;likename&#125;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span></span><br><span class="line"><span class="xml">         </span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p>把 XML方式的CRUD 修改为注解方式</p>
<h4 id="Mapper接口"><a href="#Mapper接口" class="headerlink" title="Mapper接口"></a>Mapper接口</h4><p>新增加接口CategoryMapper ，并在接口中声明的方法上，加上注解<br>对比配置文件Category.xml，其实就是把SQL语句从XML挪到了注解上来<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.how2java.mapper;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Delete;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Insert;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Select;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Update;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> com.how2java.pojo.Category;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CategoryMapper</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Insert</span>(<span class="string">" insert into category_ ( name ) values (#&#123;name&#125;) "</span>)  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(Category category)</span></span>;  </span><br><span class="line">        </span><br><span class="line">    <span class="meta">@Delete</span>(<span class="string">" delete from category_ where id= #&#123;id&#125; "</span>)  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> id)</span></span>;  </span><br><span class="line">        </span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"select * from category_ where id= #&#123;id&#125; "</span>)  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Category <span class="title">get</span><span class="params">(<span class="keyword">int</span> id)</span></span>;  </span><br><span class="line">      </span><br><span class="line">    <span class="meta">@Update</span>(<span class="string">"update category_ set name=#&#123;name&#125; where id=#&#123;id&#125; "</span>)  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(Category category)</span></span>;   </span><br><span class="line">        </span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">" select * from category_ "</span>)  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Category&gt; <span class="title">list</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在mybatis-config.xml添加对CategoryMapper的映射<br><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line">&lt;mapper <span class="keyword">class</span>=<span class="string">"com.how2java.mapper.CategoryMapper"</span>/&gt;</span><br></pre></td></tr></table></figure></p>
<p>运行测试<br><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">package com.how2java;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.io.Resources;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSession;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactoryBuilder;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> com.how2java.mapper.CategoryMapper;</span><br><span class="line"><span class="keyword">import</span> com.how2java.pojo.Category;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMybatis</span> &#123;</span></span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> throws IOException </span>&#123;</span><br><span class="line">        <span class="keyword">String</span> resource = <span class="string">"mybatis-config.xml"</span>;</span><br><span class="line">        InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">        SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">        SqlSession session = sqlSessionFactory.openSession();</span><br><span class="line">        CategoryMapper mapper = session.getMapper(CategoryMapper.class);</span><br><span class="line">  </span><br><span class="line"><span class="comment">//        add(mapper);</span></span><br><span class="line"><span class="comment">//        delete(mapper);</span></span><br><span class="line"><span class="comment">//        get(mapper);</span></span><br><span class="line"><span class="comment">//        update(mapper);</span></span><br><span class="line">        listAll(mapper);</span><br><span class="line">              </span><br><span class="line">        session.commit();</span><br><span class="line">        session.<span class="built_in">close</span>();</span><br><span class="line">   </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(CategoryMapper mapper)</span> </span>&#123;</span><br><span class="line">        Category c= mapper.<span class="built_in">get</span>(<span class="number">8</span>);</span><br><span class="line">        c.setName(<span class="string">"修改了的Category名稱"</span>);</span><br><span class="line">        mapper.update(c);</span><br><span class="line">        listAll(mapper);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">(CategoryMapper mapper)</span> </span>&#123;</span><br><span class="line">        Category c= mapper.<span class="built_in">get</span>(<span class="number">8</span>);</span><br><span class="line">        System.out.<span class="built_in">println</span>(c.getName());</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(CategoryMapper mapper)</span> </span>&#123;</span><br><span class="line">        mapper.<span class="keyword">delete</span>(<span class="number">2</span>);</span><br><span class="line">        listAll(mapper);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(CategoryMapper mapper)</span> </span>&#123;</span><br><span class="line">        Category c = <span class="keyword">new</span> Category();</span><br><span class="line">        c.setName(<span class="string">"新增加的Category"</span>);</span><br><span class="line">        mapper.add(c);</span><br><span class="line">        listAll(mapper);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">listAll</span><span class="params">(CategoryMapper mapper)</span> </span>&#123;</span><br><span class="line">        List&lt;Category&gt; cs = mapper.<span class="built_in">list</span>();</span><br><span class="line">        <span class="keyword">for</span> (Category c : cs) &#123;</span><br><span class="line">            System.out.<span class="built_in">println</span>(c.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="其他相关概念"><a href="#其他相关概念" class="headerlink" title="其他相关概念"></a>其他相关概念</h3><h4 id="打印日志"><a href="#打印日志" class="headerlink" title="打印日志"></a>打印日志</h4><p>导入log4j的包后<br>在src目录下，新建文件log4j.properties，其作用是输出com.how2java包下参与Mybatis的类的SQL语句输出<br>如果包名不一样，请根据自己的项目情况调整<br><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Global logging configuration</span></span><br><span class="line"><span class="attr">log4j.rootLogger</span>=ERROR, stdout</span><br><span class="line"><span class="comment"># MyBatis logging configuration...</span></span><br><span class="line"><span class="attr">log4j.logger.com.how2java</span>=TRACE</span><br><span class="line"><span class="comment"># Console output...</span></span><br><span class="line"><span class="attr">log4j.appender.stdout</span>=org.apache.log4j.ConsoleAppender</span><br><span class="line"><span class="attr">log4j.appender.stdout.layout</span>=org.apache.log4j.PatternLayout</span><br><span class="line"><span class="attr">log4j.appender.stdout.layout.ConversionPattern</span>=%<span class="number">5</span>p [%t] - %m%n</span><br></pre></td></tr></table></figure></p>
<h4 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h4><p>1.确保transactionManager 方式是JDBC<br>2.MYSQL 表的类型必须是INNODB</p>
<h4 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h4><p>延迟加载的配置<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">PUBLIC <span class="meta-string">"-//mybatis.org//DTD Config 3.0//EN"</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span>&gt;</span>  </span><br><span class="line">         <span class="comment">&lt;!-- 打开延迟加载的开关 --&gt;</span>  </span><br><span class="line">         <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"lazyLoadingEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span>  </span><br><span class="line">         <span class="comment">&lt;!-- 将积极加载改为消息加载即按需加载 --&gt;</span>  </span><br><span class="line">         <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"aggressiveLazyLoading"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"com.how2java.pojo"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/how2java?characterEncoding=UTF-8"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"admin"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"com/how2java/pojo/Category.xml"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">"com.how2java.mapper.CategoryMapper"</span>/&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">"com.how2java.mapper.ProductMapper"</span>/&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h4 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h4><p>Mybatis的一级缓存在ession上，只要通过session查过的数据，都会放在session上，下一次再查询相同id的数据，都直接冲缓存中取出来，而不用到数据库里去取了。<br>1.在一个Session里查相同id的数据<br>如图所示，在session1中查询两次id=1的Category对象。<br>第一次会去数据库中取数据，但是第二次就不会访问数据库了，而是直接从session中取出来。<br><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMybatis</span> &#123;</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> throws IOException </span>&#123;</span><br><span class="line">        <span class="keyword">String</span> resource = <span class="string">"mybatis-config.xml"</span>;</span><br><span class="line">        InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">        SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">        SqlSession session1 = sqlSessionFactory.openSession();</span><br><span class="line"> </span><br><span class="line">        Category c1 = session1.selectOne(<span class="string">"getCategory"</span>, <span class="number">1</span>);</span><br><span class="line">        System.out.<span class="built_in">println</span>(c1);</span><br><span class="line">        Category c2 = session1.selectOne(<span class="string">"getCategory"</span>, <span class="number">1</span>);</span><br><span class="line">        System.out.<span class="built_in">println</span>(c2);</span><br><span class="line"> </span><br><span class="line">        session1.commit();</span><br><span class="line">        session1.<span class="built_in">close</span>();</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.在不同Session里查相同id的数据<br>这一次，另外打开一个session,取同样id的数据，就会发现需要执行sql语句，证实了一级缓存是在session里的。<br><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMybatis</span> &#123;</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> throws IOException </span>&#123;</span><br><span class="line">        <span class="keyword">String</span> resource = <span class="string">"mybatis-config.xml"</span>;</span><br><span class="line">        InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">        SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">        SqlSession session1 = sqlSessionFactory.openSession();</span><br><span class="line"> </span><br><span class="line">        Category c1 = session1.selectOne(<span class="string">"getCategory"</span>, <span class="number">1</span>);</span><br><span class="line">        System.out.<span class="built_in">println</span>(c1);</span><br><span class="line">        Category c2 = session1.selectOne(<span class="string">"getCategory"</span>, <span class="number">1</span>);</span><br><span class="line">        System.out.<span class="built_in">println</span>(c2);</span><br><span class="line"> </span><br><span class="line">        session1.commit();</span><br><span class="line">        session1.<span class="built_in">close</span>();</span><br><span class="line">         </span><br><span class="line">        SqlSession session2 = sqlSessionFactory.openSession();</span><br><span class="line">        Category c3 = session2.selectOne(<span class="string">"getCategory"</span>, <span class="number">1</span>);</span><br><span class="line">        System.out.<span class="built_in">println</span>(c3);     </span><br><span class="line">        session2.commit();</span><br><span class="line">        session2.<span class="built_in">close</span>();</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h4><p>Mybatis二级缓存是SessionFactory，如果两次查询基于同一个SessionFactory，那么就从二级缓存中取数据，而不用到数据库里去取了。<br>1.启动二级缓存<br>11行新增一个段配置，以支持二级缓存<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">PUBLIC <span class="meta-string">"-//mybatis.org//DTD Config 3.0//EN"</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span>&gt;</span>  </span><br><span class="line">            <span class="comment">&lt;!-- 打开延迟加载的开关 --&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"lazyLoadingEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span>  </span><br><span class="line">            <span class="comment">&lt;!-- 将积极加载改为消息加载即按需加载 --&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"aggressiveLazyLoading"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"cacheEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">settings</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"com.how2java.pojo"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/how2java?characterEncoding=UTF-8"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"admin"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"com/how2java/pojo/Category.xml"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">"com.how2java.mapper.CategoryMapper"</span>/&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">"com.how2java.mapper.ProductMapper"</span>/&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>2.在Category.xml中增加 cache<br><figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="xml">第7行新增<span class="tag">&lt;<span class="name">cache</span>/&gt;</span>以启动对Category对象的二级缓存</span></span><br><span class="line"><span class="xml"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span></span><br><span class="line"><span class="xml"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span></span><br><span class="line"><span class="xml">    PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"</span></span><br><span class="line"><span class="xml">    "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.how2java.pojo"</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">cache</span>/&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"addCategory"</span> <span class="attr">parameterType</span>=<span class="string">"Category"</span> &gt;</span></span></span><br><span class="line"><span class="xml">            insert into category_ ( name ) values (#</span><span class="template-variable">&#123;name&#125;</span><span class="xml">)    </span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span></span><br><span class="line"><span class="xml">         </span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">"deleteCategory"</span> <span class="attr">parameterType</span>=<span class="string">"Category"</span> &gt;</span></span></span><br><span class="line"><span class="xml">            delete from category_ where id= #</span><span class="template-variable">&#123;id&#125;</span><span class="xml">   </span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span></span><br><span class="line"><span class="xml">         </span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getCategory"</span> <span class="attr">parameterType</span>=<span class="string">"_int"</span> <span class="attr">resultType</span>=<span class="string">"Category"</span>&gt;</span></span></span><br><span class="line"><span class="xml">            select * from   category_  where id= #</span><span class="template-variable">&#123;id&#125;</span><span class="xml">    </span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"updateCategory"</span> <span class="attr">parameterType</span>=<span class="string">"Category"</span> &gt;</span></span></span><br><span class="line"><span class="xml">            update category_ set name=#</span><span class="template-variable">&#123;name&#125;</span><span class="xml"> where id=#</span><span class="template-variable">&#123;id&#125;</span><span class="xml">    </span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"listCategory"</span> <span class="attr">resultType</span>=<span class="string">"Category"</span>&gt;</span></span></span><br><span class="line"><span class="xml">            select * from   category_ </span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"start!=null and count!=null"</span>&gt;</span></span></span><br><span class="line"><span class="xml">                    limit #</span><span class="template-variable">&#123;start&#125;</span><span class="xml">,#</span><span class="template-variable">&#123;count&#125;</span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">select</span>&gt;</span>     </span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>3.序列化Category<br>让Category 实现序列化接口</p>
<p>4.测试<br>再次运行TestMybatis，如图所示，在同一个SessionFactory下查询id=1的数据，只有第一次需要执行sql语句，以后都是从缓存中取出</p>
<h4 id="C3P0数据库连接池"><a href="#C3P0数据库连接池" class="headerlink" title="C3P0数据库连接池"></a>C3P0数据库连接池</h4><p>1.下载JAR包<br>下载c3p0的jar包<br>2.导入项目<br>3.新建类C3P0DataSourceFactory<br>Mybatis使用C3P0有点怪怪的，需要自己写个类继承UnpooledDataSourceFactory，然后指定dataSource 为ComboPooledDataSource。<br>这个ComboPooledDataSource就是c3p0的数据源。<br><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.mybatis.c3p0;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.datasource.unpooled.<span class="type">UnpooledDataSourceFactory</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> com.mchange.v2.c3p0.<span class="type">ComboPooledDataSource</span>;</span><br><span class="line"> </span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">C3P0DataSourceFactory</span> <span class="keyword">extends</span> <span class="title">UnpooledDataSourceFactory</span></span>&#123;</span><br><span class="line">     </span><br><span class="line">        public <span class="type">C3P0DataSourceFactory</span>()&#123;</span><br><span class="line">     </span><br><span class="line">           <span class="keyword">this</span>.dataSource =<span class="keyword">new</span> <span class="type">ComboPooledDataSource</span>();</span><br><span class="line">     </span><br><span class="line">        &#125;</span><br><span class="line">     </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>4.配置 mybatis-config.xml<br>注释掉type=”POOLED”的数据源，换成type=”org.mybatis.c3p0.C3P0DataSourceFactory”的数据源<br>这样就使用c3p0了。</p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring MVC学习</title>
    <url>/blog/2017/06/spring-mvc-learn.html</url>
    <content><![CDATA[<h3 id="视图定位"><a href="#视图定位" class="headerlink" title="视图定位"></a>视图定位</h3><p>如果代码写成这样，就表示跳转到页面 index.jsp<br>new ModelAndView(“index.jsp”); </p>
<p>所谓的视图定位，指的是代码还是写成这样，但是会跳转到 /WEB-INF/page/index.jsp<br>new ModelAndView(“index”);<br>主要步骤如下：</p>
<h4 id="修改springmvc-servlet-xml"><a href="#修改springmvc-servlet-xml" class="headerlink" title="修改springmvc-servlet.xml"></a>修改springmvc-servlet.xml</h4><p>修改springmvc-servlet.xml，增加<br><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">&lt;bean <span class="built_in">id</span>=<span class="string">"viewResolver"</span> <span class="built_in">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span><br><span class="line">   &lt;<span class="keyword">property</span> <span class="built_in">name</span>=<span class="string">"prefix"</span> value=<span class="string">"/WEB-INF/page/"</span> /&gt;</span><br><span class="line">   &lt;<span class="keyword">property</span> <span class="built_in">name</span>=<span class="string">"suffix"</span> value=<span class="string">".jsp"</span> /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p>
<p>其作用是把视图约定在 /WEB-INF/page/*.jsp 这个位置</p>
<h4 id="修改IndexController"><a href="#修改IndexController" class="headerlink" title="修改IndexController"></a>修改IndexController</h4><p>把IndexController类的这一行代码<br>ModelAndView mav = new ModelAndView(“index.jsp”);</p>
<p>修改为<br>ModelAndView mav = new ModelAndView(“index”);</p>
<h4 id="移动index-jsp"><a href="#移动index-jsp" class="headerlink" title="移动index.jsp"></a>移动index.jsp</h4><p>在WEB-INF下新建目录page<br>把index.jsp移动到 WEB-INF/page 目录下<br>这样，通过同样的操作，即可访问到page目录下的页面</p>
<h4 id="这样做的目的"><a href="#这样做的目的" class="headerlink" title="这样做的目的"></a>这样做的目的</h4><p>不是所有的视图都会使用jsp来做，还可以是JSF,html 等其他的方式。<br>用这样的手段，如果要把视图从index.jsp改为index.html，就不需要修改代码，而仅仅需要修改配置文件即可。</p>
<p>另一个便利之处在于，如果要批量修改视图文件所处于的位置，按照以前的办法，也需要对每个类逐一修改，工作量大，容易出错。 而使用这种方式，维护成本就小多了。</p>
<h3 id="注解方式实现跳转"><a href="#注解方式实现跳转" class="headerlink" title="注解方式实现跳转"></a>注解方式实现跳转</h3><p>前面的例子，都是使用配置的方式进行跳转的配置，本例讲解如何使用注解的方式进行跳转的配置<br>主要步骤如下：</p>
<h4 id="修改IndexController-1"><a href="#修改IndexController-1" class="headerlink" title="修改IndexController"></a>修改IndexController</h4><p>在类前面加上@Controller 表示该类是一个控制器<br>在方法handleRequest 前面加上 @RequestMapping(“/index”) 表示路径/index会映射到该方法上<br>注意：不再让IndexController实现Controller接口<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> controller;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/index"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handleRequest</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ModelAndView mav = <span class="keyword">new</span> ModelAndView(<span class="string">"index"</span>);</span><br><span class="line">        mav.addObject(<span class="string">"message"</span>, <span class="string">"Hello Spring MVC"</span>);</span><br><span class="line">        <span class="keyword">return</span> mav;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="修改springmvc-servlet-xml-1"><a href="#修改springmvc-servlet-xml-1" class="headerlink" title="修改springmvc-servlet.xml"></a>修改springmvc-servlet.xml</h4><p>去掉映射相关的配置，因为已经使用注解方式了<br>增加<br><figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">context</span>:<span class="keyword">component</span>-scan base-<span class="keyword">package</span>=<span class="string">"controller"</span> /&gt;</span><br></pre></td></tr></table></figure></p>
<p>表示从包controller下扫描有@Controller注解的类<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/context         </span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/context/spring-context-3.0.xsd"</span>&gt;</span></span><br><span class="line">     </span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"controller"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"irViewResolver"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/page/"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".jsp"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--     &lt;bean id="simpleUrlHandlerMapping" --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--         class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping"&gt; --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--         &lt;property name="mappings"&gt; --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--             &lt;props&gt; --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--                 &lt;prop key="/index"&gt;indexController&lt;/prop&gt; --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--             &lt;/props&gt; --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--         &lt;/property&gt; --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--     &lt;/bean&gt; --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--     &lt;bean id="indexController" class="controller.IndexController"&gt;&lt;/bean&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="接受表单数据"><a href="#接受表单数据" class="headerlink" title="接受表单数据"></a>接受表单数据</h3><p>浏览器提交数据是非常常见的场景，本例演示用户提交产品名称和价格到Spring MVC Spring MVC如何接受数据</p>
<h4 id="首先实现实体类"><a href="#首先实现实体类" class="headerlink" title="首先实现实体类"></a>首先实现实体类</h4><p>实体类Product<br><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">package pojo;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> &#123;</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> price;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">String</span> <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(<span class="keyword">String</span> name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(<span class="keyword">float</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="addProduct-jsp-提问"><a href="#addProduct-jsp-提问" class="headerlink" title="addProduct.jsp  提问"></a>addProduct.jsp  提问</h4><p>在web目录下 增加商品的页面addProduct.jsp<br>注意：产品名称input的name要使用name，而不是 product.name<br>同时注意路径，是当前路径下的addProduct<br><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">"java"</span> contentType=<span class="string">"text/html; charset=UTF-8"</span></span><br><span class="line">    pageEncoding=<span class="string">"UTF-8"</span> import=<span class="string">"java.util.*"</span> isELIgnored=<span class="string">"false"</span>%&gt;</span><br><span class="line"> </span><br><span class="line">&lt;<span class="keyword">form</span> action=<span class="string">"./addProduct"</span>&gt;</span><br><span class="line"> </span><br><span class="line">    产品名称 ：&lt;<span class="keyword">input</span> <span class="keyword">type</span>=<span class="string">"text"</span> name=<span class="string">"name"</span> value=<span class="string">""</span>&gt;&lt;<span class="keyword">br</span> /&gt;</span><br><span class="line">    产品价格： &lt;<span class="keyword">input</span> <span class="keyword">type</span>=<span class="string">"text"</span> name=<span class="string">"price"</span> value=<span class="string">""</span>&gt;&lt;<span class="keyword">br</span> /&gt;</span><br><span class="line"> </span><br><span class="line">    &lt;<span class="keyword">input</span> <span class="keyword">type</span>=<span class="string">"submit"</span> value=<span class="string">"增加商品"</span>&gt;</span><br><span class="line">&lt;/<span class="keyword">form</span>&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="ProductController"><a href="#ProductController" class="headerlink" title="ProductController"></a>ProductController</h4><p>控制器ProductController，准备一个add方法映射/addProduct路径</p>
<p>为add方法准备一个Product 参数，用于接收注入</p>
<p>最后跳转到showProduct页面显示用户提交的数据</p>
<p>注： 参数product会默认被当做值加入到ModelAndView 中，相当于：</p>
<p>mav.addObject(“product”,product);<br><figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">package controller;</span><br><span class="line"> </span><br><span class="line">import org.springframework.stereotype.Controller;</span><br><span class="line">import org.springframework.web.bind.<span class="keyword">annotation</span>.<span class="title">ModelAttribute</span>;</span><br><span class="line">import org.springframework.web.bind.<span class="keyword">annotation</span>.<span class="title">RequestMapping</span>;</span><br><span class="line">import org.springframework.web.bind.<span class="keyword">annotation</span>.<span class="title">RequestParam</span>;</span><br><span class="line">import org.springframework.web.servlet.ModelAndView;</span><br><span class="line"> </span><br><span class="line">import pojo.Product;</span><br><span class="line"> </span><br><span class="line">@Controller</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ProductController</span> &#123;</span></span><br><span class="line"> </span><br><span class="line">    @RequestMapping(<span class="string">"/addProduct"</span>)</span><br><span class="line">    public ModelAndView add(Product product) throws Exception &#123;</span><br><span class="line">        ModelAndView mav = new ModelAndView(<span class="string">"showProduct"</span>);</span><br><span class="line">        <span class="keyword">return</span> mav;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="showProduct-jsp"><a href="#showProduct-jsp" class="headerlink" title="showProduct.jsp"></a>showProduct.jsp</h4><p>用 EL 表达式显示用户提交的名称和价格,放到WEB-INF的page文件夹下<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;%@<span class="built_in"> page </span><span class="attribute">language</span>=<span class="string">"java"</span> <span class="attribute">contentType</span>=<span class="string">"text/html; charset=UTF-8"</span></span><br><span class="line">    <span class="attribute">pageEncoding</span>=<span class="string">"UTF-8"</span> <span class="attribute">isELIgnored</span>=<span class="string">"false"</span>%&gt;</span><br><span class="line"> </span><br><span class="line">产品名称： <span class="variable">$&#123;product.name&#125;</span>&lt;br&gt;</span><br><span class="line">产品价格： <span class="variable">$&#123;product.price&#125;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="客户端跳转"><a href="#客户端跳转" class="headerlink" title="客户端跳转"></a>客户端跳转</h3><p>在前面的例子中，无论是/index跳转到index.jsp 还是/addProduct 跳转到showProduct.jsp，都是服务端跳转。 本例讲解如何进行客户端跳转<br>客户端跳转与服务端跳转的主要区别在于浏览器地址是否改变<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/java/chapter1/p3.png" alt><br>具体实现如下：</p>
<h4 id="修改IndexController-2"><a href="#修改IndexController-2" class="headerlink" title="修改IndexController"></a>修改IndexController</h4><p>首先映射/jump到jump()方法<br>在jump()中编写如下代码<br><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">ModelAndView mav</span> = new ModelAndView(<span class="string">"redirect:/index"</span>);</span><br></pre></td></tr></table></figure></p>
<p>redirect:/index<br>即表示客户端跳转的意思<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> controller;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/index"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handleRequest</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ModelAndView mav = <span class="keyword">new</span> ModelAndView(<span class="string">"index"</span>);</span><br><span class="line">        mav.addObject(<span class="string">"message"</span>, <span class="string">"Hello Spring MVC"</span>);</span><br><span class="line">        <span class="keyword">return</span> mav;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/jump"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">jump</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ModelAndView mav = <span class="keyword">new</span> ModelAndView(<span class="string">"redirect:/index"</span>);</span><br><span class="line">        <span class="keyword">return</span> mav;</span><br><span class="line">    &#125;   </span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过jump访问页面后，可以发现页面跳转到了<a href="http://localhost:8080/springmvc/index" target="_blank" rel="noopener">http://localhost:8080/springmvc/index</a></p>
<h3 id="Session的使用"><a href="#Session的使用" class="headerlink" title="Session的使用"></a>Session的使用</h3><p>Session在用户登录，一些特殊场合在页面间传递数据的时候会经常用到<br>下面实现一个不停刷新session中记录的访问次数的例子<br>具体实现步骤如下：</p>
<h4 id="修改IndexController-3"><a href="#修改IndexController-3" class="headerlink" title="修改IndexController"></a>修改IndexController</h4><p>映射 /check 到方法check()<br>为方法check()提供参数HttpSession session，这样就可以在方法体中使用session了<br>接下来的逻辑就是每次访问为session中的count+1.<br>最后跳转到check.jsp页面<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> controller;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpSession;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/index"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handleRequest</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ModelAndView mav = <span class="keyword">new</span> ModelAndView(<span class="string">"index"</span>);</span><br><span class="line">        mav.addObject(<span class="string">"message"</span>, <span class="string">"Hello Spring MVC"</span>);</span><br><span class="line">        <span class="keyword">return</span> mav;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/jump"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">jump</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ModelAndView mav = <span class="keyword">new</span> ModelAndView(<span class="string">"redirect:/index"</span>);</span><br><span class="line">        <span class="keyword">return</span> mav;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/check"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">check</span><span class="params">(HttpSession session)</span> </span>&#123;</span><br><span class="line">        Integer i = (Integer) session.getAttribute(<span class="string">"count"</span>);</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="keyword">null</span>)</span><br><span class="line">            i = <span class="number">0</span>;</span><br><span class="line">        i++;</span><br><span class="line">        session.setAttribute(<span class="string">"count"</span>, i);</span><br><span class="line">        ModelAndView mav = <span class="keyword">new</span> ModelAndView(<span class="string">"check"</span>);</span><br><span class="line">        <span class="keyword">return</span> mav;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="check-jsp"><a href="#check-jsp" class="headerlink" title="check.jsp"></a>check.jsp</h4><p>通过EL表达式读取session的值，得结果如下：<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;%@<span class="built_in"> page </span><span class="attribute">language</span>=<span class="string">"java"</span> <span class="attribute">contentType</span>=<span class="string">"text/html; charset=UTF-8"</span></span><br><span class="line">    <span class="attribute">pageEncoding</span>=<span class="string">"UTF-8"</span> <span class="attribute">isELIgnored</span>=<span class="string">"false"</span>%&gt;</span><br><span class="line"> </span><br><span class="line">session中记录的访问次数：<span class="variable">$&#123;count&#125;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="中文问题"><a href="#中文问题" class="headerlink" title="中文问题"></a>中文问题</h3><p>使我们的参数请求过程中支持中文<br>在Spring MVC中处理中文问题和Filter处理中文问题是一样的手段，不过简单一点，只需要配置web.xml即可<br>具体步骤如下：</p>
<h4 id="配置web-xml"><a href="#配置web-xml" class="headerlink" title="配置web.xml"></a>配置web.xml</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">version</span>=<span class="string">"2.4"</span> <span class="attr">xmlns</span>=<span class="string">"http://java.sun.com/xml/ns/j2ee"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://java.sun.com/xml/ns/j2ee</span></span></span><br><span class="line"><span class="tag"><span class="string">http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">            org.springframework.web.servlet.DispatcherServlet</span><br><span class="line">        <span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span>     </span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="修改addProduct-jsp"><a href="#修改addProduct-jsp" class="headerlink" title="修改addProduct.jsp"></a>修改addProduct.jsp</h4><p>为form 设置method=”post”<br><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">"java"</span> contentType=<span class="string">"text/html; charset=UTF-8"</span></span><br><span class="line">    pageEncoding=<span class="string">"UTF-8"</span> import=<span class="string">"java.util.*"</span> isELIgnored=<span class="string">"false"</span>%&gt;</span><br><span class="line"> </span><br><span class="line">&lt;<span class="keyword">form</span> action=<span class="string">"/addProduct"</span> method=<span class="string">"post"</span>&gt;</span><br><span class="line"> </span><br><span class="line">    产品名称 ：&lt;<span class="keyword">input</span> <span class="keyword">type</span>=<span class="string">"text"</span> name=<span class="string">"name"</span> value=<span class="string">""</span>&gt;&lt;<span class="keyword">br</span> /&gt;</span><br><span class="line">    产品价格： &lt;<span class="keyword">input</span> <span class="keyword">type</span>=<span class="string">"text"</span> name=<span class="string">"price"</span> value=<span class="string">""</span>&gt;&lt;<span class="keyword">br</span> /&gt;</span><br><span class="line"> </span><br><span class="line">    &lt;<span class="keyword">input</span> <span class="keyword">type</span>=<span class="string">"submit"</span> value=<span class="string">"增加商品"</span>&gt;</span><br><span class="line">&lt;/<span class="keyword">form</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>注： SpringMVC会自动检测类发生的变化，但是web.xml做的改动还是必须重启tomcat才可以看到效果</p>
<h3 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h3><p>最终实现一个通过springmvc上传图片，并显示的效果<br>具体步骤如下：</p>
<h4 id="配置web-xml允许访问-jpg"><a href="#配置web-xml允许访问-jpg" class="headerlink" title="配置web.xml允许访问*.jpg"></a>配置web.xml允许访问*.jpg</h4><p>在web.xml中新增加一段<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>default<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.jpg<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>表示允许访问*.jpg。</p>
<p>为什么要加这一段呢？ 因为配置springmvc的servlet的时候，使用的路径是”/“，导致静态资源在默认情况下不能访问，所以要加上这一段，允许访问jpg。 并且必须加在springmvc的servlet之前</p>
<p>如果你配置spring-mvc使用的路径是/*.do，就不会有这个问题了。<br>注： 这里仅仅是允许访问jpg,如果你要显示png,gif那么需要额外进行配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">version</span>=<span class="string">"2.4"</span> <span class="attr">xmlns</span>=<span class="string">"http://java.sun.com/xml/ns/j2ee"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://java.sun.com/xml/ns/j2ee</span></span></span><br><span class="line"><span class="tag"><span class="string">http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd"</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>default<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.jpg<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">     </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">            org.springframework.web.servlet.DispatcherServlet</span><br><span class="line">        <span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span>     </span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="配置springmvc-servlet-xml"><a href="#配置springmvc-servlet-xml" class="headerlink" title="配置springmvc-servlet.xml"></a>配置springmvc-servlet.xml</h4><p>新增加一段配置<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;bean <span class="attribute">id</span>=<span class="string">"multipartResolver"</span> <span class="attribute">class</span>=<span class="string">"org.springframework.web.multipart.commons.CommonsMultipartResolver"</span>/&gt;</span><br></pre></td></tr></table></figure></p>
<p>开放对上传功能的支持。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/context         </span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/context/spring-context-3.0.xsd"</span>&gt;</span></span><br><span class="line">     </span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"controller"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"irViewResolver"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/page/"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".jsp"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"multipartResolver"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.multipart.commons.CommonsMultipartResolver"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="upload-jsp-上传页面"><a href="#upload-jsp-上传页面" class="headerlink" title="upload.jsp 上传页面"></a>upload.jsp 上传页面</h4><p>上传页面，需要注意的是form 的两个属性必须提供<br>method=”post” 和 enctype=”multipart/form-data” 缺一不可<br>上传组件 增加一个属性 accept=”image/*” 表示只能选择图片进行上传<br>留意<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;input <span class="attribute">type</span>=<span class="string">"file"</span> <span class="attribute">name</span>=<span class="string">"image"</span> <span class="attribute">accept</span>=<span class="string">"image/*"</span> /&gt;</span><br></pre></td></tr></table></figure></p>
<p>这个image，后面会用到这个image,注意uploadImage的路径是当前路径。<br><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">"java"</span> contentType=<span class="string">"text/html; charset=UTF-8"</span></span><br><span class="line">    pageEncoding=<span class="string">"UTF-8"</span> import=<span class="string">"java.util.*"</span> isELIgnored=<span class="string">"false"</span>%&gt;</span><br><span class="line">  </span><br><span class="line">&lt;<span class="keyword">form</span> action=<span class="string">"./uploadImage"</span> method=<span class="string">"post"</span> enctype=<span class="string">"multipart/form-data"</span>&gt;</span><br><span class="line">  选择图片:&lt;<span class="keyword">input</span> <span class="keyword">type</span>=<span class="string">"file"</span> name=<span class="string">"image"</span> accept=<span class="string">"image/*"</span> /&gt; &lt;<span class="keyword">br</span>&gt; </span><br><span class="line">  &lt;<span class="keyword">input</span> <span class="keyword">type</span>=<span class="string">"submit"</span> value=<span class="string">"上传"</span>&gt;</span><br><span class="line">&lt;/<span class="keyword">form</span>&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="准备UploadedImageFile"><a href="#准备UploadedImageFile" class="headerlink" title="准备UploadedImageFile"></a>准备UploadedImageFile</h4><p>在UploadedImageFile中封装MultipartFile类型的字段 image ，用于接受页面的注入</p>
<p>这里的字段 image必须和上传页面upload.jsp中的image<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;input <span class="attribute">type</span>=<span class="string">"file"</span> <span class="attribute">name</span>=<span class="string">"image"</span> <span class="attribute">accept</span>=<span class="string">"image/*"</span> /&gt;</span><br></pre></td></tr></table></figure></p>
<p>保持一致</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">package pojo;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.springframework.web.multipart.MultipartFile;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UploadedImageFile</span> &#123;</span></span><br><span class="line">    MultipartFile <span class="built_in">image</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> MultipartFile <span class="title">getImage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">image</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setImage</span><span class="params">(MultipartFile <span class="built_in">image</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="built_in">image</span> = <span class="built_in">image</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="UploadController-上传控制器"><a href="#UploadController-上传控制器" class="headerlink" title="UploadController 上传控制器"></a>UploadController 上传控制器</h4><p>新建类UploadController 作为上传控制器<br>准备方法upload 映射上传路径/uploadImage</p>
<ol>
<li>方法的第二个参数UploadedImageFile 中已经注入好了 image</li>
<li>通过 RandomStringUtils.randomAlphanumeric(10);获取一个随机文件名。 因为用户可能上传相同文件名的文件，为了不覆盖原来的文件，通过随机文件名的办法来规避</li>
<li>根据request.getServletContext().getRealPath 获取到web目录下的image目录，用于存放上传后的文件。</li>
<li>调用file.getImage().transferTo(newFile); 复制文件</li>
<li>把生成的随机文件名提交给视图，用于后续的显示<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> controller;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang.xwork.RandomStringUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> pojo.UploadedImageFile;</span><br><span class="line"> </span><br><span class="line">@Controller</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UploadController</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    @RequestMapping(<span class="string">"/uploadImage"</span>)</span><br><span class="line">    <span class="keyword">public</span> ModelAndView upload(HttpServletRequest request, UploadedImageFile file)</span><br><span class="line">            throws IllegalStateException, IOException &#123;</span><br><span class="line">        <span class="keyword">String</span> name = RandomStringUtils.randomAlphanumeric(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">String</span> <span class="keyword">new</span><span class="type">FileName</span> = name + <span class="string">".jpg"</span>;</span><br><span class="line">        File <span class="keyword">new</span><span class="type">File</span> = <span class="keyword">new</span> <span class="type">File</span>(request.getServletContext().getRealPath(<span class="string">"/image"</span>), <span class="keyword">new</span><span class="type">FileName</span>);</span><br><span class="line">        <span class="keyword">new</span><span class="type">File</span>.getParentFile().mkdirs();</span><br><span class="line">        file.getImage().transferTo(<span class="keyword">new</span><span class="type">File</span>);</span><br><span class="line"> </span><br><span class="line">        ModelAndView mav = <span class="keyword">new</span> <span class="type">ModelAndView</span>(<span class="string">"showUploadedFile"</span>);</span><br><span class="line">        mav.addObject(<span class="string">"imageName"</span>, <span class="keyword">new</span><span class="type">FileName</span>);</span><br><span class="line">        <span class="keyword">return</span> mav;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="showImage-jsp-显示图片的页面"><a href="#showImage-jsp-显示图片的页面" class="headerlink" title="showImage.jsp 显示图片的页面"></a>showImage.jsp 显示图片的页面</h4><p>在WEB-INF/page 下新建文件showImage.jsp 显示上传的图片<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;%@<span class="built_in"> page </span><span class="attribute">language</span>=<span class="string">"java"</span> <span class="attribute">contentType</span>=<span class="string">"text/html; charset=UTF-8"</span></span><br><span class="line">    <span class="attribute">pageEncoding</span>=<span class="string">"UTF-8"</span> <span class="attribute">isELIgnored</span>=<span class="string">"false"</span>%&gt;</span><br><span class="line"> </span><br><span class="line">&lt;img <span class="attribute">src</span>=<span class="string">"image/<span class="variable">$&#123;imageName&#125;</span>"</span>/&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h3><p>访问地址之后，看到如图所示的拦截器打印的效果<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/java/chapter1/p4.png" alt><br>具体实现步骤如下：</p>
<h4 id="拦截器类：IndexInterceptor"><a href="#拦截器类：IndexInterceptor" class="headerlink" title="拦截器类：IndexInterceptor"></a>拦截器类：IndexInterceptor</h4><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">package interceptor;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.handler.HandlerInterceptorAdapter;</span><br><span class="line"> </span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">IndexInterceptor</span> <span class="keyword">extends</span> <span class="title">HandlerInterceptorAdapter</span> </span>&#123;  </span><br><span class="line"> </span><br><span class="line">     <span class="comment"><span class="markdown">/**  </span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>在业务处理器处理请求之前被调用  </span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>如果返回false  </span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     *     </span>从当前的拦截器往回执行所有拦截器的afterCompletion(),再退出拦截器链 </span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>如果返回true  </span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     *    </span>执行下一个拦截器,直到所有的拦截器都执行完毕  </span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     *    </span>再执行被拦截的Controller  </span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     *    </span>然后进入拦截器链,  </span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     *    </span>从最后一个拦截器往回执行所有的postHandle()  </span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     *    </span>接着再从最后一个拦截器往回执行所有的afterCompletion()  </span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">     */</span></span></span>   </span><br><span class="line">    public boolean preHandle(HttpServletRequest request,    </span><br><span class="line">            HttpServletResponse response, <span class="built_in">Object</span> handler) throws Exception &#123;</span><br><span class="line">         </span><br><span class="line">        System.out.println(<span class="string">"preHandle(), 在访问Controller之前被调用"</span>);  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">         </span><br><span class="line">    &#125;  </span><br><span class="line"> </span><br><span class="line">    <span class="comment"><span class="markdown">/** </span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>在业务处理器处理请求执行完成后,生成视图之前执行的动作    </span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>可在modelAndView中加入数据，比如当前时间 </span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">     */</span></span></span> </span><br><span class="line">     </span><br><span class="line">    public <span class="keyword">void</span> postHandle(HttpServletRequest request,    </span><br><span class="line">            HttpServletResponse response, <span class="built_in">Object</span> handler,    </span><br><span class="line">            ModelAndView modelAndView) throws Exception &#123;  </span><br><span class="line">        System.out.println(<span class="string">"postHandle(), 在访问Controller之后，访问视图之前被调用,这里可以注入一个时间到modelAndView中，用于后续视图显示"</span>);</span><br><span class="line">        modelAndView.addObject(<span class="string">"date"</span>,<span class="string">"由拦截器生成的时间:"</span> + <span class="keyword">new</span> Date());</span><br><span class="line">    &#125;  </span><br><span class="line"> </span><br><span class="line">    <span class="comment"><span class="markdown">/**  </span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>在DispatcherServlet完全处理完请求后被调用,可用于清理资源等   </span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     *   </span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>当有拦截器抛出异常时,会从当前拦截器往回执行所有的拦截器的afterCompletion()  </span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">     */</span></span></span></span><br><span class="line">     </span><br><span class="line">    public <span class="keyword">void</span> afterCompletion(HttpServletRequest request,    </span><br><span class="line">            HttpServletResponse response, <span class="built_in">Object</span> handler, Exception ex)  </span><br><span class="line">    throws Exception &#123;  </span><br><span class="line">           </span><br><span class="line">        System.out.println(<span class="string">"afterCompletion(), 在访问视图之后被调用"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="配置拦截器"><a href="#配置拦截器" class="headerlink" title="配置拦截器"></a>配置拦截器</h4><p>修改springmvc-servlet.xml以对/index路径进行拦截</p>
<p>如果要拦截其他路径：<br><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">/** 拦截所有</span><br><span class="line"><span class="string">/category/</span>** 拦截<span class="string">/category</span>路径下的所有</span><br></pre></td></tr></table></figure></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/mvc"</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans  </span></span></span><br><span class="line"><span class="tag"><span class="string">     http://www.springframework.org/schema/beans/spring-beans-3.0.xsd  </span></span></span><br><span class="line"><span class="tag"><span class="string">     http://www.springframework.org/schema/context  </span></span></span><br><span class="line"><span class="tag"><span class="string">     http://www.springframework.org/schema/context/spring-context-3.0.xsd  </span></span></span><br><span class="line"><span class="tag"><span class="string">     http://www.springframework.org/schema/mvc  </span></span></span><br><span class="line"><span class="tag"><span class="string">     http://www.springframework.org/schema/mvc/spring-mvc-3.0.xsd"</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"viewResolver"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/page/"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".jsp"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"simpleUrlHandlerMapping"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.handler.SimpleUrlHandlerMapping"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mappings"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"/index"</span>&gt;</span>indexController<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"indexController"</span> <span class="attr">class</span>=<span class="string">"controller.IndexController"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span>    </span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span>    </span><br><span class="line">            <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">"/index"</span>/&gt;</span>  </span><br><span class="line">            <span class="comment">&lt;!-- 定义在mvc:interceptor下面的表示是对特定的请求才进行拦截的 --&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"interceptor.IndexInterceptor"</span>/&gt;</span>      </span><br><span class="line">        <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span>  </span><br><span class="line">        <span class="comment">&lt;!-- 当设置多个拦截器时，先按顺序调用preHandle方法，然后逆序调用每个拦截器的postHandle和afterCompletion方法 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span> </span><br><span class="line">         </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="修改-index-jsp"><a href="#修改-index-jsp" class="headerlink" title="修改 index.jsp"></a>修改 index.jsp</h4><p>打印拦截器放进去的日期<br><figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">%@</span> <span class="attr">page</span> <span class="attr">language</span>=<span class="string">"java"</span> <span class="attr">contentType</span>=<span class="string">"text/html; charset=UTF-8"</span></span></span></span><br><span class="line"><span class="xml">    pageEncoding="UTF-8" isELIgnored="false"%&gt;</span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>$</span><span class="template-variable">&#123;message&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>$</span><span class="template-variable">&#123;date&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="http://how2j.cn/k/springmvc/springmvc-springmvc/615.html" target="_blank" rel="noopener">Spring MVC学习</a></p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>服务器搭建ftp服务</title>
    <url>/blog/2017/06/ubuntu-ftp-server.html</url>
    <content><![CDATA[<p>服务器安装ftp服务器，方便我们上传文件</p>
<h3 id="有问题时完全卸载vsftpd"><a href="#有问题时完全卸载vsftpd" class="headerlink" title="有问题时完全卸载vsftpd"></a>有问题时完全卸载vsftpd</h3><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">sudo apt-<span class="builtin-name">get</span> purge vsftpd</span><br></pre></td></tr></table></figure>
<h3 id="安装vsftpd"><a href="#安装vsftpd" class="headerlink" title="安装vsftpd"></a>安装vsftpd</h3><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">sudo apt-<span class="builtin-name">get</span> install vsftpd</span><br></pre></td></tr></table></figure>
<h3 id="创建ftp用户"><a href="#创建ftp用户" class="headerlink" title="创建ftp用户"></a>创建ftp用户</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">方法一：直接在系统设置添加用户</span><br><span class="line"></span><br><span class="line">方法二：</span><br><span class="line">创建用户目录 sudo <span class="built_in">mkdir</span> /<span class="built_in">home</span>/uftp</span><br><span class="line">创建用户 sudo useradd -d /<span class="built_in">home</span>/uftp -s /bin/bash uftp</span><br><span class="line">修改密码 sudo passwd uftp</span><br></pre></td></tr></table></figure>
<h3 id="配置vsftpd-conf"><a href="#配置vsftpd-conf" class="headerlink" title="配置vsftpd.conf"></a>配置vsftpd.conf</h3><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">sudo gedit <span class="regexp">/etc/</span>vsftpd.conf</span><br></pre></td></tr></table></figure>
<p>编辑vsftpd.conf文件<br><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">userlist_deny</span>=<span class="literal">NO</span></span><br><span class="line"><span class="attr">userlist_enable</span>=<span class="literal">YES</span></span><br><span class="line"><span class="comment">#允许登录的用户</span></span><br><span class="line"><span class="attr">userlist_file</span>=/etc/allowed_users</span><br><span class="line"><span class="attr">seccomp_sandbox</span>=<span class="literal">NO</span></span><br><span class="line"><span class="comment">#默认ftp下载目录</span></span><br><span class="line"><span class="attr">local_root</span>=/home/uftp/</span><br><span class="line"></span><br><span class="line"><span class="attr">local_enable</span>=<span class="literal">YES</span></span><br><span class="line"><span class="comment">#设置文件上传</span></span><br><span class="line"><span class="attr">write_enable</span>=<span class="literal">YES</span></span><br><span class="line"><span class="comment">#使用utf8</span></span><br><span class="line"><span class="attr">utf8_filesystem</span>=<span class="literal">YES</span></span><br></pre></td></tr></table></figure></p>
<h3 id="添加允许登录的用户"><a href="#添加允许登录的用户" class="headerlink" title="添加允许登录的用户"></a>添加允许登录的用户</h3><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">sudo gedit <span class="regexp">/etc/</span>allowed_users</span><br></pre></td></tr></table></figure>
<h3 id="启动停止重启服务"><a href="#启动停止重启服务" class="headerlink" title="启动停止重启服务"></a>启动停止重启服务</h3><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line">sudo <span class="meta-keyword">/etc/</span>init.d/vsftpd start</span><br><span class="line">sudo <span class="meta-keyword">/etc/</span>init.d/vsftpd stop</span><br><span class="line">sudo <span class="meta-keyword">/etc/</span>init.d/vsftpd restart</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>java贪吃蛇实现</title>
    <url>/blog/2017/06/java-snake-game.html</url>
    <content><![CDATA[<h3 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h3><p>1.贪吃蛇的窗体游戏<br>2.可以通过键盘来控制蛇的移动方向<br>3.可以吃东西，实现蛇身增长<br>4.超过边界或者头碰到蛇身会死亡</p>
<h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><ul>
<li>此设计的重点在于对蛇身的处理上，将蛇身视为一个一个小方块组成是一个不错的选择。而对于蛇的移动，可以视为蛇尾的最后一个小方块移动到蛇头的位置（这样做的好处在于，未改变蛇的长度的情况下巧妙的实现了蛇的动态移动）。而对于蛇吃食物，也就是通过算法来判断蛇头是否和食物方块触及，若是则将食物方块添加到蛇身上并将此方块设为新的头部，而该食物方块应remove，并增添下一个随机位置的食物块。</li>
<li>另外就是通过键盘控制蛇移动的方向，这里有四个方向需要考虑，每一个不同的方向的改变其实就是通过设置新头部相对于原蛇头的位置（这里需清楚的是，Swing界面的左上角为坐标原点，水平方向为X轴坐标，垂直方向为Y轴坐标）</li>
</ul>
<h3 id="仍需改进的地方"><a href="#仍需改进的地方" class="headerlink" title="仍需改进的地方"></a>仍需改进的地方</h3><ul>
<li>该游戏未考虑游戏时长，可以加入时间计时器计时，以此来结束游戏。</li>
<li>可以为游戏设置等级难度，其中一种方式就是通过加速蛇移动的速度。实现方式：多线程Timer().schedule的刷新时间减少，线程的执行效率增加。</li>
<li>蛇身可以无障碍的穿越界面边界，并到从相对的边界出来</li>
</ul>
<h3 id="主要知识点"><a href="#主要知识点" class="headerlink" title="主要知识点"></a>主要知识点</h3><ul>
<li>Graphics绘图类的设计</li>
<li>蛇身Block类的定义</li>
<li>JFrame界面的设计</li>
<li>泛型集合LinkedList的使用，定义受限制的Block类</li>
<li>多线程Timer类的运用</li>
<li>Random随机数生成随机颜色块</li>
<li>双缓冲机制防止闪烁</li>
</ul>
<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">package com.zj.tcs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.awt.Color;</span><br><span class="line"><span class="keyword">import</span> java.awt.Graphics;</span><br><span class="line"><span class="keyword">import</span> java.awt.Image;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.KeyAdapter;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.KeyEvent;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.Timer;</span><br><span class="line"><span class="keyword">import</span> java.util.TimerTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.swing.JFrame;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mainfrm</span> <span class="title">extends</span> <span class="title">JFrame</span>&#123;</span></span><br><span class="line">	 <span class="comment">//泛型：集合里所放的数据被限制为Block</span></span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Block&gt; snake = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Timer time;<span class="comment">//定时器</span></span><br><span class="line">    <span class="keyword">int</span> direction=<span class="number">1</span>;</span><br><span class="line">    Block food = null;<span class="comment">//食物</span></span><br><span class="line">    Image offScreenImage;</span><br><span class="line">    Graphics gImage;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> WIDTH=<span class="number">600</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> HEIGHT=<span class="number">500</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Mainfrm</span><span class="params">()</span></span>&#123;</span><br><span class="line">    	initSnakeBody();</span><br><span class="line">        controler();</span><br><span class="line">        <span class="keyword">this</span>.setTitle(<span class="string">"我的超级蛇V1.0"</span>);</span><br><span class="line">        <span class="keyword">this</span>.setSize(<span class="number">600</span>,<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">this</span>.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">        <span class="keyword">this</span>.setLocationRelativeTo(null);</span><br><span class="line">        <span class="keyword">this</span>.setVisible(<span class="literal">true</span>);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        time=<span class="keyword">new</span> Timer();</span><br><span class="line">        time.schedule( <span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="built_in">run</span>() &#123;</span><br><span class="line">                <span class="built_in">move</span>(direction);</span><br><span class="line">                repaint();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>, <span class="number">500</span>);<span class="comment">//每隔1秒执行一次</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">paint</span><span class="params">(Graphics g)</span></span>&#123;<span class="comment">//绘图功能</span></span><br><span class="line">    	<span class="comment">// 在重绘函数中实现双缓冲机制     </span></span><br><span class="line">        offScreenImage = <span class="keyword">this</span>.createImage(WIDTH, HEIGHT);      </span><br><span class="line">        <span class="comment">// 获得截取图片的画布     </span></span><br><span class="line">        gImage = offScreenImage.getGraphics();      </span><br><span class="line">        <span class="comment">// 获取画布的底色并且使用这种颜色填充画布,如果没有填充效果的画，则会出现拖动的效果     </span></span><br><span class="line">        gImage.setColor(gImage.getColor());      </span><br><span class="line">        gImage.fillRect(<span class="number">0</span>, <span class="number">0</span>, WIDTH, HEIGHT); </span><br><span class="line">    	</span><br><span class="line">        super.paint(gImage);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;snake.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            Block b = snake.<span class="built_in">get</span>(i);</span><br><span class="line">            Random r = <span class="keyword">new</span> Random();</span><br><span class="line">            gImage.setColor(b.getColor());<span class="comment">//设置画笔的颜色</span></span><br><span class="line">            gImage.fillRect(b.getX(), b.getY(), <span class="number">20</span>, <span class="number">20</span>);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        drawFood(gImage);<span class="comment">//画食物</span></span><br><span class="line">        die();</span><br><span class="line">        eat();</span><br><span class="line">        g.drawImage(offScreenImage, <span class="number">0</span>, <span class="number">0</span>, null);      </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">die</span><span class="params">()</span></span>&#123;</span><br><span class="line">    	Block head = snake.getFirst();</span><br><span class="line">    	</span><br><span class="line">        <span class="keyword">if</span>((head.getX()<span class="number">-0</span>&lt;<span class="number">0</span>) || (head.getX()-WIDTH)&gt;<span class="number">0</span>||(head.getY()<span class="number">-0</span>)&lt;<span class="number">0</span>||(head.getY()-HEIGHT&gt;<span class="number">0</span>))&#123;</span><br><span class="line">            time.cancel();</span><br><span class="line">        	System.out.<span class="built_in">println</span>(head.getX());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;snake.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        	</span><br><span class="line">        	Block b=snake.<span class="built_in">get</span>(i);</span><br><span class="line">        	<span class="keyword">if</span>(b.equals(head))&#123;</span><br><span class="line">        		<span class="keyword">continue</span>;</span><br><span class="line">        	&#125;</span><br><span class="line">        	<span class="keyword">int</span> bx=b.getX();</span><br><span class="line">        	<span class="keyword">int</span> by=b.getY();</span><br><span class="line">        	</span><br><span class="line">        	<span class="keyword">if</span>(Math.<span class="built_in">abs</span>(head.getX()-bx)&lt;<span class="number">18</span> &amp;&amp; Math.<span class="built_in">abs</span>(head.getY()-by)&lt;<span class="number">18</span>)&#123;</span><br><span class="line">        		time.cancel();</span><br><span class="line">        		System.out.<span class="built_in">println</span>(i+<span class="string">","</span>+head.getX()+<span class="string">","</span>+bx+<span class="string">","</span>+by);</span><br><span class="line">        	&#125;</span><br><span class="line">        	</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initSnakeBody</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">            Block block = <span class="keyword">new</span> Block();</span><br><span class="line">            block.setX(<span class="number">92</span><span class="number">-21</span>*i);</span><br><span class="line">            block.setY(<span class="number">50</span>);</span><br><span class="line">            Random r = <span class="keyword">new</span> Random();</span><br><span class="line">            block.setColor(<span class="keyword">new</span> Color(r.nextInt(<span class="number">255</span>),r.nextInt(<span class="number">255</span>),r.nextInt(<span class="number">255</span>)));</span><br><span class="line">            snake.add(block);</span><br><span class="line">            </span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"head:"</span>+snake.getFirst().getX()+<span class="string">"end:"</span>+snake.getLast().getX());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> direc)</span></span>&#123;</span><br><span class="line">        Block <span class="built_in">end</span> = snake.removeLast();</span><br><span class="line">        Block head = snake.getFirst();</span><br><span class="line">        <span class="keyword">switch</span>(direc)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">end</span>.setX(head.getX() + <span class="number">21</span>);</span><br><span class="line">            <span class="built_in">end</span>.setY(head.getY());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="built_in">end</span>.setX(head.getX());</span><br><span class="line">            <span class="built_in">end</span>.setY(head.getY() + <span class="number">21</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="built_in">end</span>.setX(head.getX() - <span class="number">21</span>);</span><br><span class="line">            <span class="built_in">end</span>.setY(head.getY());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            <span class="built_in">end</span>.setX(head.getX());</span><br><span class="line">            <span class="built_in">end</span>.setY(head.getY() - <span class="number">21</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        snake.addFirst(<span class="built_in">end</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//键盘控制</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">controler</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.addKeyListener(<span class="keyword">new</span> KeyAdapter() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="built_in">keyPressed</span>(KeyEvent e)&#123;<span class="comment">//按下会执行</span></span><br><span class="line">                <span class="keyword">switch</span>(e.getKeyCode())&#123;</span><br><span class="line">                <span class="keyword">case</span> KeyEvent.VK_W:</span><br><span class="line">                    direction = <span class="number">4</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> KeyEvent.VK_A:</span><br><span class="line">                    direction = <span class="number">3</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> KeyEvent.VK_S:</span><br><span class="line">                    direction = <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> KeyEvent.VK_D:</span><br><span class="line">                    direction = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//画食物</span></span><br><span class="line">    <span class="keyword">boolean</span> isNew = <span class="literal">true</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawFood</span><span class="params">(Graphics g)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isNew)&#123;</span><br><span class="line">            isNew = <span class="literal">false</span> ;</span><br><span class="line">            food = <span class="keyword">new</span> Block();</span><br><span class="line">            Random r = <span class="keyword">new</span> Random();</span><br><span class="line">            food.setX(r.nextInt(<span class="number">500</span>)+<span class="number">20</span>);</span><br><span class="line">            food.setY(r.nextInt(<span class="number">400</span>)+<span class="number">20</span>);</span><br><span class="line">            food.setColor(<span class="keyword">new</span> Color(r.nextInt(<span class="number">255</span>),r.nextInt(<span class="number">255</span>),r.nextInt(<span class="number">255</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">        g.setColor(food.getColor());</span><br><span class="line">        g.fillRect(food.getX(), food.getY(), <span class="number">20</span>, <span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//吃食物</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Block head = snake.getFirst();</span><br><span class="line">        <span class="keyword">if</span>(Math.<span class="built_in">abs</span>(head.getX()-food.getX())&lt;<span class="number">20</span> &amp;&amp; Math.<span class="built_in">abs</span>(head.getY()-food.getY())&lt;<span class="number">20</span>)&#123;</span><br><span class="line">            snake.add(food);</span><br><span class="line">            isNew = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每一个方块的定义类<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zj.tcs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.awt.Color;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Block</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">private</span> Color color;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.x = x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getY</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> y;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setY</span><span class="params">(<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.y = y;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Color <span class="title">getColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> color;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColor</span><span class="params">(Color color)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.color = color;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>main方法入口<br><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">package com.zj.tcs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> Mainfrm();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h3><p>可以通过吃食物变长，碰到蛇身或者周边会死亡<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/java/chapter2/p1.gif" alt></p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>ssm框架整合</title>
    <url>/blog/2017/06/ssm-frame-combination.html</url>
    <content><![CDATA[<p>整合使用Spring, SpringMVC, Mybatis三大框架</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol>
<li>首先浏览器上访问路径 /listCategory</li>
<li>tomcat根据web.xml上的配置信息，拦截到了/listCategory，并将其交由DispatcherServlet处理。</li>
<li>DispatcherServlet 根据springMVC的配置，将这次请求交由CategoryController类进行处理，所以需要进行这个类的实例化</li>
<li>在实例化CategoryController的时候，注入CategoryServiceImple</li>
<li>在实例化CategoryServiceImple的时候，又注入CategoryMapper</li>
<li>根据ApplicationContext.xml中的配置信息，讲CategoryMapper和Category.xml关联起来了。</li>
<li>这样拿到了实例化好了的CategoryController,并调用listCategory方法</li>
<li>在listCategory方法中，访问CategoryService,并获取数据，并把数据放在”cs”上，接着服务端跳转到listCategory.jsp去</li>
<li>最后在listCategory.jsp 中显示数据<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/java/chapter1/p6.png" alt></li>
</ol>
<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><h4 id="创建数据库与表"><a href="#创建数据库与表" class="headerlink" title="创建数据库与表"></a>创建数据库与表</h4><h4 id="准备与插入数据"><a href="#准备与插入数据" class="headerlink" title="准备与插入数据"></a>准备与插入数据</h4><h4 id="新建项目与导入jar包"><a href="#新建项目与导入jar包" class="headerlink" title="新建项目与导入jar包"></a>新建项目与导入jar包</h4><h4 id="创建实体类Category"><a href="#创建实体类Category" class="headerlink" title="创建实体类Category"></a>创建实体类Category</h4><h4 id="创建CategoryMapper"><a href="#创建CategoryMapper" class="headerlink" title="创建CategoryMapper"></a>创建CategoryMapper</h4><h4 id="Category-xml"><a href="#Category-xml" class="headerlink" title="Category.xml"></a>Category.xml</h4><p>Category.xml需要和CategoryMapper放在同一个包下面，并且namespace必须写CategoryMapper的完整类名<br><figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span></span><br><span class="line"><span class="xml"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span></span><br><span class="line"><span class="xml">    PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"</span></span><br><span class="line"><span class="xml">    "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.how2java.mapper.CategoryMapper"</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"add"</span> <span class="attr">parameterType</span>=<span class="string">"Category"</span> &gt;</span></span></span><br><span class="line"><span class="xml">            insert into category_ ( name ) values (#</span><span class="template-variable">&#123;name&#125;</span><span class="xml">)    </span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span></span><br><span class="line"><span class="xml">         </span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">"delete"</span> <span class="attr">parameterType</span>=<span class="string">"Category"</span> &gt;</span></span></span><br><span class="line"><span class="xml">            delete from category_ where id= #</span><span class="template-variable">&#123;id&#125;</span><span class="xml">   </span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span></span><br><span class="line"><span class="xml">         </span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"get"</span> <span class="attr">parameterType</span>=<span class="string">"_int"</span> <span class="attr">resultType</span>=<span class="string">"Category"</span>&gt;</span></span></span><br><span class="line"><span class="xml">            select * from   category_  where id= #</span><span class="template-variable">&#123;id&#125;</span><span class="xml">    </span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"update"</span> <span class="attr">parameterType</span>=<span class="string">"Category"</span> &gt;</span></span></span><br><span class="line"><span class="xml">            update category_ set name=#</span><span class="template-variable">&#123;name&#125;</span><span class="xml"> where id=#</span><span class="template-variable">&#123;id&#125;</span><span class="xml">    </span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"list"</span> <span class="attr">resultType</span>=<span class="string">"Category"</span>&gt;</span></span></span><br><span class="line"><span class="xml">            select * from   category_      </span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">select</span>&gt;</span>     </span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<h4 id="CategoryService"><a href="#CategoryService" class="headerlink" title="CategoryService"></a>CategoryService</h4><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">package com.how2java.service;</span><br><span class="line"> </span><br><span class="line">import java.util.List;</span><br><span class="line"> </span><br><span class="line">import com.how2java.pojo.Category;</span><br><span class="line"> </span><br><span class="line">public<span class="built_in"> interface </span>CategoryService &#123;</span><br><span class="line"> </span><br><span class="line">    List&lt;Category&gt; list();</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="CategoryServiceImpl"><a href="#CategoryServiceImpl" class="headerlink" title="CategoryServiceImpl"></a>CategoryServiceImpl</h4><p>CategoryServiceImpl被注解@Service标示为一个Service<br>并且装配了categoryMapper<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.how2java.service.impl;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> com.how2java.mapper.CategoryMapper;</span><br><span class="line"><span class="keyword">import</span> com.how2java.pojo.Category;</span><br><span class="line"><span class="keyword">import</span> com.how2java.service.CategoryService;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CategoryServiceImpl</span>  <span class="keyword">implements</span> <span class="title">CategoryService</span></span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    CategoryMapper categoryMapper;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Category&gt; <span class="title">list</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> categoryMapper.list();</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="CategoryController"><a href="#CategoryController" class="headerlink" title="CategoryController"></a>CategoryController</h4><p>CategoryController被@Controller标示为了控制器<br>自动装配了categoryService<br>通过@RequestMapping映射访问路径/listCategory路径到方法listCategory()。<br>在listCategory()方法中，通过categoryService获取收，然后存放在”cs”这个key上。<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.how2java.controller;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.<span class="keyword">annotation</span>.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.<span class="keyword">annotation</span>.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> com.how2java.pojo.Category;</span><br><span class="line"><span class="keyword">import</span> com.how2java.service.CategoryService;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 告诉spring mvc这是一个控制器类</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(<span class="meta-string">""</span>)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CategoryController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    CategoryService categoryService;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@RequestMapping(<span class="meta-string">"listCategory"</span>)</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView listCategory()&#123;</span><br><span class="line">        ModelAndView mav = new ModelAndView();</span><br><span class="line">        List&lt;Category&gt; cs= categoryService.list();</span><br><span class="line">         </span><br><span class="line">        <span class="comment">// 放入转发参数</span></span><br><span class="line">        mav.addObject(<span class="string">"cs"</span>, cs);</span><br><span class="line">        <span class="comment">// 放入jsp路径</span></span><br><span class="line">        mav.setViewName(<span class="string">"listCategory"</span>);</span><br><span class="line">        <span class="keyword">return</span> mav;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="web-xml"><a href="#web-xml" class="headerlink" title="web.xml"></a>web.xml</h4><p>web.xml有两个作用：</p>
<ol>
<li><p>通过ContextLoaderListener在web app启动的时候，获取contextConfigLocation配置文件的文件名applicationContext.xml，并进行Spring相关初始化工作</p>
</li>
<li><p>有任何访问，都被DispatcherServlet所拦截，这就是Spring MVC那套工作机制了。</p>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns</span>=<span class="string">"http://java.sun.com/xml/ns/javaee"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:web</span>=<span class="string">"http://java.sun.com/xml/ns/javaee"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"</span> <span class="attr">version</span>=<span class="string">"2.5"</span>&gt;</span></span><br><span class="line">     </span><br><span class="line">    <span class="comment">&lt;!-- spring的配置文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line">     </span><br><span class="line">    <span class="comment">&lt;!-- spring mvc核心：分发servlet --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>mvc-dispatcher<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- spring mvc的配置文件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springMVC.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>mvc-dispatcher<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">     </span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="applicationContext-xml"><a href="#applicationContext-xml" class="headerlink" title="applicationContext.xml"></a>applicationContext.xml</h4><p>在src目录下新建applicationContext.xml文件，这是Spring的配置文件，其作用</p>
<ol>
<li>通过注解，将Service的生命周期纳入Spring的管理</li>
<li>配置数据源</li>
<li>扫描存放SQL语句的Category.xml</li>
<li>扫描Mapper，并将其生命周期纳入Spring的管理</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span> <span class="attr">xmlns:jdbc</span>=<span class="string">"http://www.springframework.org/schema/jdbc"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/mvc"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">     http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">     http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">     http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc-3.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">     http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">     http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">     http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd"</span>&gt;</span></span><br><span class="line">     </span><br><span class="line">   <span class="tag">&lt;<span class="name">context:annotation-config</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.how2java.service"</span> /&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DriverManagerDataSource"</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span>&gt;</span>  </span><br><span class="line">          <span class="tag">&lt;<span class="name">value</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">value</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span>&gt;</span>  </span><br><span class="line">          <span class="tag">&lt;<span class="name">value</span>&gt;</span>jdbc:mysql://localhost:3306/how2java?characterEncoding=UTF-8<span class="tag">&lt;/<span class="name">value</span>&gt;</span>  </span><br><span class="line">     </span><br><span class="line">      <span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span>&gt;</span>  </span><br><span class="line">          <span class="tag">&lt;<span class="name">value</span>&gt;</span>root<span class="tag">&lt;/<span class="name">value</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span>&gt;</span>  </span><br><span class="line">          <span class="tag">&lt;<span class="name">value</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">value</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;/<span class="name">property</span>&gt;</span>     </span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">     </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSession"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionFactoryBean"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"typeAliasesPackage"</span> <span class="attr">value</span>=<span class="string">"com.how2java.pojo"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mapperLocations"</span> <span class="attr">value</span>=<span class="string">"classpath:com/how2java/mapper/*.xml"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.mapper.MapperScannerConfigurer"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"basePackage"</span> <span class="attr">value</span>=<span class="string">"com.how2java.mapper"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">     </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="springMVC-xml"><a href="#springMVC-xml" class="headerlink" title="springMVC.xml"></a>springMVC.xml</h4><p>在src目录下新建springMVC.xml</p>
<ol>
<li>扫描Controller,并将其生命周期纳入Spring管理</li>
<li>注解驱动，以使得访问路径与方法的匹配可以通过注解配置</li>
<li>静态页面，如html,css,js,images可以访问</li>
<li>视图定位到/WEB/INF/jsp 这个目录下<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span> <span class="attr">xmlns:jdbc</span>=<span class="string">"http://www.springframework.org/schema/jdbc"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/mvc"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc-3.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.0.xsd </span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd"</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.how2java.controller"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">"annotation"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">expression</span>=<span class="string">"org.springframework.stereotype.Controller"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span> /&gt;</span></span><br><span class="line">     </span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span> /&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- 视图定位 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"viewClass"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">value</span>=<span class="string">"org.springframework.web.servlet.view.JstlView"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/jsp/"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".jsp"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="listCategory-jsp"><a href="#listCategory-jsp" class="headerlink" title="listCategory.jsp"></a>listCategory.jsp</h4><p>在WEB-INF下创建jsp目录，并创建文件listCategory.jsp。<br>在这个jsp文件中，通过forEach标签，遍历CategoryController传递过来的集合数据。</p>
<h4 id="部署运行"><a href="#部署运行" class="headerlink" title="部署运行"></a>部署运行</h4><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="http://how2j.cn/k/ssm/ssm-tutorial/1137.html?tid=77#step4518" target="_blank" rel="noopener">SSM SPRING+SPING MVC + MYBATIS 三大框架整合详细步骤</a></p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven学习</title>
    <url>/blog/2017/06/maven-learn-start.html</url>
    <content><![CDATA[<p>Maven是一种常用的构建和管理任何基于Java项目的工具，其具体目标如下：<br>Maven的主要目标是为了使开发人员在最短的时间内领会项目的所有状态。为了达到这一目标，Maven考虑一下五个方面的内容：<br>1、使得构建过程更加容易，方便编译，打包，发布<br>2、为每个项目提供统一的配置<br>3、提供优质项目信息<br>4、最佳开发实践<br>5、安装和更新第三插件透明化</p>
<h3 id="Maven下载，安装，配置"><a href="#Maven下载，安装，配置" class="headerlink" title="Maven下载，安装，配置"></a>Maven下载，安装，配置</h3><p>具体可参见<br><a href="http://blog.csdn.net/jiuqiyuliang/article/details/45390313" target="_blank" rel="noopener">【项目管理和构建】——Maven下载、安装和配置（二）</a></p>
<h3 id="Maven与Eclipse结合"><a href="#Maven与Eclipse结合" class="headerlink" title="Maven与Eclipse结合"></a>Maven与Eclipse结合</h3><p>具体可参见<br><a href="http://blog.csdn.net/jiuqiyuliang/article/details/46053543" target="_blank" rel="noopener">【项目管理和构建】十分钟教程，eclipse配置maven + 创建maven项目（三）</a></p>
<h3 id="Maven构建项目"><a href="#Maven构建项目" class="headerlink" title="Maven构建项目"></a>Maven构建项目</h3><p>新建一个Maven项目后<br>src.main.java是项目代码文件夹、src.test.java是项目单元测试文件夹、src.main.resource是放置项目资源文件、配置文件文件夹。<br>新建包并创建代码后：<br><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mvn </span>clean compile</span><br></pre></td></tr></table></figure></p>
<p>编译项目，会在targe文件夹里看到相应输出</p>
<h4 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h4><p>单元测试依赖了包，需要修改pom.xml文件<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span>  </span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.liuyan.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>MavenDemo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>然后通过mvn clean test命令执行测试<br>详情可参见：<a href="http://suhuanzheng7784877.iteye.com/blog/1066917" target="_blank" rel="noopener">Maven3实战笔记01环境配置与使用入门</a></p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>PS蒙版学习</title>
    <url>/blog/2017/06/ps-mask-learn.html</url>
    <content><![CDATA[<p>Photoshop中蒙版的作用是抠图和图像合成。Photoshop教材中蒙版的含义是指：用来保护不该被改变的像素，使其不被改变，起到一个遮罩作用的工具。然而我们可以这样形象的理解：Photoshop中的蒙版是一个半透明的塑料板，这个板是红色半透明的，我们透过这层塑料板可以清晰的看见下面遮罩的图像，在红色的遮罩区域中，我们无法对图像做任何编辑，只有在没有红色塑料板遮挡的区域才能进行编辑操作。</p>
<p>Photoshop中有四类蒙版：图层蒙版、矢量蒙版、剪贴蒙版、快速蒙版。其中图层蒙版是使用最多，也是功能最强大的一类蒙版。后面三类蒙版可以完成的效果，同样图层蒙版都能做出来。</p>
<p>图层蒙版的作用主要就是限制显示抠图，柔和图像边缘，合成图像等</p>
<h3 id="图层蒙版"><a href="#图层蒙版" class="headerlink" title="图层蒙版"></a>图层蒙版</h3><p>图层蒙版只用黑白和不同浓度的灰色。用黑白灰来控制图层的不透明度。白色是不透明，黑色是透明，灰色是半透明，越灰则透明度越高。<br>如果你涂抹掉了错误的部分，你可以按X键，调整为白色，在错误的部分涂抹，被擦掉的部分会恢复</p>
<h4 id="蒙版扣图"><a href="#蒙版扣图" class="headerlink" title="蒙版扣图"></a>蒙版扣图</h4><p>ps中蒙板工具可以让我们在不破坏素材的情况下完成对图层中图像的遮盖，而且还可以任意的再次进行修改<br>可以在我们想要抠的图像上面新建一个图层，并设为半透明，这样就可以用黑画笔涂抹，使得背景显现出来。</p>
<h4 id="蒙版图片合成"><a href="#蒙版图片合成" class="headerlink" title="蒙版图片合成"></a>蒙版图片合成</h4><p>素材<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/ps/chapter1/p9.jpg" alt><br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/ps/chapter1/p10.jpg" alt><br>效果如下：<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/ps/chapter1/p11.jpg" alt><br>详细可参见：<a href="http://jingyan.baidu.com/article/afd8f4de4e34a734e286e9ca.html" target="_blank" rel="noopener">用PS蒙版来合成图片（一）</a></p>
]]></content>
      <tags>
        <tag>photoshop</tag>
      </tags>
  </entry>
  <entry>
    <title>标准日本语第三单元</title>
    <url>/blog/2017/06/standard-japanses-third.html</url>
    <content><![CDATA[<h3 id="第九课"><a href="#第九课" class="headerlink" title="第九课"></a>第九课</h3><h4 id="语法解释"><a href="#语法解释" class="headerlink" title="语法解释"></a>语法解释</h4><p>1.名は一类形です<br>日语的形容词分两类，其中，一类形容词是以い结尾的形容词，做谓语时要在后面加です<br>2.一类形做谓语时的否定形式<br>将词尾的い变く再加上ないです或者ありません<br>注意：いいです的否定形式是よくないです或者よくありません<br>3.一类形做谓语时的过去形式<br>将词尾的い变成かつた再加です<br>其过去形式为词尾い变成くなかつたです或者くありませでした<br>注意：いいです的过去形式为よかつたです，过去否定为よくありませんでした<br>4.一类形+名<br>一类形容词可以直接修饰名词<br>5.を–&gt;は<br>当作话题或者对比时，<br>6.あまり<br>与后面的否定形式相呼应，表示程序不高<br>7.程度副词<br>8.名词+が<br>は 加在主语后面 表示后面的动词或形容词是人为或有意识地动作或状态<br>が 加在主语后面 则表示后面的动词是非动物的，或动作或意识是自然形成的</p>
<h4 id="表达及词语讲解"><a href="#表达及词语讲解" class="headerlink" title="表达及词语讲解"></a>表达及词语讲解</h4><p>1.おおい和すくない<br>这两个不同于其他一类形容词，不能单独修饰名词，需要加の<br>2.こどもよう<br>某某专用<br>3.あら<br>表惊讶<br>4.ちようどいい<br>正合适</p>
<h3 id="第十课"><a href="#第十课" class="headerlink" title="第十课"></a>第十课</h3><h4 id="语法解释-1"><a href="#语法解释-1" class="headerlink" title="语法解释"></a>语法解释</h4><p>1.名は二类形です、でした<br>二类形容词是不以い结尾的形容词，做谓语时要在后面加です，过去形式是でした<br>2。名は二类形ではありません、ではありませんでした<br>否定形式与过去否定形式，在口语中では一般说成じや<br>3.名は二类形な名です<br>二类形修改名词时，需要な<br>4.名でした<br>名词做谓语地过去形式是名词+でした，其否定形式为名+ではありませんでした<br>5.どんな+名<br>什么样的？<br>注意：なん表示询问内容和材料两种用法，どんな只用于询问性质<br>6.どうですか<br>询问意见或感想<br>7.でも和そして<br>前者表示转折<br>后者表示并列<br>8.には<br>には是に的强调形式 </p>
<h4 id="表达及词语讲解-1"><a href="#表达及词语讲解-1" class="headerlink" title="表达及词语讲解"></a>表达及词语讲解</h4><p>1.きれいです<br>きれい不是一类形容词，而是二类形容词<br>2.下雨，下雪<br>下雨，下雪这些表示自然现象的动词句，常用名词句表示。<br>3.ところで<br>转移话题<br>4.形容词+の<br>用の取代重复的名词</p>
<h3 id="第十一课"><a href="#第十一课" class="headerlink" title="第十一课"></a>第十一课</h3><h4 id="语法解释-2"><a href="#语法解释-2" class="headerlink" title="语法解释"></a>语法解释</h4><p>1.名1は名2が一类形，二类形です<br>表达情感的形容词可以用上述句型使用，名词1代表情感主体，名词2代表情感对象<br>2.名1は名2がおかります、できます<br>懂，会，擅长之类的有关能力的词也可以用这个句型<br>3.名や名<br>什么呀什么的，用于列举许多项目中的两项<br>4.から和だから<br>から说明原因，理由时使用，位于句尾。通常是在说明原因，理由之后再陈述结论。<br>だから相当于汉语里的所以<br>5.どうしてですか<br>为什么，回答时后面加から</p>
<h4 id="表达及词语讲解-2"><a href="#表达及词语讲解-2" class="headerlink" title="表达及词语讲解"></a>表达及词语讲解</h4><p>1.ぼく<br>男性对关系比较密切的人自称时使用的第一人称代词<br>2.いかがですか<br>是どうですか的礼貌表达方式，对长辈或上级使用<br>3.そうですね<br>除了表示同意对方提议的用法外，还可以用在疑问句后，表示说话人在思考接下来要说的内容。<br>4.まよいます<br>用于难以立即做出选择的场合<br>5.きにいりました<br>表示喜欢，但仅用于第一次见到某事物感到中意</p>
<h3 id="第十二课"><a href="#第十二课" class="headerlink" title="第十二课"></a>第十二课</h3><h4 id="语法解释-3"><a href="#语法解释-3" class="headerlink" title="语法解释"></a>语法解释</h4><p>1.名1は名2形容词よりです<br>比较名1和名2，名1比名2更<br>程度差异较大时用副词ずつと加以强调<br>2.名1より名2のほうが形容词です<br>名2比名1更<br>3.名1は名2ほど一类形くないです、二类形ではありません<br>名词1在程度上不及名词2<br>4.名1の中で名2がいちばん形容词です<br>在某某中最<br>5.名1と名2とどちらが形容词ですか<br>哪个更？<br>6.どの名いつがいちばん形ですか<br>询问三个以上的事物当中哪一个更具有该特性时使用</p>
<h4 id="表达及词语讲解-3"><a href="#表达及词语讲解-3" class="headerlink" title="表达及词语讲解"></a>表达及词语讲解</h4><p>1.さいきん<br>最近<br>2.がいいです<br>除了表示好，也可以表示喜欢<br>3.やつぱり<br>果然<br>4.が<br>不把话说完，用が来结尾</p>
]]></content>
      <tags>
        <tag>外语学习</tag>
      </tags>
  </entry>
  <entry>
    <title>PS抠图学习</title>
    <url>/blog/2017/06/ps-piccut-learn.html</url>
    <content><![CDATA[<p>绝大多数是时候，通道是用来抠像的。抠像，大致分三个情况。</p>
<ul>
<li>1st，从清晰轮廓中抠出；</li>
<li>2nd，复杂轮廓中抠出；</li>
<li>3rd，从半透明中抠出。</li>
</ul>
<p>针对清晰轮廓的抠像方法：上等方法为：用路径+混合剪贴法；中等方法用路径、画笔、调整轮廓灯；下等方法是用选择工具。<br>复杂轮廓：上等方法：通道+混合剪贴法；中等方法是用调整边缘的；下等方法用选择工具。<br>半透明轮廓：上等方法通道+画笔+混合剪贴法；中等调整边缘；下等方法用选择工具。混合剪贴法可去除时间一切杂边。 </p>
<h3 id="调整边缘的使用"><a href="#调整边缘的使用" class="headerlink" title="调整边缘的使用"></a>调整边缘的使用</h3><p>调整边缘是抽出滤镜的升级啊。所有选择工具都有这条命令。<br>1.建立选区之后，才能使用调整边缘命令。<br>2.调整边缘面板，半径是指边缘线的内外半径值。<br>3.建议打开智能半径，以避免让清晰轮廓处出现半透明状态。<br>4.平滑，控制线条。在像素低的时候，可以用羽化。<br>5.减少原片环境光时，可以调低移动边缘命令，叫收边。再勾选净化颜色。<br>6.可以再黑白通道中，看到细节。灰色显示有半透明的地方（本不该有）则生成带通道的图层蒙版，在蒙版中（按住Alt键进入蒙版编辑模式）用画笔（白色）去修改。<br>7.修改后删除蒙版，则保存了透明层，然后锁定透明图层，用黑色画笔刷边缘，则可把毛发刷出来。<br>8.之后，可新建图层，用1px画笔添加头发丝。</p>
<p>效果如下：<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/ps/chapter2/p1.jpg" alt></p>
<h3 id="通道做选区"><a href="#通道做选区" class="headerlink" title="通道做选区"></a>通道做选区</h3><p>通道做选区的步骤：<br>1.挑选通道，要去选一个认为能解决问题的通道，一个是挑黑白关系，挑的是清晰轮廓；一个是挑灰度关系，挑的是半透明关系。<br>2.复制通道，是为了转成选区即alpha通道。<br>3.调节色阶，是为了让黑白或灰度最大化，已达到更准确的选区，也就是让黑更黑，白更白；如果调节半透明的选区，则挑出更多灰度。<br>4.载入选区，有两种方式ctrl+点击，一种是绘制。载入之后，选择图层-通过选区建立图层即拿到了抠像。 </p>
<p>效果如下：<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/ps/chapter2/p1.png" alt><br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/ps/chapter2/p3.jpg" alt></p>
]]></content>
      <tags>
        <tag>photoshop</tag>
      </tags>
  </entry>
  <entry>
    <title>PS学习总结</title>
    <url>/blog/2017/06/ps-learn-summary.html</url>
    <content><![CDATA[<h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><p>常用的快捷键总结<br><figure class="highlight dos"><table><tr><td class="code"><pre><span class="line">复制图层ctr+j</span><br><span class="line">复制当前可见的图层ctr+alt+<span class="built_in">shift</span>+e</span><br><span class="line">合并图层向下合并Ctrl+E，合并可见图层<span class="built_in">Shift</span>+Ctrl+E  </span><br><span class="line">还原/重做前一步操作 【Ctrl】+【Z】 </span><br><span class="line">一步一步向前还原 【Ctrl】+【Alt】+【Z】 </span><br><span class="line">一步一步向后重做 【Ctrl】+【<span class="built_in">Shift</span>】+【Z】 </span><br><span class="line">自由变换 【Ctrl】+【T】 </span><br><span class="line">对当前图层做自由变换，按住Ctr键即可</span><br></pre></td></tr></table></figure></p>
<h3 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h3><p>常用操作总结</p>
<ul>
<li><a href="http://jingyan.baidu.com/album/ab69b270d5ef502ca7189fe1.html?picindex=1" target="_blank" rel="noopener">调整人物肤色</a></li>
<li><a href="http://weibo.com/5265050706/profile?topnav=1&amp;wvr=6&amp;is_all=1" target="_blank" rel="noopener">修改证件照背景颜色与尺寸</a></li>
</ul>
]]></content>
      <tags>
        <tag>photoshop</tag>
      </tags>
  </entry>
  <entry>
    <title>标准日本语第四单元</title>
    <url>/blog/2017/06/standard-japanese-four.html</url>
    <content><![CDATA[<h3 id="第十三课"><a href="#第十三课" class="headerlink" title="第十三课"></a>第十三课</h3><h4 id="语法解释"><a href="#语法解释" class="headerlink" title="语法解释"></a>语法解释</h4><p>1.数词+动<br>数词用在动词前面<br>注意，在询问数量时，何必须读作なん<br>2.时间+动词<br>表示时间数量的词语和动词一起使用时，说明动作，状态的持续时间。这时表达时间数据的词语后不能加に<br>3.时间に次数+动<br>表示在一定时间内进行了若干次动作<br>4.动词的ます形<br>动词末尾的ます有时在不同的句型中可以去掉<br>5.场所へ动にいきます、きます<br>表示去哪里做什么，在这里的动词用的是去掉ます的形式<br>6.数量+で<br>用于不称重量而以数个数的方式售物</p>
<h4 id="表达及词语讲解"><a href="#表达及词语讲解" class="headerlink" title="表达及词语讲解"></a>表达及词语讲解</h4><p>1.数词和量词<br>数词与量词组合不同，读音也会有不同<br>2.くらい、ぐらい<br>表示大概的数量<br>3.かかります<br>相当于汉语里的需要，花费<br>4.のみにいきます<br>如果不指明的时候，就是去喝酒<br>5.とりあえず<br>暂且</p>
<h3 id="第十四课"><a href="#第十四课" class="headerlink" title="第十四课"></a>第十四课</h3><h4 id="语法解释-1"><a href="#语法解释-1" class="headerlink" title="语法解释"></a>语法解释</h4><p>1.动词的て形<br>动词因其形态变化方式不同，可以分为三类。<br>(1).动词最后一个音位于い段属于一类动词<br>(2).最后一个音位于え段的，以及位于い段的一小部分动词属于二类动词<br>(3).使用します结尾的动词属于三类动词<br>三类动词的て形各不相同，有许多变化<br>2.动て动<br>表示相继发生<br>3.动てから动<br>表示两个以上的动作相继发生时也可以使用，但在一个句子中，只能使用一次。<br>4.动てください<br>请求某人做某事<br>5.场所を动<br>经过或者离开某一场所时，使用</p>
<h4 id="表达及词语讲解-1"><a href="#表达及词语讲解-1" class="headerlink" title="表达及词语讲解"></a>表达及词语讲解</h4><p>1.します<br>します有接汉字词或者外来词可以构成新的三类动词<br>2.なかなか<br>后接肯定表达时，表示上乘<br>3.てくださいませんか<br>表示请求的礼貌说法<br>4.もう<br>还有马上，就要的意思<br>5.そうしてください<br>好的，做什么</p>
<h3 id="第十五课"><a href="#第十五课" class="headerlink" title="第十五课"></a>第十五课</h3><h4 id="语法解释-2"><a href="#语法解释-2" class="headerlink" title="语法解释"></a>语法解释</h4><p>1.动ています<br>表示动作或变化正在进行时，使用动词て形<br>2.动てもいいです<br>可以做什么吗？<br>3.动てはいけません<br>表示禁止<br>4.名（附着点）に动<br>表示人或物体的附着点，比如人或物体停留在交通工具或椅子上等的时候。<br>注意这种情况绝对不能用を<br>5.目的地に动<br>表示目的地的助词除了用へ还可以用に<br>只有当用于典型的移动动词的目的地时，两者可以通用</p>
<h4 id="表达及词语讲解-2"><a href="#表达及词语讲解-2" class="headerlink" title="表达及词语讲解"></a>表达及词语讲解</h4><p>1.请求许可时的回答方式<br>(1)肯定的场合<br>根据心情判断<br>根据社会惯例或公共准则<br>(2)否定的场合<br>根据心情拒绝<br>根据法律，规章等拒绝<br>2.ゆつくり<br>好好地，慢慢地<br>3.おだいじに<br>请多保重</p>
]]></content>
      <tags>
        <tag>外语学习</tag>
      </tags>
  </entry>
  <entry>
    <title>PS调色学习</title>
    <url>/blog/2017/06/ps-color-learn.html</url>
    <content><![CDATA[<p>调色方法：一种叫Bridge 全局调色法，一种叫混合排除匹配法。另外还有一种叫做计算匹配法。</p>
<p>校准一张照片的五要素：<br>1.正确黑白场，它决定了色彩平衡的状态：在cameraraw中调节曝光即定义黑白场时，按住alt可以作为参数正常的监视器，黑色的话还没有曝光，红色是马上要爆，黄色是已经有点爆，白色就是曝光过了。建议，调出红色即可了。<br>2.准确的色彩还原：色彩还原时，即定义灰常白平衡，调节色温和色调将中性灰的值调准，或直接一键使用白平衡即可。<br>3.丰富且合理的层次（即有灰度值）：则是通过填充亮光来丰富暗部细节；调节暗部来丰富亮部细节。<br>4.足够的清晰度（相机参数设计里调高锐化值；raw格式里调高清晰度；输出之前做锐化。）<br>5.适当的饱和度。</p>
<h3 id="混合匹配法"><a href="#混合匹配法" class="headerlink" title="混合匹配法"></a>混合匹配法</h3><p>首先使用到的是图层混合模式。匹配，就是合成。做匹配，一般都用图层中的色彩平衡，这个时候建议新建图层做一个“红外线”参考层（道理来自夜视镜中对冷暖的处理），填充红色，混合模式选明度（即对亮度进行处理，这样色彩的温度就体现出来了）（shift+ +或——，就可以调换混合模式选项），因为明度接近于红外线的感觉；<br>2nd，新建调整色彩平衡图层（基于待修的图层），在两个图层中间线上按住alt键，跟下一个图层产生剪贴关系，即是通过调节参数让主体接近。如果还是有差别或不太好，还可以新建可选颜色图层，依然要编组。混合匹配法，则可对任何混合模式下出现怪异的时候进行色彩平衡或可选颜色的调节。当然，是基于红色图层。<br>注意：图层组上依然可以加蒙版，这样就可以解决给一个图层加上两个蒙版的问题<br>例子，油画效果合成<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/ps/chapter2/p4.jpg" alt></p>
]]></content>
      <tags>
        <tag>photoshop</tag>
      </tags>
  </entry>
  <entry>
    <title>读《高家村》</title>
    <url>/blog/2017/06/read-gao-village.html</url>
    <content><![CDATA[<blockquote>
<p>高家村人大部分是文盲或半文盲，但他們卻不是如一些馬克思主義者和中國的精英知識分子希望我們相信的那樣，是非常落後或封建反動的群氓，是社會主義歷史發展的障礙——“一袋袋的土豆”。他們也並不像中國那些高高在上的學術精英們所說的那樣，是死硬的保守主義者，盡管傳統的重擔確實仍然重壓在他們的身上。他們也不像城裏那些受過良好教育的人那樣，曾對社會主義中國抱著浪漫的想像。他們並不是狂熱的毛澤東主義者。雖然常常受到當地官員的欺侮和監管，這些村民還是理性而講求實際的。</p>
</blockquote>
<p>&emsp;&emsp;高家村是位于江西省鄱阳县银宝湖乡的一个小乡村，作者恰好是我的老乡，所以读起来分外熟悉，作者的所见所闻与我平时的耳闻目睹也大致相同，在本书中作者对高家村的历史背景、水土资源和农村政治、人口和政治、农村生活状况、农村医疗卫生、农村教育、文化风俗等等给出了极为生动、具体、丰富的描述，让我这个鄱阳人受益匪浅，读完才发现自己其实并不了解自己的家乡，或者说不够了解。</p>
<p>&emsp;&emsp;这本书在当年倒也引起过一段争论，因为本书读起来有些像为文革翻案的意思，但作者从自己的亲身经历出发，讲述了文革期间农村教育与医疗卫生的进步，还是相当有说服力的。比如通过在文革期间建立赤脚老师与赤脚医生制度，以极低的成本普及了基础教育与基础医疗，或许用一个例子来说明更加有说服力，作者的母亲共生了七八个孩子，每当孩子病了，她就去庙里求菩萨保佑她的孩子。当她发现高家村附近的那座庙里的菩萨不灵验时，母亲就会靠她的小脚走上几十公里，到一个据说很灵验的庙里去祈祷，但她每次都失望，她的孩子还是陆续死去，于是母亲再也不信佛了。在文革期间，赤脚医生制度成功的大幅降低了农村的新生儿死亡率，并有效的消灭了如血吸虫等传染疾病，提高了高家村人的平均寿命，减少了人们的痛苦。</p>
<center><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/blog/p3.jpg"></center>

<p>&emsp;&emsp;在教育方面，文革期间有史以来第一次在高家村办起了村办小学，使得所有小孩，包括女孩都获得了至少三年教育。文革期间还有一些其它的创举。比如说，第一个大队企业——榨油坊，就是在1973年建立的。1974年又建立了另外一家大队企业。到1976年，青林大队有了七家大队企业。1972年大队开始有了碾米机、面粉机、轧棉机、柴油机，到1976年，大队有10架柴油机、7台碾米机、1台面粉机和2台轧棉机。1973年，青林大队开始采用机械灌溉，到1976年，大队有了12台水泵灌溉稻田。高家村还买了柴油机，来带动水泵灌溉农田。而在此前，所有农田灌溉都是靠传统的水车。在这一时期，还建立了其它许多新的项目，如养鱼场、林场、养猪场和农业实验站。此外还有许多的技术革新，如在早春用塑料膜给稻种催芽等。但所有这些革新和工程项目如果与文革时许多耗费大量劳力的巨大的水利基础工程相比，都算不上什么。1967–1968年，青林大队在没有任何外部和政府的帮助下，独自建立了三座巨大的水坝，即青林大坝、西分大坝和官田大坝。三座大坝加在一起有九公里长，共享土石七百多万立方，全部是村民用铁锹、铁铲挖起来，用扁担和篮子挑上去的。</p>
<p>&emsp;&emsp;总得来说，文革期间，像高家村这些农村地区，不仅农业生产活动没有受到干预，并且在教育、医疗卫生、文化娱乐等方面还取得了显著的进展。农村在教育、医疗和文化方面的改善并没有花政府的钱，而是在文革激进的农村政策的鼓励下，当地村民集体努力的结果。从这些方面来看，文化大革命是一段具有积极作用的革新时期，这些革新举措使农村居民受益良多。而一直以来，文革无论是在官方还是在知识分子中遭到了全面否定，当然这也符合大家的一贯认识，知识精英在文革期间有些受到过严重迫害，有些被常年下放农村或者被剥夺他们认为应有的正常生活方式，他们便把这些个人经历写成了文字。对于共产党执政者和知识分子而言，文革比大跃进更具破坏性。如果要在共产党执政者和知识分子之间在看待毛泽东时代上找到什么共同点，那么，无疑就是毫不留情地谴责文革。</p>
<p>&emsp;&emsp;现如今广受称赞的，自由的，开放的，改革的80年代呢，究竟是如何的，站在知识分子的角度当然如此，高考重新开始，国家开始分配工作，那占据中国大多数人口的农民呢，他们在80年代生活的如何呢？根据官方说法，家庭联产承包责任制提高了农民的积极性与粮食产量，增加了农民收入，但如果积极性有这么厉害，中国农民已经承包两千年了，怎么从来都没有摆脱饥饿的命运呢？如果主观能动性有用，大跃进怎么就失败了呢？在作者看来，在毛泽东时代农民的贫困主要来源与掠农补工的政策与人口的增长，即国家为了积累原始资本，压低农产品的价格，抬高工业品的价格，有意识的掠夺农民，从而快速实现工业化。而在后毛泽东时代，农产品的价格的上升增加了农民的收入，但这也只是暂时的，因为农产品的价格上升对中央产生了严重的经济压力，随后化肥等产品的价格也迅速上升，农民的实际收入又回到了原点。同时在八十年代农村，以提升教育质量为名，取消了很多农村学校，同时赤脚医生制度也被废除，导致教育和健康条件每况愈下,并且苛捐杂税名目繁多,官员贪污腐败，国家机器对基层失控导致黑恶势力猖獗，这些都沉重地压在农民的肩背上使他们喘不过气来。甚至可以说，在黄金80年代，农民的生活比起文革时发生了一定的倒退。</p>
<p>&emsp;&emsp;作者对大跃进的思考也有一定独到之处，大跃进期间粮食产量下降的原因仍然是一个有争议的问题。中国官方和学者提供了几种解释。其中一种解释是，从1959年到1961年，全中国经受了连续三年的自然灾害。然而，连中国人自己都不认为自然灾害是导致灾荒的主要原因。比方说，刘少奇就曾说过，这只是“三分天灾”。经常提到的另一个原因是，在中国建设的最关键时期，苏联向中国撤回了技术和资金的支持。苏联在那时突然撤回对中国的资助确实削弱了中国的经济，然而，如果说这对中国的粮食生产有着直接的影响，并由此造成大饥荒，也有点牵强。还有一些理由也被提到，但它们仅仅是基于猜测。比如说，大锅饭造成了粮食浪费；粮食腐烂在地里无人收割（因为人人都被叫去炼钢）；掘地三尺的“深耕法”浪费了时间和精力。这些情况可能都有，但都仅是个别现象，且持续的时间不长。对于农民而言，甚至包括地方上的基层官员在内，谁会傻到自己一边挨饿，一边却让粮食烂在地里呢？另外还有一些说法，如所有地方政府都纷纷吹嘘各自的粮食产量猛增，中央政府于是就从农民手中征收更多的粮食。这也很难让人相信。如果说政府从农民手中征收了大量的粮食，那么就存在这样的问题：这些粮食用到哪里了？为什么全国到处都是粮食短缺？为什么中国政府1961年还得从国外进口40亿公斤的粮食，1962年进口得更多？现在找不到这样的数据来说明青林地区上交给国家的粮食有多少，但作者问过一些村民，他们都否认当年规定要上交更多的粮食给国家。作者看来，减产的主要原因是，村民在同一时间内突然面对这么多政治的、经济的、社会的、技术的根本性变革，比如工业布局的分散和地方工业的扩张，工业人口迅速增长，从合作社到人民公社的经济体制上的变化等，确实还没有准备好。因而缺乏有效的管理，就会干扰到生产行为。这种情况在全国都是一样的。他们本应像后来的1973年那样，获得国家的帮助。但国家没有救济他们，因为那时全国到处都粮食短缺，再加上工业人口的迅速增长，情况就变得更为严峻。无论粮食供应多么紧张，政府都想确保城市有定期供应，因为城市如发生饥荒，会更加触目惊心，会更加威胁到国家的稳定。所有这一切最终就导致农村居民孤苦无援，只能忍饥挨饿。</p>
<p>&emsp;&emsp;事实上，除了1949年共产主义革命带来的医疗和教育方面的改善外，高家村的发展在90年代以前一直都在原地打转。通过精耕细作而增加的收入一部分被国家的歧视性价格制度剥夺掉了，一部分又被快速增长的人口抵消掉。80年代末期中国的工业发展给村民提供了外出打工的机会，高家村才有可能历史上第一次打破这种原地止步的发展，高家村的村民才终于摆脱了饥饿的命运。村民外出打工带来的后果，有些不是很直接，但影响却很深远。尽管20世纪发生了重大的政治变革，包括1949年共产党的暴力革命，但在中国的农村地区，传统的东西依然根深蒂固。比如，子女必须服从父母，妻子要听丈夫的。然而，自80年代以来，家庭收入的主要来源不再是父母，而是外出打工的子女。共产革命没有做到的很多事，比如饥饿，比如贫穷，比如宗族关系，最后却以这样一种方式解决了。虽然这种方式很显然，是外出打工人员的血与汗换来的，尽管按照“西方”的标准，这些人工作和生活的条件是极其恐怖的，但如果让他们有机会选择的话，他们都不会回到高家村。原因有很多，但答案令人难受，那就是现如今严酷辛苦的打工生活，比起原来的已经好多了。大跃进时，曾有村民问共产主义的生活究竟是怎样的，高家村民对于共产主义有着怎样的欺许呢？就用来结尾吧：</p>
<blockquote>
<p>村民们被迫做这做那，都不知道发生什么事情。可村里的那些积极分子却精力充沛地忙于开会和传达上级领导的指示。一切事情都发生得如此之快，包括积极分子在内没有一个人能够说清楚，到底发生了什么事情，也预测不了将来会发生什么事。村里最大的领导——高常银，不停地重复他在县城开会时听到的消息，说共产主义很快就会在中国实现，人人都要过天堂般的生活了。当别人问高常银什么是共产主义时，他的回答在过去好几年后，还一直是村里人的笑料。他说，到共产主义时，人人都能住进楼上楼下有电灯和电话的几层高的外国式洋房。我仍然记得他说的几句话：“楼上楼下，电灯电话。”中国人总认为几层高的外国洋房一定既舒适又现代。对于供不起煤油灯的村民来说，电灯很显然是人间天堂般美好生活的象征。</p>
</blockquote>
]]></content>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>SVN使用总结</title>
    <url>/blog/2017/07/svn-learn-usage.html</url>
    <content><![CDATA[<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>1.安装VisualSVN Server<br>注意端口与SVN的位数<br>2.安装SVN客户端</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="创建资源库"><a href="#创建资源库" class="headerlink" title="创建资源库"></a>创建资源库</h4><p>1.在VisualSVN Sever中创建仓库与用户并为用户划定权限<br>创建完成资源库，记录资源库的URL地址，稍后会使用改地址连接资源库</p>
<h4 id="如何管理代码"><a href="#如何管理代码" class="headerlink" title="如何管理代码"></a>如何管理代码</h4><p>首先在想要下载代码的位置，右键单击SVN Checkout<br>填写资源库URL,以及本地代码文件夹名称。可以选择全部检出，或者根据特定的版本号检出。<br>用户身份认证后即可同步代码<br>SVN commit上传到仓库<br>SVN update与仓库同步</p>
<p>参考：<a href="http://www.cnblogs.com/xing901022/p/4399382.html" target="_blank" rel="noopener">http://www.cnblogs.com/xing901022/p/4399382.html</a></p>
]]></content>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>读《巨人的陨落》</title>
    <url>/blog/2017/07/read-fall-gaint.html</url>
    <content><![CDATA[<blockquote>
<p>英王乔治五世在伦敦威斯敏斯特教堂加冕那天，比利・威廉姆斯在南威尔士的阿伯罗温下了矿井。</p>
</blockquote>
<p>&emsp;&emsp;首先，《巨人的陨落》是一本很长的的书，以第一次世界大战为背景，在世界大战的硝烟中，每一个迈向死亡的生命都在热烈地生长——威尔士的矿工少年、刚失恋的美国法律系大学生、穷困潦倒的俄国兄弟、富有英俊的英格兰伯爵，以及痴情的德国特工，讲述了五个家族迥然不同又纠葛不断的命运，波澜壮阔的展现了那个似曾相识却有模糊不清的时代–第一次世界大战。</p>
<p>&emsp;&emsp;第一次世界大战为什么会发生呢？以结果而论，这是一场对谁都没好处的战争，无边无际的铁丝网与堑壕，四处弥漫的毒气、永不停歇的重炮轰炸、无尽的步兵冲锋与横扫一切的机枪都是这场战争的黑暗面，这场战争同时也是最后一场旧贵族精神的战争，飞行员互相尊敬，圣诞夜休战都是这场战争中闪光的亮点。然而无论如何，都有成千上万的人葬身其中。1914年到1918年，四年的战争中，边界线的变动微乎其微，战争的主要发起国没有一个完成了其领土诉求，超过850万士兵和150万平民丧生，英国，法国，俄国，德国，每一个都变得残破不堪，负债累累，如果说有一个赢家，那可能只有美国了吧。从结果而论，这是一场愚蠢的战争。</p>
<p>&emsp;&emsp;第一次世界大战，有一个众所周知的戏剧性的开头，萨拉热窝谋杀事件成了一个飞速燃烧的导火索，直接引发了血海滔天的第一次世界大战。在这场大战中，死伤人数多达3000万，整个欧洲变成了一片废墟。那么，仅仅一个皇储被刺就能导致发生一场世界大战吗？历史远远不是这样简单，在偶然与必然之间，命运在无情地降临。可以这样说吧，萨拉热窝谋杀事件不过是在一场必将到来的殊死决斗中的发令枪。事实上，1914年6月28号萨拉热窝事件时，没有人认为这是一个重要的事件:英国正因为爱尔兰问题忙的不可开交,法国则举国上下都在关注一位部长的妻子的桃色杀人事件，沙皇在担心他血友病再次发作的儿子，甚至连奥地利皇帝都对这位叛逆侄子的死表现出了一丝的幸灾乐祸。事实上，一战有个很长时间的潜伏期。1914年之前的若干年，欧洲一直处在战争一触即发的危险之中。从欧洲列强开始争夺海外领地，有了独霸全球的野心，就为这场战争埋下了伏笔。欧洲列强为了殖民地早已争得面红耳赤，大战一直延迟到1914年才爆发，已经算是个奇迹了，第一次世界大战前的欧洲好比一个黑暗森林，每一个玩家都必须遵守黑暗森林的法则，德国经过第二次工业革命的发展，实力逐渐超过了英国，但英国仍握有大量资源和霸权，那么在这种情况下，战争就在所难免了，恩格斯曾经极有预见的在1887年写到：</p>
<blockquote>
<p>对于普鲁士德意志来说，现在除了世界战争以外已经不可能有任何别的战争了！这会是一场具有空前规模和空前剧烈的世界战争。到那时会有800万到1000万的士兵彼此残杀，同时把整个欧洲都吃得干干净净，比任何时候的蝗虫群还要吃得厉害。战争的严重后果将会遍及欧洲大陆，那时到处是饥荒、瘟疫，军队和人民群众因极端困苦而普遍野蛮化；商业、工业和信贷方面的机构将陷于无法收拾的混乱状态，其结局则是普遍的破产。旧的国家及其世代相因的治国才略一齐崩溃，以致王冠成打地滚到街上而无人拾取！绝对无法预料，这一切将怎样了结，谁会成为斗争中的胜利者；只有一个结果是绝对没有疑问的，那就是普遍的衰竭和为工人阶级的最后胜利造成条件。</p>
</blockquote>
<p>事实上，如果我们从结果而论从而嘲笑第一次世界大战是愚蠢的话，那么第二次世界大战的爆发就会带来致命一击。由于害怕战争带来的巨大损失与惨痛后果，英国跟法国实行了所谓的绥靖政策，反而使德国坐大，闪击法国，一举成功，带来了更加惨痛的失败。到最后，无论是好战还是避战，是野心勃勃还是小心退让，欧洲国家好像都避免不了战争的噩运，摆脱不了黑暗森林的命运，一味退让的国家反而会遭受更加严重的失败，真是有趣，到最后结论好像是欧洲没有办法避免战争与衰弱的命运，这大概就是所谓的巨人的陨落吧，历史的规律真是神奇。但神奇的是，在第二次世界大战后，德国与日本都实现了快速崛起，可以说在今天两国的经济地位，民众的生活水平并不比任何一个战胜国差，尤其是日本，比起二战之前甚至还好了不少。德国与日本没有通过战争得到的，反而在和平中得到了，当然这并不能说明二战是无意义的，德国与日本的发展，大概得益于全球化贸易体系的建立，也得益于处于冷战前线的地位，时代不同了啊。</p>
<p><center><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/blog/p4.jpg"></center><br>&emsp;&emsp;战争打破了旧世界，而旧世界被炸烂和打碎之后，巨人陨落势必有新的力量崛起。书中着重提到了女权。妇女在战争中的作用，一战前妇女无论是在社会生活中抑或是战争中都只从事一些生产被服、照顾伤员等一些辅助性的劳动。而第一次世界大战中她们肩负起生产重型机械和社会主要生产活动的重任，并且用事实证明了她们完全能够胜任昔日被认为是男人才能从事的工作。艾瑟尔参加下议院选举更把女权推向了参与政治，决定国家命运这种昔日被认为不可能由女性参与的政治活动中来。小说主人公，本是主仆的女勋爵茉黛和来自旷工家庭的女管家艾瑟尔，殊途同归，双姝有分歧亦有合作，最终都成为了为妇女权益而呐喊的旗手和斗士，这大概是因为现在女权观点非常时髦的缘故。</p>
<p>&emsp;&emsp;战争同样促进了民众的觉醒、民主思想的深入人心和贵族阶层、等级制度的土崩瓦解。迂腐、高傲、无知、官僚味浓厚的贵族军官带领年轻的平民阶级士兵走向死亡，许多人甚至都还来不及开枪，就在密集队形的冲锋中死与机枪倾泻出的弹雨下。马恩河，凡尔登就像无妄之灾的笼罩在参战双方或者说多方军队的头上，每天推进几十米的焦灼战局给前线官兵带来的不是和平的期盼，而是在死亡线上挣扎的绝望。而比利采取灵活战术保全了自己的威尔士家乡排，格里高利也毫不犹豫的带领手下的士兵远离自杀式的冲锋。群众的智慧和贵族的愚蠢形成了鲜明的对比。肯·福莱特对民众的智慧、勇敢、团结和觉醒是充满敬佩的褒扬的。总得来说，作者既反对保守党也不是那么支持苏维埃，更多地支持走议会斗争路线的社会主义政党，搁现在应该是桑德斯或者科尔宾的支持者。</p>
<p>&emsp;&emsp;这本书还是颇为畅销的，网上宣传说三个通宵读完，评价也相当高，本书的节奏，情节，悬念安排的都很不错，但是最大的失败在于人物刻画苍白。把书中正面主角们的国籍性别属性拿掉，比如想想格斯和沃尔特的性格有什么区别？你想不出所有主角他们有什么区别嘛，一样的坚强，开明，怜悯，勇敢。他们恋爱，失恋，参军，受伤，结婚，思想却根本没有变化和成长，他们失势，战败，落魄，却从未消沉，从未怀疑过自己，坚定的就像戴着人类苍白面具的外星先知，费劲地跟着指示试图混进每个历史性场合，有些令人失望。不过看这本书的时候，我最大的惊奇其实是在1911年，英国的无产阶级已经可以读书看报，小孩子都能上学，甚至家里还有自来水，还可以组织工会，了解什么是社会主义并参与相关辩论与斗争了，俄国的无产阶级也可以通过勤奋工作积攒去美国的路费，而同时代的中国无产阶级呢？原来就算同样是无产阶级，大家也大不相同啊。</p>
]]></content>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>SSM+easyUI搭建简易的人事管理系统</title>
    <url>/blog/2017/06/ssm-easyUi-manager.html</url>
    <content><![CDATA[<h3 id="系统分析"><a href="#系统分析" class="headerlink" title="系统分析"></a>系统分析</h3><h4 id="系统功能结构"><a href="#系统功能结构" class="headerlink" title="系统功能结构"></a>系统功能结构</h4><p>人事管理系统主要包括如下几个模块：</p>
<ul>
<li>系统管理</li>
<li>部门管理</li>
<li>职位管理</li>
<li>员工管理</li>
<li>公告管理</li>
</ul>
<p><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/java/chapter2/p1.png" alt><br>整个系统包含上述的几个模块，每个模块又包括多个功能：</p>
<p>1.系统管理：添加管理员、删除管理员、修改管理员和查询管理员（全部查询和按用户名模糊查询）<br>2.部门管理：添加部门、删除部门、修改部门和查询部门（全部查询和按部门名称模糊查询）<br>3.职位管理：添加职位、删除职位、修改职位和查询职位（全部查询和按职位名称模糊查询）<br>4.员工管理：添加员工、删除员工、修改员工和查询员工（全部查询和按员工编号、员工姓名、部门、职位和性别模糊查询）<br>5.公告管理：添加公告、删除公告、修改公告和查询公告（全部查询和按公告标题模糊查询）</p>
<h4 id="开发技术"><a href="#开发技术" class="headerlink" title="开发技术"></a>开发技术</h4><ul>
<li>Java EE 架构：SSM（Spring + Spring MVC + MyBatis）框架</li>
<li>表现层技术：JSP</li>
<li>前端框架：easyUI</li>
<li>项目管理工具：Maven</li>
<li>数据库：MySQL</li>
</ul>
<h4 id="系统结构"><a href="#系统结构" class="headerlink" title="系统结构"></a>系统结构</h4><p>本系统采用的是 Java EE 分层结构：<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/java/chapter2/p2.png" alt></p>
<ul>
<li>表现层：JSP 页面</li>
<li>MVC 控制器层：Spring MVC 技术，由一系列控制器组成。</li>
<li>业务逻辑层：Spring 技术，由一系列的业务逻辑对象组成。</li>
<li>DAO 层：MyBatis 框架，由一系列的 DAO 组件组成，这些 DAO 实现了对数据库的创建、查询、更新和删除（CRUD）等原子操作。</li>
<li>Domain Object 层：由一系列的 POJO（Plain Old Java Object，即普通的、传统的Java对象）组成，是一些简单的 Java Bean 类。</li>
<li>数据库：MySQL 数据库，存储持久化数据。</li>
</ul>
<h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>主要用 Maven 搭建项目环境，并添加所需的 jar 包。<br>新建Maven工程，选择packing为war<br>具体过程可见：<a href="https://www.shiyanlou.com/courses/824/labs/2906/document" target="_blank" rel="noopener">https://www.shiyanlou.com/courses/824/labs/2906/document</a><br>pom.xml文件配置如下：<br><figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span></span><br><span class="line"><span class="xml">    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.shiyanlou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hrms<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hrms<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.apache.org<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">jdbc.driver.version</span>&gt;</span>5.1.25<span class="tag">&lt;/<span class="name">jdbc.driver.version</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">mybatis.version</span>&gt;</span>3.3.0<span class="tag">&lt;/<span class="name">mybatis.version</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">mybatis-spring.version</span>&gt;</span>1.2.2<span class="tag">&lt;/<span class="name">mybatis-spring.version</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">spring.version</span>&gt;</span>4.2.0.RELEASE<span class="tag">&lt;/<span class="name">spring.version</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">autoconfig-plugin-version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">autoconfig-plugin-version</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">maven.test.skip</span>&gt;</span>true<span class="tag">&lt;/<span class="name">maven.test.skip</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$</span><span class="template-variable">&#123;spring.version&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml">        <span class="comment">&lt;!-- commons 包依赖 --&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-collections<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-collections<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-lang<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-lang<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml">        <span class="comment">&lt;!-- 数据库包依赖 --&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$</span><span class="template-variable">&#123;mybatis.version&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$</span><span class="template-variable">&#123;mybatis-spring.version&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$</span><span class="template-variable">&#123;jdbc.driver.version&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml">        <span class="comment">&lt;!-- 日志包依赖 --&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml">        <span class="comment">&lt;!-- aspectj 包依赖 --&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjrt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml">        <span class="comment">&lt;!-- Spring 依赖 --&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$</span><span class="template-variable">&#123;spring.version&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$</span><span class="template-variable">&#123;spring.version&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context-support<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$</span><span class="template-variable">&#123;spring.version&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$</span><span class="template-variable">&#123;spring.version&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$</span><span class="template-variable">&#123;spring.version&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$</span><span class="template-variable">&#123;spring.version&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet.jsp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsp-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.sf.json-lib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>json-lib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">classifier</span>&gt;</span>jdk15<span class="tag">&lt;/<span class="name">classifier</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml">        <span class="comment">&lt;!-- ueditor 依赖 --&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-codec<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-codec<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.json<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>json<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>20160810<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baidu<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ueditor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.24<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>注意：由于我们项目中使用到的 ueditor 编辑器的 jar 包不存在远程和本地仓库，项目的 pom.xml 中无法添加依赖，导致无法使用 mvn 打包发布，我们需要手动添加到本地仓库。<br>通过<a href="http://labfile.oss.aliyuncs.com/courses/824/ueditor-1.1.2.jar这里下载，再通过以下命令来安装" target="_blank" rel="noopener">http://labfile.oss.aliyuncs.com/courses/824/ueditor-1.1.2.jar这里下载，再通过以下命令来安装</a><br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">mvn install:install-file <span class="attribute">-Dfile</span>=ueditor-1.1.2.jar <span class="attribute">-DgroupId</span>=com.baidu <span class="attribute">-DartifactId</span>=ueditor <span class="attribute">-Dversion</span>=1.1.2 <span class="attribute">-Dpackaging</span>=jar</span><br></pre></td></tr></table></figure></p>
<p>这样就将 ueditor 的 jar 包手动添加到了本地仓库。</p>
<h3 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h3><p>系统 E-R 图如下<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/java/chapter2/p3.png" alt></p>
<h3 id="持久化实体"><a href="#持久化实体" class="headerlink" title="持久化实体"></a>持久化实体</h3><p>建立表的JavaBean映射</p>
<h3 id="DAO层实现"><a href="#DAO层实现" class="headerlink" title="DAO层实现"></a>DAO层实现</h3><p>首先在项目 hrms 的 Java Resources 目录的 src/main/java 下新建包 com.shiyanlou.dao，作为 DAO 层的包， 并在 src/main/resources 下新建一个 Folder mappers 用来放置 MyBatis 的 mapper.xml 文件。</p>
<h4 id="MyBatis-配置文件"><a href="#MyBatis-配置文件" class="headerlink" title="MyBatis 配置文件"></a>MyBatis 配置文件</h4><p>在目录 src/main/resources 下新建 MyBatis 配置文件 mybatis-config.xml ，在这里主要配置了为 JavaBean 取别名，代码如下：<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Config 3.0//EN"</span> </span></span><br><span class="line"><span class="meta"><span class="meta-string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 为JavaBean 起类别名 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"com.shiyanlou.domain"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>注：在这里，我们没有配置 MyBatis 的运行环境、数据源等，那是因为我们要将这些交给 Spring 进行配置管理。</p>
<h3 id="Service-层实现"><a href="#Service-层实现" class="headerlink" title="Service 层实现"></a>Service 层实现</h3><p>主要利用 Spring 框架实现 Service 层,在项目 hrms 的目录 src/main/java 下新建包 com.shiyanlou.service，作为 Servcie 层接口的包，新建包 com.shiyanlou.service.impl 作为 Servcie 层实现的包。</p>
<h3 id="Spring-与-MyBatis-整合"><a href="#Spring-与-MyBatis-整合" class="headerlink" title="Spring 与 MyBatis 整合"></a>Spring 与 MyBatis 整合</h3><p>整合 Spring 和 MyBatis，并采用 Junit 进行单元测试。</p>
<h4 id="log4j-properties-日志文件"><a href="#log4j-properties-日志文件" class="headerlink" title="log4j.properties 日志文件"></a>log4j.properties 日志文件</h4><p>在目录 src/main/resources 下新建日志文件 log4j.properties ，在里面添加如下内容：<br><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Global logging configuration</span></span><br><span class="line"><span class="attr">log4j.rootLogger</span>=DEBUG, stdout</span><br><span class="line"><span class="comment"># Console output...</span></span><br><span class="line"><span class="attr">log4j.appender.stdout</span>=org.apache.log4j.ConsoleAppender</span><br><span class="line"><span class="attr">log4j.appender.stdout.layout</span>=org.apache.log4j.PatternLayout</span><br><span class="line"><span class="attr">log4j.appender.stdout.layout.ConversionPattern</span>=%<span class="number">5</span>p [%t] - %m%n</span><br></pre></td></tr></table></figure></p>
<h4 id="jdbc-properties-属性文件"><a href="#jdbc-properties-属性文件" class="headerlink" title="jdbc.properties 属性文件"></a>jdbc.properties 属性文件</h4><p>在目录 src/main/resources 下新建 JDBC 属性文件 jdbc.properties ，在里面添加如下内容：<br><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">jdbc.driver</span>=com.mysql.jdbc.Driver</span><br><span class="line"><span class="attr">jdbc.url</span>=jdbc:mysql://localhost:<span class="number">3306</span>/hrms_db</span><br><span class="line"><span class="attr">jdbc.username</span>=root</span><br><span class="line"><span class="attr">jdbc.password</span>=</span><br></pre></td></tr></table></figure></p>
<h4 id="spring-mybatis-xml-配置文件"><a href="#spring-mybatis-xml-配置文件" class="headerlink" title="spring-mybatis.xml 配置文件"></a>spring-mybatis.xml 配置文件</h4><p>在目录 src/main/resources 下新建 spring-mybatis.xml 配置文件，该文件用来完成 Spring 和 MyBatis的整合，主要包括了自动扫描，自动注入，配置数据库等，内容如下：<br><figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span></span><br><span class="line"><span class="xml">    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p"</span></span><br><span class="line"><span class="xml">    xmlns:context="http://www.springframework.org/schema/context" xmlns:tx="http://www.springframework.org/schema/tx"</span></span><br><span class="line"><span class="xml">    xsi:schemaLocation="</span></span><br><span class="line"><span class="xml">          http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="xml">          http://www.springframework.org/schema/beans/spring-beans-4.2.xsd</span></span><br><span class="line"><span class="xml">          http://www.springframework.org/schema/context</span></span><br><span class="line"><span class="xml">          http://www.springframework.org/schema/context/spring-context-4.2.xsd</span></span><br><span class="line"><span class="xml">          http://www.springframework.org/schema/tx</span></span><br><span class="line"><span class="xml">          http://www.springframework.org/schema/tx/spring-tx-4.2.xsd"&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="xml">    <span class="comment">&lt;!-- 自动扫描有 Spring 相关注解的类，并把这些类注册为 bean --&gt;</span> </span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.shiyanlou"</span> /&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"classpath:jdbc.properties"</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="comment">&lt;!-- 配置数据源 --&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span></span></span></span><br><span class="line"><span class="xml">        class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"$</span></span></span><span class="template-variable">&#123;jdbc.driver&#125;</span><span class="xml"><span class="tag"><span class="string">"</span> /&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$</span></span></span><span class="template-variable">&#123;jdbc.url&#125;</span><span class="xml"><span class="tag"><span class="string">"</span> /&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$</span></span></span><span class="template-variable">&#123;jdbc.username&#125;</span><span class="xml"><span class="tag"><span class="string">"</span> /&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$</span></span></span><span class="template-variable">&#123;jdbc.password&#125;</span><span class="xml"><span class="tag"><span class="string">"</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="comment">&lt;!-- MyBatis 的 SqlSession 的工厂，并引用数据源，扫描 MyBatis 的配置文件 --&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSessionFactory"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionFactoryBean"</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mapperLocations"</span> <span class="attr">value</span>=<span class="string">"classpath:/mappers/*.xml"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"configLocation"</span> <span class="attr">value</span>=<span class="string">"classpath:mybatis-config.xml"</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="comment">&lt;!-- MyBatis 自动扫描加载 Sql 映射文件/接口 --&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.mapper.MapperScannerConfigurer"</span></span></span></span><br><span class="line"><span class="xml">        p:basePackage="com.shiyanlou.dao" p:sqlSessionFactoryBeanName="sqlSessionFactory"&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="comment">&lt;!-- JDBC 事务管理器 --&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"txManager"</span></span></span></span><br><span class="line"><span class="xml">        class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="comment">&lt;!-- 启用支持 annotation 注解方式事务管理 --&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">"txManager"</span> /&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<h4 id="Junit-单元测试"><a href="#Junit-单元测试" class="headerlink" title="Junit 单元测试"></a>Junit 单元测试</h4><p>在项目 hrms 的 Java Resources 目录的 src/test/java 下新建包 com.shiyanlou.test，并在该包下新建测试类 SpringMybatisTest，添加如下代码：<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">package com.shiyanlou.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.ContextConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringJUnit4ClassRunner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.shiyanlou.domain.Admin;</span><br><span class="line"><span class="keyword">import</span> com.shiyanlou.service.AdminService;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 配置spring和junit整合，junit启动时加载springIOC容器 spring-test,junit</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line">@<span class="type">RunWith</span>(<span class="type">SpringJUnit4ClassRunner</span><span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">// 告诉<span class="title">junit</span> <span class="title">spring</span> 配置文件</span></span><br><span class="line"><span class="class">@<span class="title">ContextConfiguration</span>(</span>&#123; <span class="string">"classpath:spring-mybatis.xml"</span> &#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringMybatisTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    @<span class="type">Autowired</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">AdminService</span> adminService;</span><br><span class="line"></span><br><span class="line">    @<span class="type">Test</span></span><br><span class="line">    <span class="keyword">public</span> void testLogin() &#123;</span><br><span class="line">        <span class="type">Admin</span> admin = new <span class="type">Admin</span>();</span><br><span class="line">        admin.setUsername(<span class="string">"superadmin"</span>);</span><br><span class="line">        admin.setPassword(<span class="string">"123456"</span>);</span><br><span class="line">        <span class="type">System</span>.out.<span class="built_in">println</span>(adminService.login(admin).<span class="built_in">toString</span>());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Controller-层实现"><a href="#Controller-层实现" class="headerlink" title="Controller 层实现"></a>Controller 层实现</h3><p>主要利用 Spring MVC 框架实现 Controller 层</p>
<h4 id="spring-mvc-xml-配置文件"><a href="#spring-mvc-xml-配置文件" class="headerlink" title="spring-mvc.xml 配置文件"></a>spring-mvc.xml 配置文件</h4><p>在目录 src/main/resources 下新建 Spring MVC 配置文件 spring-mvc.xml，添加如下代码：<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/mvc"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans </span></span></span><br><span class="line"><span class="tag"><span class="string">      http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">      http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">      http://www.springframework.org/schema/context/spring-context-4.2.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">      http://www.springframework.org/schema/mvc</span></span></span><br><span class="line"><span class="tag"><span class="string">     http://www.springframework.org/schema/mvc/spring-mvc-4.2.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 自动扫描该包，Spring MVC 会将包下用 @Controller 注解的类注册为 Spring 的 controller --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.shiyanlou.controller"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 设置默认配置方案 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 静态资源访问 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">location</span>=<span class="string">"/"</span> <span class="attr">mapping</span>=<span class="string">"/**"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 视图解析器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"viewResolver"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".jsp"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"multipartResolver"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">"org.springframework.web.multipart.commons.CommonsMultipartResolver"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxUploadSize"</span> <span class="attr">value</span>=<span class="string">"3500000"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"defaultEncoding"</span> <span class="attr">value</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置拦截器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">"/*"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.shiyanlou.interceptor.LoginInterceptor"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="表现层-JSP-页面实现"><a href="#表现层-JSP-页面实现" class="headerlink" title="表现层 JSP 页面实现"></a>表现层 JSP 页面实现</h3><p>主要利用 easyUI 实现系统的前端页面。</p>
<h4 id="配置-web-xml"><a href="#配置-web-xml" class="headerlink" title="配置 web.xml"></a>配置 web.xml</h4><p>修改项目 hrms 的 src-&gt;main-&gt;webapp-&gt;WEB-INF 目录下的 web.xml 内容如下：<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns</span>=<span class="string">"http://java.sun.com/xml/ns/javaee"</span> <span class="attr">xmlns:web</span>=<span class="string">"http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">id</span>=<span class="string">"WebApp_ID"</span> <span class="attr">version</span>=<span class="string">"3.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>hrms<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置 Spring 核心监听器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 指定 Spring 的配置文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring-mybatis.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 定义 Spring MVC 前端控制器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring-mvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 为 DispatcherServlet 建立映射 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.util.IntrospectorCleanupListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 编码过滤器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>forceEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 设置首页 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>login.jsp<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h3><p>右击 hrms 工程，Run As-&gt;Run on Server，保持默认选项不变，点击 Finish，一会儿即可看到结果。<br>有时会报一些错，可能是因为编译的class没有到web-inf目录下，这里clean一下，再重新启动即可<br>效果如下<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/java/chapter2/p4.png" alt></p>
<p>参考资料：<a href="https://www.shiyanlou.com/courses/824" target="_blank" rel="noopener">SSM + easyUI 搭建简易的人事管理系统</a><br>源代码：<a href="https://github.com/shenzhen2017/hrms" target="_blank" rel="noopener">https://github.com/shenzhen2017/hrms</a></p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Ruby语法学习</title>
    <url>/blog/2017/07/ruby-learn-start.html</url>
    <content><![CDATA[<h3 id="安装Ruby"><a href="#安装Ruby" class="headerlink" title="安装Ruby"></a>安装Ruby</h3><p>直接在官网下载安装即可，记得勾选环境路径。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>1.输入irb进入交互式界面<br>2.运行rb文件</p>
<h4 id="简单语法"><a href="#简单语法" class="headerlink" title="简单语法"></a>简单语法</h4><p>1.puts输出<br>2.数字之间的运算，可以直接运算</p>
<h4 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h4><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">h</span></span></span><br><span class="line">	puts <span class="string">"hello world"</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">if __FILE__==<span class="variable">$0</span></span><br><span class="line">	h</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment">#参考：《Ruby完全自学手册》第三章、第四章</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#常量大写字母开头，变量小写字母开头</span></span><br><span class="line">CHANG_LIANG = <span class="number">1</span></span><br><span class="line">bian_liang = <span class="number">2</span></span><br><span class="line">bian_liang = <span class="string">"2"</span><span class="comment">#弱类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##分支控制</span></span><br><span class="line"><span class="comment">#if</span></span><br><span class="line"><span class="keyword">if</span> <span class="number">2</span> &gt; <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line"><span class="keyword">elsif</span> <span class="number">2</span>&gt;<span class="number">2</span> <span class="keyword">then</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">#if后置</span></span><br><span class="line">puts <span class="string">"if后置"</span> <span class="keyword">if</span> <span class="number">2</span> &gt; <span class="number">1</span></span><br><span class="line"><span class="comment">#unless</span></span><br><span class="line"><span class="keyword">unless</span> <span class="number">2</span> &gt; <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">#case</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>+<span class="number">1</span></span><br><span class="line"><span class="keyword">when</span> <span class="number">2</span> <span class="keyword">then</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line"><span class="keyword">when</span> <span class="number">3</span> <span class="keyword">then</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##循环控制</span></span><br><span class="line"><span class="comment">#while</span></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>&gt;<span class="number">2</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">#until</span></span><br><span class="line"><span class="keyword">until</span> <span class="number">1</span>&lt;<span class="number">2</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">#for</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> (<span class="number">1</span>..<span class="number">3</span>)</span><br><span class="line">   <span class="comment">#</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">#foreach的另一种写法</span></span><br><span class="line">(<span class="number">1</span>..<span class="number">3</span>).each <span class="keyword">do</span> <span class="params">|i|</span></span><br><span class="line">    <span class="comment">#可以用break和next控制，next相当于其他语言的continue</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##面向对象</span></span><br><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">MyModule</span><span class="comment">#定义模块</span></span></span><br><span class="line">    <span class="comment">#定义类</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span><span class="comment">#类名首字母大写</span></span></span><br><span class="line">        <span class="keyword">attr_accessor</span> <span class="symbol">:myAttr</span><span class="comment">#定义实例变量</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">initialize</span></span></span><br><span class="line">            @myAttr2 = <span class="string">"@定义的实例变量"</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        public<span class="comment">#访问控制级别public/protected/private</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">myMethod</span><span class="comment">#定义实例方法</span></span></span><br><span class="line">            puts <span class="string">"在实例方法中输出"</span> + myAttr + @myAttr2</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">#继承</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MySubClass</span> &lt; MyClass</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">#定义模块方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">moduleMethod</span></span></span><br><span class="line">        puts <span class="string">"MyModule的模块方法"</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span><span class="comment">#模块定义的end</span></span><br><span class="line"><span class="comment">#使用</span></span><br><span class="line">myClass = MyModule::MyClass.new<span class="comment">#实例化对象</span></span><br><span class="line">myClass.myAttr = <span class="string">"实例变量的值"</span><span class="comment">#为实例变量赋值</span></span><br><span class="line">myClass.myMethod<span class="comment">#调用实例方法</span></span><br><span class="line"><span class="comment">#动态添加方法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myClass</span>.<span class="title">newMethod</span></span></span><br><span class="line">    puts <span class="string">"动态添加的方法"</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">myClass.newMethod</span><br><span class="line"><span class="comment">#加载另一个文件中声明的模块中的类</span></span><br><span class="line">load <span class="string">'ruby_another_module.rb'</span></span><br><span class="line">anotherClass = AnotherModule::AnotherClass.new<span class="comment">#另一个文件中声明的对象</span></span><br><span class="line">anotherClass.print<span class="comment">#调用其方法</span></span><br><span class="line"><span class="comment">#混入</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UseMixin</span></span></span><br><span class="line">    <span class="keyword">include</span> MyModule</span><br><span class="line">    extend MyModule</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">UseMixin.new.moduleMethod<span class="comment">#include语句的作用，成为类的实例方法</span></span><br><span class="line">UseMixin.moduleMethod<span class="comment">#extend语句的作用，成为类的类方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##代码段</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">blockMethod</span><span class="comment">#调用代码段的方法，其中yield表示运行代码段</span></span></span><br><span class="line">    <span class="keyword">yield</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">blockMethod &#123;puts <span class="string">"匿名代码段"</span>&#125;</span><br><span class="line"><span class="comment">#带参数的代码段</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">blockMethodWithParam</span><span class="params">(arg, &amp;b)</span></span><span class="comment">#定义显式使用代码段的函数</span></span><br><span class="line">    b.call arg</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">block = Proc.new&#123;<span class="params">|x|</span> puts x&#125;<span class="comment">#定义非匿名代码段</span></span><br><span class="line">blockMethodWithParam(<span class="string">"非匿名代码段"</span>, &amp;block)<span class="comment">#使用非匿名代码段</span></span><br><span class="line">blockMethodWithParam(<span class="string">"也可以这样使用"</span>)&#123;<span class="params">|x|</span> puts x&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">##异常处理</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="comment">#正常代码运行的地方</span></span><br><span class="line"><span class="keyword">rescue</span> Error<span class="comment">#相当于其他语言的catch</span></span><br><span class="line">    <span class="comment">#进行一些调整</span></span><br><span class="line">    <span class="keyword">retry</span><span class="comment">#重新尝试执行</span></span><br><span class="line"><span class="keyword">ensure</span></span><br><span class="line">    <span class="comment">#相当于其他语言的finally，无论如何都会运行的地方</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##基本类型</span></span><br><span class="line"><span class="comment">#整数</span></span><br><span class="line">a=<span class="number">123_456</span><span class="comment">#可以加下划线</span></span><br><span class="line">b=0b10101<span class="number">0</span><span class="comment">#二进制</span></span><br><span class="line">c=<span class="number">0123</span><span class="comment">#八进制</span></span><br><span class="line">d=<span class="number">0xaa</span><span class="comment">#十六进制</span></span><br><span class="line">e=<span class="string">?a</span><span class="comment">#ascii码</span></span><br><span class="line">puts d</span><br><span class="line"><span class="comment">#浮点数略</span></span><br><span class="line"><span class="comment">#字符串</span></span><br><span class="line">str = <span class="string">"hello, world"</span></span><br><span class="line">str = <span class="string">%&#123;你好, "world"&#125;</span><span class="comment">#方便含有引号的内容</span></span><br><span class="line">str[<span class="number">0</span>] = <span class="string">"我"</span></span><br><span class="line">puts str</span><br><span class="line"><span class="comment">#符号略</span></span><br><span class="line"><span class="comment">#区间</span></span><br><span class="line">(<span class="number">1</span>..<span class="number">3</span>).each&#123;<span class="params">|a|</span> puts a&#125;</span><br><span class="line"><span class="comment">#数组</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].each&#123;<span class="params">|a|</span> puts a&#125;</span><br><span class="line"><span class="comment">#字典</span></span><br><span class="line">map = &#123;<span class="string">"键甲"</span>=&gt;<span class="string">"键甲的值"</span>, <span class="string">"键乙"</span>=&gt;<span class="string">"键乙的值"</span>&#125;</span><br><span class="line">puts map[<span class="string">"键甲"</span>]</span><br><span class="line"><span class="comment">#正则表达式</span></span><br><span class="line"><span class="string">"ab12cd"</span>.scan(<span class="regexp">/\d/</span>)&#123;<span class="params">|m|</span> puts m&#125;<span class="comment">#正则表达式字面量</span></span><br><span class="line">puts /\d/.match(<span class="string">"ab12cd"</span>)[<span class="number">0</span>]<span class="comment">#match方法</span></span><br></pre></td></tr></table></figure>
<p>参见：<a href="https://wenku.baidu.com/view/2b606dc0aa00b52acfc7cab2?pcf=2#1&amp;qq-pf-to=pcqq.group" target="_blank" rel="noopener">二十分钟 教你Ruby快速入门</a></p>
]]></content>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>比特币与挖矿</title>
    <url>/blog/2017/07/bit-money-talk.html</url>
    <content><![CDATA[<h3 id="比特币是什么"><a href="#比特币是什么" class="headerlink" title="比特币是什么"></a>比特币是什么</h3><p>比特币是一个共识网络，促成了一个全新的支付系统和一种完全数字化的货币。它是第一个去中心化的对等支付网络，由其用户自己掌控而无须中央管理机构或中间人。从用户的角度来看，比特币很像互联网的现金。<br>比特币（Bitcoin，缩写BTC）是一种总量恒定2100万的数字货币，和互联网一样具有去中心化、全球化、匿名性等特性。向地球另一端转账比特币，就像发送电子邮件一样简单，低成本，无任何限制。比特币因此被用于跨境贸易、支付、汇款等领域。</p>
<h3 id="比特币是如何运作的？"><a href="#比特币是如何运作的？" class="headerlink" title="比特币是如何运作的？"></a>比特币是如何运作的？</h3><p>从运行上来看，比特币实际上是一个互联网上的去中心化账本</p>
<h4 id="中心化账本（银行）"><a href="#中心化账本（银行）" class="headerlink" title="中心化账本（银行）"></a>中心化账本（银行）</h4><p>银行是一个中心化账本，账本存储在银行的中心数据库，上面写着：张三的A账号余额3000元，李四的B账号余额2000元……当张三想要通过A账号转账1000元给李四的B账号时：<br>① 张三到银行，向银行提交转账要求。<br>② 银行通过银行卡密码等方式确认张三身份，并检查张三的A账号是否有足够余额。<br>③ 检查通过后，银行增加一条转账记录：A账号向B账号转账1000元，并修改余额：A账号余额=3000-1000=2000元，B账号余额=2000+1000=3000元</p>
<h4 id="去中心化账本"><a href="#去中心化账本" class="headerlink" title="去中心化账本"></a>去中心化账本</h4><p>假设有这样的一个小村庄，大家不是靠银行，而是自己用账本来记录谁有多少钱，每个人的账本上都写着：张三的A账号余额3000元，李四的B账号余额2000元……当张三想要通过A账号转账1000元给李四的B账号时，<br>① 张三大吼一声：大家注意啦，我用A账号给李四的B账号转1000块钱。<br>② 张三附近的村民听了确实是张三的声音，并且检查张三的A账号是否有足够余额。<br>③ 检查通过后，村民往自己的账本上写：A账号向B账号转账1000元，并修改余额：A账号余额=3000-1000=2000元，B账号余额=2000+1000=3000元。<br>④ 张三附近的村民把转账告诉较远村民，一传十十传百，直到所有人都知道这笔转账，以此保证所有人账本的一致性。</p>
<h4 id="去中心化账本（比特币）"><a href="#去中心化账本（比特币）" class="headerlink" title="去中心化账本（比特币）"></a>去中心化账本（比特币）</h4><p>比特币用户在电脑上运行比特币客户端软件，这样的电脑称为一个节点（node）。<br>大量节点电脑互相连接，形成一张像蜘蛛网一样的P2P（点对点）网络。<br>当张三想要通过A账号转账1比特币给李四的B账号时，<br>① 张三向周围节点广播转账交易要求：A账号转账1比特币给B账号，并用A账号的私钥签名。（A账号的私钥可简单理解为A账号的密码，只要知道A账号的私钥就能使用A账号上的比特币）<br>② 张三周围的节点通过A账号的公钥检查交易签名的真伪，并且检查张三的A账号是否有足够余额。<br>③ 检查通过后，节点往自己的账本上写：A账号向B账号转账1比特币元，并修改余额：A账号余额=3比特币-1比特币=2比特币，B账号余额=2比特币+1比特币=3比特币。<br>④ 节点把这个交易广播给周围的节点，一传十十传百，直到所有节点都收到这笔交易。比特币的去中心化公开账本称为区块链。这是比特币运行的一个最简化描述，当然比特币的实际运行远比这复杂</p>
<h4 id="不可复制的比特币"><a href="#不可复制的比特币" class="headerlink" title="不可复制的比特币"></a>不可复制的比特币</h4><p>在现实世界里，你给了别人100元钞票，你自己就没有了。但数字世界里的东西都是可复制的，你复制给了别人一个文件，你还有这个文件。你复制给了别人100元，你还有100元（这称为双花 double-spending）。这导致在数字世界里的货币必须用中心化方式来管理，比如由银行的中心服务器来管理你的钱。<br>但比特币解决了这个问题，你给了别人一个比特币，你就没有这个比特币了，如果你试图再付给别人一个比特币，周围的节点会检查你实际上没有比特币了，并拒绝传播你这笔非法支付。比特币的突破之处在于，第一次在数字世界创造了一种即不可复制，又不是中心化的东西。<br>比特币和电子化的法币是完全不同的东西，比特币是首次出现的，真正的数字货币。网上的法币（支付宝或网银）并不是真正的数字货币，你在网银中的钱，只是现实中钞票的映射，根在现实中，而比特币的根在数字世界中。<br>比特币是个不可逆发明。什么叫不可逆发明呢？就是它没有的时候也没什么，可它一旦出现，这个世界就无法回到没有它的状态。轮子、下水道、抽水马桶、齿轮、发动机、复印机、互联网、移动电话、传感器、社交软件等等等等，都是这种发明，没出现的时候，没有人会觉得这东西这世界少了什么，可它们一旦出现、一旦被发明，人们就开始用起来，一旦有些人开始用起来，这世界就不再可能缺这些东西，甚至人们会感觉没有它们就寸步难行。</p>
<h3 id="比特币挖矿"><a href="#比特币挖矿" class="headerlink" title="比特币挖矿"></a>比特币挖矿</h3><h4 id="什么是比特币挖矿"><a href="#什么是比特币挖矿" class="headerlink" title="什么是比特币挖矿"></a>什么是比特币挖矿</h4><p>如前文中所述，比特币节点互相连接时，会从对方处获取自己没有的交易。但由于比特币长期积累天量的交易，两个节点逐条对照你缺了哪些交易/我缺了哪些交易，是非常困难的事情。为解决这一难题，中本聪发明了区块链（Block chain）这一重要技术。节点借助区块（block）来同步交易，保证了所有节点数据的统一性，并通过竞争区块打包权（也就是挖矿）的方式，保证了区块链的唯一性。</p>
<p>① 区块和区块链<br>一段时间内的交易打成的一个包称为区块，比特币全网平均每10分钟产生一个区块，每一个区块都链接到上一个区块，依次相连形成区块链。</p>
<p><center><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/other/p1.png"></center><br>② 以区块为单位同步交易数据<br>区块从1开始编号，因此节点A连接节点B后，只要检查双方的区块编号高度，就能方便地同步交易数据。例如节点A自己的区块高度是100，发现节点B的区块高度是110，则只要向B请求同步101~110这10个区块即可。</p>
<p>③ 打包区块的奖励<br>为保证有节点打包比特币交易，比特币规则规定：打包交易的节点将获得比特币作为酬劳。A、打包奖励的一部分来自交易创建者支付的交易手续费（每KB交易大小100~1000聪手续费）。B、另一部分来自初始2100万个比特币的分发，最开始奖励是每个区块50比特币，之后每经过21万个区块（约4年时间）奖励将减半一次，直到2140年左右区块奖励不足1聪为止，此时区块奖励总和为2100万比特币，这就是比特币2100万总量的来源（准确地说是 20999999.97690000个）。2140年后打包奖励将只来自于交易创建者支付的交易手续费。</p>
<p>④ 对区块打包权的竞争节点打包交易只需要消耗很低成本的网络和计算资源，打包奖励的存在（目前每个区块的打包奖励25比特币约为4万元），使得有大量节点想打包交易。为保证区块链的唯一性，比特币规则规定：节点使用类似“扔硬币”的方法争夺交易打包权。节点不断地扔硬币，谁首先扔出符合规则的结果，谁就能获得这个区块的交易打包权，以及这个区块的打包奖励。</p>
<p>⑤ 竞争交易打包权的方式“扔硬币”在实现上是计算机做一次哈希（SHA-256）运算，并检查运算结果从第一位开始是否有足够多连续的0（可以简单理解为一次扔256个硬币，然后看从第一个硬币开始是否有足够多的连续硬币正面）。“扔硬币”获胜的唯一诀窍是提高每秒扔硬币的次数，一个每秒能扔100亿次硬币（做100亿次哈希计算）的节点，抢到打包权的概率是每秒扔1亿次硬币节点的100倍。</p>
<p>⑥ 获胜节点打包交易并广播一旦有某个节点扔出符合系统规则的硬币结果（例如区块379543的哈希值 000000000000000008bdeb575056584429ea4be876ea7ca4ce70262d3edb8c8b），他就会立即将这段时间搜集到的交易打包成一个区块，附上“扔硬币”的结果、区块序号379543、上一区块关系等附加信息广播出去，其它节点一旦收到区块379543并验证无误，就会停止“扔硬币”抢这一区块，转而在这一区块的基础上开始“扔硬币”抢下一区块379544。</p>
<p>⑦ “挖矿”和“矿工”的由来节点大量进行哈希计算需要计算机设备，并消耗大量电力，这个过程在本质上和金矿挖矿很相似（通过挖矿设备，消耗能源换取黄金）。比特币总量恒定，产量越来越少的产生方式也和黄金很相似。因此人们形象地将比特币抢打包权的过程称为挖矿（mine），将抢打包权的比特币节点称为矿工（miner）。</p>
<h4 id="挖矿设备的演变"><a href="#挖矿设备的演变" class="headerlink" title="挖矿设备的演变"></a>挖矿设备的演变</h4><p>① CPU：最早的矿工使用CPU进行挖矿，挖矿速度在M级别（1M=1000K=10^6=每秒100万次哈希运算）。<br>② 显卡矿机：显卡有数百个计算核心（流处理器），因此速度相当于数百个CPU，挖矿速度在百M级别。由于ATI和NVIDIA显卡的架构不同，同档次A卡流处理器数量远超过N卡，因此A卡在挖矿上有巨大优势，专业矿工往往用H61B等有6个PCI-E插槽的主板，插上5-6张ATI 7850等高端显卡，组成矿机群挖矿。<br>由于比特币的上涨，这在今年也造成了一定的显卡荒</p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://www.zhihu.com/question/22076666/answer/69638270" target="_blank" rel="noopener">比特币是什么？</a></p>
]]></content>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>手机摄影技巧</title>
    <url>/blog/2017/07/mobile-camera-technique.html</url>
    <content><![CDATA[<p>手机拍照拍得丑的常见原因：<br>1.手太抖<br>2.距离不合适，要么太远要么太近<br>3.画面杂，背景不合适<br>4.速度快，太心急，还没摆好POSE就开拍</p>
<h3 id="常用技巧"><a href="#常用技巧" class="headerlink" title="常用技巧"></a>常用技巧</h3><h4 id="选背景"><a href="#选背景" class="headerlink" title="选背景"></a>选背景</h4><p>背景选择上建议尽量选干净简洁，背景越简单，人物就会越突出，背景里不宜出现复杂和歪斜的线条，墙啊天啊海啊什么的会比较好拍照。</p>
<h4 id="构图"><a href="#构图" class="headerlink" title="构图"></a>构图</h4><p>井字格构图法<br>将照片要呈现的重点放在4个交叉点上，就基本完成了构图<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/blog/p5.jpg" alt></p>
<h3 id="怎么拍的显腿长"><a href="#怎么拍的显腿长" class="headerlink" title="怎么拍的显腿长"></a>怎么拍的显腿长</h3><p>没有广角镜头，想把妹子拍成大长腿，那就要考验构图和拍摄角度了<br>1.拍摄角度<br>仰拍<br>2.构图<br>懂得蹲着拍以后，就要琢磨构图的比例了，过于居中或者头部顶天都是很显矮的构图<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/blog/p6.jpg" alt><br>脚部贴近照片底部，头部留空50%，才是站着显腿长的正确构图姿势▼<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/blog/p7.jpg" alt><br>当然，照片显腿短也未必全是摄影师的错，还有可能是妹子站姿的问题，双腿不要交叉过分，一只脚向镜头方向延伸，就可以简单又有效的显腿长▼</p>
<p>其实显腿长的技巧还有不少，比如<br>1.当穿高腰裤或者高腰裙的时候，可以俯拍秀腿<br>2.如果遇上台阶，可以踩空一格拉长腿。<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/blog/p8.jpg" alt></p>
<h3 id="怎么拍的显脸小"><a href="#怎么拍的显脸小" class="headerlink" title="怎么拍的显脸小"></a>怎么拍的显脸小</h3><p>1.角度要高，自上而下的拍摄会把脸颊两边的肉隐藏起来<br>2.利用光线，鼻子朝着光源的方向，脸部后侧会产生比较多的阴影<br>3.用头发或者手肘或者门框把肉挡起来<br>4.拍侧面，坚决不给正脸<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/blog/p9.jpg" alt></p>
<h3 id="怎么拍的白"><a href="#怎么拍的白" class="headerlink" title="怎么拍的白"></a>怎么拍的白</h3><p>如果你把握不好光线，尽量选用顺光准没错（就是你女生正面晒着阳光或者光线正面照射），也可以用下侧光（光从侧面照射）。当然了如果你会用逆光也可能给照片增色不少，但是，如果你不会控制曝光时间，那么相机或者手机会把人拍成黑人甚至一个黑影：）无穷尽的吐槽正向你袭来。要肤白如果不借用修图软件，那就稍微过曝拍一下。</p>
<h3 id="如何使表情不那么僵硬"><a href="#如何使表情不那么僵硬" class="headerlink" title="如何使表情不那么僵硬"></a>如何使表情不那么僵硬</h3><p>1.拍照不用直视前方，看地，看地，看自己，或者扭过头去看旁边即可。还有一个绝招，回头一笑。<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/blog/p10.jpg" alt><br>2.还有一个老办法，托腮摸脸状</p>
<h3 id="怎么摆姿势"><a href="#怎么摆姿势" class="headerlink" title="怎么摆姿势"></a>怎么摆姿势</h3><p>1.回头转身<br>镜头下方切着女友的上臂也就是胸部上下，女友头部在画面水平或者偏上。<br>a、侧身正脸标准像<br>最简单、最容易上手也是女友最容易摆的姿势，女生通过转头或者转身的程度变成小脸瘦身美人<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/blog/p11.jpg" alt><br>把握好光源，回眸微微一笑，一张美照就出来了~</p>
<p>或者半侧身，头微微上仰，眼睛微闭<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/blog/p13.jpg" alt></p>
<p>2.盘腿而坐，跳起来，或者走路时抓拍，或者利用身边的小物件和一切利用的上的东西。<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/blog/p14.jpg" alt></p>
<h3 id="后期"><a href="#后期" class="headerlink" title="后期"></a>后期</h3><p>参考：<a href="https://www.zhihu.com/question/21926384" target="_blank" rel="noopener">https://www.zhihu.com/question/21926384</a><br><a href="https://www.zhihu.com/question/27175448#answer-23217866" target="_blank" rel="noopener">https://www.zhihu.com/question/27175448#answer-23217866</a></p>
]]></content>
      <tags>
        <tag>photoshop</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js学习</title>
    <url>/blog/2017/06/node-js-learn.html</url>
    <content><![CDATA[<h3 id="Node-js介绍"><a href="#Node-js介绍" class="headerlink" title="Node.js介绍"></a>Node.js介绍</h3><p>Node.js是基于Chrome JavaScript运行时建立的一个平台，实际上它是对Google Chrome V8引擎进行了封装，它主要用于创建快速的、可扩展的网络应用。Node.js采用事件驱动和非阻塞I/O模型，使其变得轻量和高效，非常适合构建运行在分布式设备的数据密集型的实时应用。</p>
<p>对运行于浏览器的JavaScript来说，浏览器就是JavaScript代码的解析器，而Node.js则是服务器端的JavaScript代码解析器，存在于服务器端的JavaScript代码由Node.js来解析和运行。</p>
<p>JavaScript解析器只是JavaScript代码运行的一种环境，浏览器是JavaScript运行的一种环境，浏览器为JavaScript提供了操作DOM对象和window对象等的接口。Node.js也是JavaScript运行的一种环境，Node.js为JavaScript提供了操作文件、创建HTTP服务、 创建TCP/UDP服务等的接口，所以Node.js可以完成其他后端开发语言（如Python、PHP等）能完成的工作。</p>
<h3 id="Node-js模块和包"><a href="#Node-js模块和包" class="headerlink" title="Node.js模块和包"></a>Node.js模块和包</h3><h4 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h4><p>Node.js官方提供了很多模块，这些模块分别实现了一种功能，如操作文件的模块fs，构建http服务的模块http等，每个模块都是一个JavaScript文件，当然你也可以自己编写模块。<br>模块的导出使用module.exports和exports，exports可以看作是对module.exports对象的一个引用</p>
<h4 id="包"><a href="#包" class="headerlink" title="包"></a>包</h4><p>包用于管理多个模块及其依赖关系，可以对多个模块进行封装，包的根目录必须包含package.json文件，package.json文件是CommonJS规范用于描述包的文件，符合CommonJS规范的package.json文件一般包含以下字段：<br>1.name：包名。包名是唯一的，只能包含小写字母、数字和下划线。<br>2.version：包版本号。<br>3.description：包说明。<br>4.keywords：关键字数组。用于搜索。<br>5.homepage：项目主页。<br>6.bugs：提交bug的地址。<br>7.license：许可证。<br>8.maintainers：维护者数组。<br>9.contributors：贡献者数组。<br>10.repositories：项目仓库托管地址数组。<br>11.dependencies：包依赖。<br>package.json文件可以自己手动编辑，但为了方便，更推荐通过npm init命令进行生成。你可以自己尝试在终端中输入npm init命令来生成一个包含package.json文件的包。</p>
<h4 id="npm包管理工具"><a href="#npm包管理工具" class="headerlink" title="npm包管理工具"></a>npm包管理工具</h4><p>通过npm安装的包会按包名字母顺序出现在package.json中的dependencies字段中。<br>安装<br><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">npm <span class="keyword">install</span> 包名</span><br></pre></td></tr></table></figure></p>
<p>卸装<br><figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">npm</span> uninstall 包名</span><br></pre></td></tr></table></figure></p>
<h3 id="Node-js-Events模块"><a href="#Node-js-Events模块" class="headerlink" title="Node.js Events模块"></a>Node.js Events模块</h3><p>Node.js采用事件驱动模型，在Node.js中，事件是一个很重要的概念<br>很多对象都会发出事件。比如，fs.readStream打开文件时会发出一个事件。所有发出事件的对象都是events.EventEmitter的实例，可以通过require(“events”);获得event模块。</p>
<p>通常，事件名采用“驼峰式”(即单词首字母大写，其他字母小写)命名方式，但是，不采用这种命名方式也不会造成程序功能上的问题。但为了程序风格的规范性和一致性，请尽量使用这种命名方式。</p>
<p>对象发出的事件需要有函数来捕获并处理。为此，需要先使一个事件与一个响应函数建立关系。对象发出事件时，与其建立关系的对应函数就会被执行。这些函数被称作监听器（listeners）。在监听器函数中，this指向发出该事件的EventEmitter对象。</p>
<h4 id="events-EventEmitter类"><a href="#events-EventEmitter类" class="headerlink" title="events.EventEmitter类"></a>events.EventEmitter类</h4><p>通过require(‘events’).EventEmitter得到EventEmitter类。</p>
<p>当EventEmitter对象遇到错误时，通常会触发error事件。error事件在Node.js中是一种特殊情况，如果没有监听器，那么默认会打印出栈跟踪器并退出程序。</p>
<h4 id="添加监听器"><a href="#添加监听器" class="headerlink" title="添加监听器"></a>添加监听器</h4><p>为事件绑定事件处理程序，可以使用emitter.addListener(event, listener)和emitter.on(event, listener)，它们的作用是完全一样的。传入的参数是事件（event）和处理函数（listener）。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> server = http.createServer();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为request事件绑定处理函数</span></span><br><span class="line"><span class="comment">// 也可以使用server.addListener</span></span><br><span class="line">server.on(<span class="string">'request'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123; <span class="comment">//为`request`事件添加一个匿名listener函数</span></span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123; <span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span> &#125;); <span class="comment">//写入http响应头</span></span><br><span class="line">    res.write(<span class="string">'shiyanlou'</span>); <span class="comment">//写入http响应体</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'shiyanlou'</span>);</span><br><span class="line">    res.end(); <span class="comment">//结束，返回响应内容</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">1337</span>, <span class="string">'127.0.0.1'</span>); <span class="comment">// 在127.0.0.1(即本地回环)1337端口监听http请求</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Server running at http://127.0.0.1:1337/'</span>);</span><br></pre></td></tr></table></figure></p>
<p>运行后，访问<a href="http://127.0.0.1:1337/，即可看到结果" target="_blank" rel="noopener">http://127.0.0.1:1337/，即可看到结果</a></p>
<h4 id="只执行一次的监听器"><a href="#只执行一次的监听器" class="headerlink" title="只执行一次的监听器"></a>只执行一次的监听器</h4><p>使用emitter.once(event, listener)绑定的事件监听器只会执行一次，然后就会被删除掉。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> server = http.createServer();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为request事件绑定处理函数，事件只会执行一次</span></span><br><span class="line">server.once(<span class="string">'request'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123; <span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span> &#125;);</span><br><span class="line">    res.write(<span class="string">'shiyanlou'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'shiyanlou'</span>);</span><br><span class="line">    res.end();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">1337</span>, <span class="string">'127.0.0.1'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Server running at http://127.0.0.1:1337/'</span>);</span><br></pre></td></tr></table></figure></p>
<h4 id="移除监听器"><a href="#移除监听器" class="headerlink" title="移除监听器"></a>移除监听器</h4><p>移除监听器使用emitter.removeListener(event, listener)<br><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">var http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line">var server = http.createServer();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callback</span><span class="params">(req, res)</span></span> &#123;</span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123; <span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span> &#125;);</span><br><span class="line">    res.<span class="built_in">write</span>(<span class="string">'Hello World'</span>);</span><br><span class="line">    console.<span class="built_in">log</span>(<span class="string">'Hello World'</span>);</span><br><span class="line">    res.<span class="keyword">end</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">'request'</span>, callback);</span><br><span class="line"></span><br><span class="line">// 移除绑定的监听器callback</span><br><span class="line">server.removeListener(<span class="string">'request'</span>, callback);</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">'request'</span>, <span class="function"><span class="keyword">function</span><span class="params">(req, res)</span></span> &#123;</span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123; <span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span> &#125;);</span><br><span class="line">    res.<span class="built_in">write</span>(<span class="string">'shiyanlou'</span>);</span><br><span class="line">    console.<span class="built_in">log</span>(<span class="string">'shiyanlou'</span>);</span><br><span class="line">    res.<span class="keyword">end</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">1337</span>, <span class="string">'127.0.0.1'</span>);</span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">'Server running at http://127.0.0.1:1337/'</span>);</span><br></pre></td></tr></table></figure></p>
<h4 id="移除所有监听器"><a href="#移除所有监听器" class="headerlink" title="移除所有监听器"></a>移除所有监听器</h4><p>移除所有监听器使用emitter.removeAllListeners([event])。</p>
<h4 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h4><p>使用emitter.emit(event, [arg1], [arg2], […])可以触发自定义的事件<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> server = http.createServer();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定自定义事件myevent</span></span><br><span class="line">server.on(<span class="string">'myevent'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发自定义事件</span></span><br><span class="line">server.emit(<span class="string">'myevent'</span>, <span class="string">'shiyanlou'</span>);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">1337</span>, <span class="string">'127.0.0.1'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Server running at http://127.0.0.1:1337/'</span>);</span><br></pre></td></tr></table></figure></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>Node.js 中所有能发出事件的对象都是events.EventEmitter的实例，对象发出事件后，需要有响应函数进行响应处理。<br>EventEmitter类的对象具有一系列方法可以进行事件相关操作，他们是：</p>
<ul>
<li>addListener(event,listener) / on(event,listener): 为对象的事件event添加监听器listener.</li>
<li>once(evnet,listener): 为对象的事件event添加只响应一次的监听器listener.</li>
<li>removeListener(event,listener): 移除一个监听器listener.</li>
<li>removeAllListeners([listeners]): 移除与一个对象绑定的所有listener.</li>
<li>setMaxListeners(n): 设置与一个对象绑定的监听器最多有n个。</li>
<li>emit(event, [arg1], [arg2], […]): 触发事件event.</li>
<li>listenerCount(): 查看与对象绑定的监听器的个数。</li>
</ul>
<h3 id="Node-js-fs-模块"><a href="#Node-js-fs-模块" class="headerlink" title="Node.js fs 模块"></a>Node.js fs 模块</h3><p>出于安全考虑，浏览器端的JavaScript代码一般无法访问本地文件系统。但对于运行在服务器端的Node.js来说，文件系统是可以直接访问的，Node.js中,fs模块可以对系统文件及目录进行读写操作。</p>
<h4 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h4><p>不同于C++、Java等编程语言，JavaScript语句是异步执行的，Node.js也是如此。异步使得Node.js能够”同时”处理多个请求，提高了服务程序的并发性。异步特性也是Node.js得以流行的原因之一。</p>
<p>fs模块中所有方法都有同步和异步两种形式，我们可以在学习fs模块本身的同时体会异步和同步的差别。</p>
<p>异步方法中回调函数的第一个参数总是留给异常参数（exception），如果方法成功完成，那么这个参数为null或者undefined。</p>
<p>异步方法实例代码<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>); <span class="comment">// 载入fs模块</span></span><br><span class="line"></span><br><span class="line">fs.unlink(<span class="string">'/tmp/shiyanlou'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">throw</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'成功删除了 /tmp/shiyanlou'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>同步方法实例代码<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">fs.unlinkSync(<span class="string">'/tmp/shiyanlou'</span>); <span class="comment">// 函数名最后的Sync 表示是同步方法</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'成功删除了 /tmp/shiyanlou'</span>);</span><br></pre></td></tr></table></figure></p>
<p>同步方法执行完并返回结果后，才能执行后续的代码。而异步方法采用回调函数接收返回结果，可以立即执行后续的代码。</p>
<h4 id="readFile读取文件"><a href="#readFile读取文件" class="headerlink" title="readFile读取文件"></a>readFile读取文件</h4><p>使用fs.readFile(filename, [options], callback)方法读取文件。<br>readFile接收三个参数，filename是文件名；[options]是可选的参数，为一个对象，用于指定文件编码（encoding）及操作方式（flag）；callback是回调函数。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>); <span class="comment">// 引入fs模块</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用toString()</span></span><br><span class="line">fs.readFile(<span class="string">'./test.txt'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 读取文件失败/错误</span></span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">throw</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读取文件成功</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'toString: '</span>, data.toString());</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置编码格式</span></span><br><span class="line">fs.readFile(<span class="string">'./test.txt'</span>, <span class="string">'utf-8'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 读取文件失败/错误</span></span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">throw</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读取文件成功</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'utf-8: '</span>, data.toString());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>不指定编码时，默认为原始二进制数据<br>fs.readFileSync(filename, [options])是readFile的同步方法。</p>
<h4 id="writeFile写入文件"><a href="#writeFile写入文件" class="headerlink" title="writeFile写入文件"></a>writeFile写入文件</h4><p>使用fs.writeFile(filename, data, [options], callback)写入内容到文件。</p>
<p>writeFile接收四个参数，filename是文件名称；data是要写入文件的数据；[options]是一个对象为可选参数，包含编码格式（encoding），模式（mode）以及操作方式（flag）；callback是回调函数。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>); <span class="comment">// 引入fs模块</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入文件内容（如果文件不存在会创建一个文件）</span></span><br><span class="line"><span class="comment">// 写入时会先清空文件</span></span><br><span class="line">fs.writeFile(<span class="string">'./test2.txt'</span>, <span class="string">'test test'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">throw</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Saved.'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入成功后读取测试</span></span><br><span class="line">    fs.readFile(<span class="string">'./test2.txt'</span>, <span class="string">'utf-8'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            <span class="keyword">throw</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">console</span>.log(data);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h4 id="使用fs-read和fs-write读写文件"><a href="#使用fs-read和fs-write读写文件" class="headerlink" title="使用fs.read和fs.write读写文件"></a>使用fs.read和fs.write读写文件</h4><p>使用fs.read和fs.write读写文件需要使用fs.open打开文件和fs.close关闭文件</p>
<h5 id="fs-read"><a href="#fs-read" class="headerlink" title="fs.read()"></a>fs.read()</h5><p>先介绍fs.open(path, flags, [mode], callback)方法，此方法用于打开文件，以便fs.read()读取。path是文件路径，flags是打开文件的方式，[mode]是文件的权限（可选参数，默认值是0666），callback是回调函数。<br>fs.close(fd, [callback])用于关闭文件，fd是所打开文件的文件描述符。<br>fs.read(fd, buffer, offset, length, position, callback)方法接收6个参数。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>); <span class="comment">// 引入fs模块</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开文件</span></span><br><span class="line">fs.open(<span class="string">'./testread.txt'</span>, <span class="string">'r'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, fd</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">throw</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'open file success.'</span>);</span><br><span class="line">    <span class="keyword">var</span> buffer = <span class="keyword">new</span> Buffer(<span class="number">255</span>);</span><br><span class="line">    <span class="comment">// 读取文件</span></span><br><span class="line">    fs.read(fd, buffer, <span class="number">0</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, bytesRead, buffer</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            <span class="keyword">throw</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 打印出buffer中存入的数据</span></span><br><span class="line">        <span class="built_in">console</span>.log(bytesRead, buffer.slice(<span class="number">0</span>, bytesRead).toString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭文件</span></span><br><span class="line">        fs.close(fd);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h5 id="fs-write"><a href="#fs-write" class="headerlink" title="fs.write()"></a>fs.write()</h5><p>fs.write(fd, buffer, offset, length, position, callback)方法的参数和fs.read()相同，buffer是需要写入文件的内容。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>); <span class="comment">// 引入fs模块</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开文件</span></span><br><span class="line">fs.open(<span class="string">'./testwrite.txt'</span>, <span class="string">`w`</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, fd</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">throw</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'open file success.'</span>);</span><br><span class="line">    <span class="keyword">var</span> buffer = <span class="keyword">new</span> Buffer(<span class="string">'shiyanlou'</span>);</span><br><span class="line">    <span class="comment">// 读取文件</span></span><br><span class="line">    fs.write(fd, buffer, <span class="number">0</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, written, buffer</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            <span class="keyword">throw</span> err;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'write success.'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印出buffer中存入的数据</span></span><br><span class="line">        <span class="keyword">var</span> byteLength = buffer.byteLength;</span><br><span class="line">        <span class="built_in">console</span>.log(byteLength, buffer.slice(<span class="number">0</span>, byteLength).toString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭文件</span></span><br><span class="line">        fs.close(fd);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>读《少年巴比伦》</title>
    <url>/blog/2017/07/read-young-teenager.html</url>
    <content><![CDATA[<blockquote>
<p>在去往终南山的路上<br>天色渐亮，暮色渐沉<br>他不知终南山的鸟儿们<br>四季里只睡了这一夜<br>–张小尹《终南山》</p>
</blockquote>
<p>&emsp;&emsp;好久没读到这么好的故事了。路内的故事，有句话说得很准确，让人读起来笑着流泪，明明都是插科打谑的话，读起来却让人那么悲哀，真是有趣，我顶喜欢这样的文笔。路小路是九十年代初戴城的一个化工厂学徒，是个二十岁左右的愣头青，是个吊儿郎当不学无术的中二青年，是个总不明白自己要做什么的傻逼。路小路，高中毕业后进入糖精厂，理想成为一名无所事事的宣传科科员。师从“老牛逼”，成为一名只会拧螺丝的四级钳工，而后成为一个只会换灯泡的电工，之后由于调戏女科员被下放操作间倒三班。在工厂的岁月里，他结识了“小噘嘴”、“长脚”、小李、倒B等人，并与厂医白蓝产生了爱情。白蓝考取上海的研究生，一去不复返。在白蓝的怂恿下，路小路报考夜大并学习会计专业。多年之后，路小路在上海街头，凭吊着自己二十岁时在工厂的岁月。</p>
<center><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/blog/p23.jpg"></center>

<p>&emsp;&emsp;小说描写了路小路的青春生活，工厂岁月，还有很多工人，这些工人，也几乎是悲惨的人，但这种悲惨并不是那种巨大时代苦难的悲惨，而只是一种平庸的悲惨，这悲惨中，并没有悲哀，或者可怜，或许就是所谓的哀而不伤吧。老牛逼横行一世，“光荣退休”之时，临岸的小屋已被过路的船只摧毁；老牛逼的女儿，霸道蛮横，低三下气求得一点卑微的爱情，无疾而终；“长脚”只是想读大学，却蒙受着巨大的羞辱和阻挠；黄春妹因为过于肥胖，被所有工人视为“老虎”，没有人关心她是否温柔可爱；“小噘嘴”掉进沸水，烫伤残疾，多年后相见，却也云淡风轻；路小路呢，追着疯狗在大街奔跑，像杂耍一样被人观看。总得来说，这是一个平庸的时代，拿路小路的话来说：</p>
<blockquote>
<p>在一个不必亡命的时代里既不会杀人也不会被杀，我会被送去造糖精，犯了错会被扣工资，如此而已。在这种时代我可以把自己杀掉，无论是故意的还是不小心的，我不会为了糖精和工资而自杀，也不会为了爱情，但是我可以毫无理由地去死，如此而已.</p>
</blockquote>
<p>&emsp;&emsp;但白蓝不一样，白蓝好像是并不属于这个香甜腐烂的时代的，她因为某种原因被发配到戴城糖精厂，一开始就计划好了要逃离戴城，只有大概爱上路小路这一节算是意外吧。这是一个高中学历青工和一个大学生厂医的爱情，一个二十岁的愣头青和一个年纪稍长的姐姐的爱情，一个幼稚的男孩和一个成熟的女人的爱情。这注定是没有好结局的故事，也是一个有点悲哀带点绝望的故事，但还是令人感动。在平庸无聊的工厂生活中，白蓝是个例外，将路小路从生活中解救出来，路小路说：“很长一段日子，我都认为自己无人可爱，所以只能爱你。我为这种爱情而羞愧，但在这样的旅程中我无法为自己的羞愧之心承担责任，假如无路可走，那不是罪过。但我也不想睁着无辜的双眼看着你，你既不在此岸也不在彼岸，你在河流之中。”白蓝为什么会喜欢上路小路呢，真是奇怪，可能是由于作者是个男的吧。白蓝从未对小路说过一句情话，哪怕是情侣间简单的我爱你三个字，但白蓝又着实爱过小路。白蓝在离开他远走西藏之后，寄回的一张明信片上写着：走了几千公里路，还是不能忘记你，给我的小路。</p>
<center><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/blog/p22.jpg"></center>

<p>&emsp;&emsp;书名叫做《少年巴比伦》，有点令人费解，从我个人角度来看，巴比伦空中花园是世界七大奇迹之一，书名大概意指少年的奇幻之旅，路小路问白蓝说，”你知道什么叫奇幻的旅程吗？”和你去西藏一样，我也有我的奇幻旅程，只是你不知道。我说，在我一生中能走过的路，有多少是梦幻的，我自己不能确定，但是有多少是狗屎，这倒是历历在目。正因如此，凡不是狗屎的，我都视之为奇幻的旅程。我这么去想，并非因为我幼稚，而是试图告诉自己，在此旅程结束之时，就等同于一个梦做完了。我就是这么想的。虽然整本书一直用一种幽默的笔触来描写，但路小路从一开始就是个悲观的人，悲观者无处可去，路小路说：</p>
<blockquote>
<p>我的数学老师说过，我是一个悲观的人，我以为这个世界上这种人比比皆是，后来发现不是这样。悲观的人很少很少，有些人本来应该悲观的，可是他们打麻将唱卡拉OK，非常快乐。我身边全都是这样的人，我不知道自己应该用什么方式来看这个世界，悲伤的，还是乐观的。我和我身边的世界隔着一条河流，彼此都把对方当成是神经分裂。</p>
</blockquote>
<center><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/blog/p20.jpg"></center>

<p>白蓝之于路小路，就是一段终将告别的奇幻旅程，离别总之是伤感的，因为伤感，所以不能用言语来表达，好像春天里绵密的细雨，用肉眼都分辨不出雨丝，不知道该不该打伞。后来路小路去上海找白蓝，而白蓝已经离开了，在空无一人的标本室里，在寂静的笑声中，所谓奇异的旅程在此已经画上句号，只留下记忆给三十岁的路小路讲给张小尹听。一个女人明明出现在你香甜而腐烂的青春里，但等你回忆起来，她像是没有参与过你的生活一样，这大概是这本书里，最无言的悲伤。</p>
<blockquote>
<p>我曾经对她说过，将来我再遇见你，一定会毫不犹豫地喊你的名字，因为有情有义，不能装作从来没认识你。你在河流中看到岸上的我，这种短暂的相遇，你可以认为是一种告白，我在这个世界上无处可去所以又撞见了你。她说，你一个小工人搞得这么伤感干吗。她后来又说，你不会无处可去的，你也不会再遇到我。这些对话我早就忘了，我有时候回忆起它们，觉得这是我血液中的沉渣，也就是血栓，要是堵住脑子就会死掉.</p>
</blockquote>
<center><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/blog/p19.jpg"></center>

<p>再见了，白蓝；再见了，戴城；再见了，奇幻旅程。<br>这本书的最后也是一首诗结尾的，就摘抄在这里吧。</p>
<blockquote>
<p>没有人蜷腿躺在<br>高高的行李架上<br>并且没有人想过<br>在疾行的列车中倒下<br>农田飞奔，以及树木和云<br>这一切多像是悲剧<br>那些沿途追逐的人<br>很年轻时就嬉水而死<br>这一切，多像悲剧的开始<br>乘务员穿行在80公里时速中<br>悠游自在<br>激流中的鱼停靠在岸上<br>赤裸鲜艳<br>那些搭乘悲剧的人在凌晨惊醒于噩梦<br>她们年仅十七<br>她们手捧糖果<br>她们的制服早就歪斜在<br>黑暗中<br>衰老可能来得更慢一些吗</p>
</blockquote>
]]></content>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>树莓派的组装</title>
    <url>/blog/2017/07/raspberry-combination.html</url>
    <content><![CDATA[<p>早就想入手树莓派玩玩，一发了工资就赶紧下单了。要让树莓派跑起来，至少需要以下设备：<br>1.主板，这当然是必须的<br>2.外壳<br>3.风扇<br>4.散热片<br>5.电源<br>6.TF卡<br>7.读卡器</p>
<p>我在刚开始的时候，只下单了主板，还好奇怎么什么都没有，怎么跑起来的，赶紧联系了店家，才知道还有一大堆东西要买，好在有套餐。</p>
<h3 id="组装"><a href="#组装" class="headerlink" title="组装"></a>组装</h3><p>1.安装部分外壳<br>将主板放到外壳里面去<br>2.安装散热片<br>树莓派三的三个芯片分别是，CPU,GPU,内存。正面的两个是CPU和GPU，后面一个是内存，内存不必安装散热片，只要在前面两个安装即可<br>用指甲将双面胶剥下，即可安装散热片<br>3.安装风扇<br>将红白外壳的顶部拆开，将风扇连接主板右侧的接口，再与顶部连接起来，形成一个散热口<br>4.安装外壳<br>将外壳封闭起来<br>5.安装TF卡<br>将TF卡放入，注意方向与位置，同时需要先安装好系统，我买的是带系统的，就不必烧录了。</p>
<p>最后，将一大堆零件和主板组装好了，效果是这样子的：</p>
<center><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/other/p1.jpg"></center>
]]></content>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>Ionic与cordova区别</title>
    <url>/blog/2017/07/ionic-cordova-differ.html</url>
    <content><![CDATA[<h3 id="ionic是什么："><a href="#ionic是什么：" class="headerlink" title="ionic是什么："></a>ionic是什么：</h3><p>Ionic(ionicframework)一款开源的HTML5移动App开发框架,是AngularJS移动端解决方案,Ionic以流行的跨平台移动app开发框架phoengap为蓝本，让开发者可以通过命令行工具快速生成Android iOS移动app应用</p>
<h3 id="phoengap是什么？"><a href="#phoengap是什么？" class="headerlink" title="phoengap是什么？"></a>phoengap是什么？</h3><p>PhoneGap是一个用基于HTML，CSS和JavaScript的，创建移动跨平台移动应用程序的快速开发平台。它使开发者能够利用iPhone，android，Palm，Symbian,WP7,WP8,Bada和Blackberry智能手机的核心功能——包括地理定位，加速器，联系人，声音和振动.</p>
<h3 id="Cordova是什么？"><a href="#Cordova是什么？" class="headerlink" title="Cordova是什么？"></a>Cordova是什么？</h3><p>Cordova是PhoneGap贡献给Apache后的开源项目，是从PhoneGap中抽出的核心代码，是驱动PhoneGap的核心引擎。你可以把它们的关系想象成类似于Webkit和Google Chrome的关系<br>Cordova提供了一组设备相关的API，通过这组API，移动应用能够以JavaScript访问原生的设备功能，如摄像头、麦克风等。<br>Cordova还提供了一组统一的javascript类库，以及为这些类库所用的设备相关的原生后台代码。<br>Cordova支持如下移动操作系统：iOS, android,ubuntu phone os, Blackberry, Windows Phone, Palm WebOS, Bada 和 Symbian。</p>
<h3 id="Angularjs："><a href="#Angularjs：" class="headerlink" title="Angularjs："></a>Angularjs：</h3><p>是一款优秀的前端js框架，已经被用于Google的多款产品当中。AngularJS有着诸多特性，最为核心的是：MVVM、模块化、自动化双向数据绑定、语义化标签、依赖注入等等</p>
<p>总结来说<br>ionic= cordova编译环境+cordova api+ angular + angular ui插件(带css)<br>你开发的app= cordova下使用用angular框架开发的html应用<br>我们要写的代码就是html和js。</p>
<p>可能会有人被问道：“Cordova比Ionic/Angular好吗？”，这就很尴尬了，根本是毫无意义的问题。它们在混合开发中扮演的是不同的角色–Ionic/Angular负责页面的实现，而Cordova负责将实现的页面包装成原生应用（Android:apk；iOS:ipa）。就像花生，最内层的花生仁是Angular，花生仁的表皮是Ionic，而最外层的花生壳则是Cordova。包装完成之后我们的页面才有可能调用设备的原生能力，最后才能上传到应用商店被用户使用。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://blog.csdn.net/molashaonian/article/details/52538314" target="_blank" rel="noopener">Cordova+Angularjs+Ionic 混合开发入门讲解</a></p>
]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>git多人开发</title>
    <url>/blog/2017/07/git-mulit-people.html</url>
    <content><![CDATA[<h3 id="团队协作"><a href="#团队协作" class="headerlink" title="团队协作"></a>团队协作</h3><h4 id="git-amend使用"><a href="#git-amend使用" class="headerlink" title="git amend使用"></a>git amend使用</h4><p>有时你提交过代码之后，发现一个地方改错了，你下次提交时不想保留上一次的记录；或者你上一次的commit message的描述有误，这时候你可以使用接下来的这个命令：git commit –amend。</p>
<p>git amend适用于本地commit或者CodeReview，如果用于已经推送到远程的commit，需要合并代码<br>详情可见：<a href="https://zhuanlan.zhihu.com/p/100243017" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/100243017</a></p>
<h4 id="git合并多个提交"><a href="#git合并多个提交" class="headerlink" title="git合并多个提交"></a>git合并多个提交</h4><p>有时候在一个分支的多次意义相近的 commit，会把整个提交历史搞得很混乱，此时可以将一部分的 commit 合并为一个 commit，以美化整个 commit 历史，可以使用 rebase 的方法来合并多次 commit，主要步骤如下：<br><a href="https://www.cnblogs.com/zhaoyingjie/p/10259715.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhaoyingjie/p/10259715.html</a></p>
<h4 id="git删除某个commit"><a href="#git删除某个commit" class="headerlink" title="git删除某个commit"></a>git删除某个commit</h4><p>同样的，利用 git 压缩 rebase 指令来删除某个 commit，过程和以上是类似的；<br><a href="https://www.cnblogs.com/zhaoyingjie/p/10259715.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhaoyingjie/p/10259715.html</a></p>
<p>查看项目分支情况可以使用命令git branch:<br><figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="symbol">$</span> git branch</span><br><span class="line"><span class="comment">* master</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到当前项目坐在的分支是master（*号后边为当前所在分支名）。<br>而且项目目前也只有一个分支，就是master。</p>
<h3 id="团队开发"><a href="#团队开发" class="headerlink" title="团队开发"></a>团队开发</h3><p>但是我们在实际项目开发中，通常都是以团队开发为主，所以为了维护线上主干代码的稳定，我们也都会采取创建分支-开发-测试-合并-上线的形式进行实际操作的。所以接下来描述一下简单的团队开发Git项目。</p>
<h4 id="本地分支"><a href="#本地分支" class="headerlink" title="本地分支"></a>本地分支</h4><p>工程师Alice需要对原来的代码做改动，这是她需要创建一个分支，名字为develop：<br><figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="symbol">$</span> git branch develop</span><br><span class="line"><span class="symbol">$</span> git branch</span><br><span class="line">  develop</span><br><span class="line"><span class="comment">* master</span></span><br></pre></td></tr></table></figure></p>
<p>这个时候我们看到本地工作区已经有两个分支：master和develop。但当前工作区还是在master上（注意*号位置），需要手动切换到develop上。只需使用git checkout命令<br><figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="symbol">$</span> git checkout develop</span><br><span class="line">Switched to branch <span class="string">'develop'</span></span><br><span class="line"><span class="symbol">$</span> git branch</span><br><span class="line"><span class="comment">* develop</span></span><br><span class="line">  master</span><br></pre></td></tr></table></figure></p>
<p>这样就将当前工作区切换到新的分支中，我们可以发现此时的develop分支中的内容是master的复制。<br>当然有人希望创建分支后直接切换到新的分支<br><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">$ git checkout -b develop</span><br><span class="line">Switched <span class="built_in">to</span> <span class="keyword">a</span> <span class="built_in">new</span> branch <span class="string">'develop'</span></span><br></pre></td></tr></table></figure></p>
<h4 id="远程分支"><a href="#远程分支" class="headerlink" title="远程分支"></a>远程分支</h4><p>现在的develop分支只是存在于Alice的本地环境，当工程师Bob打算协同Alice进行相同业务的开发时，他也需要拿到develop分支的代码，那该怎么获取呢，此时需要Alice将本地分支编程远程分支，以供给其他工程师共同开发。<br>使用git branch -a能够查询当前所有分支，包括本地分支和远程分支（下边remotes/origin开头）<br><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">$ git branch -a</span><br><span class="line">* develop</span><br><span class="line">  <span class="literal">master</span></span><br><span class="line">  remotes/origin/HEAD -&gt; origin/<span class="literal">master</span></span><br><span class="line">  remotes/origin/<span class="literal">master</span></span><br></pre></td></tr></table></figure></p>
<p>发现并没有远程分支里并没有新建的develop，这是需要执行git push origin develop命令，将本地develop分支推送到Git服务器，生成远程分支。<br><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">git</span> <span class="string">push</span> <span class="string">origin</span> <span class="string">develop</span></span><br><span class="line"><span class="string">Total</span> <span class="number">0</span> <span class="string">(delta</span> <span class="number">0</span><span class="string">),</span> <span class="string">reused</span> <span class="number">0</span> <span class="string">(delta</span> <span class="number">0</span><span class="string">)</span></span><br><span class="line"><span class="string">To</span> <span class="string">git@github.com:username/project.git</span></span><br><span class="line"> <span class="string">*</span> <span class="string">[new</span> <span class="string">branch]</span>      <span class="string">develop</span> <span class="string">-&gt;</span> <span class="string">develop</span></span><br></pre></td></tr></table></figure></p>
<p>好了，现在Bob和其他任何工程师都可以通过拉取远程分支获取Alice创建的develop分支代码。<br>此时只需执行git fetch origin develop:develop将远程分支代码拉取到本地.<br><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">$ git fetch origin develop:develop</span><br><span class="line">From github.com:username/project</span><br><span class="line"> * [new branch]      develop    -&gt; develop</span><br><span class="line">$ git branch -a</span><br><span class="line">  develop</span><br><span class="line">* <span class="literal">master</span></span><br><span class="line">  remotes/origin/HEAD -&gt; origin/<span class="literal">master</span></span><br><span class="line">  remotes/origin/develop</span><br><span class="line">  remotes/origin/<span class="literal">master</span></span><br></pre></td></tr></table></figure></p>
<p>再通过查询可以看到本地多了一个develop本地分支。<br>git fetch origin develop:develop这个命令的意思是将远程develop分支代码拉取到本地develop分支中。这是一个快捷的方式，如果Bob本地没有develop分支，该命令会创建一个名为develop的分支，如果Bob本地有自己的分支，如Bob_dev，则可以执行git fetch origin develop:Bob_dev或者先切到Bob_dev分支内，执行git fetch origin develop即可。</p>
<p>此时Alice和Bob就可以切到本地develop分支进行开发了（git checkout develop）。 </p>
<ol>
<li>开发过程中每个工程师在推送代码之前要先执行拉取操作，因为远程仓库有更新的话，不先拉取（pull/fetch）是无法推送（push）的，尽量少使用git pull进行拉取，而是先用git fetch拉取在进行git merge。 </li>
<li>在每个开发阶段都及时地提交代码（git commit）并推送（git push）至远程仓库，可以使用git status检查工作区是否还有未处理的代码和文件。在提交代码的时候写好优秀的注释（git commit file -m ‘Alice fix bug in filename’）。 </li>
<li>在项目代码将要合并到主干master的时候，要由一名工程师做最后的合并处理，如创建分支的Alice。由于在合并代码时极易产生冲突，所以一定要先与主干代码版本做对比（git diff），合并时可以使用git merge，当然如果develop可以废除的话，也可以使用git rebase做最后的合并。 </li>
<li>最后在分支代码合并到主干或者代码上线后，develop分支完成了自己的任务，可以删除本地分支和远程分支。</li>
</ol>
<p>删除本地分支：<br><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">$ git branch -d develop</span><br><span class="line">Deleted branch develop (was <span class="number">1</span>fe1352).</span><br><span class="line">$ git branch -a</span><br><span class="line">* <span class="literal">master</span></span><br><span class="line">  remotes/origin/HEAD -&gt; origin/<span class="literal">master</span></span><br><span class="line">  remotes/origin/develop</span><br><span class="line">  remotes/origin/<span class="literal">master</span></span><br></pre></td></tr></table></figure></p>
<p>删除远程分支：</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">$ git push origin --delete develop</span><br><span class="line">To git@github.com:username/project.git</span><br><span class="line"> - [deleted]         develop</span><br><span class="line">$ git branch -a</span><br><span class="line">* <span class="literal">master</span></span><br><span class="line">  remotes/origin/HEAD -&gt; origin/<span class="literal">master</span></span><br><span class="line">  remotes/origin/<span class="literal">master</span></span><br></pre></td></tr></table></figure>
<h4 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h4><p>在代码的合并阶段（git pull或者git merge命令），通常会产生代码冲突。如果是其他工程师造成的冲突，需要转给相关工程师处理，也造成大量的沟通成本。为了减少冲突，建议每个工程师各自单独负责模块，业务互相不冲突。<br>在解决冲突时，需要使用git log和git diff来检查历史版本的修改信息</p>
<p>需要回退到某一版本，可以使用git reset命令<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">reset</span> <span class="comment">--hard 265886db0d6868cc669e0ef253e6e9ac1e39319c </span></span><br><span class="line"><span class="keyword">HEAD</span> <span class="keyword">is</span> <span class="keyword">now</span> <span class="keyword">at</span> <span class="number">265886</span>d chenge readme</span><br></pre></td></tr></table></figure></p>
<p>如果文件尚未提交，也可以用git checkout filename 恢复到提交前。<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date <span class="keyword">with</span> <span class="string">'origin/master'</span>.</span><br><span class="line">Changes <span class="keyword">not</span> staged <span class="keyword">for</span> <span class="keyword">commit</span>:</span><br><span class="line">  (<span class="keyword">use</span> <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">update</span> what will be committed)</span><br><span class="line">  (<span class="keyword">use</span> <span class="string">"git checkout -- &lt;file&gt;..."</span> <span class="keyword">to</span> discard changes <span class="keyword">in</span> working <span class="keyword">directory</span>)</span><br><span class="line"></span><br><span class="line">    modified:   README.md</span><br><span class="line"></span><br><span class="line"><span class="keyword">no</span> changes added <span class="keyword">to</span> <span class="keyword">commit</span> (<span class="keyword">use</span> <span class="string">"git add"</span> <span class="keyword">and</span>/<span class="keyword">or</span> <span class="string">"git commit -a"</span>)</span><br><span class="line">$ git checkout README.md </span><br><span class="line">$ git <span class="keyword">status</span></span><br><span class="line"><span class="keyword">On</span> branch <span class="keyword">master</span></span><br><span class="line">Your branch <span class="keyword">is</span> up-<span class="keyword">to</span>-<span class="built_in">date</span> <span class="keyword">with</span> <span class="string">'origin/master'</span>.</span><br><span class="line"><span class="keyword">nothing</span> <span class="keyword">to</span> <span class="keyword">commit</span>, working <span class="keyword">directory</span> clean</span><br></pre></td></tr></table></figure></p>
<h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p><a href="http://blog.csdn.net/u013474436/article/details/51287128" target="_blank" rel="noopener">使用Git进行团队开发</a><br><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013760174128707b935b0be6fc4fc6ace66c4f15618f8d000" target="_blank" rel="noopener">廖雪峰多人协作</a></p>
]]></content>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>读《智能时代》</title>
    <url>/blog/2017/10/read-intelligent-age.html</url>
    <content><![CDATA[<p>&emsp;&emsp;曾经读过吴军博士所著的《浪潮之巅》，讲述了世界各大IT公司的兴衰历程与缘由，令人心潮澎湃，这本《智能时代》也没有令人失望，读起来令人深受启发，也令人警醒，用一句话来总结这本书的核心思想就是：大数据和机器智能正在全方位的改变人类社会，新的科技革命已经开始。面对这场革命，无论对于谁，国家、企业，还是个人，只有两条路可选：要么加入浪潮，成为2%，要么被淘汰出局。很多时候，处于历史浪潮中的人，并没有意识到这个时代的方向，也只不过随波逐流，得过且过，总以为时代的浪潮不会来的这样快，最近几年来，人工智能，深度学习，大数据，这些曾经只是虚无缥缈概念的事物逐渐成为现实，智能时代即将到来，要么拥抱，要么出局，人啊，不应该无动于衷。</p>
<p>&emsp;&emsp;当今世界，仍有不少人，对人工智能的发展并不了解，对于AI的了解大概还只来自与电影或者一些陈词滥调，什么机器人只能从事一些固定的工作，而创造性是人类所独有的。这种说法，很难说到底是高估了还是低估了人类的智慧。但不论怎么说，现如今的AI，在大数据时代，已经不再是那些只能从事确定性的工作，接受固定指令的机器了，现如今，大数据已经可以解决一些不确定性问题。</p>
<blockquote>
<p>“用不确定的眼光看待世界，再用信息来消除这种不确定性”，是大数据解决智能问题的本质。吴军博士在书中提到了世界的不确定性来自两个方面，一是影响世界的变量太多以至于无法用数学模型来描述；二是来自客观世界本身：不确定性是我们所在宇宙的特性。因此，机械论已经完全无法对未来进行预测。香农通过热力学中“熵”的概念引入了“信息熵”，用信息论将世界的不确定信息联系在了一起。这个建立在不确定性上的理论，正是今天人类研究大数据与机器智能的基石。解决智能问题，就是将问题转化为消除不确定性的问题，大数据则是解决不确定性问题的良药。</p>
</blockquote>
<p>书中提出的一个理论很有意思，颇有令人茅塞顿开之感，香农引入信息熵的概念，问题的不确定性越大，则信息熵越大，而输入数据可以减少信息熵，则将不确定性问题成功的转换为了一个大数据问题，使得AI可以实现识别语音，识别图片，可以下围棋，也可以自动驾驶。就如同飞机要飞，并不是模仿鸟类，而是了解了空气动力学一样，解决不确定性问题，实现人工智能，也不一定要通过模仿人类，而可以通过数据驱动的方式实现 。</p>
<p>&emsp;&emsp;本书的第三章，思维的革命，甚是出彩，在无法确定因果关系时，数据为我们提供了解决问题的新方法，数据中所包含的信息可以帮助我们消除不确定性，而数据之间的相关性在某种程度上可以取代原来的因果关系，帮助我们得到我们想知道的答案，这便是大数据思维的核心。自从17世纪以来，一直是机械思维在指导着科学进步与工业革命，这里的机械思维并不是我们通常所指的那种贬义，机械思维在人类的进步中曾经并且仍在发挥着重要的作用，核心思想大概如下：<br>1.世界变化的规律是确定的<br>2.因为有确定性做保障，因为规律不仅可以被认识的，而且可以用简单的公式或者语言描述清楚<br>3.这些规律应该是通用的，可以应用到各种未知的领域。<br>但我们面对的世界是越来越不确定性的，不确定性是无处不在的，我们经常会看到一个现象，就是很多专家们对于未来各种趋势的预测是错的，这在金融领域是很常见的。影响世界的变量非常非常多，已经无法通过简单的办法或公式算出结果，所以我们宁愿采用一些针对随机事件的方法来处理。这个时候，大数据的作用就显现出来了，虽然我们承认不确定性的存在，但是并非没有规律可循，通常可以用概率模型来描述，进而引进一个信息论，也是给人们看待世界和处理问题的新思路。</p>
<blockquote>
<p>首先我们必须承认世界的不确定性，这样我们就不会采用确定性的思维方式去面对一个不确定性的世界，当我们了解到信息或者说数据能消除不确定性之后，便能理解为什么大数据的出现能够解决哪些智能问题。数据为我们提供了解决问题的新方法，数据中包含的信息可以帮助我们消除不确定性，而数据之间的相关性在某种程度上可以取代原来的因果关系，这便是大数据思维的核心。大数据思维和原来机械思维并非完全对立，它更多的是对后者的补充，在新的时代，一定需要新的方法论，也会产生新的方法论。</p>
</blockquote>
<p>&emsp;&emsp;现如今，深度学习越来越火，已经是IT行业毕业生的首选，智能时代即将到来，每一次技术变革，对社会的冲击都是全方面的，我们所依赖的那些所谓要靠智力的工作也要消失，即使有新的行业出现，由于机器智能影响，他们所需要的就业人数相比过去的老行业机会也少很多，在智能革命全面到来的时候，不可能像过去那样，把农业人口变成城市人口，把第一产业、第二产业变成第三产业那么简单。在现代社会，生产越来越不是问题，问题在于没有人消费，要养活全球70亿人口，可能只需要几千万农业人口就够了，要生产出足够的工业品，可能几亿也就够了，在智能时代，可能要更少，新的时代，必然会导致现阶段大量劳动力的淘汰，其中只有一小部分能够成功转型，这对我们的世界是个难题，我们该怎么办呢？<br>作者的答案很简单，对于个人来说，就是争取做2%的人，而不是自豪地宣称自己是98%的人，那该如何做2%的人呢，就是踏上智能革命的浪潮，勇当2%。哈哈，最后听起来有点像成功学了呢。</p>
]]></content>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>一根网络连接树莓派</title>
    <url>/blog/2017/08/raspberry-connect-try.html</url>
    <content><![CDATA[<p>我们当然可以远程登陆树莓派，但我们要先开机，连上wifi,才能远程登陆上去啊，不过没有显示器，该怎么操作呢？</p>
<h3 id="一、使用ssh客户端连接到raspberry的命令端"><a href="#一、使用ssh客户端连接到raspberry的命令端" class="headerlink" title="一、使用ssh客户端连接到raspberry的命令端"></a>一、使用ssh客户端连接到raspberry的命令端</h3><p>1、准备材料：<br>一根网线、装有系统的内存卡（不少于8G）、树莓派</p>
<p>2、连线：<br>将网线一端接到树莓派，另一端接到笔记本； 树莓派接好供电线，开机，让树莓派自动获取IP地址。</p>
<p>3、将电脑的网络共享给树莓派：<br>首先将笔记本通过WIFI连接到互联网，然后将无线网卡的互联网资源共享给本地连接。</p>
<p>具体操作：同时按住“win+x”——控制面板——网络和Internet——网络和共享中心——查看活动网络——找到无线网络连接左点击——右键“属性”——在共享选项卡上选中“允许其他网络用户通过此计算机的Internet连接来连接”</p>
<p>4、查找树莓派的IP地址：<br>运行DOS窗口(同时按住“win+R”，输入“cmd”)，输入“arp -a”，一般192.168.137.1地址就是树莓派的地址.</p>
<p>5、利用PuTTY软件连接树莓派<br>输入用户名与密码<br>Login as：pi<br>Password:raspberry</p>
<p><strong>6.注意</strong><br>11月之后的raspbian的ssh默认是关闭的，一个最简单的解决办法是，把内存卡插到电脑里，在内存卡根目录下建立一个名字是SSH的文件，不要后缀名，就能打开SSH了</p>
<h3 id="二、使用VNC客户端本地连接或云端连接到raspberry的界面"><a href="#二、使用VNC客户端本地连接或云端连接到raspberry的界面" class="headerlink" title="二、使用VNC客户端本地连接或云端连接到raspberry的界面"></a>二、使用VNC客户端本地连接或云端连接到raspberry的界面</h3><p>1、启用VNC服务器：<br>在你的Raspberry Pi上，运行以下命令以确保拥有最新版本的VNC Connect：<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">sudo apt-<span class="builtin-name">get</span> update</span><br><span class="line">sudo apt-<span class="builtin-name">get</span> install realvnc-vnc-server realvnc-vnc-viewer</span><br></pre></td></tr></table></figure></p>
<p>2.在命令行中启用VNC Serve<br>运行sudo raspi-config，在第5个选项中enable VNC Serve.</p>
<p>3、在笔记本上使用VNC Viewer连接到你的树莓派：<br>在你的Raspberry Pi（使用终端窗口或通过SSH）使用这些说明或运行“ifconfig”命令来找到树莓派的IP地址。<br>下载安装VNC Viewer后输入地址，然后输入用户名与密码即可</p>
<p>4。连接成功<br>连接成功后，连上wifi,就可以远程登陆，不要网线了，并且以后开机会自动连接wifi。</p>
<p>树莓派上竟然还可以玩mincraft,真是太神奇了，好玩。</p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://zhuanlan.zhihu.com/p/26149244?utm_source=qq&amp;utm_medium=social" target="_blank" rel="noopener">没有屏幕和键盘如何玩转树莓派</a><br><a href="https://zhuanlan.zhihu.com/p/20794478" target="_blank" rel="noopener">树莓派 Raspberry Pi 3 无显示器安装</a></p>
]]></content>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin基础语法</title>
    <url>/blog/2017/08/kotlin-basic-grammer.html</url>
    <content><![CDATA[<p>Kotlin 是一个基于 JVM 的新的编程语言，由 JetBrains 开发,由于被Google指定为Android官方支持的语言而开始火爆了。<br>下面就开始介绍kotlin的常用基础语法啦：</p>
<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>在Kotlin中常量用val声明，变量用var声明，关键字在前面，类型以冒号:隔开在后面，也可以省略类型直接赋值，类型后带问号?表示可为空类型(默认空安全)。<br><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">//常量数组int[<span class="string"></span>][<span class="symbol"></span>][<span class="string"></span>] arrs = new int[<span class="string">3</span>][<span class="symbol">2</span>][<span class="string">1</span>];</span><br><span class="line">val arrs = Array(3) &#123; Array(2) &#123; IntArray(1) &#125; &#125;</span><br><span class="line">//空安全变量</span><br><span class="line">var str: String = "hello"</span><br><span class="line">var str1 = "word"</span><br><span class="line">//可为空字符串变量</span><br><span class="line">var str2: String? = null</span><br></pre></td></tr></table></figure></p>
<h4 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h4><p>if…else 正常使用，不过移除了switch用更强大的when替代，when子式可以是常量、变量、返回数值的表达式、返回Boolean值的表达式，强大到可以用来替换if…else if<br><figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试值 x = 0, -1, 1, 2, 3, 6, 10</span></span><br><span class="line">var x = <span class="number">10</span></span><br><span class="line"><span class="keyword">when</span> (x) &#123;</span><br><span class="line">    <span class="comment">//常量</span></span><br><span class="line">    <span class="number">2</span> -&gt; println(<span class="string">"等于2"</span>)</span><br><span class="line">    <span class="comment">//数值表达式</span></span><br><span class="line">    <span class="function"><span class="title">if</span> (x &gt; 0) 1 <span class="keyword">else</span> -1 -&gt;</span> println(<span class="string">"大于0并等于1，或小于0并等于-1"</span>)</span><br><span class="line">    <span class="comment">//Boolean类型表达式</span></span><br><span class="line">    <span class="function"><span class="title">in</span> 1..5 -&gt;</span> println(<span class="string">"范围匹配1-5"</span>)</span><br><span class="line">    !<span class="function"><span class="title">in</span> 6..9 -&gt;</span> println(<span class="string">"不是6-9"</span>)</span><br><span class="line">    <span class="function"><span class="title">is</span> Int -&gt;</span> println(<span class="string">"类型判断"</span>)</span><br><span class="line">    <span class="function"><span class="title">else</span> -&gt;</span> println(<span class="string">"else"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 代替if...else if</span></span><br><span class="line"><span class="keyword">when</span>&#123;</span><br><span class="line">    <span class="function"><span class="title">x</span> &gt; 6 &amp;&amp; x &lt;= 10  -&gt;</span>  println(<span class="string">"大于6小于等于10"</span>)</span><br><span class="line">    <span class="function"><span class="title">x</span> &lt; 6 -&gt;</span> println(<span class="string">"小于6"</span>)</span><br><span class="line">    <span class="function"><span class="title">else</span> -&gt;</span> println(<span class="string">"else"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><p>while 和 do…while 同Java并无区别，for则有很大改变并多出了几个变种<br><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">val <span class="built_in">list</span> = arrayListOf(<span class="string">"aa"</span>, <span class="string">"bb"</span>, <span class="string">"cc"</span>)</span><br><span class="line"><span class="comment">//递增for (int i = 0; i &lt; list.size(); i++)</span></span><br><span class="line"><span class="keyword">for</span> (i in <span class="built_in">list</span>.indices) &#123;</span><br><span class="line">   <span class="built_in">print</span>(<span class="built_in">list</span>[i])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//递增for (int i = 2; i &lt; list.size(); i++)</span></span><br><span class="line"><span class="keyword">for</span> (i in <span class="number">2.</span>.<span class="built_in">list</span>.<span class="built_in">size</span><span class="number">-1</span>) &#123;</span><br><span class="line">   <span class="built_in">print</span>(<span class="built_in">list</span>[i])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//递减for (int i = list.size() - 1; i &gt;= 0; i--)</span></span><br><span class="line"><span class="keyword">for</span> (i in <span class="built_in">list</span>.<span class="built_in">size</span> - <span class="number">1</span> downTo <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">list</span>[i])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//操作列表内的对象</span></span><br><span class="line"><span class="keyword">for</span> (item in <span class="built_in">list</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//加强版</span></span><br><span class="line"><span class="keyword">for</span>（（i， item） in <span class="built_in">list</span>.witnIndex()） &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">list</span>[i])</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//变种版</span></span><br><span class="line"><span class="built_in">list</span>.forEach &#123;</span><br><span class="line">    <span class="built_in">print</span>(it)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>.forEach &#123;</span><br><span class="line">    <span class="built_in">print</span>(it)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>.forEachIndexed &#123; i, s -&gt;</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">list</span>[i])</span><br><span class="line">    <span class="built_in">print</span>(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>.forEachIndexed(object :(Int,<span class="keyword">String</span>) -&gt; Unit&#123;</span><br><span class="line">    <span class="keyword">override</span> fun invoke(i: Int, s: <span class="keyword">String</span>) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">list</span>[i])</span><br><span class="line">        <span class="built_in">print</span>(s)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h4 id="万能的冒号"><a href="#万能的冒号" class="headerlink" title="万能的冒号"></a>万能的冒号</h4><p>在Kotlin中冒号:用万能来称呼绝不为过。常量变量的类型声明，函数的返回值，类的继承都需要它<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//val表示常量var表示变量声明</span></span><br><span class="line"><span class="keyword">val</span> name: String = <span class="string">"tutu"</span> </span><br><span class="line"><span class="comment">//省略类型说明</span></span><br><span class="line"><span class="keyword">var</span> age = <span class="string">"23"</span></span><br><span class="line"><span class="comment">//fun表示函数</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getName</span><span class="params">()</span></span>: String&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">"tutu"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//类继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserList</span>&lt;<span class="type">E</span>&gt;</span>(): ArrayList&lt;E&gt;() &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu下搭建discuz论坛</title>
    <url>/blog/2018/01/ubuntu-build-discuz.html</url>
    <content><![CDATA[<p>PHP还是很强大的，所说世界上80%的网页都是PHP做的，哈哈，不过其中大部分是WordPress，discuz也是基于PHP的一套通用的社区论坛软件系统，可以帮助人们快速搭建一个论坛系统。</p>
<p>Discuz的搭建步骤如下：</p>
<h3 id="准备-LAMP-环境"><a href="#准备-LAMP-环境" class="headerlink" title="准备 LAMP 环境"></a>准备 LAMP 环境</h3><h4 id="安装-Apache2"><a href="#安装-Apache2" class="headerlink" title="安装 Apache2"></a>安装 Apache2</h4><p>ubuntu 需要安装 Apache2 ，使用 apt-get 安装 Apache2：<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">sudo apt-<span class="builtin-name">get</span> install apache2 -y</span><br></pre></td></tr></table></figure></p>
<p>安装好后，您可以通过访问你的IP地址，查看到 apache 界面，说明 apache2 安装成功。</p>
<h4 id="安装-PHP-组件"><a href="#安装-PHP-组件" class="headerlink" title="安装 PHP 组件"></a>安装 PHP 组件</h4><p>apt-get 里有 php7.0 ，所以我们可以直接安装 php7.0 ：<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">sudo apt-<span class="builtin-name">get</span> install php7.0 -y</span><br></pre></td></tr></table></figure></p>
<p>安装 php 相关组件：<br><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">sudo apt-<span class="keyword">get</span> install libapache2-<span class="keyword">mod</span>-php7<span class="number">.0</span></span><br></pre></td></tr></table></figure></p>
<p>重启 Apache 服务：<br><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">sudo <span class="regexp">/etc/i</span>nit.d<span class="regexp">/apache2 restart</span></span><br></pre></td></tr></table></figure></p>
<h4 id="安装-MySQL-服务"><a href="#安装-MySQL-服务" class="headerlink" title="安装 MySQL 服务"></a>安装 MySQL 服务</h4><p>安装 MySQL 服务，安装 MySQL 过程中，控制台会提示您输入MySQL的密码，您需要输入两次密码，并记住您输入的密码，后续安装步骤需要用到。<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">sudo apt-<span class="builtin-name">get</span> install mysql-server -y</span><br></pre></td></tr></table></figure></p>
<p>安装 php MySQL 相关组件：<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">sudo apt-<span class="builtin-name">get</span> install php7.0-mysql</span><br></pre></td></tr></table></figure></p>
<p>重启 MySQL 服务<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">sudo<span class="built_in"> service </span>mysql restart</span><br></pre></td></tr></table></figure></p>
<h4 id="安装-phpmyadmin"><a href="#安装-phpmyadmin" class="headerlink" title="安装 phpmyadmin"></a>安装 phpmyadmin</h4><p>使用 apt-get 安装 phpmyadmin，安装过程中，您需要根据提示选择 apache2 ，再根据提示输入数据库名称和 phpmyadmin 密码。<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">sudo apt-<span class="builtin-name">get</span> install phpmyadmin -y</span><br></pre></td></tr></table></figure></p>
<h3 id="安装并配置Discuz"><a href="#安装并配置Discuz" class="headerlink" title="安装并配置Discuz"></a>安装并配置Discuz</h3><h4 id="安装-Discuz"><a href="#安装-Discuz" class="headerlink" title="安装 Discuz"></a>安装 Discuz</h4><p>我们需要下载一个Discuz 压缩包：<br><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">wget</span> <span class="string">'http://download.comsenz.com/DiscuzX/3.3/Discuz_X3.3_SC_UTF8.zip'</span></span><br></pre></td></tr></table></figure></p>
<p>为了将压缩包解压，需要安装一个 unzip ：<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">sudo apt-<span class="builtin-name">get</span> install unzip</span><br></pre></td></tr></table></figure></p>
<p>下载完成后，解压这个压缩包<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">sudo</span> <span class="selector-tag">unzip</span> <span class="selector-tag">Discuz_X3</span><span class="selector-class">.3_SC_UTF8</span><span class="selector-class">.zip</span></span><br></pre></td></tr></table></figure></p>
<p>解压完后，就能在 upload 文件夹里看到discuz的源码了</p>
<h4 id="配置-Discuz"><a href="#配置-Discuz" class="headerlink" title="配置 Discuz"></a>配置 Discuz</h4><p>由于 PHP 默认访问 /var/www/html/ 文件夹，所以我们需要把 upload 文件夹里的文件都复制到 /var/www/html/ 文件夹<br><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">sudo mv upload<span class="regexp">/* /</span>var<span class="regexp">/www/</span>html<span class="regexp">/</span></span><br></pre></td></tr></table></figure></p>
<p>将目录切换到 php 访问的文件夹下，<br><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">cd <span class="regexp">/var/</span>www<span class="regexp">/html/</span></span><br></pre></td></tr></table></figure></p>
<p>修改一下 config、data、uc_server/data/、uc_client/data/cache 目录权限：<br><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">sudo</span> chmod -<span class="type">R</span> <span class="number">777</span> config/ <span class="class"><span class="keyword">data</span>/ uc_server/<span class="keyword">data</span>/ uc_client/<span class="keyword">data</span>/cache/</span></span><br></pre></td></tr></table></figure></p>
<p>将 apache 指定到 index.html<br><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">sudo mv <span class="regexp">/var/</span>www<span class="regexp">/html/i</span>ndex.html <span class="regexp">/var/</span>www<span class="regexp">/html/i</span>ndex~.html</span><br></pre></td></tr></table></figure></p>
<p>重启 Apache 服务：<br><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">sudo <span class="regexp">/etc/i</span>nit.d<span class="regexp">/apache2 restart</span></span><br></pre></td></tr></table></figure></p>
<h3 id="安装Discuz"><a href="#安装Discuz" class="headerlink" title="安装Discuz"></a>安装Discuz</h3><p>配置好后，就可以一步步安装了<br>可访问<a href="http://www.yourdomain.com/install进行安装" target="_blank" rel="noopener">http://www.yourdomain.com/install进行安装</a><br>详情可见：<a href="https://jingyan.baidu.com/article/86f4a73e5bb53237d652693c.html" target="_blank" rel="noopener">discuz论坛安装教程</a></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>腾讯云的开发者实验室挺强大<br><a href="https://cloud.tencent.com/developer/labs/lab/10102" target="_blank" rel="noopener">基于 Ubuntu 搭建 Discuz 论坛</a></p>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序入门</title>
    <url>/blog/2017/10/weixin-program-start.html</url>
    <content><![CDATA[<p>微信小程序自从发布以来，到现在，热度好像没有刚出来时那么火爆了，所以官方现在也在逐渐放开一些约束与限制，不过微信的跨平台特性，优势还是很大的，现在赶个晚集，尝试一下微信小程序开发。</p>
<h4 id="注册微信小程序"><a href="#注册微信小程序" class="headerlink" title="注册微信小程序"></a>注册微信小程序</h4><p>注册微信小程序最坑的是，不能用绑定微信或者公众号的邮箱，只能重新申请一个了。<br>申请了小程序后，只要把AppID记下来就好啦，等下用的到。</p>
<h4 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h4><p>我们需要通过开发者工具，来完成小程序创建和代码编辑。<br>现在的开发者工具，比起刚出来时，已经强多了，不错。<br>开发者工具安装完成后，打开并使用微信扫码登录。选择创建“项目”，填入上文获取到的 AppID ，设置一个本地项目的名称（非小程序名称），比如“我的第一个项目”，并选择一个本地的文件夹作为代码存储的目录，点击“新建项目”就可以了</p>
<h4 id="小程序的结构"><a href="#小程序的结构" class="headerlink" title="小程序的结构"></a>小程序的结构</h4><p>小程序创建时，已经初始化并包含了一些简单的代码文件。最关键也是必不可少的，是 app.js、app.json、app.wxss 这三个。其中，.js后缀的是脚本文件，.json后缀的文件是配置文件，.wxss后缀的是样式表文件。微信小程序会读取这些文件，并生成小程序实例。</p>
<p>下面我们简单了解这三个文件的功能，方便修改以及从头开发自己的微信小程序。</p>
<p>app.js是小程序的脚本代码。我们可以在这个文件中监听并处理小程序的生命周期函数、声明全局变量。调用框架提供的丰富的 API，如本例的同步存储及同步读取本地数据。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//app.js</span></span><br><span class="line">App(&#123;</span><br><span class="line">  onLaunch: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 展示本地存储能力</span></span><br><span class="line">    <span class="keyword">var</span> logs = wx.getStorageSync(<span class="string">'logs'</span>) || []</span><br><span class="line">    logs.unshift(<span class="built_in">Date</span>.now())</span><br><span class="line">    wx.setStorageSync(<span class="string">'logs'</span>, logs)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 登录</span></span><br><span class="line">    wx.login(&#123;</span><br><span class="line">      success: <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 发送 res.code 到后台换取 openId, sessionKey, unionId</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 获取用户信息</span></span><br><span class="line">    wx.getSetting(&#123;</span><br><span class="line">      success: <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (res.authSetting[<span class="string">'scope.userInfo'</span>]) &#123;</span><br><span class="line">          <span class="comment">// 已经授权，可以直接调用 getUserInfo 获取头像昵称，不会弹框</span></span><br><span class="line">          wx.getUserInfo(&#123;</span><br><span class="line">            success: <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">              <span class="comment">// 可以将 res 发送给后台解码出 unionId</span></span><br><span class="line">              <span class="keyword">this</span>.globalData.userInfo = res.userInfo</span><br><span class="line"></span><br><span class="line">              <span class="comment">// 由于 getUserInfo 是网络请求，可能会在 Page.onLoad 之后才返回</span></span><br><span class="line">              <span class="comment">// 所以此处加入 callback 以防止这种情况</span></span><br><span class="line">              <span class="keyword">if</span> (<span class="keyword">this</span>.userInfoReadyCallback) &#123;</span><br><span class="line">                <span class="keyword">this</span>.userInfoReadyCallback(res)</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  globalData: &#123;</span><br><span class="line">    userInfo: <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>app.json 是对整个小程序的全局配置。我们可以在这个文件中配置小程序是由哪些页面组成，配置小程序的窗口背景色，配置导航条样式，配置默认标题。注意该文件不可添加任何注释<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"pages"</span>:[</span><br><span class="line">    <span class="string">"pages/index/index"</span>,</span><br><span class="line">    <span class="string">"pages/logs/logs"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"window"</span>:&#123;</span><br><span class="line">    <span class="attr">"backgroundTextStyle"</span>:<span class="string">"light"</span>,</span><br><span class="line">    <span class="attr">"navigationBarBackgroundColor"</span>: <span class="string">"#fff"</span>,</span><br><span class="line">    <span class="attr">"navigationBarTitleText"</span>: <span class="string">"WeChat"</span>,</span><br><span class="line">    <span class="attr">"navigationBarTextStyle"</span>:<span class="string">"black"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>app.wxss 是整个小程序的公共样式表。我们可以在页面组件的 class 属性上直接使用 app.wxss 中声明的样式规则。<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**app.wxss**/</span></span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-direction</span>: column;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">  <span class="attribute">justify-content</span>: space-between;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">200</span>rpx <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="创建页面"><a href="#创建页面" class="headerlink" title="创建页面"></a>创建页面</h4><p>在这个教程里，我们有两个页面，index 页面和 logs 页面，即欢迎页和小程序启动日志的展示页，他们都在 pages 目录下。微信小程序中的每一个页面的【路径+页面名】都需要写在 app.json 的 pages 中，且 pages 中的第一个页面是小程序的首页。</p>
<p>每一个小程序页面是由同路径下同名的四个不同后缀文件的组成，如：index.js、index.wxml、index.wxss、index.json。.js后缀的文件是脚本文件，.json后缀的文件是配置文件，.wxss后缀的是样式表文件，.wxml后缀的文件是页面结构文件。</p>
<p>详情参见：<a href="https://mp.weixin.qq.com/debug/wxadoc/dev/" target="_blank" rel="noopener">https://mp.weixin.qq.com/debug/wxadoc/dev/</a></p>
<h4 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h4><p>微信小程序自带模拟器与控制台，还是比较方便的<br>同时可以通过扫码在手机端调试</p>
<h4 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h4><p>小程序初步完成后，需要上传代码，提交审核，并发布，审核大概需要1天左右，审核完毕后就可以发布了。<br>小程序的后台管理系统比较完善，可以比较全面的看到用户画像，做好用户分析与统计</p>
<p><a href="https://github.com/shenzhen2017/weixinPhoneCalculate" target="_blank" rel="noopener">第一个微信小程序</a></p>
]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>chrome调试webview</title>
    <url>/blog/2018/01/chrome-debug-webview.html</url>
    <content><![CDATA[<p>现如今在Android开发中，前端技术用的是越来越多了，webview的使用自然也越来越频繁了，有时也需要调试移动端的JS代码，google也为我们提供了工具，经过了一番尝试，终于成功，具体步骤如下。</p>
<h3 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h3><ul>
<li>开发计算机上已安装 Chrome 32 或更高版本。</li>
<li>开发计算机上已安装 USB 驱动程序（如果您使用 Windows）。 确保设备管理器报告正确的 USB 驱动程序</li>
<li>拥有一根可以将您的 Android 设备连接至开发计算机的 USB 电缆。</li>
<li>Android 4.0 或更高版本。</li>
<li>您的 Android 设备上已安装 Chrome（Android 版）</li>
</ul>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><h4 id="第-1-步：发现您的-Android-设备"><a href="#第-1-步：发现您的-Android-设备" class="headerlink" title="第 1 步：发现您的 Android 设备"></a>第 1 步：发现您的 Android 设备</h4><p>1.在您的 Android 设备上，选择 Settings &gt; Developer Options &gt; Enable USB Debugging。 在运行 Android 4.2 及更新版本的设备上，Developer options 默认情况下处于隐藏状态。 请参阅启用设备上的开发者选项以了解如何启用它。<br>2.在您的开发计算机上打开 Chrome。您应使用您的一个 Google 帐户登录到 Chrome。 远程调试在隐身模式或访客模式下无法运行。<br>3.打开 DevTools。<br>4.在 DevTools 中，点击 Main Menu 主菜单，然后选择 More tools &gt; Remote devices。<br>5.在 DevTools 中，点击 Settings 标签（如果正在显示另一个标签）。<br>6.确保已启用 Discover USB devices。<br>7.使用一根 USB 电缆将 Android 设备直接连接到您的开发计算机。 请勿使用任何中间 USB 集线器。如果这是您首次将您的 Android 设备连接到此开发计算机，您的设备将显示在 Unknown 中，其下面具有文本 Pending Authorization。<br>8.如果您的设备显示为 Unknown，则在 Android 设备上接受 Allow USB Debugging 权限提示。 Unknown 被替换为您的 Android 设备的型号名称。 绿色圆圈和 Connected 文本表示您已大功告成，可以从开发计算机远程调试您的 Android 设备。</p>
<p><strong>注意</strong><br>电脑上的chrome一定要登陆账号，我就是因为没有登陆账号所以失败了很多次，最后才发现原因<br>如果chrome没有发现你的设备，可以重新打开开发者选项试试。</p>
<h4 id="第-2-步：从您的开发计算机调试-Android-设备上的内容。"><a href="#第-2-步：从您的开发计算机调试-Android-设备上的内容。" class="headerlink" title="第 2 步：从您的开发计算机调试 Android 设备上的内容。"></a>第 2 步：从您的开发计算机调试 Android 设备上的内容。</h4><p>1.如果您尚未在 Android 设备上打开 Chrome，则现在打开它。<br>2.返回 DevTools，点击与设备的型号名称匹配的标签。 在此页面的顶部，您会看到 Android 设备的型号名称，后面紧跟着其序列号。 在型号名称下面，您可以看到在设备上运行的 Chrome 的版本，版本号在括号里。每个打开的 Chrome 标签都会有自己的区域。您可以从此区域与该标签交互。 如果有任何使用 WebView 的应用，您也会看到针对每个应用的区域<br>3.在 New tab 旁输入一个网址，然后点击 Open。此页面将在 Android 设备上的新标签中打开。<br>4.点击您刚刚打开的网址旁的 Inspect。这将打开一个新的 DevTools 实例。 您的 Android 设备上运行的 Chrome 的版本决定在开发计算机上打开的 DevTools 的版本。因此，如果您的 Android 设备正在运行一个非常旧的 Chrome 版本，则 DevTools 实例看上去可能与您常用的实例有很大的差别。</p>
<h4 id="调试webview"><a href="#调试webview" class="headerlink" title="调试webview"></a>调试webview</h4><p>通过上面的步骤已经可以调试android上的chrome页面，而要调试我们自己的webview，还要再加入一些代码设置<br>调试WebView需要满足安卓系统版本为Android 4.4+已上。并且需要再你的APP内配置相应的代码，在WebView类中调用静态方法setWebContentsDebuggingEnabled，如下：<br><figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line">if (<span class="keyword">Build</span>.VERSION.SDK_INT &gt;=<span class="keyword">Build</span>.VERSION_CODES.KITKAT) &#123;  </span><br><span class="line">   WebView.setWebContentsDebuggingEnabled(<span class="literal">true</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://developers.google.com/web/tools/chrome-devtools/remote-debugging/" target="_blank" rel="noopener">远程调试 Android 设备使用入门</a><br><a href="http://blog.csdn.net/freshlover/article/details/42528643" target="_blank" rel="noopener">移动端Web开发调试之Chrome远程调试</a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>TensorFlow的Android移植</title>
    <url>/blog/2018/01/tensorflow-android-usage.html</url>
    <content><![CDATA[<p>本文主要借由一个手写数字识别的例子，实现在机器学习在Android手机上的应用</p>
<p>要在手机上实现手写数字识别，主要分为以下几个步骤</p>
<p>1.训练手写数字识别的神经网络</p>
<p>首先需要训练用于手写数字识别的神经网络，最后需要将训练后网络的拓扑结构和参数保存为pb文件</p>
<p>2.构建TensorFlow Android开发环境</p>
<p>3.将pb文件引入Android工程中，并基于<code>TensorFlowInferenceInterface</code>类完成识别。</p>
<h4 id="训练生成pb文件"><a href="#训练生成pb文件" class="headerlink" title="训练生成pb文件"></a>训练生成pb文件</h4><p>tensorflow有多种文件保存类型，其中pb文件中保存了网络的拓扑结构和参数，具体与其他文件类型的区别可以参见：<a href="https://www.tensorflow.org/mobile/prepare_models" target="_blank" rel="noopener">https://www.tensorflow.org/mobile/prepare_models</a></p>
<p>为了得到pb文件，我们需要训练并保存网络</p>
<h5 id="给网络拓扑中的关键节点指定名称"><a href="#给网络拓扑中的关键节点指定名称" class="headerlink" title="给网络拓扑中的关键节点指定名称"></a>给网络拓扑中的关键节点指定名称</h5><p>网络的输入节点和输出节点在使用<code>tf.placeholder</code>定义的时候必须要通过<code>name</code>形参指定名称，便于在将模型移植到Android后可以通过名称来获取指定节点的值，或者给指定节点赋值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = tf.placeholder(tf.float32, [<span class="literal">None</span>, height, width], name=<span class="string">'input'</span>)  <span class="comment">#输入节点的名字这里取名为'input'</span></span><br><span class="line">sofmax_out = tf.nn.softmax(logits,name=<span class="string">"out_softmax"</span>) <span class="comment">#输出节点</span></span><br><span class="line"><span class="comment"># keep_prob_placeholder这个节点也命名了，便于后期用于区分训练和测试。</span></span><br><span class="line">keep_prob_placeholder = tf.placeholder(tf.float32, name=<span class="string">'keep_prob_placeholder'</span>)</span><br></pre></td></tr></table></figure>
<h5 id="将训练好后的网络模型保存为pb文件"><a href="#将训练好后的网络模型保存为pb文件" class="headerlink" title="将训练好后的网络模型保存为pb文件"></a>将训练好后的网络模型保存为pb文件</h5><p>通过convert_variables_to_constants(sess,input_graph_def,output_node_names,variable_names_whitelist=None)函数实现的，convert_variables_to_constants完成如下两件事情</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">convert_variables_to_constants()</span><br><span class="line">does <span class="literal">two</span> things:</span><br><span class="line">It freezes <span class="keyword">the</span> weights <span class="keyword">by</span> replacing variables <span class="keyword">with</span> constants</span><br><span class="line">It removes nodes which are <span class="keyword">not</span> related <span class="built_in">to</span> feedforward prediction</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow.python.framework <span class="keyword">import</span> graph_util</span><br><span class="line"></span><br><span class="line">constant_graph = graph_util.convert_variables_to_constants(sess, sess.graph_def, [<span class="string">"out_softmax"</span>])</span><br><span class="line"><span class="keyword">with</span> tf.gfile.FastGFile(pb_file_path,mode=<span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(constant_graph.SerializeToString())</span><br></pre></td></tr></table></figure>
<h4 id="构建TensorFlow-Android开发环境"><a href="#构建TensorFlow-Android开发环境" class="headerlink" title="构建TensorFlow Android开发环境"></a>构建TensorFlow Android开发环境</h4><p>构建TensorFlow的Android开发环境的方式主要有两种</p>
<h5 id="使用Bazel构建"><a href="#使用Bazel构建" class="headerlink" title="使用Bazel构建"></a>使用Bazel构建</h5><ol>
<li>安装 Bazel,Android NDK,Android SDK</li>
<li>下载TensorFlow源码，修改项目根目录下的WORKSPACE文件</li>
<li>构建so库</li>
<li>构建jar包</li>
<li>将jar包与so库引入Android项目中</li>
</ol>
<h5 id="利用gradle构建"><a href="#利用gradle构建" class="headerlink" title="利用gradle构建"></a>利用gradle构建</h5><p>可能是因为tensorflow版本的原因，之前的版本仍需自己编译tensorflow源码，现在已经可以利用gradle来构建啦</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">compile <span class="string">'org.tensorflow:tensorflow-android:+'</span></span><br></pre></td></tr></table></figure>
<p>真的是方便了许多呢，之前的环境搭建可真是要命，现在只需要在gradle引入，即可在工程中利用TensorFlowInferenceInterface实现识别</p>
<h5 id="使用TensorFlowInferenceInterface完成识别"><a href="#使用TensorFlowInferenceInterface完成识别" class="headerlink" title="使用TensorFlowInferenceInterface完成识别"></a>使用TensorFlowInferenceInterface完成识别</h5><p>1.将pb文件复制到assets目录下</p>
<p>2.定义一些关键的常量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String MODEL_FILE = <span class="string">"file:///android_asset/mnist-tf1.0.1.pb"</span>; <span class="comment">//asserts		目录下的pb文件名字</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String INPUT_NODE = <span class="string">"input"</span>;       <span class="comment">//输入节点的名称</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String OUTPUT_NODE = <span class="string">"out_softmax"</span>;  <span class="comment">//输出节点的名称</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEEP_PROB_NODE = <span class="string">"keep_prob_placeholder"</span>; <span class="comment">// keep_prob节点的名称</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUM_CLASSES = <span class="number">10</span>;   <span class="comment">//输出节点的个数，即总的类别数。</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HEIGHT = <span class="number">28</span>;       <span class="comment">//输入图片的像素高</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WIDTH = <span class="number">28</span>;        <span class="comment">//输入图片的像素宽</span></span><br></pre></td></tr></table></figure>
<p>3.创建<code>TensorFlowInferenceInterface</code>对象并初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">inferenceInterface = <span class="keyword">new</span> TensorFlowInferenceInterface(context.getAssets(), MODEL_FILE);</span><br></pre></td></tr></table></figure>
<p>4.输入图片的像素点，得到分类结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 输入数据</span></span><br><span class="line">      Trace.beginSection(<span class="string">"feed"</span>);</span><br><span class="line">      inferenceInterface.feed(INPUT_NODE, pixelArray,<span class="number">1</span>, HEIGHT, WIDTH);</span><br><span class="line">      inferenceInterface.feed(KEEP_PROB_NODE,<span class="keyword">new</span> <span class="keyword">float</span>[]&#123;<span class="number">1.0f</span>&#125;,<span class="number">1</span>);</span><br><span class="line">      Trace.endSection();</span><br><span class="line"></span><br><span class="line">      <span class="comment">//进行模型的推理</span></span><br><span class="line">      Trace.beginSection(<span class="string">"run"</span>);</span><br><span class="line">      inferenceInterface.run(<span class="keyword">new</span> String[]&#123;OUTPUT_NODE&#125;, <span class="keyword">false</span>);</span><br><span class="line">      Trace.endSection();</span><br><span class="line"></span><br><span class="line">      <span class="comment">//获取输出节点的输出信息</span></span><br><span class="line">      <span class="keyword">float</span>[] outputs = <span class="keyword">new</span> <span class="keyword">float</span>[NUM_CLASSES];    <span class="comment">//用于存储模型的输出数据</span></span><br><span class="line">      Trace.beginSection(<span class="string">"fetch"</span>);</span><br><span class="line">      inferenceInterface.fetch(OUTPUT_NODE, outputs);<span class="comment">//获取输出数据</span></span><br><span class="line">      Trace.endSection();</span><br></pre></td></tr></table></figure>
<p>编译运行后就可以看到结果啦</p>
<p><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/other/p2.png" alt="5736962-f3c633f154f0df34"></p>
<h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p><a href="https://www.jianshu.com/p/1168384edc1e" target="_blank" rel="noopener">基于TensorFlow的MNIST手写数字识别与Android移植</a></p>
<p><a href="https://www.tensorflow.org/mobile/mobile_intro" target="_blank" rel="noopener">Introduction to TensorFlow Mobile</a></p>
<p><a href="https://www.jianshu.com/p/d3e2eced12b2" target="_blank" rel="noopener">TensorFlow in Android</a></p>
<p><a href="https://www.jianshu.com/p/a1bc03cede5b" target="_blank" rel="noopener">Android-通过TensorFlow添加机器学习到App中</a></p>
]]></content>
      <tags>
        <tag>tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title>读《Harry Potter and the Philosopher&#39;s Stone》</title>
    <url>/blog/2018/02/read-harry-port.html</url>
    <content><![CDATA[<blockquote>
<p>It does not do to dwell on dreams and forget to live, remember that.</p>
</blockquote>
<p>&emsp;&emsp;花了一个多月，终于把哈利波特第一部读完啦，也不知道是工作后变忙了，还是变懒了，哈哈，过了这么久，终于把第一部读完了，后面还有《哈利波特与秘室》、《哈利波特与阿兹卡班的囚徒》、《哈利波特与火焰杯》、《哈利波特与凤凰社》、《哈利波特与“混血王子”》、《哈利波特与死亡圣器》，可以看很久了，哈哈。虽然从哈利波特这个系列很流行，从小就听说这本书，也看过电影的片段，但长这么大了，其实都没有详细了解过这部书，惭愧惭愧。J.K.罗琳写的还是很不错的，虽然是英文原版，但想象力的确很丰富，情节也很精彩，可以吸引人继续读下去。当然，可能也跟这个系列，尤其是前几部其实是个童话有关，用词还是比较简单的。对了，安利一下扇贝阅读，在上面看英语原版书非常方便，有的还有有声书，对于哈利波特系列，还专门有魔法字典，解释一些魔法界的专用名词如“麻瓜”什么的，而且看不懂的情况下，还可以看看大佬的翻译什么的，不会的单词也可以加入词库，第二天就可以在扇贝单词上背啦。当然了，说这么多，其实看英文书最重要的还是要有兴趣，如果一本书的内容或情节能够吸引你，这才是最大的动力吧，对于我来说，《哈利波特》就是这样一本书。</p>
<center><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/other/p2.jpg"></center>

<p>&emsp;&emsp;话说看了这本书之后才发现，《龙族》系列，尤其是《龙族》第一部，跟这本书还真有颇多相似之处，当初说龙族是哈利波特加海贼王，大概差不多吧。比如说，路明非跟哈利一样，都寄养在叔叔婶婶家，还都有个堂弟;本来两人都过着平静的生活，哈利收到了去霍格沃茨的录取通知单，而跟明非则收到了卡塞尔学院的录取通知书，命运从此发生了巨变。当然，还是略有不同的，在入学之后，哈利一下子变成有爸妈丰厚遗产的明星天才人物，而路明非则咸鱼翻身，还是个咸鱼，整天跟着八年没能毕业的师兄芬格尔混吃等死，哈哈。在一些细节上当然也很相似，尤其是去学校的方法，都是一列神秘的火车，不能说没有参考，还有昂热校长跟邓布利多，也有些相像，幽默优雅却又深不可测,尤其是哈利波特第一部中文名译作《哈利波特与魔法石》，但这个魔法石其实是贤者之石，一种据说能点石成金，长生不老的物质，在龙族中也是个极其重要的概念，不过当然贤者之石这个概念也不是在哈利波特独创的，算不上抄袭。</p>
<center><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/other/p3.jpg"></center>


<p>&emsp;&emsp;不过哈利波特毕竟是多年前的作品，而且定位似乎是个童话，读者可能比较低幼吧，还是有一些缺点的。比如霍格沃茨根据特质将学生分为四个学院，格兰芬多是勇气，拉文克劳是智慧，斯莱特林是纯血统，赫奇帕奇是勤劳，其中拉文克劳和赫奇帕奇没什么存在感，又因为主角哈利，罗恩，赫敏都是格兰芬多的，斯莱特林就负责了反派这个活了，主要任务就是跟主角团作对，好像没一个好人似的，哈哈。又比如说最后守护贤者之石时，需要先闯关才能最后到达，分别是飞行，象棋，草药学三关，分别是3个人特长，好像是专门为主角团定制的，就等着他们三个来闯关了，这个设定现在看来有些过时，可能在当时还是挺先进的吧。其实说到底，综合第一部，哈利的主角光环还是太强大了，来到霍格沃茨之后，其实没遇到什么真正的挫折。好啦，在刚来霍格沃茨时，分院帽唱了一首分院帽之歌，就抄录在这吧：</p>
<blockquote>
<p>你们也许觉得我不算漂亮，<br>但千万不要以貌取人，<br>如果你们能找到比我更漂亮的帽子，<br>我可以把自己吃掉。 </p>
<p>你们可以让你们的圆顶礼帽乌黑油亮，<br>让你们的高顶丝帽光滑挺括，<br>我可是霍格沃茨测试用的魔帽，<br>自然比你们的帽子高超出众。</p>
<p>你们头脑里隐藏的任何念头，<br>都躲不过魔帽的金睛火眼，<br>戴上它试一下一吧，<br>我会告诉你们，<br>你们应该分到哪一所学院。</p>
<p>你也许属于格兰芬多，<br>那里有埋藏在心底的勇敢，<br>他们的胆识、气魄和豪爽，<br>使格兰芬多出类拔萃；</p>
<p>你也许属于赫奇帕奇，<br>那里的人正直忠诚，<br>赫奇帕奇的学子们坚忍诚实，<br>不畏惧艰辛的劳动；</p>
<p>如果你头脑精明，<br>或许会进智慧的老拉文克劳，<br>那些睿智博学的人，<br>总会在那里遇见他们的同道；</p>
<p>也许你会进斯菜特林，<br>也许你在这里交上真诚的朋友，<br>但那些狡诈阴险之辈却会不惜一切手段，<br>去达到他们的目的。</p>
<p>来戴上我吧！不必害怕！<br>千万不要惊慌失措！<br>在我的手里（尽管我连一只手也没有）你绝对安全<br>因为我是一顶会思想的魔帽！</p>
</blockquote>
]]></content>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>读《你好，旧时光》</title>
    <url>/blog/2018/02/read-hello-time.html</url>
    <content><![CDATA[<blockquote>
<p>万事胜意的意思就是，一切的结果，都比你当初想象的，还要好一点点。</p>
</blockquote>
<p>&emsp;&emsp;《你好，旧时光》，最初是网络小说，名字叫《玛丽苏病例报告》，其实最开始的这个名字可能更合适些，套用官方简介的说法：“玛丽苏”是一种“自以为是主角”的病，我们都是患者，本书主角余周周就是这样一个，喜欢一个人角色扮演，沉浸在自己的故事里不能自拔，她是女侠、雅典娜、月野兔、花仙子、希瑞、白娘子……她以为所有人都爱她，世界等着她拯救，上天入地无所不能，打败邪恶的大魔王。谁没有想象过自己是故事的主角呢？只不过周周女侠太有才了，想象力过于丰富罢了。</p>
<center><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/other/p5.jpg"></center>

<p>&emsp;&emsp;但其实周周女侠没有自己想象的那么光鲜，她是个私生女，跟妈妈相依为命，自然经常有流言蜚语；她上小学了，和林杨兜兜转转终于成为朋友，却又因为大人的关系被迫绝交；小学即将毕业，她却学不会奥数，不能上最好的初中；换了个学校，重新开始，好不容易考上振华了，妈妈却因为车祸去世了，永远失去了至亲至爱。其实，余周周并不是那么幸运，只是有一点幸运吧，碰上了小太阳林杨与陈桉。小学毕业时，陈桉对她说，“我们来玩一个主角的游戏吧，就是那种主角被很多人嘲笑，瞧不起，陷害，然后突然掉下山崖，所有人都不知道他是生是死，他去了哪里——可是山崖下面总是有洞穴，洞穴里面总是有秘籍，等他重出江湖，大家都现他已经成了天下第一，无人能敌……，到没有人认识你的学校，给自己重新画一条起跑线吧，没有人在旁边干扰，你可以跑得更快。三年的时间，足够你成为一个小女侠。”</p>
<p>&emsp;&emsp;主角游戏，多好啊。世界上还有一种角色叫炮灰，他们资质平庸，他们努力非凡，他们永远被用来启发和激励主角，制造和开解误会，最后还要替主角挡子弹——只有幸运的人才能死在主角怀里，得到两滴眼泪。或许炮灰才是生活的常态吧，不过只要心怀主角游戏，不管碰到怎么样的艰难挫折，每个人都是自己生命的主角。</p>
<center><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/other/p4.jpg"></center>

<p>&emsp;&emsp;这本书刚开始还是很欢快的，自从周周上初中后也开始有些纠结了，其中不得不提辛锐和楚天阔两个人，这本书里有那么多角色，但大概只有这两个角色让人讨厌却又有些无奈吧。辛锐本是个沉默而自卑，经常被欺负而又没什么存在感的人，是余周周帮助了她，教给了她主角游戏，辛锐感激周周，羡慕周周，想成为周周，于是发愤图强，但是后来她发现，无论她怎么努力，她其实都成为不了余周周</p>
<blockquote>
<p>辛美香刹那间明白了自己和沈屾的区别。沈屾只想要第一名。她可以不穿漂亮的衣服，不在乎人缘，不在乎一切，只要第一名。而辛美香，她想要变成余周周，又或者说，变成余周周们。她们招人喜爱，家庭幸福，生活富足，朋友众多，成绩出色，前途远大，无忧无虑。 辛美香何其贪心</p>
</blockquote>
<p>&emsp;&emsp;其实本想说何必呢，但看看辛锐的家庭状况，或许辛锐是对的，她说，我不知道做别人是不是能幸福，但做自己，一定不幸福。或许优秀的作品就是这样，每个角色自有其合理之处。正如楚天阔没有在凌翔茜出事的时候像林杨周周那样，放弃保送考试的机会去找她，但他其实并没有什么错，反而是男女主角的行为显得太随意了，一般人输不起，换个角度，如果是高考呢？如果作者写他们放弃高考去找人，肯定会被读者骂吧，哈哈，这不太真实。不过，虽然楚天阔的行为可以理解，但有些人不会去做，是因为他们有更珍贵的东西去守护，但是这样的人比较少。</p>
<p>记得以前看《最好的我们》的时候提到了沈屾，那里只提了一句，当时好奇这样一个人的故事是怎样的，没想到竟然在这里看到了，很多人都问沈屾，你会不会后悔。</p>
<blockquote>
<p>他们都这样问。所有人。<br>沈屾，你有没有后悔过，有没有。<br>沈屾，你是所有人中最努力的。<br>沈屾，你是不是从来都不出去玩？<br>沈屾，你是不是做梦都在学习？<br>沈屾……<br>沈屾知道他们想说什么。沈屾，天才是99%的汗水和1%的灵感，你说，你都做到这个份儿上了，为什么命运还是让你阴差阳错成了一个庸碌之辈？<br>沈屾，你中考失利，赌气进普高，高中三年拼了老命，最后还是进了本地的大学。沈屾，你不怨恨吗？早知如此，不如当初开开心心享受青春，玩到够本。沈屾，你后不后悔？<br>沈屾，你后不后悔？</p>
</blockquote>
<p>但好在沈屾从不后悔，只要倾尽全力，只要问心无愧，沈屾从不后悔。还是那句话，不管甜筒在谁手里，沈屾还是沈屾，我觉得这样挺酷的。</p>
<p>&emsp;&emsp;总得来说，这是一部很独特，很温暖的青春小说，记得以前看过这本书，但不知道为什么竞没有看完，这次是偶然发现改编的网剧，拍的还不错，李兰迪饰演的余周周很可爱，笑起来的时候尤其如此，不过按照原著来说，高中时期的周周恐怕很少会笑的这么甜吧，虽然两者有些不同，但是总体来说还是拍的不错的，各有各的长处吧。错过这本书这么久，真是可惜，或许也不可惜，现在有这么一部小说可看。</p>
<center><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/other/p6.jpg"></center>]]></content>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Android代码打包成库并上传到华为云</title>
    <url>/blog/2018/02/android-huawei-maven.html</url>
    <content><![CDATA[<p>为了方便别人使用我们开发的Android Library，一般我们都会把Android Library打成aar包，并将aar包发布到Maven仓库当中。如果是开源项目就可以把包发布到Maven Central仓库或者JCenter仓库中；如果是公司内部使用，我们则可以自己搭建私有Maven仓库，就把包发布到私有Maven仓库当中，以方便别人直接使用。</p>
<p>本文将介绍如何使用Android Studio将项目发布到华为云Maven私有仓库</p>
<p>主要是以下3个步骤：</p>
<p>1.将普通工程改造成库</p>
<p>2.将库上传到华为云私有maven库</p>
<p>3.添加依赖，使用上传的库</p>
<h4 id="在Android-Studio中将普通工程改造成库"><a href="#在Android-Studio中将普通工程改造成库" class="headerlink" title="在Android Studio中将普通工程改造成库"></a>在Android Studio中将普通工程改造成库</h4><p>1.新建一个library module</p>
<p>2.抽取核心代码放到library module中</p>
<p>移植过程中尤其要注意的一点是，不要把Application移过去</p>
<p>详情可见：<a href="https://www.jianshu.com/p/71058db2e429" target="_blank" rel="noopener">一个完整的Android项目打包成第三方库</a></p>
<h4 id="将library上传到华为云"><a href="#将library上传到华为云" class="headerlink" title="将library上传到华为云"></a>将library上传到华为云</h4><p>华为云私有maven仓库地址是：<a href="https://releaseman.devcloud.huaweicloud.com/releaseman/home/maven" target="_blank" rel="noopener">https://releaseman.devcloud.huaweicloud.com/releaseman/home/maven</a></p>
<p>下面贴上audiorecord的build.gradle的脚本代码</p>
<p>audiorecord/build.gradle</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">apply <span class="string">plugin:</span> <span class="string">'com.android.library'</span></span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    compileSdkVersion <span class="number">26</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        minSdkVersion <span class="number">15</span></span><br><span class="line">        targetSdkVersion <span class="number">26</span></span><br><span class="line">        versionCode <span class="number">1</span></span><br><span class="line">        versionName <span class="string">"1.0"</span></span><br><span class="line"></span><br><span class="line">        testInstrumentationRunner <span class="string">"android.support.test.runner.AndroidJUnitRunner"</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled <span class="literal">false</span></span><br><span class="line">            proguardFiles getDefaultProguardFile(<span class="string">'proguard-android.txt'</span>), <span class="string">'proguard-rules.pro'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation fileTree(<span class="string">dir:</span> <span class="string">'libs'</span>, <span class="string">include:</span> [<span class="string">'*.jar'</span>])</span><br><span class="line"></span><br><span class="line">    implementation <span class="string">'com.android.support:appcompat-v7:26.0.0-beta1'</span></span><br><span class="line">    testImplementation <span class="string">'junit:junit:4.12'</span></span><br><span class="line">    androidTestImplementation <span class="string">'com.android.support.test:runner:0.5'</span></span><br><span class="line">    androidTestImplementation <span class="string">'com.android.support.test.espresso:espresso-core:2.2.2'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">apply <span class="string">from:</span> <span class="string">'./nexus-push.gradle'</span></span><br></pre></td></tr></table></figure>
<p>好，可以看到，基本上都是Android Studio自动生成的代码，只有最后一句不是。最后一句引用了另一个gradle脚本文件，我们的项目发布代码都写在这个脚本文件中。</p>
<p>audiorecord/nexus-push.gradle</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">apply <span class="string">plugin:</span> <span class="string">'maven'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//run command: gradlew uploadArchives</span></span><br><span class="line"></span><br><span class="line">task androidJavadocs(<span class="string">type:</span> Javadoc) &#123;</span><br><span class="line">    source = android.sourceSets.main.java.srcDirs</span><br><span class="line">    classpath += project.files(android.getBootClasspath().join(File.pathSeparator))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task androidJavadocsJar(<span class="string">type:</span> Jar, <span class="string">dependsOn:</span> androidJavadocs) &#123;</span><br><span class="line">    classifier = <span class="string">'javadoc'</span></span><br><span class="line">    from androidJavadocs.destinationDir</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task androidSourcesJar(<span class="string">type:</span> Jar) &#123;</span><br><span class="line">    classifier = <span class="string">'sources'</span></span><br><span class="line">    from android.sourceSets.main.java.srcDirs</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">artifacts &#123;</span><br><span class="line">    archives androidSourcesJar</span><br><span class="line">    archives androidJavadocsJar</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uploadArchives &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenDeployer &#123;</span><br><span class="line">            repository(<span class="string">url:</span> <span class="string">"https://devrepo.devcloud.huaweicloud.com/02/nexus/content/repositories/4929ade381434739a379556bf64b2732_1_0/"</span>) &#123;</span><br><span class="line">                authentication(<span class="string">userName:</span> <span class="string">"username"</span>, <span class="string">password:</span> <span class="string">"password"</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            pom.groupId = <span class="string">'com.zj.www.audiorecord'</span></span><br><span class="line">            pom.artifactId = <span class="string">'audiorecord'</span></span><br><span class="line">            pom.version = <span class="string">'1.0.0'</span></span><br><span class="line"></span><br><span class="line">            pom.project &#123;</span><br><span class="line">                licenses &#123;</span><br><span class="line">                    license &#123;</span><br><span class="line">                        name <span class="string">'The Apache Software License, Version 2.0'</span></span><br><span class="line">                        url <span class="string">'http://www.apache.org/licenses/LICENSE-2.0.txt'</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先需要引用maven插件；然后定义了2个任务：androidSourcesJar和androidJavadocsJar，这两个任务分别用于对Java sources打包和Java doc进行打包；接着我们对uploadArchives.repositories闭包进行一些配置，包括仓库的url地址，上传所需的用户名和密码，以及pom属性,用户名及密码需要自己注册华为云获得。</p>
<p>脚本编写完之后，在Android Studio的Terminal面板执行如下命令</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">gradlew uploadArchives</span><br></pre></td></tr></table></figure>
<p>发布成功后就可以在华为云上看到自己上传的库了</p>
<h4 id="使用已上传的库"><a href="#使用已上传的库" class="headerlink" title="使用已上传的库"></a>使用已上传的库</h4><p>使用该库的根目录下的build.gradle如下所示</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Top-level build file where you can add configuration options common to all sub-projects/modules.</span></span><br><span class="line"></span><br><span class="line">buildscript &#123;</span><br><span class="line">    </span><br><span class="line">    repositories &#123;</span><br><span class="line">        google()</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath <span class="string">'com.android.tools.build:gradle:3.0.1'</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span> Do not place your application dependencies here; they belong</span></span><br><span class="line">        <span class="comment">// in the individual module build.gradle files</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        google()</span><br><span class="line">        jcenter()</span><br><span class="line">        maven &#123;</span><br><span class="line">            credentials &#123;</span><br><span class="line">                username <span class="string">'username'</span></span><br><span class="line">                password <span class="string">'password'</span></span><br><span class="line">            &#125;</span><br><span class="line">            url <span class="string">'https://devrepo.devcloud.huaweicloud.com/02/nexus/content/repositories/4929ade381434739a379556bf64b2732_1_0/'</span></span><br><span class="line">        &#125;</span><br><span class="line">        maven &#123;</span><br><span class="line">            credentials &#123;</span><br><span class="line">                username <span class="string">'username'</span></span><br><span class="line">                password <span class="string">'password'</span></span><br><span class="line">            &#125;</span><br><span class="line">            url <span class="string">'https://devrepo.devcloud.huaweicloud.com/02/nexus/content/repositories/4929ade381434739a379556bf64b2732_2_0/'</span></span><br><span class="line">        &#125;</span><br><span class="line">        maven &#123;</span><br><span class="line">            credentials &#123;</span><br><span class="line">                username <span class="string">'username'</span></span><br><span class="line">                password <span class="string">'password'</span></span><br><span class="line">            &#125;</span><br><span class="line">            url <span class="string">'https://repo.huaweicloud.com/repository/maven/'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task clean(<span class="string">type:</span> Delete) &#123;</span><br><span class="line">    delete rootProject.buildDir</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要是在allprojects/repositories下 添加三个maven地址即可，用户名与密码可在华为云私有依赖库使用配置中找到。</p>
<p>接下来在example的build.gradle中添加依赖即可使用。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">compile <span class="string">'com.zj.www.audiorecord:audiorecord:1.0.0'</span></span><br></pre></td></tr></table></figure>
<p>编译运行一下，就可以使用audiorecord库了</p>
<h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p><a href="http://blog.csdn.net/H_Zhang/article/details/51558800" target="_blank" rel="noopener">Android Studio发布项目到Maven仓库</a></p>
<p><a href="http://blog.csdn.net/hmh0512/article/details/53818058" target="_blank" rel="noopener">怎样将自己的工程改造成库，并上传到Github作为依赖</a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>科学上网</title>
    <url>/blog/2018/03/across-grest-wall.html</url>
    <content><![CDATA[<p>1.通过修改host文件科学上网<br><a href="https://laod.cn/hosts/2017-google-hosts.html" target="_blank" rel="noopener">Google hosts 持续更新</a></p>
<p>2.lantern科学上网<br><a href="https://github.com/getlantern/lantern" target="_blank" rel="noopener">https://github.com/getlantern/lantern</a></p>
<p>3.Shadowsocks科学上网<br><a href="https://doub.ws/ss-jc26/" target="_blank" rel="noopener">关于Shadowsocks的小白常见问题 总结篇</a><br><a href="https://doub.ws/sszhfx/" target="_blank" rel="noopener">Shadowsocks免费账号分享</a><br>具体可参考<a href="https://doub.ws或https://doub.io" target="_blank" rel="noopener">https://doub.ws或https://doub.io</a></p>
]]></content>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>Glide通过key加载图片</title>
    <url>/blog/2018/03/glide-load-fid.html</url>
    <content><![CDATA[<p>最近碰到这样一个需求，加载网络图片没有url，只给我文件id，首先要通过key拿到图片的url，然后再根据url来获取图片，这样就涉及到两次网络请求来加载一张图片。</p>
<p>最开始时是用rxjava，首先请求图片url，成功后再回调来加载图片的，不过略显麻烦，而且由于图片地址是变化的，Glide自带的缓存机制也失效了。最后发现可以通过自定义ModelLoader来实现通过key加载图片。</p>
<p>虽然 Glide 内置了大部分常用模型（URL, Uri, 文件路径等）的支持，你还是可能偶尔会遇到一种 Glide 不支持的类型。你也可能会遇到需要定制或调整 Glide 默认行为的情况。你甚至可能会想要集成一种新的拉取图片的方法，或更换 Glide 目前支持的 <a href="https://muyangmin.github.io/glide-docs-cn/int/about.html" target="_blank" rel="noopener">集成库</a> 之外的网络库。</p>
<p>好在 Glide 是可扩展的。要添加对一种新的模型（Model）类型的支持，你需要按照以下步骤来执行：</p>
<ol>
<li>实现一个 <a href="https://muyangmin.github.io/glide-docs-cn/javadocs/440/com/bumptech/glide/load/model/ModelLoader.html" target="_blank" rel="noopener"><code>ModelLoader</code></a>；</li>
<li>实现一个 <a href="https://muyangmin.github.io/glide-docs-cn/javadocs/440/com/bumptech/glide/load/data/DataFetcher.html" target="_blank" rel="noopener"><code>DataFetcher</code></a>，它可被你的 <a href="https://muyangmin.github.io/glide-docs-cn/javadocs/440/com/bumptech/glide/load/model/ModelLoader.html" target="_blank" rel="noopener"><code>ModelLoader</code></a> 返回；</li>
<li>将你的新 <a href="https://muyangmin.github.io/glide-docs-cn/int/about.html" target="_blank" rel="noopener"><code>ModelLoader</code></a> 注册到 Glide ，使用 <a href="https://muyangmin.github.io/glide-docs-cn/doc/configuration.html#applications" target="_blank" rel="noopener"><code>AppGlideModule</code></a></li>
</ol>
<p>在注册ModelLoader时，有三种组件可供使用</p>
<p>在 <a href="https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/Registry.html" target="_blank" rel="noopener"><code>Registry</code></a> 类中定义了 <code>prepend()</code> , <code>append()</code> 和 <code>replace()</code> 方法，它们可以用于设置 Glide 尝试每个 <code>ModelLoader</code> 和 <code>ResourceDecoder</code> 之间的顺序。对组件进行排序允许你注册一些只处理特定树模型的子集的组件（即只处理特定类型的Uri，或仅仅特定类型的图像格式），并可以在后面追加一个捕获所有类型的组件以处理其他情况。</p>
<h5 id="prepend"><a href="#prepend" class="headerlink" title="prepend()"></a>prepend()</h5><p>假如你的 <code>ModelLoader</code> 或者 <code>ResourceDecoder</code> 在某个地方失败了，这时候你想将已有的数据交由 Glide 的默认行为来处理，可以使用 <code>prepend()</code>。 <code>prepend()</code> 将确保你的 <code>ModelLoader</code> 或 <code>ResourceDecoder</code> 先于之前注册的其他组件并被首先执行。如果你的 <code>ModelLoader</code> 或者 <code>ResourceDecoder</code> 从其 <code>handles()</code> 方法中返回了一个 <code>false</code> 或失败，所有其他的 <code>ModelLoader</code> 或 <code>ResourceDecoder</code> 将以它们被注册的顺序执行，一次一个，作为一种回退方案。</p>
<h5 id="append"><a href="#append" class="headerlink" title="append()"></a>append()</h5><p>要处理新的数据类型或提供一个到 Glide 默认行为的回退，使用 <code>append()</code>。<code>append()</code> 将确保你的 <code>ModelLoader</code> 或 <code>ResourceDecoder</code> 仅在 Glide 的默认组件被尝试后才会被调用。 如果你正在尝试处理 Glide 的默认组件能处理的某些子类型 (例如一些特定的 Uri 授权或子类型)，你可能需要使用 <code>prepend()</code> 来确保 Glide 的默认组件不会在你的定制组件之前加载。</p>
<h5 id="replace"><a href="#replace" class="headerlink" title="replace()"></a>replace()</h5><p>要完全替换 Glide 的默认行为并确保它绝不运行，请使用 <code>replace()</code>。 <code>replace()</code> 将移除所有处理给定模型和数据类的 <code>ModelLoaders</code>，并添加你的 <code>ModelLoader</code> 来代替。 <code>replace()</code> 在使用库(例如 OkHttp 或 Volley)替换掉 Glide 的网络逻辑时尤其有用，这种时候你会希望确保仅 OkHttp 或 Volley 被调用。</p>
<h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><h5 id="ObsImageLoader"><a href="#ObsImageLoader" class="headerlink" title="ObsImageLoader"></a>ObsImageLoader</h5><p>ModelLoader的作用只有一个——实现buildLoadData()方法，返回一个DataFetcher对象，同时也做了一些缓存。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObsImageLoader</span> <span class="keyword">implements</span> <span class="title">ModelLoader</span>&lt;<span class="title">ObsImageModel</span>, <span class="title">InputStream</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> <span class="keyword">implements</span> <span class="title">ModelLoaderFactory</span>&lt;<span class="title">ObsImageModel</span>, <span class="title">InputStream</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">final</span> ModelCache&lt;ObsImageModel, GlideUrl&gt; modelCache = <span class="keyword">new</span> ModelCache&lt;&gt;(<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">		<span class="meta">@NonNull</span></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> ModelLoader&lt;ObsImageModel, InputStream&gt; <span class="title">build</span><span class="params">(MultiModelLoaderFactory multiFactory)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> ObsImageLoader(modelCache);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">teardown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="comment">// Do nothing.</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Option&lt;Integer&gt; TIMEOUT = Option.memory(</span><br><span class="line">			<span class="string">"com.bumptech.glide.load.model.stream.HttpGlideUrlLoader.Timeout"</span>, <span class="number">2500</span>);</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> ModelCache&lt;ObsImageModel, GlideUrl&gt; modelCache;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ObsImageLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>(<span class="keyword">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ObsImageLoader</span><span class="params">(@Nullable ModelCache&lt;ObsImageModel, GlideUrl&gt; modelCache)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.modelCache = modelCache;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> LoadData&lt;InputStream&gt; <span class="title">buildLoadData</span><span class="params">(@NonNull ObsImageModel model, <span class="keyword">int</span> width, <span class="keyword">int</span> height,</span></span></span><br><span class="line"><span class="function"><span class="params">											   @NonNull Options options)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// GlideUrls memoize parsed URLs so caching them saves a few object instantiations and time</span></span><br><span class="line">		<span class="comment">// spent parsing urls.</span></span><br><span class="line">		GlideUrl url = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">if</span> (modelCache != <span class="keyword">null</span>) &#123;</span><br><span class="line">			url = modelCache.get(model, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">			<span class="keyword">if</span> (url == <span class="keyword">null</span>) &#123;</span><br><span class="line">				modelCache.put(model, <span class="number">0</span>, <span class="number">0</span>, model);</span><br><span class="line">				url = model;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> timeout = options.get(TIMEOUT);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> LoadData&lt;&gt;(url, <span class="keyword">new</span> ObsDataFetcher(url, timeout));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handles</span><span class="params">(@NonNull ObsImageModel model)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="ObsDataFetcher"><a href="#ObsDataFetcher" class="headerlink" title="ObsDataFetcher"></a>ObsDataFetcher</h5><p>DataFetcher的作用是从数据源（图片网络地址、本地路径、res资源id等）中获取到图片的流数据（InputStream），然后交给Glide做处理（缩放、本地缓存等）。</p>
<p>注意到在loadData中进行了两次请求，一次拿url，一次拿图片数据。不过由于前面做了缓存，所以只有等缓存失效时才会加载DataFetcher，这样就只有在最开始和缓存失效时才会进行网络请求，比起之前每次都要通过KEY去请求URL，优化了用户体验。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObsDataFetcher</span> <span class="keyword">implements</span> <span class="title">DataFetcher</span>&lt;<span class="title">InputStream</span>&gt; </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadData</span><span class="params">(@NonNull Priority priority,</span></span></span><br><span class="line"><span class="function"><span class="params">                         @NonNull DataCallback&lt;? <span class="keyword">super</span> InputStream&gt; callback)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> startTime = LogTime.getLogTime();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            DiscussionService discussionService = RoboGuice.getInjector(MainApplication.instance()).getProvider(DiscussionService<span class="class">.<span class="keyword">class</span>).<span class="title">get</span>()</span>;</span><br><span class="line">            OBSResponse obsResponse=discussionService.getOBSResponse(glideUrl.toStringUrl()).execute().body();</span><br><span class="line">            InputStream result = loadDataWithRedirects(<span class="keyword">new</span> URL(obsResponse.getUrl()), <span class="number">0</span>, <span class="keyword">null</span>, glideUrl.getHeaders());</span><br><span class="line">            callback.onDataReady(result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Log.isLoggable(TAG, Log.DEBUG)) &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"Failed to load data for url"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">            callback.onLoadFailed(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">                Log.v(TAG, <span class="string">"Finished http url fetcher fetch in "</span> + LogTime.getElapsedMillis(startTime));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="GlideModule"><a href="#GlideModule" class="headerlink" title="GlideModule"></a>GlideModule</h5><p>为特定的数据类型注册不同的加载方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlideModule</span> <span class="keyword">extends</span> <span class="title">AppGlideModule</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerComponents</span><span class="params">(@NonNull Context context, @NonNull Glide glide, @NonNull Registry registry)</span> </span>&#123;</span><br><span class="line">		registry.prepend(ObsImageModel<span class="class">.<span class="keyword">class</span>, <span class="title">InputStream</span>.<span class="title">class</span>, <span class="title">new</span> <span class="title">ObsImageLoader</span>.<span class="title">Factory</span>())</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用时指定数据类型即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">GlideApp.with(fragment)</span><br><span class="line">					.asDrawable()</span><br><span class="line">					.load(<span class="keyword">new</span> ObsImageModel(getObjectKey(i)))</span><br><span class="line">					.placeholder(<span class="keyword">new</span> ColorDrawable(Color.parseColor(<span class="string">"#f5f5f5"</span>)))</span><br><span class="line">					.into(iv);</span><br></pre></td></tr></table></figure>
<h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p><a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0927/3521.html" target="_blank" rel="noopener">加载网络图片但没URL？不要紧，通过ModelLoader，让Glide直接加载任何奇葩数据源</a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>读《文明之光》</title>
    <url>/blog/2018/04/light-of-civilization.html</url>
    <content><![CDATA[<blockquote>
<p>I must study politics and war that my sons may have liberty to study mathematics and philosophy. My sons ought to study mathematics and philosophy, geography, natural history, naval architecture, navigation, commerce, and agriculture, in order to give their children a right to study painting, poetry, music, architecture, statuary, tapestry, and porcelain.</p>
</blockquote>
<p>&emsp;&emsp;读文明之光，不得不佩服吴军博士的渊博，以前只知他是IT界的大牛，腾讯副总裁，却没想到在世界史上也有如此深的造诣。从文艺复兴到罗马法，从古埃及古巴比伦到古罗马，从文艺复兴到大航海到科学之路，从瓷器到蒸汽机到铁路到计算机，从经典力学到电力的广泛应用到核能的和平利用，还有从荷兰到美国的成功与现代商业文明的关系，甚至是从古典音乐到各大美术流派，吴军博士都能娓娓到来，深入浅出，的确是很见功力的。</p>
<p>&emsp;&emsp;本书书名为文明之光，究竟什么才是文明之光？翻开世界各国尤其是中国的历史教科书，基本上都是讲述王侯将相攻城略地的丰功伟业，帝国的扩展和兴衰，很少讲述世界各地区对文明的贡献。但放到历史长河中去看，一个王国或者帝国的武功远不如它的‘文治’来得重要。再强大的王国都会灭亡，而他们建立的文明却能薪火相传。就好比发明轮子的，无人知晓的一个或一群工匠，没有人会记住他们的名字，但他们的发明对整个人类文明，都有着巨大的意义，轮子发明的价值可能远超有史以来任何一位帝王吧，这才是文明之光吧。</p>
<p>&emsp;&emsp;总得来说，本书采取的是反英雄史观,确有一定道理，历史的创造者应该是人民而不应该是某位英雄人物。在书的前半部分，贯彻得比较彻底，如对古埃及文明、美索不达米亚文明无名创造者的敬意、对法老、亚历山大大帝、屋大维和蒙古人赫赫武功的轻描淡写，第一册的目录中，只出现了汉谟拉比一个人名，但写到后面，当写到伽利略，牛顿，爱因斯坦，达芬奇，美第奇家族，贝多芬，莫扎特的时候，尤其是写到美苏航空竞赛的时候，把这场两个大国之间的角力写成了冯布劳恩与科罗廖夫两个人之间的竞争，未免有些前后矛盾，不过也是可以理解，毕竟大家都喜欢故事，而故事往往都要突出人物，不可避免。其实仔细想想，英雄史观与群众史观或许都有其可取之处吧，100年前，大家都在争吵光究竟是粒子，还是波。最后发现，光既是粒子，也是波，类比一下，大致可以说，历史既是由大众所创造的，也是由英雄所创造的。</p>
<p>&emsp;&emsp;吴军终归是工程师出身，在他的书中对科技史与技术史的描绘，最为深入与令人信服。就比如瓷器这一章，作者将瓷器产生发展的必要条件归纳为高岭土、高温技术和上釉技术，通过对比历史上不同时期各个文明是如何进行从陶器到瓷器的探索，告诉我们上天是如何眷顾中国，让我们的先人在相当长的时间里垄断了这项技术。我们知道瓷器是中国的骄傲，但作者也向我们讲述了这样一个无比辉煌的瓷器王朝是如何衰落的，世界制瓷业的中心是如何从中国转移到日本，又有如何转移到欧洲。作者告诉我们欧洲的瓷器制造商是如何在四年的时间里完成三万次试制瓷器的实验，并且详细记录每次实验，由此当我们再反思为什么我们历史上那么多精湛的手工艺技术总走不出“发明，失传，再发明，再失传”的怪圈时，不能不有所感叹。其实作者这也是回答李约瑟之问吧，为什么现代科学没有诞生在中国。以往在教科书上总是看到，中国空有技术而没有科学，但也是泛泛之谈，不能确切了解，如今结合这个例子才豁然开朗。以往的发明往往是经验的积累，导致效率很低，而且缺乏传承，导致长久以来其实技术的进步非常缓慢。而在进入科学时代以后，通过科学的方法进行实验，总结经验并转化为理论，并通过理论继续指导实验与发明，就比如蒸汽机的发明依赖于牛顿力学，而电动机与发电机的发明离不开电磁感应定律，而核能的利用更是离不开爱因斯坦的质能方程。</p>
<p>&emsp;&emsp;或许正因为吴军不是历史学家的缘故，他的视角和写法，才与众不同，其实我也算是个喜欢读历史的人，但其实回想起来，以往读的往往是帝王将相，才子佳人，其实终归是二十四姓之家史。本书立足于世界而只是中国，立足于文明而不只是帝国兴衰，科技，文化，经济，音乐，绘画等等方面都皆有着墨，深入浅出并引人深思，的确是一本好书啊。好在这本书足够长，可以读很久，而且可以多读几次。</p>
]]></content>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>ExoPlayer的初步使用</title>
    <url>/blog/2018/03/exoplayer-use-start.html</url>
    <content><![CDATA[<p>在android设备中，视频与音乐的播放功能是非常常用的。通常我们可以使用MediaPlayer作为播放器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mediaPlayer.setDataSource(url);</span><br><span class="line">mediaPlayer.prepare();</span><br><span class="line">mediaPlayer.start();</span><br></pre></td></tr></table></figure>
<p><strong>MediaPlayer</strong> 有一些优点，最主要的就是开始使用很简单，你只需要简单的两三行代码就能播放大部分的文件。</p>
<p>缺点就是可定制性不高，不易扩展。随着功能迭代，我们需要app添加一些更多的功能，比如支持HLS流，播放速率可变，这些都是 MediaPlayer 所不能立即完成的。</p>
<p>除此之外 MediaPlayer 也有一些其他的缺点：这是一个黑盒，并且内部都是native的方法，很难去debug和弄清楚到底异常是怎么出现的。而且 MediaPlayer 作为framework级别的解决方案，这样在不同的版本，不同的ROM上表现会有差异，我们不能控制和担保到底使用的是什么样的版本。而且 MediaPlayer 会有一些各种奇怪的异常code，很难确信这些crash是怎么产生的。</p>
<p>ExpPlayer是一个开源的，App等级的媒体API，它具有强大的可扩展性，但是一开始的学习曲线比较陡峭。好在这是开源的，源码易于阅读，并且容易debug。实现上基于 MediaCodec，能够处理HLS流，同时也支持后台播放，播放速率，分辨率可配置。</p>
<ul>
<li>支持动态的自适应流HTTP(DASH) 和 平滑流，任何目前MediaPlayer支持的视频格式（同时它还支持HTTP直播了（HLS),MP4,MP3,WebM,M4A,MPEG-TS 和 AAC).</li>
<li>支持高级的HLS特性，例如正确处理 <code>EXT-X-DISCONTINUITY</code> 标签；</li>
<li>支持自定义和扩治你的使用场景。ExoPlayer专门为此设计；</li>
<li>便于随着App的升级而升级。因为ExoPlayer是一个包含在你的应用中的库，对于你使用哪个版本有完全的控制权，并且你可以简单的跟随应用的升级而升级；</li>
<li>更少的适配性问题。</li>
</ul>
<h4 id="Library-overview"><a href="#Library-overview" class="headerlink" title="Library overview"></a>Library overview</h4><p>ExoPlayer库的核心是ExoPlayer接口。ExoPlayer 接口暴露了传统的 high-level 播放器中的功能，如资源缓冲，播放，暂停和拖拽等。接口的实现类对媒体的播放类型、存储位置和渲染方式做出假设，而不是笼统的加载和渲染。Exoplayer 把播放类型、存储位置和渲染方式等任务委派给不同的部件，然后在创建播放器或后台播放的时候把这些部件注入。这些部件包括：</p>
<ul>
<li>MediaSource - 负责装载 media，装载到MediaSource 的 media 可以被读取，MediaSource 在调用 ExoPlayer.prepare 方法时被注入。</li>
<li>Render S - 用于渲染 media 的部件，在创建播放器时被注入</li>
<li>TrackSelector - 从MediaSource 中选出 media 提供给可用的 Render S 来渲染，在创建播放器时被注入。</li>
<li>LoadControl - 控制 MediaSource 缓存更多的 media，有多少 media 被缓冲。在创建播放器时被注入</li>
</ul>
<p>类库提供这些部件在通常情况下的默认实现。一个 ExoPlayer 可以利用这些部件。如果标准实现不能满足需求，也可以使用自定义实现。例如，自定义LoadControl 可以改变播放器的缓冲策略，或自定义Renderer 可实现 Android 本身不支持的视频编解码器。</p>
<h4 id="Getting-started"><a href="#Getting-started" class="headerlink" title="Getting started"></a>Getting started</h4><p>开始使用 ExoPlayer 需要执行以下步骤：</p>
<ol>
<li>添加依赖</li>
<li>创建一个 SimpleExoPlayer 实例</li>
<li>将 player 和 view （用于视频输出和用户输入）关联</li>
<li>创建MediaSource</li>
<li>调用 prepare 方法，注入MediaSource，准备播放</li>
<li>播放结束释放 player</li>
</ol>
<p><strong>添加依赖</strong></p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    jcenter()</span><br><span class="line">    google()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">compile <span class="string">'com.google.android.exoplayer:exoplayer:2.X.X'</span></span><br></pre></td></tr></table></figure>
<p>需要添加google仓库，并添加依赖，同时也可以只依赖自己需要的core或者dash等</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">compile <span class="string">'com.google.android.exoplayer:exoplayer-core:2.X.X'</span></span><br><span class="line">compile <span class="string">'com.google.android.exoplayer:exoplayer-dash:2.X.X'</span></span><br><span class="line">compile <span class="string">'com.google.android.exoplayer:exoplayer-ui:2.X.X'</span></span><br></pre></td></tr></table></figure>
<p><strong>Creating the player</strong></p>
<p>您可以通过 ExoPlayerFactory 工厂方法创建一个 ExoPlayer 实例。 工厂提供了一系列的方法创建不同程度定制的 ExoPlayer 实例。对于绝大多数使用情况下，默认 Renderer 库提供的实现足够用。这时应该使用 ExoPlayerFactory.newSimpleInstance 方法。方法返回 SimpleExoPlayer，SimpleExoPlayer 扩展了 ExoPlayer 并添加额外的 high-level 播放功能。下面演示了如何创建一个 SimpleExoPlayer。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Create a default track selector.</span></span><br><span class="line"> BandwidthMeter bandwidthMeter = <span class="keyword">new</span> DefaultBandwidthMeter();</span><br><span class="line"> TrackSelection.Factory videoTrackSelectionFactory =</span><br><span class="line">         <span class="keyword">new</span> AdaptiveTrackSelection.Factory(bandwidthMeter);</span><br><span class="line"> DefaultTrackSelector trackSelector = <span class="keyword">new</span> DefaultTrackSelector(videoTrackSelectionFactory);</span><br><span class="line"> <span class="comment">// Create a player instance.</span></span><br><span class="line"> player = ExoPlayerFactory.newSimpleInstance(context, trackSelector);</span><br></pre></td></tr></table></figure>
<p><strong>Attaching the player to a view</strong></p>
<p>ExoPlayer 库提供了 SimpleExoPlayerView ，它封装了一个 PlaybackControlView 和 Surface 用来渲染视频。一个 SimpleExoPlayerView 可以包含在布局 XML 文件中。下面演示了如何绑定 player</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="comment">// Bind the player to the view.</span></span><br><span class="line">simpleExoPlayerView.setPlayer(player);</span><br></pre></td></tr></table></figure>
<p>如果我们需要自定义播放界面，或者控制界面，也可以修改或继承SimpleExoPlayerView与PlaybackControlView个来实现</p>
<p><strong>创建mediasource</strong></p>
<p>不同类型的数据源创建mediasource的方法不同</p>
<p>在 ExoPlayer 每一个 media 都由 MediaSource 代表。要播放 media 必须先创建一个相应的 MediaSource，然后把这个对象传递给 ExoPlayer.prepare。ExoPlayer 库提供 MediaSource 的DASH实现（实DashMediaSource），SmoothStreaming 实现（ SsMediaSource），HLS 实现（HlsMediaSource）和常规 media files 实现（ExtractorMediaSource）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> MediaSource <span class="title">buildMediaSource</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      Uri uri,</span></span></span><br><span class="line"><span class="function"><span class="params">      String overrideExtension,</span></span></span><br><span class="line"><span class="function"><span class="params">      @Nullable Handler handler,</span></span></span><br><span class="line"><span class="function"><span class="params">      @Nullable MediaSourceEventListener listener)</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ContentType</span> <span class="keyword">int</span> type = TextUtils.isEmpty(overrideExtension) ? Util.inferContentType(uri)</span><br><span class="line">        : Util.inferContentType(<span class="string">"."</span> + overrideExtension);</span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">      <span class="keyword">case</span> C.TYPE_DASH:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DashMediaSource.Factory(</span><br><span class="line">                <span class="keyword">new</span> DefaultDashChunkSource.Factory(mediaDataSourceFactory),</span><br><span class="line">                buildDataSourceFactory(<span class="keyword">false</span>))</span><br><span class="line">            .createMediaSource(uri, handler, listener);</span><br><span class="line">      <span class="keyword">case</span> C.TYPE_SS:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SsMediaSource.Factory(</span><br><span class="line">                <span class="keyword">new</span> DefaultSsChunkSource.Factory(mediaDataSourceFactory),</span><br><span class="line">                buildDataSourceFactory(<span class="keyword">false</span>))</span><br><span class="line">            .createMediaSource(uri, handler, listener);</span><br><span class="line">      <span class="keyword">case</span> C.TYPE_HLS:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HlsMediaSource.Factory(mediaDataSourceFactory)</span><br><span class="line">            .createMediaSource(uri, handler, listener);</span><br><span class="line">      <span class="keyword">case</span> C.TYPE_OTHER:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ExtractorMediaSource.Factory(mediaDataSourceFactory)</span><br><span class="line">            .createMediaSource(uri, handler, listener);</span><br><span class="line">      <span class="keyword">default</span>: &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unsupported type: "</span> + type);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>除了上面所说的，也可以利用LoopingMediaSource 和ConcatenatingMediaSource，来构建mediasource播放列表</p>
<p><strong>Preparing the player</strong></p>
<p>一旦 player 已经被 prepared，playback 可以通过调用播放器上的方法进行控制。例如 setPlayWhenReady 可用于启动和暂停播放，和各种 seekTo 方法可以用于改变进度,以及可以设置重播模式，也可以设置不播放视频或语音等。如果 player 被绑定到 SimpleExoPlayerView 或 PlaybackControlView ，那么用户与这些部件的交互将会导致 player 相应的方法被调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// This is the MediaSource representing the content media (i.e. not the ad).</span></span><br><span class="line">       <span class="keyword">final</span> MediaSource contentMediaSource = createMediaSource(Uri.parse(playUrl), <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">       <span class="comment">// Prepare the player with the source.</span></span><br><span class="line">       player.seekTo(contentPosition);</span><br><span class="line">       player.prepare(contentMediaSource);</span><br><span class="line">       player.setPlayWhenReady(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>
<p><strong>Releasing the player</strong></p>
<p>不再使用的时候将 player 释放掉是非常重要的，以便腾出有限的资源，如为其他应用程序使用视频解码器。这可以通过调用 ExoPlayer.release 来完成。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (player != <span class="keyword">null</span>) &#123;</span><br><span class="line">      player.release();</span><br><span class="line">      player = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p><a href="http://blog.csdn.net/hejjunlin/article/details/54693696" target="_blank" rel="noopener"><a href="http://blog.csdn.net/hejjunlin/article/details/54693696" target="_blank" rel="noopener">Google Exoplayer之全面认识</a></a></p>
<p><a href="https://www.jianshu.com/p/3251a5189f56" target="_blank" rel="noopener">ExoPlayer 开发者指导</a></p>
<p><a href="https://www.jianshu.com/p/d5a0ed770b3d" target="_blank" rel="noopener">转型到ExoPlayer，实现更多的自定义功能</a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>OAuth2.0学习</title>
    <url>/blog/2018/04/auth-learn-about.html</url>
    <content><![CDATA[<p>OAuth是一个关于授权（authorization）的开放网络标准，在全世界得到广泛应用，目前的版本是2.0版。</p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>周末逛简书，看了一篇写的极好的文章，点击大红心点赞，就直接给我跳转到登录界面了，原来点赞是需要登录的。<br>可是没有我并没有简书账号，一直使用的QQ的集成登录。下面有一排社交登录按钮，我们可以用第三方社交账号登陆即可。点击QQ图标，就给我跳转到了QQ登录授权页面，这样我们就可以通过QQ账号来登录简书，而不用重新注册一个账号了，而简书也可以拿到相关信息。</p>
<p>在传统的client-server认证模型中，客户端请求访问服务器上受限的资源（protected resource），需要通过使用资源所有者（resource owner）的凭证在服务器上进行认证。为了支持第三方应用程序访问受限资源，资源所有者需要向第三方应用共享其凭证。这就会造成以下问题：</p>
<p>1.第三方应用为了后续使用，会存储资源所有者的凭证主要是密码。<br>2.服务端需要支持密码认证，尽管密码认证不安全。<br>3.第三方应用获得对资源的过度访问而不仅局限于受限资源，且资源所有者没有办法对其进行限制。<br>4.资源所有者无法收回权限，除非修改密码。<br>5.如果第三方应用的密码被破解，就会导致所有被该密码保护的数据被泄露。</p>
<p>想一想这样一个场景，如果简书是直接使用QQ用户名密码登录，简书就很有可能会为了后续业务的需要而擅自保存QQ用户名及密码，简书只要拿到了QQ用户名密码就可以访问不仅仅QQ昵称、头像等信息，甚至可以获取到QQ用户的所有通讯录列表。如果简书的账号密码泄露，就会直接影响到QQ数据的安全。这是一个可怕的问题。</p>
<p>所以OAuth应运而生，来解决这一问题。</p>
<h3 id="授权流程"><a href="#授权流程" class="headerlink" title="授权流程"></a>授权流程</h3><p>下面我们就以简书使用QQ授权登录为例，来捋一捋OAuth 2.0的流程。<br>先来看看OAuth 2.0的流程，如下图所示：<br><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/other/p4.png" alt></p>
<p>这里面主要包含四个角色：</p>
<p>1.Client：需要授权的客户端，本文中就是【简书】。<br>2.Resource Owner：资源所有者，在本文中你可能会以为是 QQ，但要想清楚，QQ是属于个人的，所以在本文中资源所有者是指【QQ用户】。<br>3.Authorization Server：认证服务器，本文中特指【QQ互联平台】。<br>4.Resource Server：资源服务器，顾名思义，用来专门保存资源的服务器，接受通过访问令牌进行访问。本文特指【QQ用户信息中心】。</p>
<h4 id="第一步：引导用户到认证服务器"><a href="#第一步：引导用户到认证服务器" class="headerlink" title="第一步：引导用户到认证服务器"></a>第一步：引导用户到认证服务器</h4><p>打开简书网页，简书跳转到登录界面，要求用户登录。可是我们未在简书注册帐号，所以就点击了QQ图标，使用QQ帐号进行集成登录。跳转到QQ登录界面后，QQ要求用户授权。<br>这一步中简书主要做了这样一件事就是引导用户到认证服务器。<br>很显然【QQ互联平台】就是认证服务器。</p>
<p>如何引导？当然是页面跳转。<br>那认证服务器如何知道是简书过来的认证请求？<br>当然是传参。<br>那需要传递哪些参数呢？</p>
<ul>
<li>response_type：表示响应类型，必选项，此处的值固定为”code”；</li>
<li>client_id：表示客户端的ID，用来标志授权请求的来源，必选项；</li>
<li>redirect_uri：成功授权后的回调地址；</li>
<li>scope：表示申请的权限范围，可选项；</li>
<li>state：表示客户端的当前状态，可以指定任意值，认证服务器会原封不动地返回这个值。</li>
</ul>
<p>咱们看看简书实际发送的授权请求Url是：<br><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">https:<span class="regexp">//g</span>raph.qq.com<span class="regexp">/oauth2.0/</span>authorize?client_id=<span class="number">100410602</span> &amp;redirect_uri=http:<span class="regexp">//</span>www.jianshu.com<span class="regexp">/users/</span>auth<span class="regexp">/qq_connect/</span>callback &amp;response_type=code &amp;state=bb38108d1aaf567c72da0f1167e87142d0e20cb2bb24ec5a</span><br></pre></td></tr></table></figure></p>
<p>如图所示，除了scope参数外，其他四个参数均有传参。<br>此时你可能唯一对state参数比较迷惑，传递一个state参数，认证服务器会原封不动返回，那还干嘛要传递state参数呢？</p>
<p>我的理解是，简书用一个guid加长版字符串来唯一标识一个授权请求。这样才会正确获取授权服务器返回的授权码。</p>
<p>这里你可能会问了，既然我知道了这些参数，我岂不是可以伪造简书认证请求，修改redirect_uri参数跳转到个人的网站，然后不就可以获取QQ授权？</p>
<p>跟我一样太傻太天真，简书在QQ互联平台申请时肯定已经预留备案了要跳转返回的URL。QQ互联平台在收到简书的授权请求时肯定会验证回调Url的。</p>
<h4 id="第二步：用户同意为第三方客户端授权"><a href="#第二步：用户同意为第三方客户端授权" class="headerlink" title="第二步：用户同意为第三方客户端授权"></a>第二步：用户同意为第三方客户端授权</h4><p>这一步，对于用户来说，只需要使用资源所有者（QQ）的用户名密码登录，并同意授权即可。点击授权并登录后，授权服务器首先会post一个请求回服务器进行用户认证，认证通过后授权服务器会生成一个授权码，然后服务器根据授权请求的redirect_uri进行跳转，并返回授权码code和授权请求中传递的state。<br>这里要注意的是：授权码有一个短暂的时效</p>
<p>最终跳转回简书的Url为：<br><figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">http://www.jianshu.com/users/auth/qq_connect/callback?code=<span class="number">093</span>B9307E38DC5A2C3AD147B150F2AB3 &amp;<span class="keyword">state</span>=bb38108d1aaf567c72da0f1167e87142d0e20cb2bb24ec5a</span><br></pre></td></tr></table></figure></p>
<p>和之前的授权请求URL进行对比，可以发现redirect_uri、state完全一致。<br>而code=093B9307E38DC5A2C3AD147B150F2AB3就是返回的授权码</p>
<h4 id="第三步：使用授权码向认证服务器申请令牌"><a href="#第三步：使用授权码向认证服务器申请令牌" class="headerlink" title="第三步：使用授权码向认证服务器申请令牌"></a>第三步：使用授权码向认证服务器申请令牌</h4><p>从这一步开始，对于用户来说是察觉不到的。简书后台默默的在做后续的工作。</p>
<p>简书拿到QQ互联平台返回的授权码后，需要根据授权码再次向认证服务器申请令牌（access token）。<br>到这里有必要再理清两个概念：</p>
<ul>
<li>授权码（Authorization Code）：相当于授权服务器口头告诉简书，用户同意授权使用他的QQ登录简书了。</li>
<li>令牌（Access Token）：相当于临时身份证。</li>
</ul>
<p>那如何申请令牌呢？<br>简书需要后台发送一个get请求到认证服务器（QQ互联平台）。<br>那要携带哪些必要信息呢？<br>是的，要携带以下参数：</p>
<ul>
<li>grant_type：表示授权类型，此处的值固定为”authorization_code”，必选项；</li>
<li>client_id：表示从QQ互联平台申请到的客户端ID，用来标志请求的来源，必选项；</li>
<li>client_secret：这个是从QQ互联平台申请到的客户端认证密钥，机密信息十分重要，必选项；</li>
<li>redirect_uri：成功申请到令牌后的回调地址；</li>
<li>code：上一步申请到的授权码。</li>
</ul>
<p>根据以上信息我们可以模拟一个申请AccessToken的请求：<br><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">https:<span class="regexp">//g</span>raph.qq.com<span class="regexp">/oauth2.0/</span>token?client_id=<span class="number">100410602</span> &amp;client_secret=<span class="number">123456</span>jianshu &amp;redirect_uri=http:<span class="regexp">//</span>www.jianshu.com<span class="regexp">/users/</span>auth<span class="regexp">/qq_connect/</span>callback &amp;grant_type=authorization_code &amp;code=<span class="number">093</span>B9307E38DC5A2C3AD147B150F2AB3</span><br></pre></td></tr></table></figure></p>
<p>发送完该请求后，认证服务器验证通过后就会发放令牌，并跳转会简书，其中应该包含以下信息：</p>
<ul>
<li>access_token：令牌</li>
<li>expires_in：access token的有效期，单位为秒。</li>
<li>refresh_token：在授权自动续期步骤中，获取新的Access_Token时需要提供的参数。</li>
</ul>
<p>同样，我们可以模拟出一个返回的token：<br><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">http:<span class="regexp">//</span>www.jianshu.com<span class="regexp">/users/</span>auth<span class="regexp">/qq_connect/</span>callback?access_token=<span class="number">548</span>ADF2D5E1C5E88H4JH15FKUN51F &amp;expires_in=<span class="number">36000</span>&amp;refresh_token=<span class="number">53</span>AD68JH834HHJF9J349FJADF3</span><br></pre></td></tr></table></figure></p>
<p>这个时候简书还有一件事情要做，就是把用户token写到cookie里，进行用户登录状态的维持。</p>
<h4 id="第四步：向资源服务器申请资源"><a href="#第四步：向资源服务器申请资源" class="headerlink" title="第四步：向资源服务器申请资源"></a>第四步：向资源服务器申请资源</h4><p>有了token，向资源服务器提供的资源接口发送一个get请求不就行了，资源服务器校验令牌无误，就会向简书返回资源（QQ用户信息）。</p>
<p>同样咱们也来模拟一个使用token请求QQ用户基本信息资源的URL：<br><figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">https://graph.qq.com/user/get_user_info?<span class="attr">client_id=100410602</span> &amp;<span class="attr">qq=2098769873</span> &amp;<span class="attr">access_token=548ADF2D5E1C5E88H4JH15FKUN51F</span></span><br></pre></td></tr></table></figure></p>
<p>到这一步OAuth2.0的流程可以说是结束了，但是对于简书来说还有重要的事情要做。那就是：<br>拿到token、reresh_token和用户数据这么重要的东西不存数据库傻呀？</p>
<h4 id="第五步：令牌延期（刷新）"><a href="#第五步：令牌延期（刷新）" class="headerlink" title="第五步：令牌延期（刷新）"></a>第五步：令牌延期（刷新）</h4><p>你肯定对第四步返回的refresh_token比较好奇。<br>它是用来对令牌进行延期（刷新）的。为什么会有两种说法呢，因为可能认证服务器会重新生成一个令牌，也有可能对过期的令牌进行延期。</p>
<p>比如说，QQ互联平台为了安全性考虑，返回的access_token是有时间限制的，假如用户某天不想授权了呢，总不能给了个access_token你几年后还能用吧。我们上面模拟返回的令牌有效期为10小时。10小时后，用户打开浏览器逛简书，浏览器中用户的token对应的cookie已过期。简书发现浏览器没有携带token信息过来，就明白token失效了，需要重新向认证平台申请授权。如果让用户再点击QQ进行登录授权，这明显用户体验不好。咋搞呢？refresh_token就派上了用场，可以直接跳过前面申请授权码的步骤，当发现token失效了，简书从浏览器携带的cookie中的sessionid找到存储在数据库中的refresh_token，然后再使用refresh_token进行token续期（刷新）。</p>
<p>那用refresh_token进行token续期需要怎么做呢？<br>同样需要向认证服务器发送一个get请求。<br>需要哪些参数？</p>
<ul>
<li>grant_type：表示授权类型，此处的值固定为”refresh_token”，必选项；</li>
<li>client_id：表示从QQ互联平台申请到的客户端ID，用来标志请求的来源，必选项；</li>
<li>client_secret：这个是从QQ互联平台申请到的客户端认证密钥，机密信息十分重要，必选项；</li>
<li>refresh_token：即申请令牌返回的refresh_token。</li>
</ul>
<p>根据上述信息，我们又可以模拟一个令牌刷新的URL：<br><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">https:<span class="regexp">//g</span>raph.qq.com<span class="regexp">/oauth2.0/</span>token?client_id=<span class="number">100410602</span> &amp;client_secret=<span class="number">123456</span>jianshu &amp;redirect_uri=http:<span class="regexp">//</span>www.jianshu.com<span class="regexp">/users/</span>auth<span class="regexp">/qq_connect/</span>callback &amp;grant_type=refresh_token &amp;refresh_token=<span class="number">53</span>AD68JH834HHJF9J349FJADF3</span><br></pre></td></tr></table></figure></p>
<p>那返回的结果呢?<br>和第四步返回的结果一样。</p>
<p>这里你可能又有疑问了，那既然每次进行令牌延期后都会重新返回一个refresh_token，那岂不是我可以使用refresh_token无限延期？<br>天真如我啊，refresh_token也是有过期时间的。而这个过期时间具体是由认证服务器决定的。<br>一般来说refresh_token的过期时间要大于access_token的过期时间。只有这样，access_token过期时，才可以使用refresh_token进行令牌延期（刷新）。</p>
<p>举个简单例子：<br>假设简书从QQ互联平台默认获取到的access_token的有效期是1天，refresh_token的有效期为一周。</p>
<p>用户今天使用QQ登录授权后，过了两天再去逛简书，简书发现token失效，立马用refresh_token刷新令牌，默默的完成了授权的延期。<br>假如用户隔了两周再去逛简书，简书一核对，access_token、refresh_token全都失效，就只能乖乖引导用户到授权页面重新授权，也就是回到OAuth2.0的第一步。</p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://www.cnblogs.com/sheng-jie/p/6564520.html" target="_blank" rel="noopener">OAuth2.0 知多少</a><br><a href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html" target="_blank" rel="noopener">理解OAuth 2.0</a></p>
]]></content>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>Android开源项目学习</title>
    <url>/blog/2018/04/android-open-project.html</url>
    <content><![CDATA[<p>1.<a href="https://github.com/Assassinss/Interessant" target="_blank" rel="noopener">A simple, unofficial android client of Eyepetizer–开眼视频.</a><br>2.<a href="https://github.com/wenmingvs/WeiBo" target="_blank" rel="noopener">第三方新浪微博客户端</a><br>3.<a href="https://github.com/i5sing/5sing-mobile-api" target="_blank" rel="noopener">中国原创音乐基地5sing mobile api</a><br>4.<a href="https://github.com/brianwernick/ExoMedia" target="_blank" rel="noopener">An Android ExoPlayer wrapper to simplify Audio and Video implementations</a><br>5.<a href="https://mp.weixin.qq.com/s/x395QKua6MjGb0Ayj4Q8PQ" target="_blank" rel="noopener">地理杂志阅读类APP,采用Architecture Components构建</a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Java多线程与线程池</title>
    <url>/blog/2018/05/java-thread-pool.html</url>
    <content><![CDATA[<h3 id="java-Object-wait-notify等待通知机制的理解"><a href="#java-Object-wait-notify等待通知机制的理解" class="headerlink" title="java Object.wait notify等待通知机制的理解"></a>java Object.wait notify等待通知机制的理解</h3><h4 id="wait"><a href="#wait" class="headerlink" title="wait()"></a>wait()</h4><figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">* notify()&#125;<span class="built_in"> or </span>&#123;@code notifyAll()&#125; method of this object. This method can</span><br><span class="line"> * only be invoked by a thread which owns this object's monitor; see</span><br><span class="line"> * &#123;@link <span class="comment">#notify()&#125; on how a thread can become the owner of a monitor.</span></span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * A waiting thread can be sent &#123;@code interrupt()&#125; to cause it to</span><br><span class="line"> * prematurely stop waiting, so &#123;@code wait&#125; should be called in a loop to</span><br><span class="line"> *<span class="built_in"> check </span>that the condition that has been waited for has been met before</span><br><span class="line"> * continuing.</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * While the thread waits, it gives up ownership of this object's monitor.</span><br><span class="line"> * When it is notified (or interrupted), it re-acquires the<span class="built_in"> monitor </span>before</span><br><span class="line"> * it starts running.</span><br><span class="line"> * @throws IllegalMonitorStateException</span><br><span class="line"> *            <span class="built_in"> if </span>the thread calling this method is<span class="built_in"> not </span>the owner of this</span><br><span class="line"> *             object's monitor.</span><br><span class="line"> * @throws InterruptedException</span><br><span class="line"> *            <span class="built_in"> if </span>another thread interrupts this thread while it is waiting.</span><br></pre></td></tr></table></figure>
<p>该方法的注释说：使调用线程处于wait状态，直到其他线程调用这个Object的notify或者notifyAll才会被唤醒。这个方法只能被拥有这个Object的Monitor才能被调用。一个正在wait的线程能够被调用interrupt方法。<br>当一个线程处于Wait，它放弃了它自己的Object Monitor，当它被notified或者interrupted的时候，它会在它启动之前重新请求这个monitor</p>
<h4 id="noitify"><a href="#noitify" class="headerlink" title="noitify()"></a>noitify()</h4><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">* calling one <span class="keyword">of</span> <span class="keyword">the</span> &#123;@code wait()&#125; methods) <span class="keyword">to</span> be woken up. If more than one thread <span class="keyword">is</span> waiting, one <span class="keyword">of</span> them <span class="keyword">is</span> chosen <span class="keyword">at</span> <span class="keyword">the</span> discretion <span class="keyword">of</span> <span class="keyword">the</span> VM. The chosen thread will <span class="keyword">not</span> <span class="built_in">run</span> immediately. The thread</span><br><span class="line"> * <span class="keyword">that</span> called &#123;@code notify()&#125; has <span class="keyword">to</span> release <span class="keyword">the</span> object's monitor <span class="keyword">first</span>.</span><br><span class="line"> * Also, <span class="keyword">the</span> chosen thread still has <span class="keyword">to</span> compete <span class="keyword">against</span> other threads <span class="keyword">that</span></span><br><span class="line"> * <span class="keyword">try</span> <span class="keyword">to</span> synchronize <span class="keyword">on</span> <span class="keyword">the</span> same object.</span><br><span class="line"> * This method can only be invoked <span class="keyword">by</span> a thread which owns this object's</span><br><span class="line"> * monitor. A thread becomes owner <span class="keyword">of</span> an object's monitor <span class="keyword">by</span> executing a synchronized method <span class="keyword">of</span> <span class="keyword">that</span> object; <span class="keyword">by</span> executing <span class="keyword">the</span> body <span class="keyword">of</span> a &#123;@code synchronized&#125; statement <span class="keyword">that</span> synchronizes <span class="keyword">on</span> <span class="keyword">the</span> object;<span class="keyword">by</span> executing a synchronized static method <span class="keyword">if</span> <span class="keyword">the</span> object <span class="keyword">is</span> <span class="keyword">of</span> type &#123;@code Class&#125;.</span><br></pre></td></tr></table></figure>
<p>使得一个正在等待这个Object的Monitor的线程被唤醒。如果超过一个线程正在等待的话，那么就只有一个线程会被唤醒，而这个线程会由VM自己决定。而这个被选择的线程并不会立马就进入run的状态，调用了notify的线程会首先释放这个Object的Monitor。并且，被选择的线程必须完成和其他线程完成对这个Object锁的竞争。这个方法只能被拥有这个Object的Monitor的线程调用。这个线程拥有这个Object的Monitor，通过执行一个同步方法或者一个同步的代码块来获取这个对象的锁，或者通过执行这个对象的Class类来进行同步。</p>
<h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><ul>
<li>使用wait 必须进行try catch</li>
<li>记住调用wait或者notify方法必须采用当前锁调用，即必须采用synchronized中的对象，wait的本意是暂时释放掉对象锁，让别的需要此对象的代码能够有机会执行。</li>
<li>永远不要在循环之外调用wait方法,对于从wait中被notify的进程来说，它在被notify之后还需要重新检查是否符合执行条件，如果不符合，就必须再次被wait，如果符合才能往下执行</li>
</ul>
<h3 id="thread-join的作用"><a href="#thread-join的作用" class="headerlink" title="thread join的作用"></a>thread join的作用</h3><p>join的作用：让父线程等待子线程结束之后才能继续运行。<br>详情可见：<a href="https://www.cnblogs.com/huangzejun/p/7908898.html#p1" target="_blank" rel="noopener">https://www.cnblogs.com/huangzejun/p/7908898.html#p1</a></p>
<h3 id="synchronized的作用"><a href="#synchronized的作用" class="headerlink" title="synchronized的作用"></a>synchronized的作用</h3><p>synchronized是Java中的关键字，是一种同步锁。它修饰的对象有以下几种： </p>
<ol>
<li>修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象； </li>
<li>修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象； </li>
<li>修改一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象； </li>
<li>修改一个类，其作用的范围是synchronized后面括号括起来的部分，作用主的对象是这个类的所有对象。</li>
</ol>
<p>一个线程访问一个对象中的synchronized(this)同步代码块时，其他试图访问该对象的线程将被阻塞。<br>synchronized只锁定对象，每个对象只有一个锁（lock）与之相关联<br>详情可见：<a href="https://blog.csdn.net/luoweifu/article/details/46613015" target="_blank" rel="noopener">https://blog.csdn.net/luoweifu/article/details/46613015</a></p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>读《刀锋》</title>
    <url>/blog/2018/05/read-razar-shape.html</url>
    <content><![CDATA[<blockquote>
<p>The sharp edge of a razor is difficult to pass over, thus the wise say the path to Salvation is hard.</p>
</blockquote>
<p>&emsp;&emsp;其实我是不大喜欢读外国名著的，就如诗歌经过翻译后往往索然无味一样，很多名著在我读来也是味如嚼蜡，正如《白鹿原》在我读来比《百年孤独》有趣的多，大概是因为文化和语言的隔阂吧。但毛姆，我总共也只读过他写的三本书，《月亮与六便士》，《面纱》，还有就是这本《刀锋》，竟然每一本都很惊艳，很喜欢，真的是一件挺神奇的事，不得不说，毛姆的确非常会讲故事。读了这几本书，也能发现一些共同点，在毛姆的作品中，似乎总会出现这样一个人。这个人，穷极一生都在追求自己所追求的真理。这样的主题要是俄罗斯作家写起来，肯定是让人头痛的大部头。但在毛姆的笔下，却总是引人入胜的故事，这大概是毛姆最大的优点吧。</p>
<p>&emsp;&emsp;《刀锋》主要写了一个参加第一次大战的美国青年飞行员拉里·达雷尔。在军队中，拉里结识了一个爱尔兰好友：这人平时是那样一个生龙活虎般的置生死于度外的飞行员，但在一次遭遇战中，因趋救拉里而中弹牺牲。拉里因此对人生感到迷惘，弄不懂世界上为什么有恶和不幸.复员后，拉里既不肯进大学，也不肯就业，一心想探求人生的终极。为此，他丢下未婚妻来到巴黎；两年后，和未婚妻解约，又从巴黎遍游世界各地，最后到了印度，找到了印度的吠陀经哲学。于是了悟人生，把自己的一点薄产分散给亲友，自己返回美国，当一个自食其力的出租汽车司机,打算隐身人海，以终天年。</p>
<center><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/blog/p24.jpg"></center>

<p>&emsp;&emsp;毫无疑问，拉里这个角色看起来不太真实，要是现实生活中碰到，肯定会被当作是不切实际的文艺青年，尤其是作者写到拉里在印度呆了五年并且获得了顿悟，这让人想起了近些年流行去西藏洗涤心灵的文艺青年，印度对于英国人，大概就象西藏对于我们，都是母国疆界内的神秘异域，潜藏着无尽的智慧源泉，可以方便地为一切苦恼提供答案，想当年乔布斯也去过印度来者。不过我这个人向来不相信去旅行一趟就能够涤荡心灵什么的，也不相信印度或者西藏会有什么特别的智慧。倘若印度或者西藏有什么智慧，这种智慧，既没有为低种姓和西藏农奴带来什么幸福，也没能帮助印度免于大英帝国的殖民。书中伊莎贝尔多次问拉里，你所追求的这些知识有什么用呢？拉里回答说，当我有了知识，我自然会知道它有什么用处。哈哈，这倒有点禅宗的意思了。不过在我看来，从古至今的宗教大师带给全人类的幸福，恐怕还不及牛顿一人。</p>
<p>&emsp;&emsp;至于本书的其他角色，毛姆写《刀锋》的时候已经70岁了，他对笔下的人物既刻薄又宽容，刻薄的是笔下的人物不论怎么有钱怎么高尚怎么大方，毛姆都不觉得新鲜，觉得这是人性使然。宽容的也是笔下的人物不论怎么“作”怎么傻怎么不理智，毛姆也都不觉得新鲜，觉得这是人性使然。他小心翼翼地“不把艾略特.谈波登那个‘大大的势利鬼’贬得很低。对放浪形骸的索菲.麦唐纳只有同情，对当模特儿兼妓女的苏姗.鲁维埃能够有一个归宿感到欣幸，对头脑简单的格雷.马图林，在他的笔下绝少挖苦，而往往突出他的忠厚和慈爱”，对伊莎贝儿也谈不上“毫不徇情地揭露”，可以说笔下都留有余地、善意、宽容。</p>
<p>&emsp;&emsp;正如作者在最后所说的那样，我是个俗人，是尘世中人；我只能对拉里这类人中麟凤的光辉形象表示景慕，没法步他的后尘。他没有野心，不要名；他最厌恶成为知名人士；所以很可能安心安意地过着自己挑选的生活，我行我素，别无所求，他本人始终抱着无我和无求的态度，走着一条通往自我完善的道路。 不管怎么说，拉里的生命历程代表了人类可以选择的另一种生活方式，虽然不能理解，却总是能够吸引人的。在这本书里，大家都求仁得仁，想必是极好的。作者在最后写到：</p>
<blockquote>
<p>使我非常吃惊的是，我忽然恍悟，尽管丝毫没有意思要这样做，我不多不少恰恰写了一部以“成功”为题材的小说。因为书中和我有关的人物无不<br>如愿以偿：艾略特成为社交界名流；伊莎贝儿在一个活跃而有文化的社会里取得巩固地位，并且有一笔财产做靠山；格雷找到一个稳定而赚钱的职业可以每天从早上九点到下午六点上班；苏姗·鲁维埃得到生活保障；索菲获得死；拉里找到了安身立命之道。所以，不管那些自命风雅的人多么挑剔，一般公众从心眼里还是喜欢一部如愿以偿的小说的；所以，也许我的故事结局毕竟并不是怎样不如人意呢。 </p>
</blockquote>
]]></content>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Android组件化</title>
    <url>/blog/2018/05/android-componet-start.html</url>
    <content><![CDATA[<h3 id="为什么要项目组件化"><a href="#为什么要项目组件化" class="headerlink" title="为什么要项目组件化"></a>为什么要项目组件化</h3><p>随着APP版本不断的迭代，新功能的不断增加，业务也会变的越来越复杂，APP业务模块的数量有可能还会继续增加，而且每个模块的代码也变的越来越多，这样发展下去单一工程下的APP架构势必会影响开发效率，增加项目的维护成本，每个工程师都要熟悉如此之多的代码，将很难进行多人协作开发，而且Android项目在编译代码的时候电脑会非常卡，又因为单一工程下代码耦合严重，每修改一处代码后都要重新编译打包测试，导致非常耗时，最重要的是这样的代码想要做单元测试根本无从下手，所以必须要有更灵活的架构代替过去单一的工程架构。</p>
<p>随着产品的迭代，业务越来越复杂，随之带来的是项目结构复杂度的极度增加，此时我们会面临如下几个问题：</p>
<p>1、实际业务变化非常快，但是单一工程的业务模块耦合度太高，牵一发而动全身；<br>2、对工程所做的任何修改都必须要编译整个工程；<br>3、功能测试和系统测试每次都要进行；<br>4、团队协同开发存在较多的冲突.不得不花费更多的时间去沟通和协调，并且在开发过程中，任何一位成员没办法专注于自己的功能点，影响开发效率；<br>5、不能灵活的对业务模块进行配置和组装；</p>
<p>为了满足各个业务模块的迭代而彼此不受影响，更好的解决上面这种让人头疼的依赖关系，就需要整改App的架构。</p>
<h3 id="如何组件化"><a href="#如何组件化" class="headerlink" title="如何组件化"></a>如何组件化</h3><center><img src="https://raw.githubusercontent.com/shenzhen2017/myImage/master/other/p5.png"></center>

<p>Android APP组件化架构的目标是告别结构臃肿，让各个业务变得相对独立，业务组件在组件模式下可以独立开发，而在集成模式下又可以变为arr包集成到“app壳工程”中，组成一个完整功能的APP；<br>从组件化工程模型中可以看到，业务组件之间是独立的，没有关联的，这些业务组件在集成模式下是一个个library，被app壳工程所依赖，组成一个具有完整业务功能的APP应用，但是在组件开发模式下，业务组件又变成了一个个application，它们可以独立开发和调试，由于在组件开发模式下，业务组件们的代码量相比于完整的项目差了很远，因此在运行时可以显著减少编译时间。</p>
<h3 id="组件化实施流程"><a href="#组件化实施流程" class="headerlink" title="组件化实施流程"></a>组件化实施流程</h3><h4 id="组件模式和集成模式的转换"><a href="#组件模式和集成模式的转换" class="headerlink" title="组件模式和集成模式的转换"></a>组件模式和集成模式的转换</h4><p>Gradle自动构建工具有一个重要属性，可以帮助我们完成这个事情。每当我们用AndroidStudio创建一个Android项目后，就会在项目的根目录中生成一个文件 gradle.properties，我们将使用这个文件的一个重要属性：在Android项目中的任何一个build.gradle文件中都可以把gradle.properties中的常量读取出来；那么我们在上面提到解决办法就有了实际行动的方法，首先我们在gradle.properties中定义一个常量值 isModule（是否是组件开发模式，true为是，false为否）：<br><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 每次更改“isModule”的值后，需要点击 "Sync Project" 按钮</span></span><br><span class="line"><span class="attr">isModule</span>=<span class="literal">false</span></span><br></pre></td></tr></table></figure></p>
<p>然后我们在业务组件的build.gradle中读取 isModule，但是 gradle.properties 还有一个重要属性： gradle.properties 中的数据类型都是String类型，使用其他数据类型需要自行转换；也就是说我们读到 isModule 是个String类型的值，而我们需要的是Boolean值，代码如下：<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (isModule.toBoolean()) &#123;</span><br><span class="line">    apply <span class="string">plugin:</span> <span class="string">'com.android.application'</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    apply <span class="string">plugin:</span> <span class="string">'com.android.library'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="组件之间AndroidManifest合并问题"><a href="#组件之间AndroidManifest合并问题" class="headerlink" title="组件之间AndroidManifest合并问题"></a>组件之间AndroidManifest合并问题</h4><p>在集成模式和组件模式，AndroidManifest也不同，我们可以为组件开发模式下的业务组件再创建一个 AndroidManifest.xml，然后根据isModule指定AndroidManifest.xml的文件路径，让业务组件在集成模式和组件模式下使用不同的AndroidManifest.xml，这样表单冲突的问题就可以规避了。<br><figure class="highlight puppet"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sourceSets</span> &#123;</span><br><span class="line">      <span class="keyword">main</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (isModule.toBoolean()) &#123;</span><br><span class="line">              <span class="literal">manifest</span>.srcFile <span class="string">'src/main/module/AndroidManifest.xml'</span></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="literal">manifest</span>.srcFile <span class="string">'src/main/AndroidManifest.xml'</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>这样在不同的开发模式下就会读取到不同的 AndroidManifest.xml ，然后我们需要修改这两个表单的内容以为我们不同的开发模式服务。</p>
<p>首先是集成开发模式下的 AndroidManifest.xml，前面我们说过集成模式下，业务组件的表单是绝对不能拥有自己的 Application 和 launch 的 Activity的，也不能声明APP名称、图标等属性，总之app壳工程有的属性，业务组件都不能有，下面是一份标准的集成开发模式下业务组件的 AndroidManifest.xml：<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">package</span>=<span class="string">"com.guiying.girls"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span> <span class="attr">android:theme</span>=<span class="string">"@style/AppTheme"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">".main.GirlsActivity"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:screenOrientation</span>=<span class="string">"portrait"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">".girl.GirlActivity"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:screenOrientation</span>=<span class="string">"portrait"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:theme</span>=<span class="string">"@style/AppTheme.NoActionBar"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>然后是组件开发模式下的表单文件：<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">package</span>=<span class="string">"com.guiying.girls"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">"debug.GirlsApplication"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:allowBackup</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:icon</span>=<span class="string">"@mipmap/ic_launcher"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:label</span>=<span class="string">"@string/girls_name"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:supportsRtl</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:theme</span>=<span class="string">"@style/AppTheme"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">".main.GirlsActivity"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:screenOrientation</span>=<span class="string">"portrait"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.MAIN"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.LAUNCHER"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">".girl.GirlActivity"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:screenOrientation</span>=<span class="string">"portrait"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:theme</span>=<span class="string">"@style/AppTheme.NoActionBar"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://blog.csdn.net/guiying712/article/details/55213884" target="_blank" rel="noopener">Android组件化方案</a><br><a href="https://www.jianshu.com/p/1b1d77f58e84" target="_blank" rel="noopener">Android彻底组件化方案实践</a></p>
<p>示例项目：<br><a href="https://github.com/qingmei2/MvpArchitecture-Android" target="_blank" rel="noopener">https://github.com/qingmei2/MvpArchitecture-Android</a><br><a href="https://github.com/luojilab/DDComponentForAndroid" target="_blank" rel="noopener">https://github.com/luojilab/DDComponentForAndroid</a><br><a href="https://github.com/guiying712/AndroidModulePattern" target="_blank" rel="noopener">https://github.com/guiying712/AndroidModulePattern</a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>读《天行健》</title>
    <url>/blog/2018/06/read-tian-jian.html</url>
    <content><![CDATA[<blockquote>
<p>唯刀百辟，唯心不易</p>
</blockquote>
<p>&emsp;&emsp;《天行健》，作者燕垒生，是作者天地人三部曲的第一部，后面两部分别是《地火明夷》，《人之道》。首先这套书是一套非常长却也非常精彩的书。小说从帝国军讨伐共和军叛乱开始讲起。由武侯所率领的帝国军攻下了共和军的最后一座城池——高鹫城。作为前锋营百夫长的我（楚休红），因为首先攻破了城门，而被武侯器重，赐给了我一把刀–百辟刀。还沉浸在大获全胜的狂欢喜悦中的帝国军，却陷入了蛇人的包围。蛇人上半身长得像人，下半身是蛇，行动灵活，而又力大无穷。在蛇人的围困下，十万帝国南征军全军覆灭，只有主角和另个七个人乘坐飞行机逃生。，蛇人的攻势席卷大江南北，从帝国的最南方攻到了帝都城下。面临着被灭种的危机，帝国在全国最有权势的人——文侯的带领下，开始了反击战，在帝都城下，背城一战，通过地雷阵重创蛇人，成功扭转了战局。帝都这一战大概是全书写的最好的一场战役了，从高鹫全军覆没到东平城破，再到北宁失陷，帝国军一败再败，退守孤城，最后力挽狂澜，反败为胜，令人拍案，就像一支蓄足了势的弓箭，一旦脱手便如流星般席卷而去，最后正中靶心。</p>
<p>&emsp;&emsp;这本书初看起来是古代背景，但又出现了共和军，帝国军这样的称谓，同时后面竟然出现了火雷阵，飞行机，铁甲车，螺舟，铁甲舰这些重新发明的武器，颇有些蒸汽朋克的味道。后面才知道，这本书的历史背景大概是人类经过核大战或者其他什么灾难之后，上古人类躲藏到了地下，而地面上的人类，也就是我们的主角们，都是在末世后重新发展出来的文明。而蛇人则是旧人类从地下走出来后，用机器造出来的用以消灭新人类的工具。听起来有点科幻了，哈哈。不过在这本书里层出不穷的新科技的发明，往往是战争的决定性因素，每次战争的转折点，往往都是一件新武器的发明，这样读来却是新奇，让人觉得有点像开了金手指一样。不过回过头来想一想，或许战争也可以是这样的，在一战时，各国不断推出的坦克，毒气，潜艇，飞艇，机枪等等武器，更不要说二战时美国的原子弹了。</p>
<p>&emsp;&emsp;本书的主角，楚休红，却实在有些不太讨人喜欢，比起书中的其他角色，做事优柔寡断迟疑不决，而且还有点圣母，不知道是不是第一人称的原因，感觉才能也一般，能活到最后成为大帅让人感觉只是运气好，哈哈。毕竟是十年前的书了，现在圣母和杰克苏已经让人有些厌烦了。其实这本书最有趣的还是书中的影射，共和军遭到政府军多次围剿后处于覆灭边缘，突然杀出蛇人（日军），于是两方不得不联手抗敌，期间共和军改变根据地，更换领导班子，扩大力量，渐渐获得部分地区统治权。其后又发动土地革命，顺应民心民意，最终夺取政权。而在第二部《地火明夷》中对共和政府的种种讽刺更是有一种熟悉的感觉。可以看出，对于共和制和帝制，作者其实并没有什么倾向，对于两者对讽刺了个遍。兴，百姓苦，亡，百姓苦，所以在地火明夷的结尾，作者安排陆明夷又复辟了帝制，历经数年的共和正统之争都成了空，最后一切都回到了起点。所以说封侯将军事，战士半死生，头颅轻一掷，空有国殇名；所以说一朝英雄拔剑起，又是苍生十年劫；所以说苍生苦难，不知伊于胡底。但是究竟该怎么办呢，纵然共和制并不完美，难道就是没有意义没有进步的吗？究竟该怎么办呢？可能作者也不知道吧，所以主角楚休红选择了牺牲而主角郑司楚选择了归隐，这个问题就留给郡主，文候，南武，陆明夷这样的人吧，楚休红，或者郑司楚都不适合这样的问题。</p>
<blockquote>
<p>巍巍宫阙接天长，九阍帝子欲开疆。<br>东城健儿备鞍马，西城健儿市刀枪。<br>家家裁征衣，户户舂军粮。<br>稚儿犹在抱，漫语阿爷早还乡。<br>君不见白骨蔽野纷如雪，高树悲风声飒飒。<br>一朝英雄拔剑起，又是苍生十年劫。</p>
</blockquote>
]]></content>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Retrofit2缓存实现</title>
    <url>/blog/2018/07/retrofit-okhttp-cache.html</url>
    <content><![CDATA[<h3 id="为什么使用缓存"><a href="#为什么使用缓存" class="headerlink" title="为什么使用缓存"></a>为什么使用缓存</h3><p>1.提高加载速度<br>2.减少流量消耗<br>3.减轻服务端压力<br>4.没有网络时可以同样访问，优化用户体验</p>
<p>说说我的需求:<br>1.有网的时候使用缓存较短时间，及时更新，没有网的时候缓存更长时间<br>2.指定的接口产生缓存文件,其他接口不会产生缓存文件<br>3.可通过下拉刷新强制刷新</p>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>Retrofit2实现缓存自然是通过okhttp拦截器实现，具体则是由Cache-Control控制<br>分别如下：<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">no-<span class="keyword">cache</span>    <span class="keyword">no</span>-<span class="keyword">cache</span>是会被缓存的，只不过每次在向客户端（浏览器）提供响应数据时，缓存都要向服务器评估缓存响应的有效性。 </span><br><span class="line"></span><br><span class="line"><span class="keyword">no</span>-<span class="keyword">store</span>    所有内容都不会被缓存到缓存或 Internet 临时文件中</span><br><span class="line"></span><br><span class="line"><span class="keyword">max</span>-age=xxx (xxx <span class="keyword">is</span> <span class="built_in">numeric</span>)    缓存的内容将在 xxx 秒后失效, 这个选项只在<span class="keyword">HTTP</span> <span class="number">1.1</span>可用, 并如果和<span class="keyword">Last</span>-Modified一起使用时, 优先级较高</span><br><span class="line"></span><br><span class="line"><span class="keyword">max</span>-stale和<span class="keyword">max</span>-age一样，只能设置在请求头里面。</span><br><span class="line"></span><br><span class="line">同时设置<span class="keyword">max</span>-stale和<span class="keyword">max</span>-age，缓存失效的时间按最长的算。(这个其实不用纠结)</span><br><span class="line"></span><br><span class="line">CacheControl.FORCE_CACHE 强制使用缓存,如果没有缓存数据,则抛出<span class="number">504</span>(<span class="keyword">only</span>-<span class="keyword">if</span>-cached)</span><br><span class="line">CacheControl.FORCE_NETWORK 强制使用网络,不使用任何缓存.</span><br></pre></td></tr></table></figure></p>
<h3 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h3><p>1.先要创建拦截器<br><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> Interceptor REWRITE_CACHE_CONTROL_INTERCEPTOR = <span class="keyword">new</span> Interceptor() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="function">Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">            Request request = chain.request();</span><br><span class="line">            Response response = chain.<span class="keyword">proceed</span>(request);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (NetworkUtil.isNetworkAvalible(MyApplication.getContext())) &#123;</span><br><span class="line">                <span class="keyword">int</span> maxAge = <span class="number">60</span>;<span class="comment">//缓存失效时间，单位为秒</span></span><br><span class="line">                <span class="keyword">return</span> response.newBuilder()</span><br><span class="line">                        .removeHeader(<span class="string">"Pragma"</span>)<span class="comment">//清除头信息，因为服务器如果不支持，会返回一些干扰信息，不清除下面无法生效</span></span><br><span class="line">                        .header(<span class="string">"Cache-Control"</span>, <span class="string">"public ,max-age="</span> + maxAge)</span><br><span class="line">                        .build();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure></p>
<p>2.这样的话就写好了拦截器，然后就是把拦截器设置到okhttp里面</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">File httpCacheDirectory = new File(MyApplication.getInstance().getExternalCacheDir(), <span class="string">"HttpCache"</span>);</span><br><span class="line">        int <span class="keyword">cacheSize </span>= <span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">        <span class="keyword">Cache </span><span class="keyword">cache </span>= new <span class="keyword">Cache(httpCacheDirectory, </span><span class="keyword">cacheSize);</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword"> </span>       OkHttpClient client = new OkHttpClient.<span class="keyword">Builder()</span></span><br><span class="line"><span class="keyword"> </span>               .connectTimeout(<span class="number">15</span>, TimeUnit.SECONDS)</span><br><span class="line">                .readTimeout(<span class="number">20</span>, TimeUnit.SECONDS)</span><br><span class="line">                .<span class="keyword">addNetworkInterceptor(REWRITE_CACHE_CONTROL_INTERCEPTOR)</span></span><br><span class="line"><span class="keyword"> </span>               .<span class="keyword">cache(cache)</span></span><br><span class="line"><span class="keyword"> </span>               .<span class="keyword">build();</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword"> </span> 		retrofit = new Retrofit.<span class="keyword">Builder()</span></span><br><span class="line"><span class="keyword"> </span>               .<span class="keyword">baseUrl(BASE_URL)</span></span><br><span class="line"><span class="keyword"> </span>               .client(client)</span><br><span class="line">                .<span class="keyword">addConverterFactory(GsonConverterFactory.create())</span></span><br><span class="line"><span class="keyword"> </span>               .<span class="keyword">addCallAdapterFactory(RxJava2CallAdapterFactory.create())</span></span><br><span class="line"><span class="keyword"> </span>               .<span class="keyword">build();</span></span><br></pre></td></tr></table></figure>
<p>注意缓存路径要写对，同时注意addNetworkInterceptor和addInterceptor的区别<br>这样就简单实现了retrofit的缓存，在60秒内可以通过缓存来访问，优化访问速度与体验</p>
<h3 id="不同接口可缓存不同时间，同时可设置是否缓存"><a href="#不同接口可缓存不同时间，同时可设置是否缓存" class="headerlink" title="不同接口可缓存不同时间，同时可设置是否缓存"></a>不同接口可缓存不同时间，同时可设置是否缓存</h3><p>从header中获取cache-Control字段，即可实现不同接口缓存不同时间，header中没有cache-control字段时则不缓存</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Headers</span>(<span class="string">"Cache-Control: public, max-age=3600"</span>)</span><br><span class="line">    <span class="meta">@GET</span>(<span class="string">"song/getsonglistsong?id=recommend"</span>)</span><br><span class="line">    Flowable&lt;SongList&gt; getRecommendList();</span><br><span class="line"></span><br><span class="line"> 	<span class="keyword">static</span> Interceptor REWRITE_CACHE_CONTROL_INTERCEPTOR = <span class="keyword">new</span> Interceptor() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="function">Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">            Request request = chain.request();</span><br><span class="line">            Response response = chain.<span class="keyword">proceed</span>(request);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (NetworkUtil.isNetworkAvalible(MyApplication.getContext())) &#123;</span><br><span class="line">                String cacheControl =request.cacheControl().toString();</span><br><span class="line">                <span class="keyword">return</span> response.newBuilder()</span><br><span class="line">                        .removeHeader(<span class="string">"Pragma"</span>)<span class="comment">//清除头信息，因为服务器如果不支持，会返回一些干扰信息，不清除下面无法生效</span></span><br><span class="line">                        .header(<span class="string">"Cache-Control"</span>, cacheControl)</span><br><span class="line">                        .build();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://www.cnblogs.com/cxk1995/p/5996586.html" target="_blank" rel="noopener">https://www.cnblogs.com/cxk1995/p/5996586.html</a><br><a href="https://blog.csdn.net/adzcsx2/article/details/51365548" target="_blank" rel="noopener">https://blog.csdn.net/adzcsx2/article/details/51365548</a><br><a href="https://www.jianshu.com/p/241e6af94390" target="_blank" rel="noopener">https://www.jianshu.com/p/241e6af94390</a><br><a href="https://blog.csdn.net/wangkeke1860/article/details/52084869" target="_blank" rel="noopener">https://blog.csdn.net/wangkeke1860/article/details/52084869</a><br><a href="https://www.jianshu.com/p/9c3b4ea108a7" target="_blank" rel="noopener">https://www.jianshu.com/p/9c3b4ea108a7</a><br><a href="https://www.cnblogs.com/android-yus/p/5280739.html" target="_blank" rel="noopener">https://www.cnblogs.com/android-yus/p/5280739.html</a><br><a href="https://blog.csdn.net/u010286855/article/details/52608485" target="_blank" rel="noopener">https://blog.csdn.net/u010286855/article/details/52608485</a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android事件传递</title>
    <url>/blog/2018/07/android-touch-demo.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近在实现自定义Sticklayout,发现有时候move子view时不能整体滑动，log日志如下：<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="number">07</span><span class="number">-16</span> <span class="number">20</span>:<span class="number">48</span>:<span class="number">50.945</span> <span class="number">16256</span><span class="number">-16256</span><span class="regexp">/com.zhangjie.androidtouch I/</span><span class="string">tiaoshi:</span> linearlayout <span class="string">dispatchTouchEvent:</span>action_down</span><br><span class="line">    linearlaout <span class="string">onInterceptTouchEvent:</span>action_down</span><br><span class="line"><span class="number">07</span><span class="number">-16</span> <span class="number">20</span>:<span class="number">48</span>:<span class="number">50.946</span> <span class="number">16256</span><span class="number">-16256</span><span class="regexp">/com.zhangjie.androidtouch I/</span><span class="string">tiaoshi:</span> linearlaout <span class="string">onInterceptTouchEvent:</span>:<span class="literal">false</span></span><br><span class="line"><span class="number">07</span><span class="number">-16</span> <span class="number">20</span>:<span class="number">48</span>:<span class="number">50.946</span> <span class="number">16256</span><span class="number">-16256</span><span class="regexp">/com.zhangjie.androidtouch E/</span><span class="string">tiaoshi:</span> customview <span class="string">dispatchTouchEvent:</span>action_down</span><br><span class="line">    customview <span class="string">onTouchEvent:</span>action_down</span><br><span class="line">    customview <span class="string">onTouchEvent:</span>:<span class="literal">false</span></span><br><span class="line">    customview <span class="string">dispatchTouchEvent:</span>:<span class="literal">false</span></span><br><span class="line"><span class="number">07</span><span class="number">-16</span> <span class="number">20</span>:<span class="number">48</span>:<span class="number">50.946</span> <span class="number">16256</span><span class="number">-16256</span><span class="regexp">/com.zhangjie.androidtouch I/</span><span class="string">tiaoshi:</span> linearlayout <span class="string">onTouchEvent:</span>action_down</span><br><span class="line">    linearlayout <span class="string">onTouchEvent:</span>:<span class="literal">false</span></span><br><span class="line">    linearlayout <span class="string">dispatchTouchEvent:</span>:<span class="literal">false</span></span><br></pre></td></tr></table></figure></p>
<p>可以发现，只响应了ACTION_DOWN，就是没有调用后续的ACTION_MOVE,ACTION_UP,跳回到viewGroup的onTouchEvent后事件就被掐掉了，为什么呢。<br>经过查阅资料得知，发现只需将子view设置为clickable=true即可<br>但其中原理究竟是怎样的</p>
<h3 id="具体分析"><a href="#具体分析" class="headerlink" title="具体分析"></a>具体分析</h3><p>这里先给出结论</p>
<ul>
<li>事件传递Activity-ViewGroup-view，如下图所示。</li>
<li>事件传递的最小单位是view的onTouchEvent,从onTouchEvent开始开始冒泡(如果布局有嵌套会递归弹栈)依次回传ViewGroup的onTouchEvent(如果onTouchEvent()没有返回true)</li>
<li>View 如果不是clickable ,longClickable,contextClickable （可点击状态），不会消费事件</li>
<li>如果给View设置了TouchListener也能处理后续事件，在ACTION_DWON 时返回 true</li>
<li>ViewGroup也是继承于View，ViewGorup本身clickable=false</li>
<li>给View设置clickListener 同时会让 clickable = true</li>
<li>如果View 没有消费ACTION_DOWN 事件，之后其他的ACTION_MOVE,ACTION_UP等事件也不会被响应,（包括上层的ViewGroup)，ViewGroup 继承于View,所以ViewGroup也同理</li>
</ul>
<center><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog/p1.png"></center>

<p>具体viewGruop,子view的dispatchTouchEvent,onInterceptTouchEvent,onTouchEvent的调用关系是怎样的，LOG分析如下：</p>
<h4 id="子View不消耗事件的情况"><a href="#子View不消耗事件的情况" class="headerlink" title="子View不消耗事件的情况"></a>子View不消耗事件的情况</h4><p>即是最开始的情况，子View不消费任何事件，返回到viewGroup的onTouchEvent<br>但如果View 没有消费ACTION_DOWN 事件，之后其他的ACTION_MOVE,ACTION_UP等事件也不会被响应<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="number">07</span><span class="number">-16</span> <span class="number">20</span>:<span class="number">48</span>:<span class="number">50.945</span> <span class="number">16256</span><span class="number">-16256</span><span class="regexp">/com.zhangjie.androidtouch I/</span><span class="string">tiaoshi:</span> linearlayout <span class="string">dispatchTouchEvent:</span>action_down</span><br><span class="line">    linearlaout <span class="string">onInterceptTouchEvent:</span>action_down</span><br><span class="line"><span class="number">07</span><span class="number">-16</span> <span class="number">20</span>:<span class="number">48</span>:<span class="number">50.946</span> <span class="number">16256</span><span class="number">-16256</span><span class="regexp">/com.zhangjie.androidtouch I/</span><span class="string">tiaoshi:</span> linearlaout <span class="string">onInterceptTouchEvent:</span>:<span class="literal">false</span></span><br><span class="line"><span class="number">07</span><span class="number">-16</span> <span class="number">20</span>:<span class="number">48</span>:<span class="number">50.946</span> <span class="number">16256</span><span class="number">-16256</span><span class="regexp">/com.zhangjie.androidtouch E/</span><span class="string">tiaoshi:</span> customview <span class="string">dispatchTouchEvent:</span>action_down</span><br><span class="line">    customview <span class="string">onTouchEvent:</span>action_down</span><br><span class="line">    customview <span class="string">onTouchEvent:</span>:<span class="literal">false</span></span><br><span class="line">    customview <span class="string">dispatchTouchEvent:</span>:<span class="literal">false</span></span><br><span class="line"><span class="number">07</span><span class="number">-16</span> <span class="number">20</span>:<span class="number">48</span>:<span class="number">50.946</span> <span class="number">16256</span><span class="number">-16256</span><span class="regexp">/com.zhangjie.androidtouch I/</span><span class="string">tiaoshi:</span> linearlayout <span class="string">onTouchEvent:</span>action_down</span><br><span class="line">    linearlayout <span class="string">onTouchEvent:</span>:<span class="literal">false</span></span><br><span class="line">    linearlayout <span class="string">dispatchTouchEvent:</span>:<span class="literal">false</span></span><br></pre></td></tr></table></figure></p>
<h4 id="子View消费事件的情况"><a href="#子View消费事件的情况" class="headerlink" title="子View消费事件的情况"></a>子View消费事件的情况</h4><p>调用顺序如下：<br>当子view消费了事件，子View的onTouchEvent返回true，这样返回ViewGroup就在dispatchTouchEvent结束了，不会继续调用ViewGroup的onTouchEvent</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ACTION_DWON</span></span><br><span class="line"><span class="number">07</span><span class="number">-16</span> <span class="number">20</span>:<span class="number">59</span>:<span class="number">52.919</span> <span class="number">17114</span><span class="number">-17114</span><span class="regexp">/com.zhangjie.androidtouch I/</span><span class="string">tiaoshi:</span> linearlayout <span class="string">dispatchTouchEvent:</span>action_down</span><br><span class="line"><span class="number">07</span><span class="number">-16</span> <span class="number">20</span>:<span class="number">59</span>:<span class="number">52.920</span> <span class="number">17114</span><span class="number">-17114</span><span class="regexp">/com.zhangjie.androidtouch I/</span><span class="string">tiaoshi:</span> linearlaout <span class="string">onInterceptTouchEvent:</span>action_down</span><br><span class="line">    linearlaout <span class="string">onInterceptTouchEvent:</span>:<span class="literal">false</span></span><br><span class="line"><span class="number">07</span><span class="number">-16</span> <span class="number">20</span>:<span class="number">59</span>:<span class="number">52.920</span> <span class="number">17114</span><span class="number">-17114</span><span class="regexp">/com.zhangjie.androidtouch E/</span><span class="string">tiaoshi:</span> customview <span class="string">dispatchTouchEvent:</span>action_down</span><br><span class="line"><span class="number">07</span><span class="number">-16</span> <span class="number">20</span>:<span class="number">59</span>:<span class="number">52.921</span> <span class="number">17114</span><span class="number">-17114</span><span class="regexp">/com.zhangjie.androidtouch E/</span><span class="string">tiaoshi:</span> customview <span class="string">onTouchEvent:</span>action_down</span><br><span class="line">    customview <span class="string">onTouchEvent:</span>:<span class="literal">true</span></span><br><span class="line">    customview <span class="string">dispatchTouchEvent:</span>:<span class="literal">true</span></span><br><span class="line"><span class="number">07</span><span class="number">-16</span> <span class="number">20</span>:<span class="number">59</span>:<span class="number">52.921</span> <span class="number">17114</span><span class="number">-17114</span><span class="regexp">/com.zhangjie.androidtouch I/</span><span class="string">tiaoshi:</span> linearlayout <span class="string">dispatchTouchEvent:</span>:<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ACTION_MOVE</span></span><br><span class="line"><span class="number">07</span><span class="number">-16</span> <span class="number">21</span>:<span class="number">02</span>:<span class="number">17.082</span> <span class="number">17114</span><span class="number">-17114</span><span class="regexp">/com.zhangjie.androidtouch I/</span><span class="string">tiaoshi:</span> linearlayout <span class="string">dispatchTouchEvent:</span>action_move</span><br><span class="line">    linearlaout <span class="string">onInterceptTouchEvent:</span>action_move</span><br><span class="line">    linearlaout <span class="string">onInterceptTouchEvent:</span>:<span class="literal">false</span></span><br><span class="line"><span class="number">07</span><span class="number">-16</span> <span class="number">21</span>:<span class="number">02</span>:<span class="number">17.082</span> <span class="number">17114</span><span class="number">-17114</span><span class="regexp">/com.zhangjie.androidtouch E/</span><span class="string">tiaoshi:</span> customview <span class="string">dispatchTouchEvent:</span>action_move</span><br><span class="line">    customview <span class="string">onTouchEvent:</span>action_move</span><br><span class="line"><span class="number">07</span><span class="number">-16</span> <span class="number">21</span>:<span class="number">02</span>:<span class="number">17.083</span> <span class="number">17114</span><span class="number">-17114</span><span class="regexp">/com.zhangjie.androidtouch E/</span><span class="string">tiaoshi:</span> customview <span class="string">onTouchEvent:</span>:<span class="literal">true</span></span><br><span class="line">    customview <span class="string">dispatchTouchEvent:</span>:<span class="literal">true</span></span><br><span class="line"><span class="number">07</span><span class="number">-16</span> <span class="number">21</span>:<span class="number">02</span>:<span class="number">17.083</span> <span class="number">17114</span><span class="number">-17114</span><span class="regexp">/com.zhangjie.androidtouch I/</span><span class="string">tiaoshi:</span> linearlayout <span class="string">dispatchTouchEvent:</span>:<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ACTION_UP</span></span><br><span class="line"><span class="number">07</span><span class="number">-16</span> <span class="number">20</span>:<span class="number">59</span>:<span class="number">52.923</span> <span class="number">17114</span><span class="number">-17114</span><span class="regexp">/com.zhangjie.androidtouch I/</span><span class="string">tiaoshi:</span> linearlayout <span class="string">dispatchTouchEvent:</span>action_up</span><br><span class="line">    linearlaout <span class="string">onInterceptTouchEvent:</span>action_up</span><br><span class="line">    linearlaout <span class="string">onInterceptTouchEvent:</span>:<span class="literal">false</span></span><br><span class="line"><span class="number">07</span><span class="number">-16</span> <span class="number">20</span>:<span class="number">59</span>:<span class="number">52.923</span> <span class="number">17114</span><span class="number">-17114</span><span class="regexp">/com.zhangjie.androidtouch E/</span><span class="string">tiaoshi:</span> customview <span class="string">dispatchTouchEvent:</span>action_up</span><br><span class="line">    customview <span class="string">onTouchEvent:</span>action_up</span><br><span class="line">    customview <span class="string">onTouchEvent:</span>:<span class="literal">true</span></span><br><span class="line">    customview <span class="string">dispatchTouchEvent:</span>:<span class="literal">true</span></span><br><span class="line"><span class="number">07</span><span class="number">-16</span> <span class="number">20</span>:<span class="number">59</span>:<span class="number">52.923</span> <span class="number">17114</span><span class="number">-17114</span><span class="regexp">/com.zhangjie.androidtouch I/</span><span class="string">tiaoshi:</span> linearlayout <span class="string">dispatchTouchEvent:</span>:<span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h4 id="当onInterceptTouchEvent拦截了事件的时候"><a href="#当onInterceptTouchEvent拦截了事件的时候" class="headerlink" title="当onInterceptTouchEvent拦截了事件的时候"></a>当onInterceptTouchEvent拦截了事件的时候</h4><p>当onInterceptTouchEvent在ACTION_MOVE的时候拦截事件时，则会有另一番表现<br>拦截代码</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        log(ev,ON_INTERCEPT_TOUCH_EVENT);</span></span><br><span class="line">        <span class="keyword">switch</span> (ev.getAction())&#123;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> result = <span class="keyword">super</span>.onInterceptTouchEvent(ev);</span><br><span class="line">        Log.i(TAG,ON_INTERCEPT_TOUCH_EVENT+<span class="string">":"</span>+result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>log如下</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="number">07</span><span class="number">-16</span> <span class="number">21</span>:<span class="number">08</span>:<span class="number">39.683</span> <span class="number">18219</span><span class="number">-18219</span><span class="regexp">/com.zhangjie.androidtouch I/</span><span class="string">tiaoshi:</span> linearlayout <span class="string">dispatchTouchEvent:</span>action_down</span><br><span class="line">    linearlaout <span class="string">onInterceptTouchEvent:</span>action_down</span><br><span class="line"><span class="number">07</span><span class="number">-16</span> <span class="number">21</span>:<span class="number">08</span>:<span class="number">39.684</span> <span class="number">18219</span><span class="number">-18219</span><span class="regexp">/com.zhangjie.androidtouch I/</span><span class="string">tiaoshi:</span> linearlaout <span class="string">onInterceptTouchEvent:</span>:<span class="literal">false</span></span><br><span class="line"><span class="number">07</span><span class="number">-16</span> <span class="number">21</span>:<span class="number">08</span>:<span class="number">39.684</span> <span class="number">18219</span><span class="number">-18219</span><span class="regexp">/com.zhangjie.androidtouch E/</span><span class="string">tiaoshi:</span> customview <span class="string">dispatchTouchEvent:</span>action_down</span><br><span class="line">    customview <span class="string">onTouchEvent:</span>action_down</span><br><span class="line"><span class="number">07</span><span class="number">-16</span> <span class="number">21</span>:<span class="number">08</span>:<span class="number">39.685</span> <span class="number">18219</span><span class="number">-18219</span><span class="regexp">/com.zhangjie.androidtouch E/</span><span class="string">tiaoshi:</span> customview <span class="string">onTouchEvent:</span>:<span class="literal">true</span></span><br><span class="line">    customview <span class="string">dispatchTouchEvent:</span>:<span class="literal">true</span></span><br><span class="line"><span class="number">07</span><span class="number">-16</span> <span class="number">21</span>:<span class="number">08</span>:<span class="number">39.685</span> <span class="number">18219</span><span class="number">-18219</span><span class="regexp">/com.zhangjie.androidtouch I/</span><span class="string">tiaoshi:</span> linearlayout <span class="string">dispatchTouchEvent:</span>:<span class="literal">true</span></span><br><span class="line"><span class="number">07</span><span class="number">-16</span> <span class="number">21</span>:<span class="number">08</span>:<span class="number">39.701</span> <span class="number">18219</span><span class="number">-18219</span><span class="regexp">/com.zhangjie.androidtouch I/</span><span class="string">tiaoshi:</span> linearlayout <span class="string">dispatchTouchEvent:</span>action_move</span><br><span class="line">    linearlaout <span class="string">onInterceptTouchEvent:</span>action_move</span><br><span class="line"><span class="number">07</span><span class="number">-16</span> <span class="number">21</span>:<span class="number">08</span>:<span class="number">39.701</span> <span class="number">18219</span><span class="number">-18219</span><span class="regexp">/com.zhangjie.androidtouch E/</span><span class="string">tiaoshi:</span> customview <span class="string">onTouchEvent:</span>:<span class="literal">true</span></span><br><span class="line">    customview <span class="string">dispatchTouchEvent:</span>:<span class="literal">true</span></span><br><span class="line"><span class="number">07</span><span class="number">-16</span> <span class="number">21</span>:<span class="number">08</span>:<span class="number">39.701</span> <span class="number">18219</span><span class="number">-18219</span><span class="regexp">/com.zhangjie.androidtouch I/</span><span class="string">tiaoshi:</span> linearlayout <span class="string">dispatchTouchEvent:</span>:<span class="literal">true</span></span><br><span class="line"><span class="number">07</span><span class="number">-16</span> <span class="number">21</span>:<span class="number">08</span>:<span class="number">39.717</span> <span class="number">18219</span><span class="number">-18219</span><span class="regexp">/com.zhangjie.androidtouch I/</span><span class="string">tiaoshi:</span> linearlayout <span class="string">dispatchTouchEvent:</span>action_move</span><br><span class="line">    linearlayout <span class="string">onTouchEvent:</span>action_move</span><br><span class="line"><span class="number">07</span><span class="number">-16</span> <span class="number">21</span>:<span class="number">08</span>:<span class="number">39.718</span> <span class="number">18219</span><span class="number">-18219</span><span class="regexp">/com.zhangjie.androidtouch I/</span><span class="string">tiaoshi:</span> linearlayout <span class="string">onTouchEvent:</span>:<span class="literal">false</span></span><br><span class="line">    linearlayout <span class="string">dispatchTouchEvent:</span>:<span class="literal">false</span></span><br><span class="line"><span class="number">07</span><span class="number">-16</span> <span class="number">21</span>:<span class="number">08</span>:<span class="number">39.733</span> <span class="number">18219</span><span class="number">-18219</span><span class="regexp">/com.zhangjie.androidtouch I/</span><span class="string">tiaoshi:</span> linearlayout <span class="string">dispatchTouchEvent:</span>action_move</span><br><span class="line"><span class="number">07</span><span class="number">-16</span> <span class="number">21</span>:<span class="number">08</span>:<span class="number">39.733</span> <span class="number">18219</span><span class="number">-18219</span><span class="regexp">/com.zhangjie.androidtouch I/</span><span class="string">tiaoshi:</span> linearlayout <span class="string">onTouchEvent:</span>action_move</span><br><span class="line"><span class="number">07</span><span class="number">-16</span> <span class="number">21</span>:<span class="number">08</span>:<span class="number">39.734</span> <span class="number">18219</span><span class="number">-18219</span><span class="regexp">/com.zhangjie.androidtouch I/</span><span class="string">tiaoshi:</span> linearlayout <span class="string">onTouchEvent:</span>:<span class="literal">false</span></span><br><span class="line">    linearlayout <span class="string">dispatchTouchEvent:</span>:<span class="literal">false</span></span><br><span class="line">linearlayout <span class="string">dispatchTouchEvent:</span>action_up</span><br><span class="line">    linearlayout <span class="string">onTouchEvent:</span>action_up</span><br><span class="line"><span class="number">07</span><span class="number">-16</span> <span class="number">21</span>:<span class="number">08</span>:<span class="number">39.878</span> <span class="number">18219</span><span class="number">-18219</span><span class="regexp">/com.zhangjie.androidtouch I/</span><span class="string">tiaoshi:</span> linearlayout <span class="string">onTouchEvent:</span>:<span class="literal">false</span></span><br><span class="line">    linearlayout <span class="string">dispatchTouchEvent:</span>:<span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>可以发现，当onInterceptTouchEvent返回true，拦截了事件后，事件就被viewGroup处理了，不再传到子view中</p>
<p>事件分发：public boolean dispatchTouchEvent(MotionEvent ev)<br>Android事件以隧道方式逐层向下传递。事件首先由dispatchTouchEvent方法分发，分发逻辑如下：<br>return true；由该dispatchTouchEvent方法消费并且停止分发。<br>return false；返回给父view的onTouch方法处理<br>return super.dispatchTouchEvent(ev)；有当前view的onInterceptTouchEvent（）拦截处理。<br>事件拦截：public boolean onInterceptTouchEvent(MotionEvent ev)<br>当前view拦截到事件后，处理流程如下：<br>return false；表示放行由当前view的子view的dispatchTouchEvent分发处理。<br>return true或return super.onInterceptTouchEvent()表示拦截该事件，由该View的Ontouch方法处理。<br>事件响应：public boolean onTouchEvent(MotionEvent ev)<br>return true表示消费。<br>return false或return super.onTouch()则此事件传递给上层View的onTouch方法处理。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>参考链接：<br><a href="https://www.jianshu.com/p/f0124c2e1a6e" target="_blank" rel="noopener">你的android事件传递知识能解答这个问题？</a><br><a href="https://blog.csdn.net/u014316462/article/details/53117321" target="_blank" rel="noopener">ViewPager子View滑动事件冲突解决</a><br>Demo代码：<a href="https://github.com/shenzhen2017/androidTouch" target="_blank" rel="noopener">https://github.com/shenzhen2017/androidTouch</a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>MediaSession框架学习</title>
    <url>/blog/2018/07/media-session-learn.html</url>
    <content><![CDATA[<p>我们先来看看如何设计一款音乐播放App的架构，传统的做法是这样的：</p>
<ul>
<li>注册一个Service，用于异步获取音乐库数据、音乐控制等，在Service中我们可能还需要自定义一些状态值和回调接口用于流程控制</li>
<li>通过广播（其他方式如接口、Messenger都可以）实现Activity和Service之间的通信，使得用户可以通过界面上的组件控制音乐的播放、暂停、拖动进度条等操作</li>
</ul>
<p>如果我们的音乐播放器还需要支持通知栏快捷控制音乐播放的功能，那么又得新增一套广播和相应的接口去响应通知栏按钮的事件</p>
<p>Google在Android 5.0中加入了MediaSession框架（在support-v4中同样提供了相应的兼容包，相关的类以Compat结尾，Api基本相同），专门用来解决媒体播放时界面和Service通讯的问题，意在规范上述这些功能的流程。使用这个框架我们可以减少一些流程复杂的开发工作，例如使用各种广播来控制播放器，而且其代码可读性、结构耦合度方面都控制得非常好，因此推荐大家尝试下这个框架。下面我们就开始介绍MediaSession框架的核心成员和使用流程</p>
<h3 id="常用成员类概述"><a href="#常用成员类概述" class="headerlink" title="常用成员类概述"></a>常用成员类概述</h3><p>MediaSession框架中有四个常用的成员类，它们是整个流程控制的核心</p>
<ul>
<li><p>MediaBrowser<br>媒体浏览器，用来连接MediaBrowserService和订阅数据，通过它的回调接口我们可以获取和Service的连接状态以及获取在Service中异步获取的音乐库数据。媒体浏览器一般创建于客户端（可以理解为各个终端负责控制音乐播放的界面）中</p>
</li>
<li><p>MediaBrowserService<br>浏览器服务，提供onGetRoot（控制客户端媒体浏览器的连接请求，通过返回值决定是否允许该客户端连接服务）和onLoadChildren（媒体浏览器向Service发送数据订阅时调用，一般在这执行异步获取数据的操作，最后将数据发送至媒体浏览器的回调接口中）这两个抽象方法<br>同时MediaBrowserService还作为承载媒体播放器（如MediaPlayer、ExoPlayer等）和MediaSession的容器</p>
</li>
<li><p>MediaSession<br>媒体会话，即受控端，通过设置MediaSessionCompat.Callback回调来接收媒体控制器MediaController发送的指令，当收到指令时会触发Callback中各个指令对应的回调方法（回调方法中会执行播放器相应的操作，如播放、暂停等）。Session一般在Service.onCreate方法中创建，最后需调用setSessionToken方法设置用于和控制器配对的令牌并通知浏览器连接服务成功</p>
</li>
<li><p>MediaController<br>媒体控制器，在客户端中开发者不仅可以使用控制器向Service中的受控端发送指令，还可以通过设置MediaControllerCompat.Callback回调方法接收受控端的状态，从而根据相应的状态刷新界面UI。MediaController的创建需要受控端的配对令牌，因此需在浏览器成功连接服务的回调执行创建的操作</p>
</li>
</ul>
<p>通过上述的简介中我们不难看出这四个成员之间有着非常明确的分工和作用范围，使得整个代码结构变得清晰易读。可以通过下面这张图来简单归纳它们之间的关系<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog/p1.jpg" alt><br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog/p6.png" alt></p>
<p>除此之外，MediaSession框架中还有一些同样重要的类需要拿出来讲，例如封装了各种播放状态的PlaybackState，和Map相似通过键值对保存媒体信息的MediaMetadata，以及用于MediaBrowser和MediaBrowserService之间进行数据交互的MediaItem等</p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://juejin.im/post/5aa0e18851882577b45e91df" target="_blank" rel="noopener">Android 媒体播放框架MediaSession分析与实践</a><br><a href="https://www.oschina.net/question/2561862_2150611" target="_blank" rel="noopener">Android：MediaSession框架介绍</a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>tensorflow手写数字识别</title>
    <url>/blog/2018/07/tensorflow-android-new.html</url>
    <content><![CDATA[<p>本文主要借由一个手写数字识别的例子，实现在机器学习在Android手机上的应用 </p>
<p>要在手机上实现手写数字识别，主要分为以下几个步骤</p>
<p>1.训练手写数字识别的神经网络</p>
<p>首先需要训练用于手写数字识别的神经网络，最后需要将训练后网络的拓扑结构和参数保存为pb文件</p>
<p>2.将pb文件引入Android工程中，并基于<code>TensorFlowInferenceInterface</code>类完成识别。</p>
<h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><h4 id="神经元和大脑"><a href="#神经元和大脑" class="headerlink" title="神经元和大脑"></a><strong>神经元和大脑</strong></h4><p>最近几年AI挺火的，其实说到底，AI就是为了用程序实现跟人脑一样甚至比人脑强大的效果，就是想制造出与人类大脑作用效果相同的机器 ，作为人脑，我们感受到听觉，视觉，触觉，味觉，可以学习数学，英语，音乐，美术，还可以控制跑步，游泳，开车。如果要做出这样一个程序的话，实在可以说是一个非常复杂的程序。</p>
<p>现在我们开发的程序，往往是有一个新的需求，就去开发一个新的功能，如果我们要模仿大脑的话，得写很多不同的软件来模拟所有这些五花八门的奇妙的事情。不过能不能假设大脑做所有这些，不同事情的方法，不需要用上千个不同的程序去实现。相反的，大脑处理的方法，只需要一个单一的学习算法就可以了？尽管这只是一个假设，不过让我们看以看一些这方面的证据。 </p>
<p><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog/p2.jpg" alt></p>
<p>舌头可以看见</p>
<p>这张图是用舌头学会“看”的一个例子。它的原理是：这实际上是一个名为BrainPort的系统，它现在正在FDA (美国食品和药物管理局)的临床试验阶段，它能帮助失明人士看见事物。它的原理是，你在前额上带一个灰度摄像头，面朝前，它就能获取你面前事物的低分辨率的灰度图像。你连一根线到舌头上安装的电极阵列上，那么每个像素都被映射到你舌头的某个位置上，可能电压值高的点对应一个暗像素电压值低的点。对应于亮像素，即使依靠它现在的功能，使用这种系统就能让你我在几十分钟里就学会用我们的舌头“看”东西。 </p>
<p>这个实验和其它一些类似的实验，被称为神经重接实验，从这个意义上说，如果人体有同一块脑组织可以处理光、声或触觉信号，那么也许存在一种学习算法，可以同时处理视觉、听觉和触觉，而不是需要运行上千个不同的程序，或者上千个不同的算法来做这些大脑所完成的成千上万的美好事情。也许我们需要做的就是找出一些近似的或实际的大脑学习算法，然后通过学习不同的数据获取不同的能力。</p>
<h4 id="神经网络的模型表示"><a href="#神经网络的模型表示" class="headerlink" title="神经网络的模型表示"></a>神经网络的模型表示</h4><p>为了构建神经网络模型,我们需要首先思考大脑中的神经网络是怎样的?每一个神经元 都可以被认为是一个处理单元/神经核(processing unit/ Nucleus),它含有许多输入/树突 (input/Dendrite),并且有一个输出/轴突(output/Axon)。神经网络是大量神经元相互链 接并通过电脉冲来交流的一个网络。</p>
<p>神经网络模型建立在很多神经元之上,每一个神经元又是一个个学习模型。这些神经元 (也叫激活单元,activation unit)采纳一些特征作为输出,并且根据本身的模型 供一个输出</p>
<p>我们设计出了类似于神经元的神经网络,效果如下: </p>
<p><img src="https://raw.githubusercontent.com/whuhan2013/myImage/master/machineLearning/class4/p1.png" alt></p>
<p>其中 x1,x2,x3 是输入单元(input units),我们将原始数据输入给它们。 a1,a2,a3 是中间单元,它们负责将数据进行处理,然后呈递到下一层。 最后是输出单元,它负责计算 hθ(x)。 神经网络模型是许多逻辑单元按照不同层级组织起来的网络,每一层的输出变量都是下 一层的输入变量。下图为一个 3 层的神经网络,第一层成为输入层(Input Layer),最后一 层称为输出层(Output Layer),中间一层成为隐藏层(Hidden Layers) </p>
<h4 id="前向传播算法"><a href="#前向传播算法" class="headerlink" title="前向传播算法"></a>前向传播算法</h4><p><img src="https://raw.githubusercontent.com/whuhan2013/myImage/master/machineLearning/class4/p2.png" alt></p>
<p>对于上图所示的模型,激活单元和输出分别表达为: </p>
<p><img src="https://raw.githubusercontent.com/whuhan2013/myImage/master/machineLearning/class4/p3.png" alt></p>
<p>我们可以知道:每一个 a 都是由上一层所有的 x 和每一个 x 所对应的决定的。 (我们把这样从左到右的算法称为前向传播算法( FORWARD PROPAGATION )) </p>
<h4 id="直观理解"><a href="#直观理解" class="headerlink" title="直观理解"></a>直观理解</h4><p>通过控制权重的大小和神经网络的层次，我们可以实现多种复杂的逻辑</p>
<p>比如当为了实现或与非逻辑时，二元逻辑运算符(BINARY LOGICAL OPERATORS)当输入特征为布尔值(0 或 1)时,我 们可以用一个单一的激活层可以作为二元逻辑运算符,为了表示不同的运算符,我们之需要 选择不同的权重即可。 </p>
<p><img src="https://raw.githubusercontent.com/whuhan2013/myImage/master/machineLearning/class4/p7.png" alt></p>
<p>如图所示，这是通过改变权重实现不同逻辑的一个最简单的例子，但是权重究竟是怎么决定的，又是由什么标准决定的呢？</p>
<h4 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a>代价函数</h4><p><img src="https://raw.githubusercontent.com/whuhan2013/myImage/master/machineLearning/p5.png" alt></p>
<p>以上是代价函数的基本形式，随着激活函数形式的不同而发生变化</p>
<p><img src="https://raw.githubusercontent.com/whuhan2013/myImage/master/machineLearning/class5/p2.png" alt="img"> </p>
<p>这个看起来复杂很多的代价函数背后的思想还是一样的,我们希望通过代价函数来观察 算法预测的结果与真实情况的误差有多大,唯一不同的是,对于每一行特征,我们都会给出 K 个预测,基本上我们可以利用循环,对每一行特征都预测 K 个不同结果,然后在利用循环 在 K 个预测中选择可能性最高的一个,将其与 y 中的实际数据进行比较。 </p>
<h4 id="梯度下降算法"><a href="#梯度下降算法" class="headerlink" title="梯度下降算法"></a>梯度下降算法</h4><p>现在问题转换成了一个求代价函数最小值的问题，我们知道，梯度也就是导数方向是函数下降最快的方向，</p>
<p>首先来看看梯度下降的一个直观的解释。比如我们在一座大山上的某处位置，由于我们不知道怎么下山，于是决定走一步算一步，也就是在每走到一个位置的时候，求解当前位置的梯度，沿着梯度的负方向，也就是当前最陡峭的位置向下走一步，然后继续求解当前位置梯度，向这一步所在位置沿着最陡峭最易下山的位置走一步。这样一步步的走下去，一直走到觉得我们已经到了山脚。当然这样走下去，有可能我们不能走到山脚，而是到了某一个局部的山峰低处。</p>
<p>　　　　从上面的解释可以看出，梯度下降不一定能够找到全局的最优解，有可能是一个局部最优解。当然，如果损失函数是凸函数，梯度下降法得到的解就一定是全局最优解。</p>
<p><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog/p2.png" alt></p>
<p><img src="https://raw.githubusercontent.com/whuhan2013/myImage/master/machineLearning/p7.png" alt></p>
<ul>
<li>将数据集在神经网络中进行一次正向传递，得到预测结果 </li>
<li>计算输出层神经元的<strong>误差梯度（error gradient）δ</strong></li>
<li>更新权重变化 <strong>Δw_i</strong></li>
</ul>
<p>重复第二三步直到找到最小值</p>
<h4 id="反向传播算法"><a href="#反向传播算法" class="headerlink" title="反向传播算法"></a>反向传播算法</h4><p>现在我们知道了更新权重的方法，但其实我们只知道最后一层的代价函数，而并不知道中间的神经网络的代价函数，所以需要通过反向传播算法获得各中间层的代价函数</p>
<p>其基本原理是：首先计算最后一层的误差,然后再一层一层反向求出各层的误差,直到倒数第二层 </p>
<p>关于反向传播算法的数学推导比较复杂，在此略过，具体可见：</p>
<p>关于反向误差的计算方法可以参见：<a href="http://mooc.guokr.com/note/16702/" target="_blank" rel="noopener">关于第5周反向传播算法的一些争论与思考</a>  </p>
<p>具体数学推导可以参见：<a href="https://my.oschina.net/findbill/blog/529001" target="_blank" rel="noopener">反向传播（Backpropagation）算法的数学原理</a> </p>
<p>最后可得出结论：</p>
<p><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog/p3.png" alt></p>
<p>这样我们就可以求出针对任一层任一个神经元的代价函数，也就可以反向传播更新权重，达到最佳效果</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>小结一下使用神经网络时的步骤:<br>网络结构:第一件要做的事是选择网络结构,即决定选择多少层以及决定每层分别有多 少个单元。 第一层的单元数即我们训练集的特征数量。 最后一层的单元数是我们训练集的结果的类的数量。 如果隐藏层数大于 1,确保每个隐藏层的单元个数相同,通常情况下隐藏层单元的个数 越多越好。</p>
<p>我们真正要决定的是隐藏层的层数和每个中间层的单元数。</p>
<p>训练神经网络:</p>
<ol>
<li>参数的随机初始化</li>
<li>利用正向传播方法计算所有的 hθ(x)</li>
<li>编写计算代价函数 J 的代码</li>
<li>利用反向传播方法计算所有偏导数</li>
<li>使用优化算法来最小化代价函数</li>
</ol>
<h3 id="开始训练模型"><a href="#开始训练模型" class="headerlink" title="开始训练模型"></a>开始训练模型</h3><p>使用tensorflow1.9,python3.6 基于mnist数据进行训练。</p>
<p>MNIST是一个巨大的手写数字数据集，被广泛应用于机器学习识别领域。MNIST有60000张训练集数据和10000张测试集数据，每一个训练元素都是28*28像素的手写数字图片 </p>
<p>将训练结果保存在pb文件中，供移动端使用</p>
<p>训练结果如下：</p>
<p><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog/p4.png" alt></p>
<p>经过20分钟的运算，跑完了50轮的训练，可以看到，在测试集1万张图片上的准确率达到了99.3%左右，其中在最开始的时候在97%左右，通过加大数据量将准确率明显提高。</p>
<p>而在训练集上到了后期，准确率基本上到达了100%，应该是发生了过拟合。</p>
<h3 id="移植到Android手机"><a href="#移植到Android手机" class="headerlink" title="移植到Android手机"></a>移植到Android手机</h3><p>1.引入tensorflow Android版</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">compile</span> <span class="string">'org.tensorflow:tensorflow-android:+'</span></span><br></pre></td></tr></table></figure>
<p>2.将pb文件复制到assets目录下 </p>
<p>3.使用TensorFlowInferenceInterface完成识别</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">inferenceInterface = <span class="keyword">new</span> TensorFlowInferenceInterface(context.getAssets(), MODEL_FILE);</span><br><span class="line">/ 输入数据</span><br><span class="line">      Trace.beginSection(<span class="string">"feed"</span>);</span><br><span class="line">      inferenceInterface.feed(INPUT_NODE, pixelArray,<span class="number">1</span>, HEIGHT, WIDTH);</span><br><span class="line">      inferenceInterface.feed(KEEP_PROB_NODE,<span class="keyword">new</span> <span class="keyword">float</span>[]&#123;<span class="number">1.0f</span>&#125;,<span class="number">1</span>);</span><br><span class="line">      Trace.endSection();</span><br><span class="line">      <span class="comment">//进行模型的推理</span></span><br><span class="line">      Trace.beginSection(<span class="string">"run"</span>);</span><br><span class="line">      inferenceInterface.run(<span class="keyword">new</span> String[]&#123;OUTPUT_NODE&#125;, <span class="keyword">false</span>);</span><br><span class="line">      Trace.endSection();</span><br><span class="line">      <span class="comment">//获取输出节点的输出信息</span></span><br><span class="line">      <span class="keyword">float</span>[] outputs = <span class="keyword">new</span> <span class="keyword">float</span>[NUM_CLASSES];    <span class="comment">//用于存储模型的输出数据</span></span><br><span class="line">      Trace.beginSection(<span class="string">"fetch"</span>);</span><br><span class="line">      inferenceInterface.fetch(OUTPUT_NODE, outputs);<span class="comment">//获取输出数据</span></span><br><span class="line">      Trace.endSection();</span><br></pre></td></tr></table></figure>
<p>编译运行后即可看到结果了：</p>
<p><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog/p5.png" alt></p>
<h3 id="应用前景"><a href="#应用前景" class="headerlink" title="应用前景"></a>应用前景</h3><p>1.由于神经网络的特性，训练慢，使用快，在某些场景下，比如拍照，实时翻译，在本地处理速度更快，用户体能更佳</p>
<p>2.安全性，将数据放在本地，不上传服务器，更有利于数据保护</p>
]]></content>
      <tags>
        <tag>tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title>App启动流程</title>
    <url>/blog/2018/09/app-start-way.html</url>
    <content><![CDATA[<p>本文主要从插件化的角度讲述APP的启动流程</p>
<p>在手机屏幕上点击某个App的图标时，这个App的首页（或引导页）就出现在我们面前了，这个操作其实就是系统启动APP的过程。这个看似简单的操作，背后经历了Activity和AMS的反反复复的通信过程。<br>首先要搞清楚，在手机屏幕上点击App的icon快捷图标，此时手机屏幕就是一个Activity，而这个Activity所在的App，业界称之为Launcher。Launcher是手机系统厂商提供的一个APP。Launcher这个App，其实和我们做的各类应用类App没有什么不同，我们大家用过华为、小米之类的手机，预装App以及我们下载的各种App，都显示在Launcher上，每个App表现为一个Icon。Icon多了可以分页，可以分组，此外，Launcher也会发起网络请求，调用天气的数据，显示在屏幕上，所谓的人性化界面。</p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="AMS"><a href="#AMS" class="headerlink" title="AMS"></a>AMS</h4><p>仔细看，我们会发现，Launcher和斗鱼是两个不同的App，他们位于不同的进程中，它们之间的通信是通过Binder完成的——这时候AMS出场了。<br>如果站在四大组件的角度来看，AMS就是Binder中的Server。<br>AMS全称是ActivityManagerService，看字面意思是管理Activity的，但其实四大组件都归它管。在启动APP时，四大组件一直通过Binder跨进程通信，类似AIDL的实现，具体参见：<a href="https://www.cnblogs.com/chase1/p/7135961.html" target="_blank" rel="noopener">https://www.cnblogs.com/chase1/p/7135961.html</a></p>
<h4 id="具体流程"><a href="#具体流程" class="headerlink" title="具体流程"></a>具体流程</h4><p>1.Launcher通知AMS，要启动斗鱼App，而且指定要启动斗鱼的哪个页面（也就是首页）。<br>2.AMS通知Launcher，好了我知道了，没你什么事了，同时，把要启动的首页记下来。<br>3.Launcher当前页面进入Paused状态，然后通知AMS，我睡了，你可以去找斗鱼App了。<br>4.AMS检查斗鱼App是否已经启动了。是，则唤起斗鱼App即可。否，就要启动一个新的进程。AMS在新进程中创建一个ActivityThread对象，启动其中的main函数。<br>5.斗鱼App启动后，通知AMS，说我启动好了。<br>6.AMS翻出之前在第二步存的值，告诉斗鱼App，启动哪个页面。<br>7.斗鱼App启动首页，创建Context并与首页Activity关联。然后调用首页Activity的onCreate函数。</p>
<p>详情可参见：<br><a href="https://www.cnblogs.com/Jax/p/6880604.html" target="_blank" rel="noopener">写给Android App开发人员看的Android底层知识（2)</a><br><a href="http://weishu.me/2016/03/21/understand-plugin-framework-activity-management/" target="_blank" rel="noopener">Android 插件化原理解析——Activity生命周期管理</a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>读《三体》</title>
    <url>/blog/2018/07/read-three-body.html</url>
    <content><![CDATA[<blockquote>
<p>一、生存是文明的第一需要<br>二、文明不断增长和扩张，但宇宙中的物质总量保持不变</p>
</blockquote>
<p>&emsp;&emsp;《三体》大概是中国最出名的科幻小说了，自诞生以来收获了无数读者的喜爱，几乎以单枪匹马，把中国科幻文学提升到了世界级的水平。同时三体也引起了一些社会影响，记得前几年，互联网圈也流行降维打击，黑暗森林这些概念，同时三体中反复强调基础科学的重要性，没有基础科学的进步，其他进步也只是镜花水月，这一观点通过三体小说的广泛传播更加深入人心，想必对基础科学的发展是有一定作用的。以前就曾经看过三体，但以往看得比较匆忙，只记得了罗辑的力挽狂澜，逆风翻盘，这次久违重读，读起来倒也津津有味。</p>
<p>&emsp;&emsp;简单来说，《三体》其实是一个打外星人的故事。故事要从文革开始讲起，科学家家庭出生的女子叶文洁在文革中目睹父亲被批斗致死，自己也被人陷害，对整个人类社会和人性失去了信心。因为其优秀的科学素养，后被调入红岸基地（表面上是国防科研基地，实际上是进行与外星人接触的工程，不断向太空发送表达接触意愿的信号），一日，叶文洁收到了来自距离地球四光年的半人马座α回复的警告讯息。该信息出自半人马座α“三体世界”一个太空观测者的善意警告，警告地球不要再对外发送信号，更不要回复该警告讯息，否则会被锁定精确坐标，从而被外星文明摧毁或入侵。叶文洁因为对人类社会的极端失望，决定引入外星文明对地球文明进行清洗，帮助地球进步，故而没有上报组织并私自回复了希望外星文明来地球的信息，地球精确坐标被三体世界掌握。距离地球四个光年外的三体舰队就此出发，将在四个世纪后到达太阳系，三体的故事也正式开始了。</p>
<p>&emsp;&emsp;有人说，刘慈欣塑造人物的功力不足，但或许是因为刘慈欣的故事和设定太夺人眼球以至于让人物黯然失色了。以前只喜欢第二部面壁者的故事，这次重读才发现第一部的妙处。作者通过游戏一步步揭示三体星系的真面目，从第一次登录游戏，汪淼携伴周文王前去朝歌占卜天体运行，却惨遭三星凌空，以致三体世界被严寒瞬间破灭；到汪淼窥视墨子建造的双层宇宙模型，最后再遭双日同现，以致三体世界惨遭地域火焰炙烤殆尽；再到汪淼化身哥白尼揭示三体世界的真实概貌（经由三颗太阳分别影响绕行），并准确阐明了恒纪元与乱纪元的本质，但后来却是遭到三空凌日，以致三体世界瞬间毁灭。经过数百轮的毁灭与轮回，三体文明终于认识到了三体问题的无解，这也直接导出了一个结果，要想延续三体文明，必须寻找一个新的家园，而距三体星系四光年的地球，正是一个完美的选择。通过一个游戏，而不是干巴巴的解说来描述三体世界，不得不说是非常高明的。同时在描述游戏中的种种设定更是基于一定科学基础的脑洞大开，尤其是人形阵列计算机一节更是让我这个程序员叹为观止。</p>
<blockquote>
<p>冯·诺伊曼指着下方巨大的人列回路开始介绍：“陛下，我们把这台计算机命名为‘秦一号’。请看，那里，中心部分，是CPU，是计算机的核心计算元件。由您最精锐的五个军团构成，对照这张图您可以看到里面的加法器、寄存器、堆栈存贮器；外围整齐的部分是内存，构建这部分时我们发现人手不够，好在这部分每个单元的动作最简单，就训练每个士兵拿多种颜色的旗帜，组合起来后，一个人就能同时完成最初二十个人的操作，这就使内存容量达到了运行‘秦1.0’操作系统的最低要求；你再看那条贯穿整个阵列的通道，还有那些在通道上待命的轻转兵，那是BUS，系统总线，负责在整个系统间传递信息。”<br>“总线结构是个伟大的发明，新的插件，最大可由十个军团构成，能够快捷地挂接到总线上运行，这使得‘秦一号’的硬件扩展和升级十分便利；再看最远处那一边，可能要用望远镜才能看清，那是外存，我们又用了哥白尼起的名字，叫它‘硬盘’，那是由三百万名文化程度较高的人构成，您上次坑儒时把他们留下是对了，他们每个人手中都有一个记录本和笔，负责记录运算结果，当然，他们最大的工作量还是作为虚拟内存，存贮中间运算结果，运算速度的瓶颈就在他们那里。这儿，离我们最近的地方，是显示阵列，能显示计算机运行的主要状态参数。”</p>
</blockquote>
<p>&emsp;&emsp;三体2黑暗森林的开头由罗辑与叶文洁的对话开始，一开始就将宇宙的基本公理告诉读者，最后在末日之战时，从这两条宇宙基本公理出发推导而出的黑暗森林法则，成为罗辑最有力的武器，成功逆转了一切，迫使三体人放弃一切，无条件退出太阳系。但这一切在故事的开始就已经告诉读者了，所以这一逆袭一点都不突兀，反而显得非常自然。当读者读到最后时，再想起故事开头的文明公理时，想必一定会拍案叫绝吧。同时对于末日之战的描写，在一般的想象中，星球大战一般时舰队互射，炮火纷飞。但是在人类科技被三体人锁死的情况下，三体只有一个探测器水滴到达太阳系时，整个地球舰队就全军覆没了，而毁灭的方式是最原始的撞击，整整两千艘战舰，转瞬间就灰飞烟灭了，毁灭你，与你何干。相比之下，好莱坞大片与外星人的战争显得有些开玩笑了，外星人真的会跟你玩舰炮互射吗？想当初几百个西班牙人便征服了印加帝国，数千英军就让大清帝国无能为力，仅仅是在地球上，文明之间的差距便这么大，更何况星际之间呢？最后，把黑暗森林法则抄录在这吧：</p>
<blockquote>
<p>宇宙就是一座黑暗森林，每个文明都是带枪的猎人，像幽灵般潜行与林间，轻轻拨开挡路的树枝，竭力不让脚步发出一点儿声音，连呼吸都必须小心翼翼……他必须小心，因为林中到处都有与他一样潜行的猎人，如果他发现了别的生命，不管是不是猎人，不管是天使还是魔鬼，不管是娇嫩的婴儿还是步履蹒跚的老人，也不管是天仙般的少女还是天神般的男孩，能做的只有一件事：开枪消灭之？在这片森林中，他人就是地狱，就是永恒的威胁，任何暴露自己存在的生命都将很快被消灭，这就是宇宙文明的图景，这就是对费米悖论的解释</p>
</blockquote>
]]></content>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>启动没有注册的Activity</title>
    <url>/blog/2018/09/no-register-activity.html</url>
    <content><![CDATA[<p>如何启动一个没有在manifest文件中注册的Activity<br>要启动一个没有注册的Activity，首先需要了解Activity的启动过程<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog/p7.png" alt></p>
<p>简单来说，先从App进程调用startActivity；然后通过IPC调用进入系统进程system_server，完成Activity管理以及一些校检工作，最后又回到了APP进程完成真正的Activioty对象创建。</p>
<p>由于这个检验过程是在AMS进程完成的，我们对system_server进程里面的操作无能为力，只有在我们APP进程里面执行的过程才是有可能被Hook掉的，也就是第一步和第三步；<br>所以启动一个没有注册的Activity的基本思路是欺骗AMS</p>
<p>1.在发送要启动的Activity给AMS前，把这个Activity替换为一个已经在AndroidManifest文件中注册过了的StubActivity，这样就能绕过AMS的检查。在替换过程中，要把原来的Activity的信息存储在Bundle中。<br>2.在AMS通知APP启动StubActivity时，我们要在启动之前，把StubActivity替换为原先的Activity.原先的Activity的信息从Bundle中取出来。</p>
<p>代码如下：</p>
<h4 id="HOOK的上半场"><a href="#HOOK的上半场" class="headerlink" title="HOOK的上半场"></a>HOOK的上半场</h4><p>在发送要启动的Activity给AMS前进行HOOK</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Hook AMS</span></span><br><span class="line"><span class="comment">     * 主要完成的操作是  "把真正要启动的Activity临时替换为在AndroidManifest.xml中声明的替身Activity",进而骗过AMS</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void hookAMN() throws ClassNotFoundException,</span><br><span class="line">            NoSuchMethodException, InvocationTargetException,</span><br><span class="line">            IllegalAccessException, NoSuchFieldException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取AMN的gDefault单例gDefault，gDefault是final静态的</span></span><br><span class="line">        Object gDefault = RefInvoke.getStaticFieldObject(<span class="string">"android.app.ActivityManagerNative"</span>, <span class="string">"gDefault"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// gDefault是一个 android.util.Singleton&lt;T&gt;对象; 我们取出这个单例里面的mInstance字段</span></span><br><span class="line">        Object mInstance = RefInvoke.getFieldObject(<span class="string">"android.util.Singleton"</span>, gDefault, <span class="string">"mInstance"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个这个对象的代理对象MockClass1, 然后替换这个字段, 让我们的代理对象帮忙干活</span></span><br><span class="line">        Class&lt;?&gt; classB2Interface = Class.forName(<span class="string">"android.app.IActivityManager"</span>);</span><br><span class="line">        Object proxy = Proxy.<span class="keyword">new</span><span class="type">ProxyInstance</span>(</span><br><span class="line">                Thread.currentThread().getContextClassLoader(),</span><br><span class="line">                <span class="keyword">new</span> <span class="type">Class</span>&lt;?&gt;[] &#123; classB2Interface &#125;,</span><br><span class="line">                <span class="keyword">new</span> <span class="type">MockClass1</span>(mInstance));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把gDefault的mInstance字段，修改为proxy</span></span><br><span class="line">        Class class1 = gDefault.getClass();</span><br><span class="line">        RefInvoke.setFieldObject(<span class="string">"android.util.Singleton"</span>, gDefault, <span class="string">"mInstance"</span>, proxy);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MockClass1</span> <span class="keyword"><span class="keyword">implements</span> <span class="type">InvocationHandler</span></span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> final <span class="keyword">String</span> TAG = <span class="string">"MockClass1"</span>;</span><br><span class="line"></span><br><span class="line">    Object mBase;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> MockClass1(Object base) &#123;</span><br><span class="line">        mBase = base;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line"></span><br><span class="line">        Log.e(<span class="string">"bao"</span>, method.getName());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"startActivity"</span>.equals(method.getName())) &#123;</span><br><span class="line">            <span class="comment">// 只拦截这个方法</span></span><br><span class="line">            <span class="comment">// 替换参数, 任你所为;甚至替换原始Activity启动别的Activity偷梁换柱</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 找到参数里面的第一个Intent 对象</span></span><br><span class="line">            Intent raw;</span><br><span class="line">            int index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (args[i] instanceof Intent) &#123;</span><br><span class="line">                    index = i;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            raw = (Intent) args[index];</span><br><span class="line"></span><br><span class="line">            Intent <span class="keyword">new</span><span class="type">Intent</span> = <span class="keyword">new</span> <span class="type">Intent</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 替身Activity的包名, 也就是我们自己的包名</span></span><br><span class="line">            <span class="keyword">String</span> stubPackage = raw.getComponent().getPackageName();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这里我们把启动的Activity临时替换为 StubActivity</span></span><br><span class="line">            ComponentName componentName = <span class="keyword">new</span> <span class="type">ComponentName</span>(stubPackage, StubActivity.class.getName());</span><br><span class="line">            <span class="keyword">new</span><span class="type">Intent</span>.setComponent(componentName);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 把我们原始要启动的TargetActivity先存起来</span></span><br><span class="line">            <span class="keyword">new</span><span class="type">Intent</span>.putExtra(AMSHookHelper.EXTRA_TARGET_INTENT, raw);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 替换掉Intent, 达到欺骗AMS的目的</span></span><br><span class="line">            args[index] = <span class="keyword">new</span><span class="type">Intent</span>;</span><br><span class="line"></span><br><span class="line">            Log.d(TAG, <span class="string">"hook success"</span>);</span><br><span class="line">            <span class="keyword">return</span> method.invoke(mBase, args);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> method.invoke(mBase, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="HOOK的下半场"><a href="#HOOK的下半场" class="headerlink" title="HOOK的下半场"></a>HOOK的下半场</h4><p>在AMS通知APP启动StubActivity时进行HOOK<br><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 由于之前我们用替身欺骗了AMS; 现在我们要换回我们真正需要启动的Activity</span></span><br><span class="line"><span class="comment">     * 不然就真的启动替身了, 狸猫换太子...</span></span><br><span class="line"><span class="comment">     * 到最终要启动Activity的时候,会交给ActivityThread 的一个内部类叫做 H 来完成</span></span><br><span class="line"><span class="comment">     * H 会完成这个消息转发; 最终调用它的callback</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hookActivityThread</span><span class="params">()</span> throws Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先获取到当前的ActivityThread对象</span></span><br><span class="line">        Object currentActivityThread = RefInvoke.getStaticFieldObject(<span class="string">"android.app.ActivityThread"</span>, <span class="string">"sCurrentActivityThread"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 由于ActivityThread一个进程只有一个,我们获取这个对象的mH</span></span><br><span class="line">        Handler mH = (Handler) RefInvoke.getFieldObject(currentActivityThread, <span class="string">"mH"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//把Handler的mCallback字段，替换为new MockClass2(mH)</span></span><br><span class="line">        RefInvoke.setFieldObject(Handler.class, mH, <span class="string">"mCallback"</span>, <span class="keyword">new</span> MockClass2(mH));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MockClass2</span> <span class="title">implements</span> <span class="title">Handler</span>.<span class="title">Callback</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    Handler mBase;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MockClass2</span><span class="params">(Handler base)</span> </span>&#123;</span><br><span class="line">        mBase = base;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">            <span class="comment">// ActivityThread里面 "LAUNCH_ACTIVITY" 这个字段的值是100</span></span><br><span class="line">            <span class="comment">// 本来使用反射的方式获取最好, 这里为了简便直接使用硬编码</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">100</span>:</span><br><span class="line">                handleLaunchActivity(msg);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mBase.handleMessage(msg);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleLaunchActivity</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里简单起见,直接取出TargetActivity;</span></span><br><span class="line">        Object obj = msg.obj;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把替身恢复成真身</span></span><br><span class="line">        Intent intent = (Intent) RefInvoke.getFieldObject(obj, <span class="string">"intent"</span>);</span><br><span class="line"></span><br><span class="line">        Intent targetIntent = intent.getParcelableExtra(AMSHookHelper.EXTRA_TARGET_INTENT);</span><br><span class="line">        intent.setComponent(targetIntent.getComponent());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p><a href="http://weishu.me/2016/03/21/understand-plugin-framework-activity-management/" target="_blank" rel="noopener">Android 插件化原理解析——Activity生命周期管理</a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>java代理模式</title>
    <url>/blog/2018/08/java-dynmaic-proxy.html</url>
    <content><![CDATA[<p>java代理机制分为静态代理与动态代理。代理常常用于实现方法的增强<br>静态代理即新建一个接口，代理类与目标类都实现这个接口，然后通过代理类来操作目标类即可，较为简单，不详细描述了。</p>
<h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>实现了一个或者一组接口，目的是，其中任何一个接口的实例的方法调用将会被指派到统一的另一个接口的方法中。<br>代码示例如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicEatProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object object;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DynamicEatProxy</span><span class="params">(Object T)</span> </span>&#123;</span><br><span class="line">        object = T;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        wash();</span><br><span class="line">        Object returnValue = method.invoke(object, args);<span class="comment">//真正调用的方法，object是之前传进来的具体实例，args是接口所需要的方法参数</span></span><br><span class="line">        <span class="keyword">return</span> returnValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">wash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(<span class="string">"DynamicEatProxy"</span>, <span class="string">"Wash Hands"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Proxy.newProxyInstance方法共有3个参数</p>
<p>1、targetObject.getClass().getClassLoader()目标对象通过getClass方法获取类的所有信息后，调用getClassLoader()方法来获取类加载器。获取类加载器后，可以通过这个类型的加载器，在程序运行时，将生成的代理类加载到JVM即Java虚拟机中，以便运行时需要！这个参数即目标对象的类加载器<br>2、targetObject.getClass().getInterfaces()获取被代理类的所有接口信息，以便于生成的代理类可以具有代理类接口中的所有方法。<br>3、InvocationHandler：调用处理器，动态代理的实际执行者。</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> void DynamicProxy() &#123;</span><br><span class="line">       HumanImpl human = <span class="keyword">new</span> <span class="type">HumanImpl</span>();</span><br><span class="line">       DynamicEatProxy action = <span class="keyword">new</span> <span class="type">DynamicEatProxy</span>(human);</span><br><span class="line">       ClassLoader loader = human.getClass().getClassLoader();</span><br><span class="line">       Class[] interfaces = human.getClass().getInterfaces();</span><br><span class="line">       Object proxy = Proxy.<span class="keyword">new</span><span class="type">ProxyInstance</span>(loader, interfaces, action);</span><br><span class="line">       Human humanProxy = (Human)proxy;<span class="comment">//将proxy代理转为Human接口类进行Human接口内方法的调用</span></span><br><span class="line">       humanProxy.eat(<span class="string">"rice"</span>);</span><br><span class="line">       humanProxy.toilet();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="利用动态代理实现retrofit"><a href="#利用动态代理实现retrofit" class="headerlink" title="利用动态代理实现retrofit"></a>利用动态代理实现retrofit</h3><p>我们知道，retrofit是通过接口调用的,就像是这样的<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>GitHubService &#123;</span><br><span class="line">  @<span class="builtin-name">GET</span>(<span class="string">"users/&#123;user&#125;/repos"</span>)</span><br><span class="line">  Call&lt;List&lt;Repo&gt;&gt; listRepos(@Path(<span class="string">"user"</span>) String user);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Retrofit retrofit = new Retrofit.Builder()</span><br><span class="line">    .baseUrl(<span class="string">"https://api.github.com"</span>)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GitHubService<span class="built_in"> service </span>= retrofit.create(GitHubService.class);</span><br><span class="line"></span><br><span class="line">Call&lt;List&lt;Repo&gt;&gt; repos = service.listRepos(<span class="string">"octocat"</span>);</span><br></pre></td></tr></table></figure></p>
<p>那么你有没有想过一个问题，接口是不可以直接new出来的，GitHubService接口的实例是如何产生的呢，retrofit.create方法内部到底做了什么呢。没错，答案就是动态代理。该对象是程序运行期生成的代理对象。</p>
<p>我们可以使用动态代理，实现一个简易版的retrofit</p>
<p>首先说明一点，我们的请求是异步的，所以返回值我们使用void，增加一个回调的参数，约定最后一个参数是回调。<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>Callback &#123;</span><br><span class="line"></span><br><span class="line">    void onSuccess(String json);</span><br><span class="line"></span><br><span class="line">    void onFailed(Exception e);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最终的接口定义会是这个样子</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">public</span> <span class="selector-tag">interface</span> <span class="selector-tag">GithubService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="variable">@GET</span>(<span class="string">"users/&#123;user&#125;/repos"</span>)</span><br><span class="line"></span><br><span class="line">    void listRepos(<span class="variable">@Path</span>(<span class="string">"user"</span>) String user,Callback callback);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * 约定最后一个参数是callback</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用到了两个注解，一个是方法注解，一个是参数注解</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> GET &#123;</span><br><span class="line"></span><br><span class="line">    String value() <span class="keyword">default</span> <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(ElementType.PARAMETER)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Path &#123;</span><br><span class="line"></span><br><span class="line">    String value();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们编写Retrofit类，这个类应该是一个builder模式，里面可以设置baseUrl，姑且忽略其他所有参数。还有一个create方法，则原型如下</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Retrofit</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String baseUrl;</span><br><span class="line">    <span class="keyword">private</span> Retrofit(Builder builder) &#123;</span><br><span class="line">        <span class="keyword">this</span>.baseUrl = builder.baseUrl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T create(Class&lt;T&gt; clazz) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String baseUrl;</span><br><span class="line">        Builder baseUrl(String host) &#123;</span><br><span class="line">            <span class="keyword">this</span>.baseUrl = host;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Retrofit build() &#123;</span><br><span class="line">            <span class="keyword">return</span> new Retrofit(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最最关键的内容就是create方法的实现了。原理就是先拿到最后一个参数，也就是回调，再拿到方法上的注解，获得具体的值，然后拿到除了回调之外的其他参数，获得参数上的注解，然后根据注解取得对应的值，还有原来的参数值，将方法上的注解的值中进行替换。使用OkHttp构造请求,然后回调结果</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; T create(Class&lt;T&gt; clazz) &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 缓存中去</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">Object</span> o = serviceMap.<span class="built_in">get</span>(clazz);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 取不到则取构造代理对象</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            o = (T) Proxy.newProxyInstance(clazz.getClassLoader(), <span class="keyword">new</span> Class[]&#123;clazz&#125;, <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">Object</span> invoke(<span class="keyword">Object</span> proxy, Method method, <span class="keyword">Object</span>[] args) <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                    <span class="keyword">final</span> Callback callback = (Callback) args[args.length - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">final</span> GET <span class="built_in">get</span> = method.getAnnotation(GET.class);</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">get</span> != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">/**</span></span><br><span class="line"><span class="comment">                         * 获得GET注解的值</span></span><br><span class="line"><span class="comment">                         */</span></span><br><span class="line">                        <span class="keyword">String</span> getValue = <span class="built_in">get</span>.value();</span><br><span class="line"></span><br><span class="line">                        System.out.<span class="built_in">println</span>(getValue);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">/**</span></span><br><span class="line"><span class="comment">                         * 获得所有参数上的注解</span></span><br><span class="line"><span class="comment">                         */</span></span><br><span class="line">                        Annotation[][] methodParameterAnnotationArrays = method.getParameterAnnotations();</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (methodParameterAnnotationArrays != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="built_in">int</span> count = methodParameterAnnotationArrays.length;</span><br><span class="line">                            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                                 * 获得单个参数上的注解</span></span><br><span class="line"><span class="comment">                                 */</span></span><br><span class="line">                                Annotation[] methodParameterAnnotations = methodParameterAnnotationArrays[i];</span><br><span class="line"></span><br><span class="line">                                <span class="keyword">if</span> (methodParameterAnnotations != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                    <span class="keyword">for</span> (Annotation methodParameterAnnotation : methodParameterAnnotations) &#123;</span><br><span class="line"></span><br><span class="line">                                        <span class="comment">/**</span></span><br><span class="line"><span class="comment">                                         * 如果是Path注解</span></span><br><span class="line"><span class="comment">                                         */</span></span><br><span class="line">                                        <span class="keyword">if</span> (methodParameterAnnotation <span class="keyword">instanceof</span> Path) &#123;</span><br><span class="line"></span><br><span class="line">                                            <span class="comment">/**</span></span><br><span class="line"><span class="comment">                                             * 取得path注解上的值</span></span><br><span class="line"><span class="comment">                                             */</span></span><br><span class="line">                                            Path path = (Path) methodParameterAnnotation;</span><br><span class="line">                                            <span class="keyword">String</span> pathValue = path.value();</span><br><span class="line">                                            System.out.<span class="built_in">println</span>(pathValue);</span><br><span class="line"></span><br><span class="line">                                            <span class="comment">/**</span></span><br><span class="line"><span class="comment">                                             * 这是对应的参数的值</span></span><br><span class="line"><span class="comment">                                             */</span></span><br><span class="line">                                            System.out.<span class="built_in">println</span>(args[i]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                                            Request.Builder builder = <span class="keyword">new</span> Request.Builder();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                                            <span class="comment">/**</span></span><br><span class="line"><span class="comment">                                             * 使用path注解替换get注解中的值为参数值</span></span><br><span class="line"><span class="comment">                                             */</span></span><br><span class="line">                                            <span class="keyword">String</span> result = getValue.replaceAll(<span class="string">"\\&#123;"</span> + pathValue + <span class="string">"\\&#125;"</span>, (<span class="keyword">String</span>) args[i]);</span><br><span class="line"></span><br><span class="line">                                            System.out.<span class="built_in">println</span>(result);</span><br><span class="line"></span><br><span class="line">                                            <span class="comment">/**</span></span><br><span class="line"><span class="comment">                                             * 开始构造请求</span></span><br><span class="line"><span class="comment">                                             */</span></span><br><span class="line">                                            Request request = builder.<span class="built_in">get</span>()</span><br><span class="line">                                                    .url(baseUrl + <span class="string">"/"</span> + result)</span><br><span class="line">                                                    .build();</span><br><span class="line"></span><br><span class="line">                                            okHttpClient.newCall(request).enqueue(<span class="keyword">new</span> okhttp3.Callback() &#123;</span><br><span class="line">                                                @Override</span><br><span class="line">                                                <span class="keyword">public</span> <span class="keyword">void</span> onFailure(Call call, IOException e) &#123;</span><br><span class="line">                                                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                                                     * 失败则回调失败的方法</span></span><br><span class="line"><span class="comment">                                                     */</span></span><br><span class="line">                                                    callback.onFailed(e);</span><br><span class="line">                                                &#125;</span><br><span class="line"></span><br><span class="line">                                                @Override</span><br><span class="line">                                                <span class="keyword">public</span> <span class="keyword">void</span> onResponse(Call call, Response response) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                                                    <span class="keyword">if</span> (response.isSuccessful()) &#123;</span><br><span class="line">                                                        <span class="comment">/**</span></span><br><span class="line"><span class="comment">                                                         * 请求成功</span></span><br><span class="line"><span class="comment">                                                         */</span></span><br><span class="line">                                                        <span class="keyword">String</span> body = response.body().string();</span><br><span class="line">                                                        <span class="comment">/**</span></span><br><span class="line"><span class="comment">                                                         * 回调成功</span></span><br><span class="line"><span class="comment">                                                         */</span></span><br><span class="line">                                                        callback.onSuccess(body);</span><br><span class="line">                                                    &#125;</span><br><span class="line">                                                &#125;</span><br><span class="line">                                            &#125;);</span><br><span class="line"></span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 扔到缓存中</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            serviceMap.put(clazz, o);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (T) o;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>然后我们就可以根据Retrofit那样进行调用了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">        .baseUrl(<span class="string">"https://api.github.com"</span>)</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">GithubService githubService = retrofit.create(GithubService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">githubService.listRepos(<span class="string">"lizhangqu"</span>, <span class="keyword">new</span> Callback() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(String t)</span> </span>&#123;</span><br><span class="line">        System.out.println(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailed</span><span class="params">(Exception e)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>以上就是一个Retrofit的最简单实现,如果有兴趣，可以去看源码</p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://blog.csdn.net/eastmoon502136/article/details/79366943" target="_blank" rel="noopener">Android开发学习之路–插件化基础动态代理Hook</a><br><a href="https://blog.csdn.net/sbsujjbcy/article/details/50554116" target="_blank" rel="noopener">Android开发中无处不在的设计模式——动态代理模式</a><br><a href="https://blog.csdn.net/self_study/article/details/55050627" target="_blank" rel="noopener">Android 动态代理以及利用动态代理实现 ServiceHook</a></p>
<h3 id="代理模式与装饰模式的区别"><a href="#代理模式与装饰模式的区别" class="headerlink" title="代理模式与装饰模式的区别"></a>代理模式与装饰模式的区别</h3><p>代理模式更偏向于逻辑的控制，装饰模式更偏向于功能的增强<br>有一个比较大的区别是客户不知道代理委托了另一个对象<br>在代理模式中，目标类对于客户端是透明的，而装饰模式中，客户端是对特殊目标的对象进行增强</p>
<p>伪代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//代理模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Subject</span></span>&#123;</span><br><span class="line">       <span class="keyword">private</span> Subject subject;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">Proxy</span><span class="params">()</span></span>&#123;</span><br><span class="line">             <span class="comment">//关系在编译时确定</span></span><br><span class="line">            subject = <span class="keyword">new</span> RealSubject();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAction</span><span class="params">()</span></span>&#123;</span><br><span class="line">             ….</span><br><span class="line">             subject.doAction();</span><br><span class="line">             ….</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//装饰模式</span></span><br><span class="line"><span class="comment">//装饰器模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> <span class="keyword">implements</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Component component;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Decorator</span><span class="params">(Component component)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.component = component</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span>&#123;</span><br><span class="line">            ….</span><br><span class="line">            component.operation();</span><br><span class="line">            ….</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>读《一句顶一万句》</title>
    <url>/blog/2018/10/read-one-thound.html</url>
    <content><![CDATA[<p>《一句顶一万句》是一本讲孤独的书，讲孤独的书通常很矫情，所以这本书只分“说得着”和“说不着”两种。简单的分类法，却非常有效。无论家人，朋友还是夫妻，一旦说得着了，人就亲了。反过来，一旦说不上，就没有亲味儿了。这本书是两段式结构，整本书好像一个轮回，他安排两个时代（上、下两篇），两批人物，却是相同的孤独。上篇是出延津记，主角杨百顺（后改名为吴摩西），生活在一个叫做延津的地方。他一辈子过得七零八落，换了十几个工作都很难找到“说得上话”的人。偏偏他和继女巧玲（他老婆跟前夫的孩子，后改名为曹春娥）说得着，但这个孩子却又被他自己弄丢了。于是杨百顺走出延津，去找巧玲，可是找了半辈子，也没找着。下篇是回延津记，曹春娥的后代牛爱国，同样为了摆脱孤独寻找“说得上话”的朋友，走向延津，时代在前进，历史却在轮回。</p>
<p>这本书小说通篇写的就是，人和人怎么都说不上话，能说到一块儿去的人，又不能够在一起。人总是难找到能说上话的人，你想和别人说，别人却不一定想和你说。即使遇到了能说上话的，要么会离开，要么后来变得说不上话了，要么属于了别人。这其中的无奈和悲剧也只能一声叹息，说一声无可奈何。<br>老杨自认为是老马的朋友，却不知自己在老马眼中根本无足轻重。<br>杨百顺和家人之间没有任何的共同语言，所以他选择逃离，并且再也没有回家。<br>杨百顺的嫂子在出嫁之前活在自以浪漫的言情剧中，而见到新郎那一刻的失望就注定她是孤独的。<br>三个县长，第一个喜欢做木匠，想必也是和人说不上话，第二个喜欢演讲，却少有人能听懂，还有一个只喜欢听戏和手谈，让自己无着无落的心有所寄托。</p>
<p>在这本书里人与人之间说不上话是一种常态。或许在人生的某个阶段他们能说得上话，但是随着时间的推移，距离的变迁，原本的朋友可能变得缄口莫言<br>吴摩西以为自己的老婆吴香香沉默寡言，性情暴烈。谁知她在银匠老金身边却是嘻笑欢颜。<br>牛爱国的妻子庞丽娜在他身边一言不发。谁知她却能和影楼的小蒋谈笑风生。<br>曹青娥和丈夫争吵不断，却能在有月光的夜晚和开着拖拉机的青年一起看泥土在灯光下泛起的金色。<br>当牛爱国退伍回乡时，发现跟发小也不再如当初那样说得着了，满怀心事来到当年无话不谈的战友杜青海身边寻求倾诉时，却发现自己也找错人了。<br>没有永恒说得着的人。</p>
<p>书中有个例子很有趣，书中一个例子，詹神父在黄河边碰到一个中国的杀猪匠，劝杀猪匠说你要信主，杀猪匠说为什么要信主？詹神父说你信了主你就知道你是谁，从哪来，到哪去？杀猪匠说不信我也知道，我是个杀猪匠，从张家庄来去李家庄杀猪。看上起很搞笑是么？实际上发生在人间的对话大抵如此，只是有时我们是詹神父，有时我们是杀猪匠，而且我们还不自知。我们以为说得上话的人，实际却说不上；我们以为跟别人说得上，别人可能觉得和我们说不上。书里说，世上的遍地都是，说得着的人千里难寻啊，诚哉斯言。</p>
<p>在本书的前半段，吴摩西出走延津，完成了出延津记，变成了罗长礼，读来有些感慨，却又不太能说出所以然，就摘抄在这里吧</p>
<blockquote>
<p>“你从哪儿来呀？”<br>因候着他的座位，他问什么，吴摩西赶紧回答什么。于是如实答：<br>“延津。”<br>回头一想，又不如实。自己这半年来并不在延津。<br>中年男人：“延津不挨铁道。你去哪儿呀？”<br>吴摩西：“宝鸡。”<br>这是实话。中年男人：“干啥去？”<br>吴摩西：“投亲戚。”<br>回答着中年男人的问话，吴摩西突然又想起师傅老詹。当年老詹让人信主，说的就是这套话。说人信了主，就明白自己从哪儿来，到哪儿去。吴摩西当初为了生计信过主，后来又不信了；不管信不信，一个最大的问题一直没解决，就是到哪儿去。没想到这些话，又在火车上被一个陌生人问到了。这些话问过，中年男人又问：<br>“你叫个啥？”<br>吴摩西这时愣在那里，没有像回答“从哪儿来”、“到哪儿去”那么利落。一是半年来，全在外面漂泊寻人，接触的全是生人，没有一人关心他的名姓，也没有一人喊起过他的名姓；半年下来，自己叫啥，自己一下也有些茫然；二是自己活了二十一岁，姓名已改过三遍，一开始叫杨百顺，后来叫杨摩西，后来又叫吴摩西，仓皇之下，一时不知从何说起。中年男人见他发愣，从烧鸡上抬起头，不耐烦地说：<br>“自己叫个啥，有啥难说的？不是杀了人，逃出来的吧？”<br>吴摩西唉的一声长叹。要说他杀过人，他没杀过；但在心里，也杀过几个；从他爹他兄弟，一直到赶大车的老马，一直到自己的老婆吴香香，还有“起文堂”的掌柜老高。吴摩西张口要解释什么，这时火车要钻山洞，突然一声长鸣，又让吴摩西想起罗家庄喊丧的罗长礼。罗长礼当年喊丧，就像火车鸣笛一样气派。当年的罗长礼，是吴摩西在世界上最崇拜的人。听罗长礼喊丧，也就七八年前的事；现在想起来，却好像过了半辈子。前几年还偶尔想起罗长礼，后来人多事杂，渐渐就把他忘了。但细想起来，吴摩西从杨家庄走到现在，和罗长礼关系最大。不是喜“虚”不喜实，迄今他还在杨家庄跟老杨做豆腐。虽然他和罗长礼，迄今还没说过一句话。感慨之下，他又不解释了，答：<br>“大哥，我没杀过人，你就叫我罗长礼吧。”</p>
</blockquote>
]]></content>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>读《未来简史》</title>
    <url>/blog/2018/10/read-future-history.html</url>
    <content><![CDATA[<blockquote>
<p>研究历史，就是为了挣脱过去的桎梏，让我们能看向不同的方向，并开始注意到前人无法想象或过去不希望我们想象到的可能性。观察让我们走到现在的一连串意外事件，就能了解人类的每个念头和梦想是如何变成现实的，然后我们就能开始以不同的方式思考并编织出不同的梦想。研究历史并不能告诉我们该如何选择，但至少能给我们提供更多的选项。</p>
</blockquote>
<p>&emsp;&emsp;教师节的时候，公司发了《人类简史》，《未来简史》，《今日简史》三部曲，到今天才啃完未来简史，速度实在有点慢啊。记得去年看过人类简史觉得非常惊艳，没想到转眼间尤瓦尔·赫拉利就又写出了两本出来，不禁让人有点担心是不是会有点老生常谈。但读完之后才发现，这本书反而更加天马行空了。</p>
<p>&emsp;&emsp;其实说起来也怪，这本书的题目叫做未来简史，未来尚未发生，历史从何说起呢。曾经有人说，学习历史是为了从历史中吸取教训，但历史的经验教训告诉我们，人们不会从历史的经验中吸取教训，哈哈。在作者看来，研究历史，就是为了挣脱过去的桎梏，让我们能看向不同的方向，并开始注意到前人无法想象或过去不希望我们想象到的可能性。观察让我们走到现在的一连串意外事件，就能了解人类的每个念头和梦想是如何变成现实的，然后我们就能开始以不同的方式思考并编织出不同的梦想。研究历史并不能告诉我们该如何选择，但至少能给我们提供更多的选项。那些希望改变世界的举动，常常发端于改写历史，从而使得人们能够重新想象未来。不管你是希望工人发动全体罢工、女性夺回自己身体的自主权，还是受压迫的少数民族站起来要求政治权利，第一步都是要重述他们的历史。新的历史会告诉他们，“现在的状况既非自然而然，也不会永恒不变。过去曾经是另一个样子，只是有了一连串的偶然事件，才创造出现在这个不公平的世界。只要我们采取明智的行动，就能改变并创造出更好的世界。”正因为如此，马克思主义者才要讲述资本主义的历史，女权主义者才要研究父权社会的形成，非洲裔美国人才要永远记住奴隶贸易的恐怖。他们的目的不是要延续过去，而是要从过去中解放出来。所谓欲灭其国，先去其史，诚哉斯言。</p>
<center><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog/p3.jpg"></center>


<p>&emsp;&emsp;这本书的主要线索，是讲述了人文主义是怎样打败宗教，成为现代社会的主流价值观，以及随着科技的发展，人文主义将会如何发展。在现代社会之前，多数文化都相信人类是某个伟大宇宙计划的一部分。这个计划的设计者是某些万能的神或是永恒的自然规律，人类无法改变。这个宇宙计划让人的生命有了意义，但同时也限制了人的力量，在中世纪的欧洲，如果一个人有什么疑问的话，他应该做的就是从圣经中寻找答案。但接着出现了人文主义，又讲了一个全新的故事：是人类发明了神，写了《圣经》，而且用了上千种方式加以诠释。所以，人类本身才是一切真理的本源。如果你面临两难局面，只要聆听自己，听从你内心的声音就够了。但其实这背后本质上是生产力的进步，科学技术的进步。在科技的进步下，人类可以掌握自己的命运而不是只能向神明祈祷，人类可以环球旅行，上可九天揽月，下可五洋捉鳖，人类有史以来第一次遏制了饥荒、瘟疫和战争，所以人文主义歌颂人类，赞美人类，认为人类本身才是价值所在。曾有人希望列宁用一句话来定义共产主义。他回答：“共产主义就是苏维埃政权加全国电气化。”没有电力、铁路、无线电，就不会有共产主义。所以，16世纪的俄国不可能建立共产主义政权，因为共产主义需要将信息及资源集中在一个枢纽上。要达到马克思所称“各尽所能、各取所需”的理想，社会就必须让距离遥远的各种产品都能够方便集中及分配，而且整个国家也要能够监控和协调国内所有的活动。</p>
<p>&emsp;&emsp;同时如果我们有什么困惑或者不解时，也不需要再向上帝或者任何权威寻求指导，而是好好探索一下自己的感受。而这正是《绿野仙踪》里面那个锡皮樵夫的遭遇。他和桃乐丝及她的朋友一起走着黄砖路，希望等他们到达奥兹国之后，大巫师能给他一颗心。同样，稻草人想要的是大脑，而狮子想要的是勇气。到了旅程的终点，他们发现大巫师只是个江湖术士，没有办法完成他们的愿望。但他们发现了更重要的事：他们希望拥有的一切，早已在自己心里了。要变得敏感、聪明、勇敢，从来就不需要什么巫师的魔法，只要继续沿着黄砖路走下去，敞开心胸迎接任何体验。一模一样的教训，也发生在柯克舰长与皮卡德舰长乘着“企业号”在星系航行；哈克贝利·费恩和吉姆沿着密西西比河顺流而下；《逍遥骑士》（Easy Rider ）的怀特和比利骑着哈雷摩托；其他无数公路电影中的无数其他角色，离开了在宾州（或是新南威尔士）的家乡，开着一辆旧的敞篷车（或是搭着巴士），感受到一次又一次改变生命的体验，敞开心扉，谈着他们的感受，最后到了旧金山（或是爱丽丝泉），成了一个更好、更聪明的人。</p>
<center><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog/p4.jpg"></center>


<p>&emsp;&emsp;但是人文主义也不是高枕无忧的，他与科学的结盟也不是牢不可破的，人类编织出一张意义的网，并全然相信它，不过，经过几十年、几世纪，意义的网也可能忽然解体，而由一张新的网取而代之。读历史就是在看这些网的编织和解体，并让人意识到，对这个世代的人来说最重要的事情，很有可能对他们的后代就变得毫无意义。作者认为：</p>
<blockquote>
<p>自由主义推崇自由市场和民主选举，是因为自由主义相信每个人都独一无二、各有价值，而且每个人的自由选择就是权威的本源。但在21世纪，有三项“务实”的发展，可能会让这种信念成为明日黄花：<br>1.人类将会失去在经济和军事上的用途，因此经济和政治制度将不再继续认同人类有太多价值。<br>2.社会系统仍然认为人类整体有其价值，但个人则无价值。<br>3.社会系统仍然会认为某些独特的个人有其价值，但这些人会是一群超人类的精英阶层，而不是一般大众。</p>
</blockquote>
<p>21世纪经济学最重要的问题，可能就是多余的人能有什么功用。一旦拥有高度智能而本身没有意识的算法接手几乎一切工作，而且能比有意识的人类做得更好时，人类还能做什么？很难想象民主制度、自由市场和其他自由主义制度如何能承受这记打击。毕竟，自由主义之所以能成为意识形态的主流，并不只是因为它的哲学论证最合理，更是因为它赋予每个人价值，这一点在政治、经济和军事上大有好处。在现代工业战争的大规模战场、现代工业经济的大规模生产线上，每个人都很重要。只要能拿起步枪或是扳动拉杆，每双手都有价值。但到了21世纪，可能事情会发生变化。</p>
<p>&emsp;&emsp;在Alpha GO击败李世石后，人工智能技术更加吸引起关注。不过想要达成作者书中描述的效果其实还是差得很远。不过作者说的很对，很多专家说我们还需要很长时间，才能孕育出基因改良婴儿，或制造出能与人比拟的人工智能。然而，大多数专家所谓的很长时间，用的是学术经费和大学职位的时间标准。所以，所谓“很久”可能只是20年，而“绝不”可能是超过50年。毕竟互联网的历史也不过几十年而已。但是不管怎么说，就算AI要淘汰人类，程序员总归是比较靠后的角色，哈哈，事实上程序员做的越好，互联网产业越兴盛，离开发出一个可以代替程序员的人工智能就越近。就让我们策马狂奔，自掘坟墓吧，天下大势,浩浩汤汤,顺之者昌,逆之者亡。</p>
]]></content>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象的六大原则</title>
    <url>/blog/2018/12/basic-design-pattern.html</url>
    <content><![CDATA[<p>这是学习设计模式系列开篇的第一篇文章，也是我学习设计模式过程中的总结。本文主要以一个图片加载器为例，讲述面向对象设计中，我们应该遵循的六大原则。只有掌握了这些原则，我们才能更好的理解设计模式。</p>
<p>我们接下来要介绍以下6个内容。</p>
<p>1.单一职责原则(Single Responsibility Principle)——SRP<br>2.开闭原则(Open Close Principle)——OCP<br>3.里式替换原则(Liskov Substitution Principle)——LSP<br>4.依赖倒置原则(Dependence Inversion Principle)——DIP<br>5.接口隔离原则(InterfacesSergregation Principle)——ISP<br>6.迪米特原则(Law of Demeter)——LOD</p>
<h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><p>单一职责原则很好理解，就是一个类尽量只做一件事。<br>比如当我们做一个ImageLoader类时,初始版本可能是这样的:<a href="https://github.com/hehonghui/android_dp_analysis_code/blob/master/imageloader-demo/android_dp_chapter01/src/com/dp/chapter01/part1/ImageLoader.java" target="_blank" rel="noopener">ImageLoader</a></p>
<p>可以看到所有的功能都写在了一个类里，随着功能越来越多，代码越来越很复杂，ImageLoader类也会越来越庞大，难以维护。<br>根据单一职责原则，我们应该将ImageLoader类拆开，ImagerLoader只负责图片加载逻辑，而ImagerCache类负责处理图片缓存逻辑。</p>
<h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h3><p>开闭原则的定义是软件中的对象(类，模块，函数等)应该对于扩展是开放的，但是对于修改是关闭的。<br>即当需求发生改变的时候，我们需要对代码进行修改，这个时候我们应该尽量去扩展原来的代码，而不是去修改原来的代码，因为这样可能会引起更多的问题。<br>比如我们上面ImageLoader使用的缓存是内存缓存，但当我们后面要添加磁盘盘存或双缓存时，就不得不修改原来的代码，同时当我们的代码开源时，用户将不能自定义自己的缓存，所以可以修改如下：<br>通过定义ImageCache接口提高代码的扩展性</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 图片缓存接口</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @author mrsimple</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> interface ImageCache &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Bitmap <span class="title">get</span><span class="params">(<span class="keyword">String</span> url)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">String</span> url, Bitmap bmp)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 图片缓存</span></span><br><span class="line">    ImageCache mImageCache = <span class="keyword">new</span> MemoryCache();</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setImageCache</span><span class="params">(ImageCache cache)</span> </span>&#123;</span><br><span class="line">        mImageCache = cache;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">displayImage</span><span class="params">(<span class="keyword">String</span> imageUrl, ImageView imageView)</span> </span>&#123;</span><br><span class="line">        Bitmap bitmap = mImageCache.<span class="built_in">get</span>(imageUrl);</span><br><span class="line">        <span class="keyword">if</span> (bitmap != null) &#123;</span><br><span class="line">            imageView.setImageBitmap(bitmap);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        submitLoadRequest(imageUrl, imageView);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="里式替换原则"><a href="#里式替换原则" class="headerlink" title="里式替换原则"></a>里式替换原则</h3><p>里式替换原则简单说来就是：所有引用基类的地方必须能够透明地使用其子类的对象。<br>里氏替换原则通俗的去讲就是：子类可以去扩展父类的功能，但是不能改变父类原有的功能。他包含以下几层意思：</p>
<p>1.子类可以实现父类的抽象方法，但是不能覆盖父类的非抽象方法。<br>2.子类可以增加自己独有的方法。<br>3.当子类的方法重载父类的方法时候，方法的形参要比父类的方法的输入参数更加宽松。<br>4.当子类的方法实现父类的抽象方法时，方法的返回值要比父类更严格。</p>
<p>其实这里我不太理解，按照java的继承方式，子类都天生的可以代替父类，所有引用基类的地方必须能够透明地使用其子类的对象，这不是本来就满足的吗？</p>
<h4 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h4><p>这个原则从名字根本看不出什么意思。高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。简单的说就是尽量面向接口编程.<br>我们上面建立的ImageCache接口就是一个典型的例子。<br>我们建立了ImageCache抽象，并且让ImageLoader依赖于抽象而不是具体细节。当需求发生变化时，我们只需实现ImageCache或者继承其他已有的ImageCachee子类完成相应的缓存功能即可。<br>这样就保证了缓存系统的高扩展性，有了拥抱变化的能力，这就是依赖倒置原则。</p>
<h3 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h3><p>接口隔离原则的定义是：客户端不应该依赖它不需要的接口；<br>一个类对另一个类的依赖应该建立在最小的接口上。接口最小化,过于臃肿的接口依据功能,可以将其拆分为多个接口</p>
<p>举一个例子：<br>我们知道在Java中一个具体类实现了一个接口，那必然就要实现接口中的所有方法。如果我们有一个类A和类B通过接口I来依赖，类B是对类A依赖的实现，这个接口I有5个方法。但是类A与类B只通过方法1,2,3依赖，然后类C与类D通过接口I来依赖，类D是对类C依赖的实现但是他们却是通过方法1,4,5依赖。那么是必在实现接口的时候，类B就要有实现他不需要的方法4和方法5 而类D就要实现他不需要的方法2，和方法3。这简直就是一个灾难的设计。<br>所以我们需要对接口进行拆分，就是把接口分成满足依赖关系的最小接口，类B与类D不需要去实现与他们无关接口方法。比如在这个例子中，我们可以把接口拆成3个，第一个是仅仅由方法1的接口，第二个接口是包含2,3方法的，第三个接口是包含4,5方法的。<br>这样，我们的设计就满足了接口隔离原则。<br>以上这些设计思想用英文的第一个字母可以组成SOLID ，满足这个5个原则的程序也被称为满足了SOLID准则。</p>
<h3 id="迪米特原则"><a href="#迪米特原则" class="headerlink" title="迪米特原则"></a>迪米特原则</h3><p>迪米特原则也被称为最小知识原则，他的定义：一个对象应该对其他对象保持最小的了解。<br>因为类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大，所以这也是我们提倡的软件编程的总的原则：低耦合，高内聚。</p>
<p>迪米特法则还有一个更简单的定义<br>只与直接的朋友通信。首先来解释一下什么是直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖、关联、组合、聚合等。其中，我们称出现成员变量、方法参数、方法返回值中的类为直接的朋友，而出现在局部变量中的类则不是直接的朋友。也就是说，陌生的类最好不要作为局部变量的形式出现在类的内部。</p>
<p>这里我们可以用一个现实生活中的例子来讲解一下。比如我们需要一张CD,我们可能去音像店去问老板有没有我们需要的那张CD，老板说现在没有，等有的时候你们来拿就行了。在这里我们不需要关心老板是从哪里，怎么获得的那张CD，我们只和老板（直接朋友）沟通，至于老板从他的朋友那里通过何种条件得到的CD，我们不关心，我们不和老板的朋友（陌生人）进行通信，这个就是迪米特的一个应用。说白了，就是一种中介的方式。我们通过老板这个中介来和真正提供CD的人发生联系。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>面向对象的六大原则就这样简单的介绍完了，我们看出来，这些原则其实都是应对不断改变的需求。每当需求变化的时候，我们利用这些原则来使我们的代码改动量最小，而且所造成的影响也是最小的。但是我们在看这些原则的时候，我们会发现很多原则并没有提供一种公式化的结论，而即使提供了公式化的结论的原则也只是建议去这样做。这是因为，这些设计原则本来就是从很多实际的代码中提取出来的，他是一个经验化的结论。怎么去用它，用好他，就要依靠设计者的经验。否则一味者去使用设计原则可能会使代码出现过度设计的情况。大多数的原则都是通过提取出抽象和接口来实现，如果发生过度的设计，就会出现很多抽象类和接口，增加了系统的复杂度。所以到底如何用好还是要程序员在实际项目中掌握。</p>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Okhttp Cookie持久化</title>
    <url>/blog/2018/10/okhttp-cookie-presist.html</url>
    <content><![CDATA[<p>Okhttp并不会保留cookie，我们可以通过拦截器的方式实现cookie持久化<br>通过响应拦截器从response取出cookie并保存到本地，通过请求拦截器从本地取出cookie并添加到请求中</p>
<h4 id="将cookie存储到本地"><a href="#将cookie存储到本地" class="headerlink" title="将cookie存储到本地"></a>将cookie存储到本地</h4><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ReceivedCookiesInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public Response intercept(<span class="meta">@NonNull</span> Chain chain) throws IOException &#123;</span><br><span class="line">        Response originalResponse = chain.proceed(chain.request());</span><br><span class="line">        <span class="keyword">if</span> (!originalResponse.headers(<span class="string">"set-cookie"</span>).isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="built_in">StringBuffer</span> cookieBuffer = <span class="keyword">new</span> <span class="built_in">StringBuffer</span>();</span><br><span class="line">            Observable.from(originalResponse.headers(<span class="string">"set-cookie"</span>))</span><br><span class="line">                    .map(<span class="keyword">new</span> Func1&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        public <span class="built_in">String</span> call(<span class="built_in">String</span> s) &#123;</span><br><span class="line">                            <span class="built_in">String</span>[] cookieArray = s.split(<span class="string">";"</span>);</span><br><span class="line">                            <span class="keyword">return</span> cookieArray[<span class="number">0</span>];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">                    .subscribe(<span class="keyword">new</span> Action1&lt;<span class="built_in">String</span>&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        public <span class="keyword">void</span> call(<span class="built_in">String</span> cookie) &#123;</span><br><span class="line">                            cookieBuffer.append(cookie).append(<span class="string">";"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            SpUtil.setString(GlobalConstant.COOKIES, cookieBuffer.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> originalResponse;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="将本地的cookie追加到http请求头中"><a href="#将本地的cookie追加到http请求头中" class="headerlink" title="将本地的cookie追加到http请求头中"></a>将本地的cookie追加到http请求头中</h4><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddCookiesInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function">Response <span class="title">intercept</span><span class="params">(@NonNull Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Request.Builder builder = chain.request().newBuilder();</span><br><span class="line">        Observable.just(SpUtil.getString(GlobalConstant.COOKIES))</span><br><span class="line">                .subscribe(<span class="keyword">new</span> Action1&lt;String&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">call</span><span class="params">(String cookie)</span> </span>&#123;</span><br><span class="line">                        <span class="comment">//添加cookie</span></span><br><span class="line">                        builder.addHeader(<span class="string">"cookie"</span>, cookie);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="keyword">return</span> chain.<span class="keyword">proceed</span>(builder.build());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Okhttp配置"><a href="#Okhttp配置" class="headerlink" title="Okhttp配置"></a>Okhttp配置</h4><figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">OkHttpClient okHttpClient = <span class="keyword">new</span> <span class="type">OkHttpClient</span>.Builder()</span><br><span class="line">                .addInterceptor(httpLoggingInterceptor)</span><br><span class="line"></span><br><span class="line">                .addInterceptor(<span class="keyword">new</span> <span class="type">ReceivedCookiesInterceptor</span>())</span><br><span class="line">                .addInterceptor(<span class="keyword">new</span> <span class="type">AddCookiesInterceptor</span>())</span><br><span class="line"></span><br><span class="line">                .connectTimeout(<span class="number">15</span>, TimeUnit.SECONDS)</span><br><span class="line">                .build();</span><br></pre></td></tr></table></figure>
<h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p><a href="https://www.jianshu.com/p/fcccf5907bab" target="_blank" rel="noopener">Retrofit实现持久化Cookie的三种方案</a><br><a href="https://blog.csdn.net/yechaoa/article/details/80369924" target="_blank" rel="noopener">Retrofit+OkHttp实现Cookie持久化，RxJava方式</a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android获取View的宽高</title>
    <url>/blog/2018/11/android-view-measure.html</url>
    <content><![CDATA[<p>在oncreate()中无论利用view.getWidth()或是view.getHeiht()还是view.getMeasuredHeight或view.getMeasuredWidth()来获取view的宽和高，看似没有问题，其实他们取得值是0，并不是你想要的结果。这是因为每个布局都要经过如下三个步骤:</p>
<p>1.测量：onMeasure 设置自己显示在屏幕上的宽高<br>2.布局：onLayout 设置自己显示在屏幕上的位置(只有在自定义ViewGroup中才用到)<br>3.绘制：onDraw 控制显示在屏幕上的样子(viewgroup没有这个过程) </p>
<p>如上的步骤是异步进行的，在oncreate()中界面处于不可见状态，内存加载组件还没有绘制出来,所以是无法获取他的尺寸。<br>那如何在绘制组件之前能获取到该组件的尺寸大小呢？ </p>
<h4 id="方法一-最常用的方法"><a href="#方法一-最常用的方法" class="headerlink" title="方法一(最常用的方法):"></a>方法一(最常用的方法):</h4><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">//手动调用测量方法。</span></span><br><span class="line"><span class="comment">//制定测量规则 参数表示size + mode </span></span><br><span class="line">   <span class="keyword">int</span>  <span class="built_in">width</span> =View.MeasureSpec.makeMeasureSpec(<span class="number">0</span>,View.MeasureSpec.UNSPECIFIED);</span><br><span class="line">   <span class="keyword">int</span>  <span class="built_in">height</span> =View.MeasureSpec.makeMeasureSpec(<span class="number">0</span>,View.MeasureSpec.UNSPECIFIED);</span><br><span class="line">   view.measure(<span class="built_in">width</span>,<span class="built_in">height</span>);</span><br><span class="line"><span class="comment">//调用measure方法之后就可以获取宽高。</span></span><br><span class="line">   <span class="keyword">int</span>   <span class="built_in">height</span>=view.getMeasuredHeight(); </span><br><span class="line">   <span class="keyword">int</span>    <span class="built_in">width</span>=view.getMeasuredWidth();</span><br></pre></td></tr></table></figure>
<h4 id="方法二-设置树桩结构监听器"><a href="#方法二-设置树桩结构监听器" class="headerlink" title="方法二(设置树桩结构监听器):"></a>方法二(设置树桩结构监听器):</h4><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">  ViewTreeObserver  vto =view.getViewTreeObserver(); </span><br><span class="line">  vto.addOnGlobalLayoutListener(<span class="keyword">new</span> OnGlobalLayoutListener()&#123; </span><br><span class="line">    @Override </span><br><span class="line">   <span class="keyword">public</span>  <span class="keyword">void</span>  onGlobalLayout() &#123; </span><br><span class="line">   view.getViewTreeObserver().removeGlobalOnLayoutListener(<span class="keyword">this</span>);     </span><br><span class="line">  <span class="keyword">int</span>  <span class="built_in">height</span> =view.getMeasuredHeight(); </span><br><span class="line">  <span class="keyword">int</span>  <span class="built_in">width</span> =view.getMeasuredWidth();  </span><br><span class="line">    &#125; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>方法三(增加组件绘制之前的监听):</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">ViewTreeObserver  vto =view.getViewTreeObserver(); </span><br><span class="line"></span><br><span class="line">vto.addOnPreDrawListener(<span class="keyword">new</span>  ViewTreeObserver.OnPreDrawListener() &#123; </span><br><span class="line">   @Override </span><br><span class="line">   <span class="keyword">public</span>  <span class="keyword">boolean</span>  onPreDraw() &#123; </span><br><span class="line">   <span class="keyword">int</span>  <span class="built_in">height</span> =view.getMeasuredHeight(); </span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">width</span> =view.getMeasuredWidth();     </span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="详解View-measure"><a href="#详解View-measure" class="headerlink" title="详解View.measure:"></a>详解View.measure:</h4><p>measure()方法是实际测量的方法，而在绘制布局过程中调用的onMeasure()只是制定测量规则.<br>在自定义布局中我们一般重写onMeasure()方法，measure()方法是final的，子类无法重写。 </p>
<p>看到measure函数有2个参数，int widthMeasureSpec 和 int heightMeasureSpec表示具体的测量规则。<br>这两个数值不是普通的数值, 它表示: size + mode </p>
<p>例如:<br>int widthMeasureSpec= View.MeasureSpec.makeMeasureSpec(1000,View.MeasureSpec.EXACTLY);<br>int heightMeasureSpec= View.MeasureSpec.makeMeasureSpec(1000,View.MeasureSpec.AT_MOST); </p>
<p>模式分为:<br>View.MeasureSpec.EXACTLY:表示父视图希望子类的大小是specSize中制定的大小.<br>View.MeasureSpec.AT_MOST:父试图希望子类的大小最高不超过specSize中制定的大小.<br>View.MeasureSpec.UNSPECIFIED:父试图不对子类实施任何限制,子试图可以得到自己想得到的任意大小</p>
<p>MeasureSpect是由LayoutParameter通过父容器的施加的规则产生的</p>
<p>下面我们来看一看三种模式产生的情况.</p>
<figure class="highlight cos"><table><tr><td class="code"><pre><span class="line">MeasureSpec.EXACTLY</span><br><span class="line">父容器已经精确的检测出了子<span class="keyword">View</span>的大小,子<span class="keyword">view</span>的大小就是MeasureSpect.getSize()的值.</span><br><span class="line"></span><br><span class="line">适用情况:</span><br><span class="line">    a.子<span class="keyword">View</span>的LayoutParameter使用具体的值(如:宽高为<span class="number">100</span>dp),不管父容器的spectMode为什么,系统返回给子<span class="keyword">View</span>的mode为EXACTLY,系统返回给子<span class="keyword">View</span>的大小为子V诶额外自己指定的大小(<span class="number">100</span>dp)</span><br><span class="line">    b.子<span class="keyword">View</span>的LayoutParams采用match_parent并且父容器的mode为EXACTLY,那么子<span class="keyword">View</span>的mode即为EXACTLY,子<span class="keyword">View</span>大小为父容器剩余的大小</span><br><span class="line"></span><br><span class="line">MeasureSpec.AT_MOST</span><br><span class="line">父容器期望对子<span class="keyword">View</span>的最大值做了限定</span><br><span class="line"></span><br><span class="line">适用情况:</span><br><span class="line">    c.子<span class="keyword">View</span>的LayoutParams采用match_parent并且父容器的mode为AT_MOST,那么子<span class="keyword">View</span>的mode即为AT_MOST,子<span class="keyword">View</span>大小为父容器剩余的大小</span><br><span class="line">    <span class="keyword">d</span>.当子<span class="keyword">View</span>的LayoutParams采用wrap_content时并且父容器的mode为EXACTLY或者AT_MOST时,子<span class="keyword">View</span>的Mode就为AT_MOST，子<span class="keyword">View</span>的specSize就为该父容器剩余的大小</span><br><span class="line"></span><br><span class="line">MeasureSpec.UNSPECIFIED</span><br><span class="line">父容器不限定大小,子<span class="keyword">View</span>想多大就多大</span><br><span class="line"></span><br><span class="line">适应情况:</span><br><span class="line">    e.当子<span class="keyword">View</span>的LayoutParams采用wrap_content时并且父容器的mode为UNSPECIFIED时,子<span class="keyword">View</span>的Mode就为UNSPECIFIED，子<span class="keyword">View</span>的大小不做限制</span><br></pre></td></tr></table></figure>
<h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p><a href="https://blog.csdn.net/itheimach/article/details/52295699" target="_blank" rel="noopener">MeasureSpect之三种模式(补)</a><br><a href="https://blog.csdn.net/canot/article/details/50430998" target="_blank" rel="noopener">Android获取View的宽高与View.measure详解</a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>kotlin语法学习</title>
    <url>/blog/2018/12/kotlin-languag-learn.html</url>
    <content><![CDATA[<h4 id="kotlin语法学习及资料"><a href="#kotlin语法学习及资料" class="headerlink" title="kotlin语法学习及资料"></a>kotlin语法学习及资料</h4><ul>
<li><a href="https://www.kotlincn.net/docs/reference/basic-syntax.html" target="_blank" rel="noopener">kotlin中文文档</a></li>
<li><a href="https://shenzhen2017.github.io/blog/2017/08/kotlin-basic-grammer.html">Kotlin基础语法</a></li>
</ul>
<h4 id="一些零散知识点"><a href="#一些零散知识点" class="headerlink" title="一些零散知识点"></a>一些零散知识点</h4><ul>
<li><a href="https://blog.csdn.net/lv_fq/article/details/72869124" target="_blank" rel="noopener">Kotlin 双冒号 :: 使用</a></li>
<li><a href="https://www.jianshu.com/p/73c54e35ce25" target="_blank" rel="noopener">掌握Kotlin标准函数：run, with, let, also and apply</a></li>
</ul>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>tinker原理手写实现</title>
    <url>/blog/2019/08/tinker-principle-learn.html</url>
    <content><![CDATA[<p>Tinker热修复方法，利用了Android 的类加载机制，Android中有两个主要的Classloader，PathClassLoader和DexClassLoader，它们都继承自BaseDexClassLoader，这两个类加载器的主要区别是：Android系统通过PathClassLoader来加载系统类和主dex中的类。而DexClassLoader则可用于加载指定路径的apk、jar或dex文件。上述两个类都是继承自BaseDexClassLoader。</p>
<p>BaseDexClassLoader 的构造函数中创建一个DexPathList实例，DexPathList的构造函数会创建一个dexElements 数组,BaseDexClassLoader 在findclass方法中调用了pathList.findClass，这个方法中会遍历dexpathlist中的dexElements数组，然后初始化DexFile，如果DexFile不为空那么调用DexFile类的loadClassBinaryName方法返回Class实例。简言之，ClassLoader会遍历dexelements,然后加载这个数组中的dex文件. ClassLoader在加载到正确的类之后就会停止加载此类,因此我们将包含正确的类的Dex文件中插入在dexElements数组前面就可以完成对问题类的修复</p>
<p>所以我们热修复的简单实现如下：<br>1.创建自己的类加载器DexClassLoader<br>2.下载修复好的dex,复制到私有目录中，用自己的类加载器，加载修复好的dex<br>3.将自己和系统的dexElements数组进行合并，并设置优先级<br>4.通过反射技术，将合并后的dexElements赋值给系统的pathList实例</p>
<p>通过以上操作，就可以实现ClassLoader加载时首先加载到正确的类的效果.<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog/p8.png" alt></p>
<h3 id="具体实现如下："><a href="#具体实现如下：" class="headerlink" title="具体实现如下："></a>具体实现如下：</h3><p>1.创建自有的类加载器<br><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createClassLoader</span><span class="params">(Context context, <span class="built_in">File</span> fileDir)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建类加载器输出的目录</span></span><br><span class="line">        <span class="keyword">String</span> optimizeDir = fileDir.getAbsolutePath() + <span class="built_in">File</span>.separator + <span class="string">"opt_dex"</span>;</span><br><span class="line">        <span class="comment">//创建一个目录</span></span><br><span class="line">        <span class="built_in">File</span> fopt = <span class="keyword">new</span> <span class="built_in">File</span>(optimizeDir);</span><br><span class="line">        <span class="keyword">if</span> (!fopt.<span class="built_in">exists</span>()) &#123;</span><br><span class="line">            fopt.mkdirs();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">File</span> dex : loadedDex) &#123;</span><br><span class="line">            <span class="comment">//创建自有的类加载器</span></span><br><span class="line">            DexClassLoader dexClassLoader = <span class="keyword">new</span> DexClassLoader(dex.getAbsolutePath(), optimizeDir, null, context.getClassLoader());</span><br><span class="line">            <span class="comment">//每循环一次，修复一次</span></span><br><span class="line">            hotfix(dexClassLoader, context);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>2.下载修复好的dex.复制到私有目录，用自己的类加载器，加载修复好的dex</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fix</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//不模拟网络下载过程</span></span><br><span class="line">        <span class="comment">//SD卡下的修复文件</span></span><br><span class="line">        <span class="built_in">File</span> sourceFile = <span class="keyword">new</span> <span class="built_in">File</span>(Environment.getExternalStorageDirectory(), Constants.DEX_NAME);</span><br><span class="line">        <span class="comment">//目标文件，私有目录</span></span><br><span class="line">        <span class="built_in">File</span> targetFile = <span class="keyword">new</span> <span class="built_in">File</span>(getDir(Constants.DEX_DIR, Context.MODE_PRIVATE).getAbsolutePath() + <span class="built_in">File</span>.separator + Constants.DEX_NAME);</span><br><span class="line">        <span class="comment">//可能已经存在classes2.dex</span></span><br><span class="line">        <span class="keyword">if</span> (targetFile.<span class="built_in">exists</span>()) &#123;</span><br><span class="line">            targetFile.<span class="keyword">delete</span>();</span><br><span class="line">            Log.i(<span class="string">"tiaoshi"</span>, <span class="string">"删除老的修复包"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.将下载的修复包复制到私有目录,然后再做解压操作</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileUtils.copyFile(sourceFile, targetFile);</span><br><span class="line">            Log.i(<span class="string">"tiaoshi"</span>, <span class="string">"复制完成"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//调用FileDexUtils修复工具，开始修复</span></span><br><span class="line">            FixDexUtils.loadFixdDex(<span class="keyword">this</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>3.合并dexElements数组并排序</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取系统的pathClassLoader</span></span><br><span class="line">           PathClassLoader pathClassLoader = (PathClassLoader) context.getClassLoader();</span><br><span class="line">           <span class="comment">//获取自有的dexElements数组</span></span><br><span class="line">           <span class="keyword">Object</span> myElements = ReflectUtils.getDexElements(ReflectUtils.getPathList(classLoader));</span><br><span class="line">           <span class="comment">//获取系统的dexElements数组</span></span><br><span class="line">           <span class="keyword">Object</span> systemElements = ReflectUtils.getDexElements(ReflectUtils.getPathList(pathClassLoader));</span><br><span class="line">           <span class="comment">//合并数组并且生成一个新的dex数组(包含排序工作)</span></span><br><span class="line">           <span class="keyword">Object</span> dexElements = ArrayUtils.combinArray(myElements, systemElements);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * @param arrayLhs 前数组(准备插队的数组)</span></span><br><span class="line"><span class="comment">    * @param arrarRhs 后数组</span></span><br><span class="line"><span class="comment">    * @return 处理后的新数组</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">Object</span> combinArray(<span class="keyword">Object</span> arrayLhs,<span class="keyword">Object</span> arrarRhs)&#123;</span><br><span class="line">       <span class="comment">//获取一个数组的Class对象，通过Array.newInstance可以反射生成数组对象</span></span><br><span class="line">       Class&lt;?&gt; localClass = arrayLhs.getClass().getComponentType();</span><br><span class="line">       <span class="comment">//前数组长度</span></span><br><span class="line">       <span class="built_in">int</span> i = <span class="keyword">Array</span>.getLength(arrayLhs);</span><br><span class="line">       <span class="comment">//新数组总长度</span></span><br><span class="line">       <span class="built_in">int</span> j = i + <span class="keyword">Array</span>.getLength(arrarRhs);</span><br><span class="line">       <span class="comment">//生成数组对象</span></span><br><span class="line">       <span class="keyword">Object</span> result = <span class="keyword">Array</span>.newInstance(localClass,j);</span><br><span class="line">       <span class="keyword">for</span> (<span class="built_in">int</span> k=<span class="number">0</span>;k&lt;j;++k)&#123;</span><br><span class="line">           <span class="keyword">if</span> (k&lt;i)&#123;</span><br><span class="line">               <span class="comment">//如果前数组有值则插入</span></span><br><span class="line">               <span class="keyword">Array</span>.<span class="built_in">set</span>(result,k,<span class="keyword">Array</span>.<span class="built_in">get</span>(arrayLhs,k));</span><br><span class="line">           &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">//添加完前数组，再添加后数组，合并完成</span></span><br><span class="line">               <span class="keyword">Array</span>.<span class="built_in">set</span>(result,k,<span class="keyword">Array</span>.<span class="built_in">get</span>(arrarRhs,k-i));</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>4.通过反射，将dexElements，赋值给系统的pathList</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取系统的pathList属性，通过反射机制</span></span><br><span class="line">         <span class="built_in">Object</span> systemPathList = ReflectUtils.getPathList(pathClassLoader);</span><br><span class="line">         <span class="comment">//通过反射，将新的dexElements数组，赋值给系统的pathList属性</span></span><br><span class="line">         ReflectUtils.setField(systemPathList, systemPathList.getClass(), dexElements);</span><br></pre></td></tr></table></figure>
<p>以上就是tinker原理的简单实现，tinker在实际使用中其实还用到了差分包算法，安全校验等复杂操作，这里只是基本原理的实现。<br>具体源码可见：<a href="https://github.com/shenzhen2017/TinkerDemo" target="_blank" rel="noopener">https://github.com/shenzhen2017/TinkerDemo</a>            </p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>PorterDuffXfermode使用</title>
    <url>/blog/2018/11/porter-duffx-use.html</url>
    <content><![CDATA[<p>PorterDuffXfermode extends Xfermode。它将所绘制的图形的像素与Canvas中对应位置的像素按照一定规则进行混合，形成新的像素值，从而更新Canvas中最终的像素颜色值。</p>
<p>PorterDuffXfermode这个类中的Porter和Duff是两个人名，这两个人在1984年一起写了一篇名为《Compositing Digital Images》的论文.</p>
<p>使用PorterDuffXfermode可以组合成各种我们想要的图形，下面看一张著名的图</p>
<center><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog/p5.jpg"></center>

<p>上面这张图从一定程度上形象地说明了运用PorterDuff.Mode进行图像合成的作用，两个图形一圆一方通过一定的计算产生了不同的合成效果，我们在实际工作中需要做图片处理时可以参考这张图的示意快速地选择合适的Mode。<br>下面我们可以看一些示例</p>
<h4 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h4><p>我们在演示如何使用PorterDuffXfermode之前，先看一下下面这个例子，代码如下所示：</p>
<figure class="highlight mel"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">    protected void onDraw(Canvas <span class="keyword">canvas</span>) &#123;</span><br><span class="line">        super.onDraw(<span class="keyword">canvas</span>);</span><br><span class="line">        <span class="comment">//设置背景色</span></span><br><span class="line">        <span class="keyword">canvas</span>.drawARGB(<span class="number">255</span>, <span class="number">139</span>, <span class="number">197</span>, <span class="number">186</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> canvasWidth = <span class="keyword">canvas</span>.getWidth();</span><br><span class="line">        <span class="keyword">int</span> r = canvasWidth / <span class="number">3</span>;</span><br><span class="line">        <span class="comment">//绘制黄色的圆形</span></span><br><span class="line">        paint.setColor(<span class="number">0xFFFFCC44</span>);</span><br><span class="line">        <span class="keyword">canvas</span>.drawCircle(r, r, r, paint);</span><br><span class="line">        <span class="comment">//绘制蓝色的矩形</span></span><br><span class="line">        paint.setColor(<span class="number">0xFF66AAFF</span>);</span><br><span class="line">        <span class="keyword">canvas</span>.drawRect(r, r, r * <span class="number">2.7</span>f, r * <span class="number">2.7</span>f, paint);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>我们重写了View的onDraw方法，首先将View的背景色设置为绿色，然后绘制了一个黄色的圆形，然后再绘制一个蓝色的矩形，效果如下所示： </p>
<center><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog/p6.jpg"></center>

<p>上面演示就是Canvas正常的绘图流程，没有使用PorterDuffXfermode。</p>
<h4 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h4><p>下面我们使用PorterDuffXfermode对上面的代码进行一下修改，修改后的代码如下所示：</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDraw(canvas);</span><br><span class="line">        <span class="comment">//设置背景色</span></span><br><span class="line">        canvas.drawARGB(<span class="number">255</span>, <span class="number">139</span>, <span class="number">197</span>, <span class="number">186</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> canvasWidth = canvas.getWidth();</span><br><span class="line">        <span class="keyword">int</span> r = canvasWidth / <span class="number">3</span>;</span><br><span class="line">        <span class="comment">//正常绘制黄色的圆形</span></span><br><span class="line">        paint.setColor(<span class="number">0xFFFFCC44</span>);</span><br><span class="line">        canvas.drawCircle(r, r, r, paint);</span><br><span class="line">        <span class="comment">//使用CLEAR作为PorterDuffXfermode绘制蓝色的矩形</span></span><br><span class="line">        paint.setXfermode(<span class="keyword">new</span> PorterDuffXfermode(PorterDuff.Mode.CLEAR));</span><br><span class="line">        paint.setColor(<span class="number">0xFF66AAFF</span>);</span><br><span class="line">        canvas.drawRect(r, r, r * <span class="number">2.7</span>f, r * <span class="number">2.7</span>f, paint);</span><br><span class="line">        <span class="comment">//最后将画笔去除Xfermode</span></span><br><span class="line">        paint.setXfermode(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>效果如下所示：</p>
<center><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog/p7.jpg"></center>

<p>我们具体分析一下白色矩形出现的原因。一般我们在调用canvas.drawXXX()方法时都会传入一个画笔Paint对象，Android在绘图时会先检查该画笔Paint对象有没有设置Xfermode，如果没有设置Xfermode，那么直接将绘制的图形覆盖Canvas对应位置原有的像素；如果设置了Xfermode，那么会按照Xfermode具体的规则来更新Canvas中对应位置的像素颜色。</p>
<p>就本例来说，在执行canvas.drawCirlce()方法时，画笔Paint没有设置Xfermode对象，所以绘制的黄色圆形直接覆盖了Canvas上的像素。当我们调用canvas.drawRect()绘制矩形时，画笔Paint已经设置Xfermode的值为PorterDuff.Mode.CLEAR，此时Android首先是在内存中绘制了这么一个矩形，所绘制的图形中的像素称作源像素（source，简称src），所绘制的矩形在Canvas中对应位置的矩形内的像素称作目标像素（destination，简称dst）。</p>
<p>源像素的ARGB四个分量会和Canvas上同一位置处的目标像素的ARGB四个分量按照Xfermode定义的规则进行计算，形成最终的ARGB值，然后用该最终的ARGB值更新目标像素的ARGB值。本例中的Xfermode是PorterDuff.Mode.CLEAR，该规则比较简单粗暴，直接要求目标像素的ARGB四个分量全置为0，即(0，0，0，0)，即透明色，所以我们通过canvas.drawRect()在Canvas上绘制了一个透明的矩形，由于Activity本身屏幕的背景时白色的，所以此处就显示了一个白色的矩形。</p>
<h4 id="示例三"><a href="#示例三" class="headerlink" title="示例三"></a>示例三</h4><p>我们在对示例二中的代码进行一下修改，将绘制圆形和绘制矩形相关的代码放到canvas.saveLayer()和canvas.restoreToCount()之间，代码如下所示：<br><figure class="highlight mel"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">    protected void onDraw(Canvas <span class="keyword">canvas</span>) &#123;</span><br><span class="line">        super.onDraw(<span class="keyword">canvas</span>);</span><br><span class="line">        <span class="comment">//设置背景色</span></span><br><span class="line">        <span class="keyword">canvas</span>.drawARGB(<span class="number">255</span>, <span class="number">139</span>, <span class="number">197</span>, <span class="number">186</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> canvasWidth = <span class="keyword">canvas</span>.getWidth();</span><br><span class="line">        <span class="keyword">int</span> canvasHeight = <span class="keyword">canvas</span>.getHeight();</span><br><span class="line">        <span class="keyword">int</span> layerId = <span class="keyword">canvas</span>.saveLayer(<span class="number">0</span>, <span class="number">0</span>, canvasWidth, canvasHeight, null, Canvas.ALL_SAVE_FLAG);</span><br><span class="line">            <span class="keyword">int</span> r = canvasWidth / <span class="number">3</span>;</span><br><span class="line">            <span class="comment">//正常绘制黄色的圆形</span></span><br><span class="line">            paint.setColor(<span class="number">0xFFFFCC44</span>);</span><br><span class="line">            <span class="keyword">canvas</span>.drawCircle(r, r, r, paint);</span><br><span class="line">            <span class="comment">//使用CLEAR作为PorterDuffXfermode绘制蓝色的矩形</span></span><br><span class="line">            paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.CLEAR));</span><br><span class="line">            paint.setColor(<span class="number">0xFF66AAFF</span>);</span><br><span class="line">            <span class="keyword">canvas</span>.drawRect(r, r, r * <span class="number">2.7</span>f, r * <span class="number">2.7</span>f, paint);</span><br><span class="line">            <span class="comment">//最后将画笔去除Xfermode</span></span><br><span class="line">            paint.setXfermode(null);</span><br><span class="line">        <span class="keyword">canvas</span>.restoreToCount(layerId);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>效果如下所示:</p>
<center><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog/p8.jpg"></center>

<p>关于canvas绘图中的layer有以下几点需要说明：</p>
<ul>
<li>canvas是支持图层layer渲染这种技术的，canvas默认就有一个layer，当我们平时调用canvas的各种drawXXX()方法时，其实是把所有的东西都绘制到canvas这个默认的layer上面。</li>
<li>我们还可以通过canvas.saveLayer()新建一个layer，新建的layer放置在canvas默认layer的上部，当我们执行了canvas.saveLayer()之后，我们所有的绘制操作都绘制到了我们新建的layer上，而不是canvas默认的layer。</li>
<li>用canvas.saveLayer()方法产生的layer所有像素的ARGB值都是(0，0，0，0)，即canvas.saveLayer()方法产生的layer初始时时完全透明的。</li>
<li>canvas.saveLayer()方法会返回一个int值，用于表示layer的ID，在我们对这个新layer绘制完成后可以通过调用canvas.restoreToCount(layer),或者canvas.restore()把这个layer绘制到canvas默认的layer上去，这样就完成了一个layer的绘制工作。</li>
</ul>
<p>那你可能感觉到很奇怪，我们只是将绘制圆形与矩形的代码放到了canvas.saveLayer()和canvas.restoreToCount()之间，为什么不再像示例二那样显示白色的矩形了？</p>
<p>我们在分析示例二代码时知道了最终矩形区域的目标颜色都被重置为透明色(0,0,0,0)了，最后只是由于Activity背景色为白色，所以才最终显示成白色矩形。在本例中，我们在新建的layer上面绘制完成后，其实矩形区域的目标颜色也还是被重置为透明色(0,0,0,0)了，这样整个新建layer只有圆的3/4不是透明的，其余像素全是透明的，然后我们调用canvas.restoreToCount()将该layer又绘制到了Canvas上面去了。在将一个新建的layer绘制到Canvas上去时，Android会用整个layer上面的像素颜色去更新Canvas对应位置上像素的颜色，并不是简单的替换，而是Canvas和新layer进行Alpha混合，可参见<a href="https://baike.baidu.com/item/ALPHA%E6%B7%B7%E5%90%88?fr=aladdin" target="_blank" rel="noopener">此处链接</a></p>
<p>由于我们的layer中只有两种像素：完全透明的和完全不透明的，不存在部分透明的像素，并且完全透明的像素的颜色值的四个分量都为0，所以本例就将Canvas和新layer进行Alpha混合的规则简化了，具体来说：</p>
<ul>
<li>如果新建layer上面某个像素的Alpha分量为255，即该像素完全不透明，那么Android会直接用该像素的ARGB值作为Canvas对应位置上像素的颜色值。</li>
<li>如果新建layer上面某个像素的Alpha分量为0，即该像素完全透明，在本例中Alpha分量为0的像素，其RGB分量也都为0，那么Android会保留Canvas对应位置上像素的颜色值。</li>
</ul>
<p>这样当将新layer绘制到Canvas上时，完全不透明的3/4黄色圆中的像素会完全覆盖Canvas对应位置的像素，而由于在新layer上面绘制的矩形区域的像素ARGB都为(0,0,0,0)，所以最终Canvas上对应矩形区域还是保持之前的背景色，这样就不会出现白色的矩形了。</p>
<p>大部分情况下，我们想要本例中实现的效果，而不是想要示例二中形成的白色矩形，所以大部分情况下在使用PorterDuffXfermode时都是结合canvas.saveLayer()、canvas.restoreToCount()的，将关键代码写在这两个方法之间。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>通过PorterDuffXfermode我们可以实现各种效果动效，比如将PorterDuffXfermode与水波纹结合就可以做出圆形背景的水波。详情可见：<br><a href="https://blog.csdn.net/xiaomengzi_16/article/details/77470958" target="_blank" rel="noopener">Android自定义WaveView实现波浪进度效果</a><br><a href="https://www.cnblogs.com/itcqx/p/5557273.html" target="_blank" rel="noopener">Android 自定义view实现水波纹效果</a></p>
<p>参考链接：<br><a href="https://www.jianshu.com/p/70e912f21a01" target="_blank" rel="noopener">Canvas和PorterDuffXfermode的秘密</a><br><a href="https://www.jianshu.com/p/d11892bbe055" target="_blank" rel="noopener">各个击破搞明白PorterDuff.Mode</a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>FakeApp使用</title>
    <url>/blog/2019/01/fake-app-use.html</url>
    <content><![CDATA[<p>随着深度学习技术的发展，也逐渐产生了一些有趣的应用，FakeApp即是其中一个，通过较为简单的操作，即可实现视频换脸的效果。</p>
<h3 id="原理简介"><a href="#原理简介" class="headerlink" title="原理简介"></a>原理简介</h3><p>如何把A视频的脸，替换进B视频 ？</p>
<p>分以下几步：</p>
<p>1.收集A,B的脸<br>因为是视频，所以要用一些特殊的技巧，把一个视频，转换成一张张图片，比如10s的视频，可能会有上百张图片，然后在上百张图片里，找出带有人脸的，最终都截取成相同大小的，比如256*256的脸图片</p>
<p>2.训练模型，A-&gt;B<br>有了A的256<em>256脸，和B的256</em>256脸，通过一些特殊的技巧，能找到两张脸之间联系，图片数越多，联系也就越紧，找到关系后，保存成 模型。这个模型的作用就是，给一张A的脸，输入进模型，模型会给出B的脸</p>
<p>3.换脸<br>随便找一个A的视频，依旧是转换成一张张图片，依旧要找出带有人脸的图片。把这一张张图片，丢进第2步得到的模型，就能得出一张张替换成B脸的图片。最后把所有的图片，再合并成视频，换脸完成</p>
<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>1.硬件和操作系统，支持cuda的Nvidia显卡，8G及以上的内存，Windows10 x64（推荐，Windows7 x64亲测可行），可以使用gpu-z查看你的显卡详情<br>2.安装cuda9.0(不是9.1）和对应版本的cudnn,通过CUDA加速可以有效的加快训练速度<br>3.安装python3.6和tensorflow1.5，进入python环境，import tensorflow as tf如果不报错就可以了<br>4.下载并安装Fakeapp2.2.0，官网<a href="https://www.fakeapp.org/" target="_blank" rel="noopener">https://www.fakeapp.org/</a><br>下载后得到FakeApp Setup 2.2.0.exe和core.zip，将core.zip解压到目录C:\Users\usename\AppData\Local\FakeApp\app-2.2.0\resources\api下<br>5.GET DATASET，输入视频路径和fps(视频较长就把fps设置低点，比如填1），使用默认设置（gpu模式）EXTRACT试试，先会把视频按fps拆分，再提取人脸。<br>遇到错时可看Log文件，同时视频分辨率也会影响，，找不到原因时可尝试调低视频分辨率。比如我在1080P下就EXTRACT失败，改成720P才好了<br>6.TRAIN，自建model文件夹，把路径填进去，DATA  A，B填人脸所在路径，修改设置，主要是Batch Size，Nodes，Layers，这些调太高可能 会内存溢出，我的计算机配置太低，分别设置到[16,256,4]才能开始训练，否则一直报错，训练开始会弹出一个新窗口，在这个窗口上按“q”结束训练<br>7.CREATE，能训练了就接着试试生成，model路径，要换脸的视频路径，fps(必须输入）</p>
<p>训练到预览图第三列已经比较清晰了，或者loss降到0.02以下了，一般就可以了。<br>训练一般需要十几个小时，依显卡性能而定。最后的效果则与数据集大小，清晰度，训练时间，两张脸的相似度等相关。</p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://github.com/3c/share/blob/master/&#39;%E6%8D%A2%E8%84%B8&#39;%E5%88%9D%E7%BA%A7%E6%95%99%E7%A8%8B%20%E6%9A%B4%E5%8A%9B%E4%B8%8D%E8%A1%80%E8%85%A5.md" target="_blank" rel="noopener">‘换脸’初级教程</a><br><a href="https://www.cnblogs.com/iJessie/p/8568377.html" target="_blank" rel="noopener">Fakeapp2.2安装，使用简记</a></p>
]]></content>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>多个Android项目依赖公共项目</title>
    <url>/blog/2019/01/common-android-library.html</url>
    <content><![CDATA[<p>在开发过程中，有时需要将公共代码抽取出来，如果变更比较频繁，变化比较多，抽取成maven仓库又不太合适，所以有时可以将代码存放在公共项目中，供多个工程依赖使用。</p>
<h4 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h4><p>将建一个库工程，新建两个Library，library1,librarycomon，其中librry1依赖与librarycomon</p>
<p>在settings.gradle中加入以下文件</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">include <span class="string">':library1'</span></span><br><span class="line">include <span class="string">':librarycomon'</span></span><br><span class="line">project(<span class="string">':library1'</span>).projectDir = <span class="keyword">new</span> File(<span class="string">"../MyProj2Lib"</span>, <span class="string">'library1'</span>)</span><br><span class="line">project(<span class="string">':librarycomon'</span>).projectDir = <span class="keyword">new</span> File(<span class="string">"../MyProj2Lib"</span>, <span class="string">'librarycomon'</span>)</span><br></pre></td></tr></table></figure>
<p>打开MyProj1里面app模块的build.gradle，在dependencies里面增加：</p>
<p>api project(‘:library1’)</p>
<p>由此实现MyProj1编译MyProj2Lib中的库模块。</p>
<p> MyProj1不仅引用了library1，也引用了librarycommon.</p>
<p>此刻完成了库模块的跨项目工程引用。</p>
<p>详情可见：<a href="https://blog.csdn.net/max2005/article/details/52480187" target="_blank" rel="noopener">https://blog.csdn.net/max2005/article/details/52480187</a></p>
<h4 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h4><p>1、新建一个library工程，叫MyLibrary(注意是工程，不是Stuio里面的Module),再新建一个library，比如叫base（放置基础工具类）。</p>
<p>2、新建一个我们正常的工程，叫MyTest（与MyLibrary工程在同一目录下），在根目录下的settings.gradle文件添加</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">include <span class="string">':MyLibrary'</span></span><br><span class="line">project(<span class="string">':MyLibrary'</span>).projectDir = <span class="keyword">new</span> File(<span class="string">'../MyLibrary'</span>)</span><br><span class="line">include <span class="string">':MyLibrary:base'</span></span><br></pre></td></tr></table></figure>
<p>3、在MyTest中要使用library的module中的build.gradle文件中添加引用：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">implementation project(<span class="string">':MyLibrary:base'</span>)</span><br></pre></td></tr></table></figure>
<p>至此多个工程引用同一个lib的方法就基本完成，配置好后sync下，然后项目中就会新增MyLibrary项目。</p>
<p>上面的写法有一个问题，MyLibrary的module不能互相依赖，比如aaa依赖base，解决方法如下：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">compile project(project.path.replace(project.name, <span class="string">''</span>) + <span class="string">':base'</span>)</span><br></pre></td></tr></table></figure>
<p>详情可见：</p>
<p><a href="https://blog.csdn.net/yu75567218/article/details/79528257" target="_blank" rel="noopener">https://blog.csdn.net/yu75567218/article/details/79528257</a></p>
<p><a href="https://blog.csdn.net/yu75567218/article/details/79482203" target="_blank" rel="noopener">https://blog.csdn.net/yu75567218/article/details/79482203</a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>https与中间人劫持</title>
    <url>/blog/2019/09/https-certificate-learn.html</url>
    <content><![CDATA[<h4 id="https三次握手"><a href="#https三次握手" class="headerlink" title="https三次握手"></a>https三次握手</h4><ol>
<li>HTTPS要完成的任务：</li>
</ol>
<blockquote>
<p>1.Client必须要能确定，它要访问的Server确实是正确的Server<br>2.Client和Server交流的信息不能被其它第三方窃听<br>3.当然，针对第1点，反过来，Server也可以要求，必须确认Client是它想通信的正确的Client，不过道理和1一样，这里不展开</p>
</blockquote>
<ol start="2">
<li>通过HTTPS握手建立加密信道来保证上述要求</li>
</ol>
<p>三次握手过程如下：</p>
<p><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/bog2/p1.PNG" alt="p1"></p>
<p>看了上述三次握手过程，可以知道，handshake主要完成的事情：</p>
<blockquote>
<p>1.客户端&amp;服务端通信，协商加密方式<br>2.客户端(Client)和服务端(Server)互相确认身份<br>3.双方安全地交换https通信使用的密钥（Session Key）</p>
</blockquote>
<h5 id="1-第一阶段：C-amp-S协商加密方式"><a href="#1-第一阶段：C-amp-S协商加密方式" class="headerlink" title="1. 第一阶段：C&amp;S协商加密方式"></a>1. 第一阶段：C&amp;S协商加密方式</h5><p>客户端向服务端发送ClientHello信息，信息主要包括客户端支持的加密方式、客户端支持的SSL版本等；服务端接收到ClientHello信息后，向客户端发送一个ServerHello信息，主要是告诉客户端它将使用什么加密方式和SSL版本。</p>
<h5 id="2-第二阶段：身份校验"><a href="#2-第二阶段：身份校验" class="headerlink" title="2. 第二阶段：身份校验"></a>2. 第二阶段：身份校验</h5><p>阶段2主要是，客户端&amp;服务端互相校验对方身份</p>
<p>客户端与服务端之间验证身份是通过证书完成的</p>
<p>1.关于证书：</p>
<p>服务端向客户端下发自己的证书，通常是CA认证的证书。证书包括了很多信息，主要有“公钥信息”、“签名”、“组织机构地区等信息”、“证书颁发机构”，关联的中级证书(medium certificate)、根证书(root certificate)等。</p>
<p>X.509 应该是比较流行的 SSL 数字证书标准，包含（但不限于）以下的字段：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>值说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>对象名称（Subject Name）</td>
<td>用于识别该数字证书的信息</td>
</tr>
<tr>
<td>共有名称（Common Name）</td>
<td>对于客户证书，通常是相应的域名</td>
</tr>
<tr>
<td>证书颁发者（Issuer Name）</td>
<td>发布并签署该证书的实体的信息</td>
</tr>
<tr>
<td>签名算法（Signature Algorithm）</td>
<td>签名所使用的算法</td>
</tr>
<tr>
<td>序列号（Serial Number）</td>
<td>数字证书机构（Certificate Authority， CA）给证书的唯一整数，一个数字证书一个序列号</td>
</tr>
<tr>
<td>生效期（Not Valid Before）</td>
<td>(｀・ω・´)</td>
</tr>
<tr>
<td>失效期（Not Valid After）</td>
<td>(╯°口°)╯(┴—┴</td>
</tr>
<tr>
<td>公钥（Public Key）</td>
<td>可公开的密钥</td>
</tr>
<tr>
<td>签名（Signature）</td>
<td>通过签名算法计算证书内容后得到的数据，用于验证证书是否被篡改</td>
</tr>
</tbody>
</table>
<p><strong>主要就是签名，用于验证是否篡改过</strong></p>
<p>2.客户端如何通过证书确定服务端的身份？</p>
<p>证明下面两点，（然后才可以使用证书上的公钥来加密生成Session key的随机数）</p>
<blockquote>
<ol>
<li>证明baidu.com这个证书确实是百度的</li>
<li>证明baidu.com这个证书没有被其他人攥改过</li>
</ol>
</blockquote>
<p>证书以证书链的形式组织，在颁发证书的时候首先要有根CA机构颁发的根证书，再由根CA机构颁发一个中级CA机构的证书，最后由中级CA机构颁发具体的SSL证书。</p>
<p>数字证书采用信任链验证。数字证书的信任锚（信任的起点）就是根证书颁发机构。根证书（root certificate）是一个无签名或自签名的证书。是用于识别根证书颁发机构（CA）的公钥证书。</p>
<p>验证的具体实现如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/bog2/p4.PNG" alt="p3"></p>
<ol>
<li>从左往右，用户证书指向签署它的中级证书，并且，用户证书的摘要经由中级证书的私钥加密，密文作为该用户的证书签名(signature)记录在用户证书上。</li>
<li>中级证书相应的，指向签署它的根证书，同时，中级证书的摘要经由根证书的私钥加密，密文作为中级证书的签名记录在中级证书上</li>
<li>根证书在签署的时候，使用签发机构的私钥对证书的摘要进行加密，密文作为根证书的签名记录在根证书上。</li>
</ol>
<p><strong>如何验证证书</strong></p>
<p>1.如何验证证书没有被篡改过</p>
<p>比如验证用户证书A，需要用到中级证书的公钥B解密前者的签名得到摘要 Digest1，我们的客户端也计算A证书的内容得到摘要 Digest2。对比这两个摘要就能知道前者是否被篡改。后者同理，使用他的证书签发者提供的公钥验证。当验证到<strong>到受信任的根证书</strong>时，就能确定这个证书是可信的。</p>
<p>2.为什么根证书是可信的</p>
<p>数字证书认证机构（Certificate Authority, CA）签署和管理的 <strong>CA 根证书</strong>，会被纳入到你的浏览器和操作系统的可信证书列表中，并由这个列表判断根证书是否可信。所以不要随便导入奇奇怪怪的根证书到你的操作系统中。</p>
<h5 id="3-第三阶段：产生通信密钥"><a href="#3-第三阶段：产生通信密钥" class="headerlink" title="3. 第三阶段：产生通信密钥"></a>3. 第三阶段：产生通信密钥</h5><p>前面讲过，第1阶段，服务端告知了客户端后面要使用的加密方式（普遍都是对称加密，因为非对称加密成本太高，速度低下）。</p>
<p>第2阶段，客户端验证服务端证书是正确的，即，证书上标明的公钥拿来加密信息，加密后的信息，只有该服务端能解密，其它第三方无法解密。<br>那么在第三阶段，客户端产生了第三个随机数，这个随机数称为PMSc（a premaster secret，46 bytes ），使用服务端的公钥对PMSc加密，然后上送给服务端。服务端取到这个密文后，用自己的私钥解密，得到PMSc。</p>
<p>好了，接下来最重要的一步来了：根据之前协商好的加密方式，以及3个随机数，客户端、服务端各自产生出通信密钥，该密钥称为Master Secret，简称MS，也称Session Key。这个密钥虽然是各自产生的，但是产生后是一致的。</p>
<h5 id="4-加密信道已经建立"><a href="#4-加密信道已经建立" class="headerlink" title="4. 加密信道已经建立"></a>4. 加密信道已经建立</h5><p>客户端，服务端各自产生了通信密钥后，就用这个相同的MS对往后的所有通信信息进行加密。而这个密钥，第三方是不知道的，第三方尽管去窥探，但是他们看不懂信息，所以效果相当于，客户端&amp;服务端在一个加密信道中通信。</p>
<p>从上面可以看出，https通信过程是<strong>对称与非对称加密混合的</strong></p>
<h4 id="中间人攻击与https抓包"><a href="#中间人攻击与https抓包" class="headerlink" title="中间人攻击与https抓包"></a>中间人攻击与https抓包</h4><p>一个针对SSL的中间人攻击过程如下：</p>
<p><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/bog2/p3.png" alt="p4"></p>
<p>中间人其实是做了一个偷梁换柱的动作，核心是如何欺骗客户端，从而让客户端能够放心的与中间人进行数据交互而没有任何察觉。我们来看Charles如何做到HTTPS抓包的，网上有很多fiddlers如何抓HTTPS包的教程，几步就搞定了，其中最核心的就是：</p>
<blockquote>
<p>将私有CA签发的数字证书安装到手机中并且作为受信任证书保存</p>
</blockquote>
<p>当私有的CA证书添加到系统信任证书后，就可以完成证书链验证过程</p>
<p>fiddler抓包过程，详情可见：<a href="https://www.cnblogs.com/afeng2010/p/10073446.html" target="_blank" rel="noopener">https://www.cnblogs.com/afeng2010/p/10073446.html</a></p>
<h5 id="android7-0之后用户CA限制"><a href="#android7-0之后用户CA限制" class="headerlink" title="android7.0之后用户CA限制"></a>android7.0之后用户CA限制</h5><p>Android从7.0开始系统不再信任用户CA证书（应用targetSdkVersion &gt;= 24时生效，如果targetSdkVersion &lt; 24即使系统是7.0+依然会信任）。也就是说即使安装了用户CA证书，在Android 7.0+的机器上，targetSdkVersion &gt;= 24的应用的HTTPS包就抓不到了。</p>
<p>Android 6.0（API 23）及更低版本应用的默认网络安全性配置如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 默认允许所有明文通信 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">base-config</span> <span class="attr">cleartextTrafficPermitted</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">trust-anchors</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 信任系统预装 CA 证书 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">certificates</span> <span class="attr">src</span>=<span class="string">"system"</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 信任用户添加的 CA 证书，Charles 和 Fiddler 抓包工具安装的证书属于此类 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">certificates</span> <span class="attr">src</span>=<span class="string">"user"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">trust-anchors</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">base-config</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>而在 Android 7.0（API 24）到 Android 8.1（API 27）的默认网络安全性配置如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 默认允许所有明文通信 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">base-config</span> <span class="attr">cleartextTrafficPermitted</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">trust-anchors</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 信任系统预装 CA 证书 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">certificates</span> <span class="attr">src</span>=<span class="string">"system"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">trust-anchors</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">base-config</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>而在 Android 9.0（API 28）及更高版本的默认网络安全性配置如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 默认禁止所有明文通信 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">base-config</span> <span class="attr">cleartextTrafficPermitted</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">trust-anchors</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 信任系统预装 CA 证书 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">certificates</span> <span class="attr">src</span>=<span class="string">"system"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">trust-anchors</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">base-config</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果我们要抓自已APP的包，解决方式就是使用 Android 6.0 以下的网络安全性配置：</p>
<p>添加<code>res/xml/network_security_config.xml</code>:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">network-security-config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">base-config</span> <span class="attr">cleartextTrafficPermitted</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">trust-anchors</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">certificates</span> <span class="attr">src</span>=<span class="string">"system"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">certificates</span> <span class="attr">src</span>=<span class="string">"user"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">trust-anchors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">base-config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">network-security-config</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后在清单文件中指向该文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">...</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span> <span class="attr">android:networkSecurityConfig</span>=<span class="string">"@xml/network_security_config"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">...</span> &gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="连接公共WIFI访问HTTPS站点，是否安全？"><a href="#连接公共WIFI访问HTTPS站点，是否安全？" class="headerlink" title="连接公共WIFI访问HTTPS站点，是否安全？"></a>连接公共WIFI访问HTTPS站点，是否安全？</h4><p>假设你的设备没有安装信任过来历不明的证书，那么不管在任何WIFI或者网络环境下，通常HTTPS通信都是安全的。<br>1）. 假设该开放网络偷偷作为中间人，拦截HTTPS握手，下发一个它自己签发的假证书，这种情况下，由于该证书无法被设备的证书信任链校验通过，HTTPS链接建立失败，浏览器会有一个明显的错误提示页面，提示用户证书不被信任。<br>2）. 假设该开放网络作为中间人，拦截HTTPS握手，下发一个合法的CA证书，这个时候，客户端校验通过，建立HTTPS链接，但是由于在协商生成Session Key的过程，PMSc使用了证书的公钥进行加密，这意味着只有那个合法的CA证书拥有者才有私钥可以解密，中间人无法解密。所以中间人无法识别到HTTPS的通信内容。</p>
<p>3).根据第2点的思路，假设中间人下发的也是一个合法的CA证书，但是这个证书是中间人自己的，因此中间人知道这个证书的私钥！这种情况下，意味着一旦建立了HTTPS链接，通信内容完全可以被窥视</p>
<p>是否能正确建立HTTPS链接，完全取决于设备如何验证证书，比如我们的设备准备和<a href="https://www.baidu.com/" target="_blank" rel="noopener">https://www.baidu.com</a>通信，在握手阶段，被第三方拦截，第三方下发了一个合法CA给设备，设备如果在校验的过程中，既校验的信任链，又从证书中取出域名做校验、取出CA证书拥有者的信息做校验，那么就可以辨别这个证书不是baidu的！因为第三方的CA证书虽然也是CA颁发，但是CA在颁发时已经确认过该机构的信息以及域名等写到证书上了</p>
<p>所以有时不仅需要校验证书链，域名校验也是很有必要的。</p>
<h4 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h4><p><a href="https://www.zybuluo.com/blueGhost/note/805491" target="_blank" rel="noopener">HTTPS系列1——HTTPS三次握手</a></p>
<p><a href="https://www.cnblogs.com/oc-bowen/p/5896041.html" target="_blank" rel="noopener">iOS 中对 HTTPS 证书链的验证</a></p>
<p><a href="https://juejin.im/post/5cc313755188252d6f11b463#heading-8" target="_blank" rel="noopener">Android平台HTTPS抓包解决方案及问题分析</a></p>
<p><a href="https://juejin.im/post/5b8642f851882542f32799d8" target="_blank" rel="noopener">HTTPS原理及OKHTTP对HTTPS的支持</a></p>
<p><a href="https://www.jianshu.com/p/1dd77e56cc3c" target="_blank" rel="noopener">Android中Https请求如何防止中间人攻击和Charles抓包原理</a></p>
<p><a href="https://www.cnblogs.com/leegent/p/8144425.html" target="_blank" rel="noopener">HTTPS、证书与使用Charles抓包</a></p>
<p><a href="https://johnnyshieh.me/posts/android-7-capture-https-package/" target="_blank" rel="noopener">Android 7.0 以上 Charles 和 Fiddler 无法抓取 HTTPS 包的解决方式</a></p>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>kotlin与lambda表达式</title>
    <url>/blog/2020/03/kotlin-inline-learn.html</url>
    <content><![CDATA[<h4 id="inline-noline-accrolines区别"><a href="#inline-noline-accrolines区别" class="headerlink" title="inline noline accrolines区别"></a>inline noline accrolines区别</h4><h5 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h5><p><code>inline</code> 就是我们常说的内联。这个关键字会在编译期间起作用。如果一个函数是 <code>inline</code> 的，那么编译器会在编译的时候，把这个函数复制到调用处</p>
<p>具体优势如下：</p>
<p>1.会减少函数调用的次数，减少开销</p>
<p>2.会减少对象的生成</p>
<p>缺点</p>
<p>1.对于一个 <code>public</code> 的 <code>inline</code> 方法，他不可以引用类的私有变量</p>
<p>2.inline 方法会对流程造成非常隐晦的影响 （return）</p>
<h5 id="noinline"><a href="#noinline" class="headerlink" title="noinline"></a>noinline</h5><p><code>noinline</code> 修饰的是 <code>inline</code> 方法中的 <code>lambda</code> 参数。<code>noinline</code> 用于我们不想让 <code>inline</code> 特性作用到 <code>inline</code> 方法的某些 <code>lambda</code> 参数上的场景</p>
<h5 id="crossinline"><a href="#crossinline" class="headerlink" title="crossinline"></a>crossinline</h5><p>是不是有了 <code>inline</code> 和 <code>noinline</code>，对于我们开发人员来讲就够了呢？就满足了呢？显然不是的。考虑一种情况，我们既想让 <code>lambda</code> 也被 <code>inline</code>，但是又不想让 <code>lambda</code> 对调用方的控制流程产生影响。这个产生影响，可以是有意识的主动控制，但是大多数情况下是开发人员的不小心导致的。我们知道 java 语言是一个编译型语言，如果能在编译期间对这种 <code>inline</code> <code>lambda</code> 对调用方产生控制流程影响的地方进行提示甚至报错，就万无一失了。</p>
<p>crossinline<code>就是为了处理这种情况而产生的。</code>crossinline<code>保留了</code>inline<code>特性，但是如果想在传入的</code>lambda<code>里面</code>return<code>的话，就会报错。</code>return<code>只能</code>return<code>当前的这个</code>lambda</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p><code>inline</code> 关键字的作用，是把 <code>inline</code> 方法以及方法中的 <code>lambda</code> 参数在编译期间复制到调用方，进而减少函数调用以及对象生成。对于有时候我们不想让 <code>inline</code> 关键字对 <code>lambda</code> 参数产生影响，可以使用 <code>noline</code> 关键字。如果想 <code>lambda</code> 也被 <code>inline</code>，但是不影响调用方的控制流程，那么就要是用 <code>crossinline</code>。</p>
<p>详情参见：<a href="https://www.jianshu.com/p/cd0be9b887ec" target="_blank" rel="noopener">https://www.jianshu.com/p/cd0be9b887ec</a></p>
<h4 id="kotlin中的lambda表达式优化"><a href="#kotlin中的lambda表达式优化" class="headerlink" title="kotlin中的lambda表达式优化"></a>kotlin中的lambda表达式优化</h4><p>Java8之后，我们将只有单一方法的接口称为SAM（Single Abstract Method）接口，Java8通过Lambda可以大大简化对于SAM接口的调用,最典型的就是setOnClickListener方法,通过lambda表达式可以大幅简化调用</p>
<p>但是目前kotlin只支持java中的SameType,Kotlin中的SamType无法转化为lambda，<strong>因为kotlin鼓励开发者多尝试用函数式编程的思想替换面向对象的思维方式，所以推荐使用函数类型替代SamType</strong>。</p>
<p>具说在kotlin1.4中这一问题会得到解决。但目前只能通过一些替代方案实现SAM转换</p>
<p>使用typealias实现</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typealias</span> KotlinFunctionAlias = (Item) -&gt; String</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">delegateAliasWork</span><span class="params">(f: <span class="type">KotlinFunctionAlias</span>)</span></span>: String &#123;</span><br><span class="line">  <span class="keyword">return</span> f.invoke(item)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">delegateAliasWork &#123; <span class="string">"Print <span class="variable">$it</span>"</span> &#125;</span><br></pre></td></tr></table></figure>
<p>当然使用以上方法也有一个风险</p>
<p>当有多个同类型的typealias时，是无法保证类型安全的</p>
<p>使用typealias可以实现lambda表达式代替object的效果</p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>读《曾国藩传》</title>
    <url>/blog/2019/08/read-zen-guo-pan.html</url>
    <content><![CDATA[<blockquote>
<p>然而文正固非有超群绝伦之天才，在并时诸贤杰中，称最钝拙；其所遭值事会，  亦终身在拂逆之中；然乃立德、立功、立言，三不朽，所成就震古铄今而莫与京者，其一生得力在立志自拔于流俗，而困而知，而勉而行，历百千艰阻而不挫屈，不求近效，铢积寸累，受之以虚，将之以勤，植之以刚，贞之以恒，帅之以诚，勇猛精进，坚苦卓绝，如斯而已，如斯而已。</p>
</blockquote>
<p>&emsp;&emsp;想起曾国藩，往往想起了机场成功学，想起了曾国藩家书，想起了喜欢写日记，想要做圣人的曾国藩，想起了小偷在曾国藩家房梁上听他背书，然后比他还先背熟的段子。其实如果我们看看曾国藩的科举之路，可以发现曾国藩虽然考秀才连续考了七次才考上，而考举人时却一考即中，然后在尝试了两次之后，在二十八岁中了进士，比中进士的平均年龄低了十岁。要知道在清朝一代，进士占总人口的比例大概为百万分之零点四八，由此可见，网络上那些描写曾国藩钝拙的段子，大概是站不住脚的。只能说，比起李鸿章，胡林翼，梁启超这些少年天才来说，曾国藩的确没有那么有才气，但是能够在万千举子从脱颖而出，也绝不是什么钝拙之人吧。</p>
<p>&emsp;&emsp;曾国藩家书也算是新时代的畅销书了，不过有趣的是，如果我们翻开曾氏家族的家谱，一直翻到朝，不但找不到做官的人，连读书人都没有一个。曾国藩曾说，吾曾氏由衡阳到湘乡，五六百载，曾无人与于科目秀才之列。五六百年间，连一个秀才也没有出过，这个家族也可以说是平平无奇了。曾国藩的爷爷是开始改变这个家族的人，下定决心非要供自己的孩子读书当官，于是老曾家开始了科举之路。开始时，老曾家的科举之路的确比较艰辛，曾国藩的父亲连考了十七次才考上了秀才，成为曾氏家族有史以来第一个秀才，曾国藩的叔叔一辈子都是一个老童生，曾国藩的几个弟弟，也一个个很早就开始读书，结果也没有一个能中举人。只有曾国藩在六次挫败之后，连中举人进士，的确是挺不容易的了。但是自从曾国藩发迹之后，我们可以看到曾氏家族仿佛基因变异了，曾国藩家族在200年间，子孙之杰出者240余人，后人中很多留学欧美或日本等国，取得博士、硕士学位或获得院士、教授、研究员职，在外交，数学，化学化工，文化艺术，军政与实业等方面都取得了相当的成就。如果曾氏家族曾经有什么钝拙的基因的话，后来肯定变异掉了，其实从前面的五六百载平平无奇，到后面的两百年人才辈出，恐怕有什么比基因更重要的因素影响了吧，不是吗？其实比较曾国藩家书来说，或许曾国藩他爷爷的家书对普罗大众来说更有用。</p>
<p>&emsp;&emsp;曾国藩还有一个特点，就是立志做圣人，喜欢写日记，勤勉而又能持之以恒，直到生命的末尾，数十年如一日，始终如一的写日记，的确是超出常人许多许多，令人佩服，毕竟坚持是这个世界最难的事之一，不是吗？曾国藩不仅写日记，还把自己的日记给朋友看，因为外力的作用远远大于内力，事必有所激有所逼才能有所成，每个人的意志力是有限的。但是人都有自尊心，而通过朋友，老师监督自己往往更有效，这大概跟现在朋友圈打卡的原理一样吧，估计曾国藩如果生在现在，可能每天都会发条打卡的朋友圈，哈哈。</p>
<center><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog/p9.jpg" width="400px" height="400px" align="center"></center>

<p>&emsp;&emsp;曾国藩说，不为圣贤，便为禽兽。三十岁是曾国藩最重要的人生分水岭，他立下了学做圣人的志向并用他的后半生踏踏实实的完成。从立志之日起，就每天做日课，写日记，以圣人的标准监督自己每天的一举一动，并记载下来，深刻反省，完成从庸人到圣人的跳跃。一个人，到三十岁了，还能有这样一个梦想，真的牛逼，曾国藩简直是个燃烧自己的人，充满了生命力。不过调门起的太高容易让人失望，人设立得太好容易反噬，毕竟圣人不容易在这个世界生存，更何况你还要做官，还要做事。在曾国藩被同治皇帝打压，退隐两年后重新复出后，便发生了明显的变化。以前他做事直来直去，不太讲求虚文俗套，现在则和那些庸官俗吏一样注意礼仪排场，总不能众人皆醉我独醒，那样如何在官场生存呢；他对皇帝，也不再那么直言不讳，而是学会了打太极，逐渐赢回了皇帝的信任；第三，他也不再慎于保举，而是开始随大流了，曾国藩原以为忠诚为天下倡，以为仅凭忠义相激，就可以让部下出生入死，但阅历即久，也意识到没有保举而金钱，难以网罗天下英才。再加上曾国藩在南京等地的屠杀，劫掠，杀降问题，曾国藩说，四十年来，当杀未杀之人，满坑满谷。其实比较起来，曾国藩肯定是晚清那些重臣中，最干净的一个，虽然后期开始变得随大流圆融，但是个人也是比较清廉，主要是为了与官场交际与沟通，至于对待太平军的问题，那大概是立场问题，对于曾国藩来说，对于儒教来说，太平军皆是当杀未杀之人。只不过世道已经到了‘不假不成’的地步，对于立志做圣人的曾国藩来说还是比较尴尬的。</p>
<p>&emsp;&emsp;毛泽东说，曾国藩是地主阶级最厉害的人。儒家讲求，立功，立德，立言，曾国藩全都做到了，仿佛儒家精神世界崩溃前夜的回光返照，集中在曾国藩身上，在风雨飘摇的末世做一次告别演出式的呈现，绚烂而又凄婉。他从一介书生起家，创建军队，统率群雄，挽狂澜于既倒，扶大厦于将倾，使自己珍视的文化免遭彻底毁灭的命运，使清王朝的生命又延续了六十年。就私德而言，他时时以圣贤标准要求自己，道德修养近乎纯粹，实事求是，经世致用，反身而诚，数十年来，始终如一，成为了儒家最后一个精神偶像。</p>
<p>&emsp;&emsp;当然，曾国藩的一生从一定意义上说也是失败的。他是逐日的夸父、填海的精卫、补天的女娲。然而在垂暮之年，他猛然发现自己一生的奋斗，最后竟然如拔刀斫水，并不能丝毫影响水之东流。他以圣贤自期，然而他遵循圣人之道一丝不苟地苦学苦修，却并没有达到“为天地立心，为生民立命，为往圣继绝学，为万世开太平”的理想。他以一人之力，无法挽回传统社会积千百年形成的强大颓势。他没有能探悟到拯救旧世界的真理，没能实现自己澄清天下造福万民，创造一个以儒家学说为指针的太平世界的理想。相反，他眼看着神州不断陆沉，自己却无能为力。</p>
<p>&emsp;&emsp;当然这不是他一个人的失败，这是整个国家，整个社会，整个民族的失败。不论如何，曾国藩用一生捍卫、守护了自己珍视的文化和信仰，他死在了补天填海的路上。曾国藩用自己的一生，证明了人的意志力所能达到的高度，同时，也证明了一个人意志力的局限。他无望的努力在人类精神征途上，树起了一座令人不得不肃然起敬的丰碑。最后用曾国藩的一幅著名的对联结尾吧。</p>
<blockquote>
<p>倚天照海花无数，流水高山心自知。</p>
</blockquote>
]]></content>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>kotlin协程简介</title>
    <url>/blog/2019/09/kotlin-coroutine.html</url>
    <content><![CDATA[<p>先看官方文档的定义 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">协程通过将复杂性放入库来简化异步编程。程序的逻辑可以在协程中顺序地表达，而底层库会为我们解决其异步性。该库可以将用户代码的相关部分包装为回调、订阅相关事件、在不同线程（甚至不同机器）上调度执行，而代码则保持如同顺序执行一样简单。</span><br></pre></td></tr></table></figure>
<p>协程的开发人员 Roman Elizarov 是这样描述协程的：<strong>协程就像非常轻量级的线程</strong>。线程是由系统调度的，线程切换或线程阻塞的开销都比较大。而协程依赖于线程，但是协程挂起时不需要阻塞线程，几乎是无代价的，协程是由开发者控制的。所以<strong>协程也像用户态的线程</strong>，非常轻量级，一个线程中可以创建任意个协程。</p>
<p>总而言之：协程可以简化异步编程，可以顺序地表达程序，协程也提供了一种避免阻塞线程并用更廉价、更可控的操作替代线程阻塞的方法 – 协程挂起。</p>
<p>关于协程，线程，进程的区别具体可参见：<a href="https://www.sohu.com/a/236536167_684445" target="_blank" rel="noopener">https://www.sohu.com/a/236536167_684445</a></p>
<h4 id="协程的优势"><a href="#协程的优势" class="headerlink" title="协程的优势"></a>协程的优势</h4><p>使用协程可以提高线程的利用率</p>
<p>当我们进行耗时操作时，常常使用线程，我们在线程执行过程中经常会遇到因磁盘IO或者是网络请求等操作而导致线程阻塞，而此时当前线程只能阻塞等待，无法做任何事情，在等待的这段时间里线程相当于白白了浪费了自身资源，导致线程自身利用率低下。</p>
<p><strong>协程可以最大程度的复用线程，通过让线程满载运行，从而达到充分的利用CPU提高系统性能</strong></p>
<p>同时协程可以用同步方式写异步代码，使用协程后的代码非常简洁，以顺序的方式书写异步代码，不会阻塞当前 UI 线程，错误处理也和平常代码一样简单。</p>
<p>具体描述可参见：<a href="https://blog.csdn.net/huyongl1989/article/details/89287132" target="_blank" rel="noopener">https://blog.csdn.net/huyongl1989/article/details/89287132</a></p>
<h4 id="kotlin协程的一些关键字"><a href="#kotlin协程的一些关键字" class="headerlink" title="kotlin协程的一些关键字"></a>kotlin协程的一些关键字</h4><p>kotlin协程的语法具体可以上官方文档学习：<a href="https://www.kotlincn.net/docs/reference/coroutines-overview.html" target="_blank" rel="noopener">https://www.kotlincn.net/docs/reference/coroutines-overview.html</a></p>
<p>这里只列举一些最常见的用法</p>
<h5 id="CoroutineScope"><a href="#CoroutineScope" class="headerlink" title="CoroutineScope"></a>CoroutineScope</h5><p>什么是CoroutineScope?<br>CoroutineScope可以理解为协程的<code>作用域</code>，可以管理其域内的所有协程。一个CoroutineScope可以有许多的子scope</p>
<p>创建子scope的方式有许多种，常见的有：</p>
<ul>
<li>使用lauch, async 等builder创建一个新的子协程。协程(AbstractCoroutine)继承了 CoroutineScope，从父scope中继承了协程上下文(见下文CoroutineContext) 以及Job</li>
<li>使用coroutineScope Api创建新scope,注意这个方法只有在所有 block中创建的子协程全部执行完毕后，才会退出</li>
</ul>
<h5 id="CoroutineContext"><a href="#CoroutineContext" class="headerlink" title="CoroutineContext"></a>CoroutineContext</h5><p>协程上下文，包含了协程中的一些元素，主要有<code>Job</code>和<code>CoroutineDispatcher</code></p>
<h5 id="Job"><a href="#Job" class="headerlink" title="Job"></a>Job</h5><p>协程的后台任务，它有自己的生命周期，该任务可以被取消。</p>
<p><code>Job</code>可以有父<code>Job</code>，当父<code>Job</code>被取消时，其所有子<code>Job</code>也会被取消。</p>
<p><code>Job</code>有三种状态:</p>
<ol>
<li><code>isActive</code> 是否处于活动状态</li>
<li><code>isCompleted</code> 是否完成</li>
<li><code>isCancelled</code> 是否被取消</li>
</ol>
<h5 id="Deferred"><a href="#Deferred" class="headerlink" title="Deferred"></a>Deferred</h5><p>它是Job的子类，与Job不同的是它可以有返回值，而Job是没有返回值的。</p>
<p>通过调用Deferred的await()方法即可拿到返回值，而await()方法也是一个挂起函数，因此调用该方法时会挂起当前协程，直到拿到返回值协程重新恢复执行。</p>
<p>Android中协程结合Retrofit发起网络请求可以考虑使用该类获取请求结果</p>
<h5 id="CoroutineDispatcher"><a href="#CoroutineDispatcher" class="headerlink" title="CoroutineDispatcher"></a>CoroutineDispatcher</h5><p>协程调度器，它可以将协程的执行局限在指定的线程中，它有四个默认的实现：</p>
<ul>
<li>Dispatchers.Default 默认调度器，在使用launch和async等协程构造器创建协程时，如果不指定调度器则会使用此默认调度器，该调度器会让协程在JVM提供的共享线程池中执行</li>
<li>Dispatchers.Main 主线程调度器，让协程在主线程即UI线程中执行</li>
<li>Dispatchers.IO 让协程在IO线程(子线程)中执行，该调度器会与Dispatchers.Default调度器共享同一个线程池</li>
<li>Dispatchers.Unconfined 该调度器不指定协程在某个线程中执行。设置了该调度器的协程会在调用者线程中启动执行直到第一个挂起点，挂起后，它将在挂起函数执行的线程中恢复，恢复的线程完全取决于该挂起函数在哪个线程执行。</li>
<li>newSingleThreadContext 这是Kotlin另外提供的一个调度器，它会为协程启动一个新的线程。一个专用的线程是一种非常昂贵的资源。 在真实的应用程序中两者都必须被释放，当不再需要的时候，使用 close 函数，或存储在一个顶级变量中使它在整个应用程序中被重用。</li>
</ul>
<p>另外需要注意的是：协程调度器默认承袭外部协程的调度器</p>
<h5 id="GlobalScope"><a href="#GlobalScope" class="headerlink" title="GlobalScope"></a>GlobalScope</h5><p>这是一个全局的<code>CoroutineScope</code>不会受任何Job约束，通过它创建的是全局协程</p>
<p>一般应用级别的协程才使用GlobalScope</p>
<h5 id="withContext"><a href="#withContext" class="headerlink" title="withContext"></a>withContext</h5><p>切换协程上下文，一般主要用来切换协程所在的线程环境，如从主线程切换到IO线程。</p>
<p>调用该方法不会创建新的协程，同时是一个挂起函数</p>
<p>该方法会有一个返回值，其返回值为<code>withContext</code>中lambda表达式的返回值</p>
<h4 id="kotlin协程的三种启动方式"><a href="#kotlin协程的三种启动方式" class="headerlink" title="kotlin协程的三种启动方式"></a>kotlin协程的三种启动方式</h4><p>1.runBlocking:</p>
<p>2.launch:Job</p>
<p>3.async/await:Deferred</p>
<h5 id="launch"><a href="#launch" class="headerlink" title="launch"></a>launch</h5><p>这是一个扩展的<code>CoroutineScope</code>实例方法，同时也是一个很常用的协程构建器。</p>
<p>通过其默认参数会创建一个不会阻塞当前线程且会立即执行的协程，该方法会返回一个<code>Job</code>对象，该方法默认承袭所在的<code>CoroutineScope</code>对象的调度器。</p>
<h5 id="runBlocking"><a href="#runBlocking" class="headerlink" title="runBlocking"></a>runBlocking</h5><p>这是一个全局的协程构建器，可以在任何地方调用。</p>
<p>该构建器会创建一个阻塞当前线程的协程，所以该构建器不建议使用在协程内</p>
<h5 id="async"><a href="#async" class="headerlink" title="async"></a>async</h5><p>和<code>launch</code>函数一样，也是<code>CoroutineScope</code>的扩展实例方法，它也是一个常用的协程构建器，不同是它创建协程时返回的是<code>Deferred</code>,通过<code>Deferred</code>可以拿到执行结果</p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>协程取代rxjava</title>
    <url>/blog/2019/09/coroutine-replace-rxjava.html</url>
    <content><![CDATA[<p>现在的Android项目普遍使用Retrofit+RxJava的组合实现网络接口请求与数据的展现。这一功能通过Kotlin语言的协程功能也可以很方便的实现。</p>
<p>相比较而言，RxJava功能过于强大，如果仅用于封装网络请求，有些杀鸡用牛刀的感觉。使用Kotlin的协程实现这个需求代码更精简，逻辑也更清晰</p>
<h4 id="协程相对RxJava有什么优点呢"><a href="#协程相对RxJava有什么优点呢" class="headerlink" title="协程相对RxJava有什么优点呢"></a>协程相对RxJava有什么优点呢</h4><p>(1)RxJava堆栈可读性查，一旦出现问题，堆栈信息爆炸，难以定位问题，而协程就可以避免这个问题</p>
<p>(2)协程用同步的方式写异步的代码，美好了生活，方便代码阅读。</p>
<p>(3)协程学习曲线比较平坦，相对于RxJava，协程对初学者更易于学习。</p>
<p>关于协程相对于线程的优势，具体可见：<a href="https://www.jianshu.com/p/b359ce3a8f2e" target="_blank" rel="noopener">https://www.jianshu.com/p/b359ce3a8f2e</a></p>
<p>所以我们在android开发中可以尝试在一部分场景中使用协程取代rxjava</p>
<h5 id="协程与retrofit结合"><a href="#协程与retrofit结合" class="headerlink" title="协程与retrofit结合"></a>协程与retrofit结合</h5><p>通过自定义实现CallAdapterFactory，将api定义时的结果Call直接转换成Deferred，然后通过Deferred.await获取请求结果，这种写法是写法一写法二的结合。</p>
<p>这种写法JakeWharton大神早已为我们实现了,通过retrofit2-kotlin-coroutines-adapter可轻松实现</p>
<p>需要在构建retrofit的时候addCallAdapterFactory(CoroutineCallAdapterFactory())</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CallAdapterApiService</span> </span>&#123;</span><br><span class="line">        <span class="meta">@GET(<span class="meta-string">"data/iOS/2/1"</span>)</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">getIOSGank</span><span class="params">()</span></span>: Deferred&lt;GankResult&gt;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@GET(<span class="meta-string">"data/Android/2/1"</span>)</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">getAndroidGank</span><span class="params">()</span></span>: Deferred&lt;GankResult&gt;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="meta">@JvmField</span></span><br><span class="line">        <span class="keyword">val</span> callAdapterInstance = Retrofit.Builder()</span><br><span class="line">            .baseUrl(<span class="string">"http://gank.io/api/"</span>)</span><br><span class="line">            .addCallAdapterFactory(CoroutineCallAdapterFactory())</span><br><span class="line">            .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">            .build().create(CallAdapterApiService::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>更新<br>新版的retrofit已经支持协程了，直接使用suspend关键字即可</p>
<h5 id="mvp中使用协程"><a href="#mvp中使用协程" class="headerlink" title="mvp中使用协程"></a>mvp中使用协程</h5><p>我们在开发中常常使用mvp模式，其中也经常用到rxjava，主要涉及到在退出Activity时，要将协程操作取消</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">BasePresenter</span>&lt;<span class="type">V: MvpView</span>&gt; : <span class="type">MvpPresenter</span>&lt;<span class="type">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> view: V</span><br><span class="line">    <span class="keyword">val</span> presenterScope: CoroutineScope <span class="keyword">by</span> lazy &#123;</span><br><span class="line">        CoroutineScope(Dispatchers.Main + Job())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">attachView</span><span class="params">(view: <span class="type">V</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.view = view</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">detachView</span><span class="params">()</span></span> &#123;</span><br><span class="line">        presenterScope.cancel()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用CoroutineScope.cancel()取消协程<br>大家应该可以看到上面BasePresenter.detachView中调用了presenterScope.cancel()，那这个方法有什么作用呢，作用就是取消掉presenterScope创建的所有协程和其子协程。</p>
<p>前面的文章我也介绍过使用launch创建协程时会返回一个Job对象，通过Job对象的cancel方法也可以取消该任务对应的协程，那我这里为什么不使用这种方式呢？</p>
<p>很明显，如果使用Job.cancel()方式取消协程，那我创建每个协程的时候都必须保存返回的Job对象，然后再去取消，显然要更复杂点，而使用CoroutineScope.cancel()则可以一次性取消该协程上下文创建的所有协程和子协程，该代码也可以很方便的提取到基类中，这样后面在写业务代码时也就不用关心协程与View的生命周期的问题。</p>
<p>其实大家看源码的话也可以发现CoroutineScope.cancel()最终使用的也是Job.cancel()取消协程</p>
<h5 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h5><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">tryCatch</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        tryBlock: <span class="type">suspend</span> <span class="type">CoroutineScope</span>.() -&gt; <span class="type">Unit</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        finallyBlock: <span class="type">suspend</span> <span class="type">CoroutineScope</span>.() -&gt; <span class="type">Unit</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        useDefaultShowError: <span class="type">Boolean</span> = <span class="literal">false</span></span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span> &#123;</span><br><span class="line">        coroutineScope &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                tryBlock()</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">                Log.i(<span class="string">"tiaoshi"</span>,<span class="string">"base Presenter exception:"</span>+e.message)</span><br><span class="line">                <span class="keyword">if</span> (e !<span class="keyword">is</span> CancellationException &amp;&amp; useDefaultShowError) &#123;</span><br><span class="line">                    mView.showError(e)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> e</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                finallyBlock()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>kotlin协程使用跟正常程序一样使用try,catch来捕获异常，其 中当取消协程时，会抛出CancellationException，不必处理。</p>
<p>具体操作已经封装到BaseKtPresenter中，直接继承使用即可</p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划详解</title>
    <url>/blog/2020/03/dynamic-programming-learn.html</url>
    <content><![CDATA[<p>动态规则是数据结构与算法中常用的一个求解方法</p>
<p>下面以一个凑零钱问题为例说明。</p>
<blockquote>
<p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p>
</blockquote>
<p>动态规划问题的一般形式就是求最值。动态规划其实是运筹学的一种最优化方法，只不过在计算机问题上应用比较多，比如说让你求最长递增子序列呀，最小编辑距离呀等等。</p>
<p>既然是要求最值，核心问题是什么呢？求解动态规划的核心问题是穷举。因为要求最值，肯定要把所有可行的答案穷举出来，然后在其中找最值</p>
<p>但是，动态规划的穷举有点特别，因为这类问题存在「重叠子问题」,如果暴力穷举的话效率会极其低下，所以需要「备忘录」或者「DP table」来优化穷举过程，避免不必要的计算。<br>而且，动态规划问题一定会具备「最优子结构」，才能通过子问题的最值得到原问题的最值。<br>另外，虽然动态规划的核心思想就是穷举求最值，但是问题可以千变万化，穷举所有可行解其实并不是一件容易的事，只有列出正确的「状态转移方程」才能正确地穷举。</p>
<h4 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h4><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"># 伪码框架</span><br><span class="line">def coinChange(coin<span class="variable">s:</span> List[<span class="keyword">int</span>], amoun<span class="variable">t:</span> <span class="keyword">int</span>):</span><br><span class="line">    # 定义：要凑出金额 n，至少要 <span class="keyword">dp</span>(n) 个硬币</span><br><span class="line">    def <span class="keyword">dp</span>(n):</span><br><span class="line">        # 做选择，选择需要硬币最少的那个结果</span><br><span class="line">        <span class="keyword">for</span> coin in coin<span class="variable">s:</span></span><br><span class="line">            <span class="keyword">res</span> = <span class="built_in">min</span>(<span class="keyword">res</span>, <span class="number">1</span> + <span class="keyword">dp</span>(n - coin))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">res</span></span><br><span class="line">    # 我们要求的问题是 <span class="keyword">dp</span>(amount)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">dp</span>(amount)</span><br></pre></td></tr></table></figure>
<p>时间复杂度分析：子问题总数 x 每个子问题的时间。</p>
<p>子问题总数为递归树节点个数，这个比较难看出来，是 O(n^k)，总之是指数级别的。每个子问题中含有一个 for 循环，复杂度为 O(k)。所以总时间复杂度为 O(k * n^k)，指数级别。</p>
<h4 id="带备忘录的递归"><a href="#带备忘录的递归" class="headerlink" title="带备忘录的递归"></a>带备忘录的递归</h4><p>只需要稍加修改，就可以通过备忘录消除子问题：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">def coinChange(coin<span class="variable">s:</span> List[<span class="keyword">int</span>], amoun<span class="variable">t:</span> <span class="keyword">int</span>):</span><br><span class="line">    # 备忘录</span><br><span class="line">    memo = dict()</span><br><span class="line">    def <span class="keyword">dp</span>(n):</span><br><span class="line">        # 查备忘录，避免重复计算</span><br><span class="line">        <span class="keyword">if</span> n in memo: <span class="keyword">return</span> memo[n]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span>: <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">res</span> = float(<span class="string">'INF'</span>)</span><br><span class="line">        <span class="keyword">for</span> coin in coin<span class="variable">s:</span></span><br><span class="line">            subproblem = <span class="keyword">dp</span>(n - coin)</span><br><span class="line">            <span class="keyword">if</span> subproblem == -<span class="number">1</span>: <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">res</span> = <span class="built_in">min</span>(<span class="keyword">res</span>, <span class="number">1</span> + subproblem)</span><br><span class="line">        </span><br><span class="line">        # 记入备忘录</span><br><span class="line">        memo[n] = <span class="keyword">res</span> <span class="keyword">if</span> <span class="keyword">res</span> != float(<span class="string">'INF'</span>) <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> memo[n]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">dp</span>(amount)</span><br></pre></td></tr></table></figure>
<p>很显然「备忘录」大大减小了子问题数目，完全消除了子问题的冗余，所以子问题总数不会超过金额数 n，即子问题数目为 O(n)。处理一个子问题的时间不变，仍是 O(k)，所以总的时间复杂度是 O(kn)</p>
<h4 id="动态规划解法"><a href="#动态规划解法" class="headerlink" title="动态规划解法"></a>动态规划解法</h4><p>首先，这个问题是动态规划问题，因为它具有「最优子结构」的。要符合「最优子结构」，子问题间必须互相独立。啥叫相互独立？你肯定不想看数学证明，我用一个直观的例子来讲解。</p>
<p>比如说，你的原问题是考出最高的总成绩，那么你的子问题就是要把语文考到最高，数学考到最高…… 为了每门课考到最高，你要把每门课相应的选择题分数拿到最高，填空题分数拿到最高…… 当然，最终就是你每门课都是满分，这就是最高的总成绩。</p>
<p>得到了正确的结果：最高的总成绩就是总分。因为这个过程符合最优子结构，“每门科目考到最高”这些子问题是互相独立，互不干扰的。</p>
<p>但是，如果加一个条件：你的语文成绩和数学成绩会互相制约，此消彼长。这样的话，显然你能考到的最高总成绩就达不到总分了，按刚才那个思路就会得到错误的结果。因为子问题并不独立，语文数学成绩无法同时最优，所以最优子结构被破坏。</p>
<p>回到凑零钱问题，为什么说它符合最优子结构呢？比如你想求 amount = 11 时的最少硬币数（原问题），如果你知道凑出 amount = 10 的最少硬币数（子问题），你只需要把子问题的答案加一（再选一枚面值为 1 的硬币）就是原问题的答案，因为硬币的数量是没有限制的，子问题之间没有相互制，是互相独立的。</p>
<p>那么，既然知道了这是个动态规划问题，就要思考如何列出正确的状态转移方程？</p>
<ul>
<li>先确定「状态」，也就是原问题和子问题中变化的变量。由于硬币数量无限，所以唯一的状态就是目标金额 amount。</li>
<li>然后确定 dp 函数的定义：当前的目标金额是 n，至少需要 dp(n) 个硬币凑出该金额。</li>
<li>然后确定「选择」并择优，也就是对于每个状态，可以做出什么选择改变当前状态。具体到这个问题，无论当的目标金额是多少，选择就是从面额列表 coins 中选择一个硬币，然后目标金额就会减少</li>
</ul>
<p>实现如下，我们自底向上使用 dp table 来消除重叠子问题，dp 数组的定义和刚才 dp 函数类似，定义也是一样的：<br>dp[i] = x 表示，当目标金额为 i 时，至少需要 x 枚硬币。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 数组大小为 amount + 1，初始值也为 amount + 1</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(amount + <span class="number">1</span>, amount + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dp.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="comment">// 内层 for 在求所有子问题 + 1 的最小值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> coin : coins) &#123;</span><br><span class="line">            <span class="comment">// 子问题无解，跳过</span></span><br><span class="line">            <span class="keyword">if</span> (i - coin &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            dp[i] = <span class="built_in">min</span>(dp[i], <span class="number">1</span> + dp[i - coin]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (dp[amount] == amount + <span class="number">1</span>) ? <span class="number">-1</span> : dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p><a href="https://leetcode-cn.com/problems/coin-change/solution/dong-tai-gui-hua-tao-lu-xiang-jie-by-wei-lai-bu-ke/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/coin-change/solution/dong-tai-gui-hua-tao-lu-xiang-jie-by-wei-lai-bu-ke/</a></p>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>七大排序算法kotlin实现</title>
    <url>/blog/2020/03/kotlin-sort-algortim.html</url>
    <content><![CDATA[<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>冒泡排序是一种交换排序，它的基本思想是：两两比较相邻记录的关键字，如果是反序则交换，直到没有反序的记录为止。</p>
<h4 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h4><p>1.比较相邻的元素。如果第一个比第二个大，就交换它们两个；<br>2.对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；<br>3.针对所有的元素重复以上的步骤，除了最后一个；<br>4.重复步骤1~3，直到排序完成</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">bubbleSort</span><span class="params">(array: <span class="type">IntArray</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until  array.size -<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until array.size -i -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (array[j]&gt;array[j+<span class="number">1</span>])&#123;</span><br><span class="line">                swap(array,j,j+<span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//交换</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">swap</span><span class="params">(array: <span class="type">IntArray</span>,a:<span class="type">Int</span>,b:<span class="type">Int</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> temp = array[a]</span><br><span class="line">    array[a] = array[b]</span><br><span class="line">    array[b] = temp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n^2)</p>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p>1.首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置.<br>2.再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>
<h4 id="算法描述-1"><a href="#算法描述-1" class="headerlink" title="算法描述"></a>算法描述</h4><p>n个记录的直接选择排序可经过n−1 n-1n−1趟直接选择排序得到有序结果。具体算法描述如下：</p>
<p>1.初始状态：无序区为R[1..n] R[1..n]R[1..n]，有序区为空；<br>2.第i趟排序(i=1,2,3…n−1) (i=1,2,3…n-1)(i=1,2,3…n−1)开始时，当前有序区和无序区分别为R[1..i−1]和R(i..n） R[1..i-1]和R(i..n）R[1..i−1]和R(i..n）。该趟排序从当前无序区中选出关键字最小的记录 R[k] R[k]R[k]，将它与无序区的第1个记录R RR交换，使R[1..i] R[1..i]R[1..i]和R[i+1..n) R[i+1..n)R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；<br>3.n−1 n-1n−1趟结束，数组有序化了</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//选择排序</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">selectionSort</span><span class="params">(arr: <span class="type">IntArray</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> arr.indices)&#123;</span><br><span class="line">            <span class="keyword">var</span> mIndex = i;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> i until arr.size)&#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j]&lt;arr[mIndex])&#123;</span><br><span class="line">                    mIndex = j</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(arr,i,mIndex)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度O(n^2)</p>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><h4 id="算法描述-2"><a href="#算法描述-2" class="headerlink" title="算法描述"></a>算法描述</h4><p>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：</p>
<p>1.从第一个元素开始，该元素可以认为已经被排序；<br>2.取出下一个元素，在已经排序的元素序列中从后向前扫描；<br>3.如果该元素（已排序）大于新元素，将该元素移到下一位置；<br>4.重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；<br>5.将新元素插入到该位置后；<br>6.重复步骤2~5。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">//插入排序</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> fun <span class="title">insertionSort</span><span class="params">(<span class="built_in">array</span>: IntArray)</span> </span>&#123;</span><br><span class="line">       var current: Int</span><br><span class="line">       <span class="keyword">for</span> (i in <span class="number">0</span> until <span class="built_in">array</span>.<span class="built_in">size</span> - <span class="number">1</span>) &#123;</span><br><span class="line">           current = <span class="built_in">array</span>[i + <span class="number">1</span>]</span><br><span class="line">           var preIndex = i</span><br><span class="line">           <span class="keyword">while</span> (preIndex &gt;= <span class="number">0</span> &amp;&amp; current &lt; <span class="built_in">array</span>[preIndex]) &#123;</span><br><span class="line">               <span class="built_in">array</span>[preIndex + <span class="number">1</span>] = <span class="built_in">array</span>[preIndex]</span><br><span class="line">               preIndex--</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="built_in">array</span>[preIndex + <span class="number">1</span>] = current</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度O(n^2)</p>
<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>希尔排序是希尔（Donald Shell）于1959年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序，同时该算法是冲破O(n^2)的第一批算法之一。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。</p>
<p>希尔排序使更高效的插入排序，它的思想在于，</p>
<p>1.把数组分成几块，每一块进行一个插入排序；<br>2.而分块的依据在于增量的选择分好块之后，从gap开始到n，每一组和它前面的元素（自己组内的）进行插入排序；</p>
<p>每次和组内的元素比较完之后，最后的元素基本就是有序的了，希尔排序相对于插入排序的优势在于插入排序每次只能将数据移动一位，不过希尔排序时间复杂度的大小还是要取决于步长的合适度，另外希尔排序不是一种稳定的排序算法。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">shellSort</span><span class="params">(arr: <span class="type">IntArray</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> startTime = System.nanoTime()</span><br><span class="line">        <span class="keyword">val</span> len = arr.size</span><br><span class="line">        <span class="keyword">var</span> temp: <span class="built_in">Int</span></span><br><span class="line">        <span class="keyword">var</span> gap = len / <span class="number">2</span></span><br><span class="line">        <span class="keyword">while</span> (gap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (i <span class="keyword">in</span> gap until len) &#123;</span><br><span class="line">                temp = arr[i]</span><br><span class="line">                <span class="keyword">var</span> preIndex = i - gap</span><br><span class="line">                <span class="keyword">while</span> (preIndex &gt;= <span class="number">0</span> &amp;&amp; arr[preIndex] &gt; temp) &#123;</span><br><span class="line">                    arr[preIndex + gap] = arr[preIndex]</span><br><span class="line">                    preIndex -= gap</span><br><span class="line">                &#125;</span><br><span class="line">                arr[preIndex + gap] = temp</span><br><span class="line">            &#125;</span><br><span class="line">            gap /= <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> endTime = System.nanoTime()</span><br><span class="line">        println(((endTime - startTime) / <span class="number">1000.0</span>).toString() + <span class="string">"ms"</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：nlongn</p>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p>
<p>1.从数列中挑出一个元素，称为 “基准”（pivot）；<br>2.重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；<br>3.递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">//快速排序方法</span><br><span class="line">  private fun quickSort(array: IntArray, <span class="keyword">start</span>: <span class="built_in">Int</span>, <span class="keyword">end</span>: <span class="built_in">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array.isEmpty() || <span class="keyword">start</span> &lt; <span class="number">0</span> || <span class="keyword">end</span> &gt;= array.size || <span class="keyword">start</span> &gt; <span class="keyword">end</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        val smallIndex = <span class="keyword">partition</span>(<span class="built_in">array</span>, <span class="keyword">start</span>, <span class="keyword">end</span>)</span><br><span class="line">        <span class="keyword">if</span> (smallIndex &gt; <span class="keyword">start</span>) &#123;</span><br><span class="line">            quickSort(<span class="built_in">array</span>, <span class="keyword">start</span>, smallIndex - <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (smallIndex &lt; <span class="keyword">end</span>) &#123;</span><br><span class="line">            quickSort(<span class="built_in">array</span>, smallIndex + <span class="number">1</span>, <span class="keyword">end</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	//快速排序算法——<span class="keyword">partition</span></span><br><span class="line">    <span class="keyword">private</span> fun <span class="keyword">partition</span>(<span class="built_in">array</span>: IntArray, <span class="keyword">start</span>: <span class="built_in">Int</span>, <span class="keyword">end</span>: <span class="built_in">Int</span>): <span class="built_in">Int</span> &#123;</span><br><span class="line">        val <span class="keyword">pivot</span> = (<span class="keyword">start</span> + Math.random() * (<span class="keyword">end</span> - <span class="keyword">start</span> + <span class="number">1</span>)).toInt()</span><br><span class="line">        <span class="keyword">var</span> smallIndex = <span class="keyword">start</span> - <span class="number">1</span></span><br><span class="line">        swap(<span class="built_in">array</span>, <span class="keyword">pivot</span>, <span class="keyword">end</span>)</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> start..end)</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">array</span>[i] &lt;= <span class="built_in">array</span>[<span class="keyword">end</span>]) &#123;</span><br><span class="line">                smallIndex++</span><br><span class="line">                <span class="keyword">if</span> (i &gt; smallIndex)</span><br><span class="line">                    swap(<span class="built_in">array</span>, i, smallIndex)</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> smallIndex</span><br><span class="line">    &#125;</span><br><span class="line">	//交换数组内两个元素</span><br><span class="line">    <span class="keyword">private</span> fun swap(<span class="built_in">array</span>: IntArray, i: <span class="built_in">Int</span>, j: <span class="built_in">Int</span>) &#123;</span><br><span class="line">        val temp = <span class="built_in">array</span>[i]</span><br><span class="line">        <span class="built_in">array</span>[i] = <span class="built_in">array</span>[j]</span><br><span class="line">        <span class="built_in">array</span>[j] = temp</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：nlogn</p>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>堆排序（Heap sort）是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">heapSort</span><span class="params">(array: <span class="type">IntArray</span>)</span></span>: IntArray &#123;</span><br><span class="line">        len = array.size</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">1</span>) <span class="keyword">return</span> array</span><br><span class="line">        <span class="comment">//构建一个最大堆</span></span><br><span class="line">        buildMaxHeap(array)</span><br><span class="line">        <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            swap(array, <span class="number">0</span>, len - <span class="number">1</span>)</span><br><span class="line">            len--</span><br><span class="line">            adjustHeap(array, <span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调整使之成为最大堆</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">adjustHeap</span><span class="params">(array: <span class="type">IntArray</span>, i: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> maxIndex = i</span><br><span class="line">        <span class="comment">//如果有左子树，且左子树大于父节点，则将最大指针指向左子树</span></span><br><span class="line">        <span class="keyword">if</span> (i * <span class="number">2</span> &lt; len &amp;&amp; array[i * <span class="number">2</span>] &gt; array[maxIndex]) &#123;</span><br><span class="line">            maxIndex = i * <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果有右子树，且右子树大于父节点，则将最大指针指向右子树</span></span><br><span class="line">        <span class="keyword">if</span> (i * <span class="number">2</span> + <span class="number">1</span> &lt; len &amp;&amp; array[i * <span class="number">2</span> + <span class="number">1</span>] &gt; array[maxIndex]) &#123;</span><br><span class="line">            maxIndex = i * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果父节点不是最大值，则将父节点与最大值交换，并且递归调整与父节点交换的位置。</span></span><br><span class="line">        <span class="keyword">if</span> (maxIndex != i) &#123;</span><br><span class="line">            swap(array, maxIndex, i)</span><br><span class="line">            adjustHeap(array, maxIndex)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//建立最大堆</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">buildMaxHeap</span><span class="params">(array: <span class="type">IntArray</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> len / <span class="number">2</span> - <span class="number">1</span> downTo <span class="number">0</span>) &#123;</span><br><span class="line">            adjustHeap(array, i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：nlogn</p>
<h3 id="归并排序（Merge-Sort）"><a href="#归并排序（Merge-Sort）" class="headerlink" title="归并排序（Merge Sort）"></a>归并排序（Merge Sort）</h3><p>和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(nlogn) O(nlogn)O(nlogn)的时间复杂度。代价是需要额外的内存空间。</p>
<p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。</p>
<h4 id="算法描述-3"><a href="#算法描述-3" class="headerlink" title="算法描述"></a>算法描述</h4><p>把长度为n nn的输入序列分成两个长度为n/2 n/2n/2的子序列；<br>对这两个子序列分别采用归并排序；<br>将两个排序好的子序列合并成一个最终的排序序列。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 归并排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">mergeSort</span><span class="params">(array: <span class="type">IntArray</span>)</span></span>: IntArray &#123;</span><br><span class="line">        <span class="keyword">if</span> (array.size &lt; <span class="number">2</span>) <span class="keyword">return</span> array</span><br><span class="line">        <span class="keyword">val</span> mid = array.size / <span class="number">2</span></span><br><span class="line">        <span class="keyword">val</span> left = Arrays.copyOfRange(array, <span class="number">0</span>, mid)</span><br><span class="line">        <span class="keyword">val</span> right = Arrays.copyOfRange(array, mid, array.size)</span><br><span class="line">        <span class="keyword">return</span> merge(mergeSort(left), mergeSort(right))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 归并排序——将两段排序好的数组结合成一个排序数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">merge</span><span class="params">(left: <span class="type">IntArray</span>, right: <span class="type">IntArray</span>)</span></span>: IntArray &#123;</span><br><span class="line">        <span class="keyword">val</span> result = IntArray(left.size + right.size)</span><br><span class="line">        <span class="keyword">var</span> index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> (index &lt; result.size) &#123;</span><br><span class="line">            <span class="keyword">when</span> &#123;</span><br><span class="line">                i &gt;= left.size -&gt; result[index] = right[j++]</span><br><span class="line">                j &gt;= right.size -&gt; result[index] = left[i++]</span><br><span class="line">                left[i] &gt; right[j] -&gt; result[index] = right[j++]</span><br><span class="line">                <span class="keyword">else</span> -&gt; result[index] = left[i++]</span><br><span class="line">            &#125;</span><br><span class="line">            index++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(nlogn)</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://blog.csdn.net/jun5753/article/details/89708242" target="_blank" rel="noopener">七大经典排序算法总结</a><br><a href="https://www.cnblogs.com/chengxiao/p/6129630.html" target="_blank" rel="noopener">图解数据结构</a><br><a href="https://www.jianshu.com/p/67a0296d7972" target="_blank" rel="noopener">递归树以及时间复杂度</a></p>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Flex语法学习</title>
    <url>/blog/2020/03/flex-grama-learn.html</url>
    <content><![CDATA[<h3 id="flex-grow、flex-shrink与flex-basis"><a href="#flex-grow、flex-shrink与flex-basis" class="headerlink" title="flex-grow、flex-shrink与flex-basis"></a>flex-grow、flex-shrink与flex-basis</h3><h4 id="第一个属性：flex-basis"><a href="#第一个属性：flex-basis" class="headerlink" title="第一个属性：flex-basis"></a>第一个属性：flex-basis</h4><p>basis英文意思是&lt;主要成分&gt;<br>该属性用来设置元素的宽度，其实，width也可以设置宽度。如果元素上同时设置了width和flex-basis，那么width 的值就会被flex-basis覆盖掉。</p>
<h4 id="第二个属性：flex-grow"><a href="#第二个属性：flex-grow" class="headerlink" title="第二个属性：flex-grow"></a>第二个属性：flex-grow</h4><p>该属性用来设置当父元素的宽度大于所有子元素的宽度的和时（即父元素会有剩余空间），子元素如何分配父元素的剩余空间。 flex-grow的默认值为0，意思是该元素不索取父元素的剩余空间，如果值大于0，表示索取。值越大，索取的越厉害。</p>
<p>举个例子: 父元素宽400px，有两个子元素：A和B。A宽为100px，B宽为200px。 则空余空间为 400-（100+200）= 100px。 如果A，B都不索取剩余空间，则有100px的空余空间</p>
<p>如果A索取剩余空间:设置flex-grow为1，B不索取。则最终A的大小为 自身宽度（100px）+ 剩余空间的宽度（100px）= 200px 。</p>
<p>如果A，B都设索取剩余空间，A设置flex-grow为1，B设置flex-grow为2。则最终A的大小为 自身宽度（100px）+ A获得的剩余空间的宽度（100px (1/(1+2))）,最终B的大小为 自身宽度（200px）+ B获得的剩余空间的宽度（100px (2/(1+2))）</p>
<h4 id="第三个属性：flex-shrink"><a href="#第三个属性：flex-shrink" class="headerlink" title="第三个属性：flex-shrink"></a>第三个属性：flex-shrink</h4><p>该属性用来设置，当父元素的宽度小于所有子元素的宽度的和时（即子元素会超出父元素），子元素如何缩小自己的宽度的。 flex-shrink的默认值为1，当父元素的宽度小于所有子元素的宽度的和时，子元素的宽度会减小。值越大，减小的越厉害。如果值为0，表示不减小。</p>
<p>举个例子: 父元素宽400px，有两子元素：A和B。A宽为200px，B宽为300px。 则A，B总共超出父元素的宽度为(200+300)- 400 = 100px。 如果A，B都不减小宽度，即都设置flex-shrink为0，则会有100px的宽度超出父元素。 </p>
<p>如果A不减小宽度:设置flex-shrink为0，B减小。则最终B的大小为 自身宽度(300px)- 总共超出父元素的宽度(100px)= 200px </p>
<p>如果A，B都减小宽度，A设置flex-shirk为3，B设置flex-shirk为2。则最终A的大小为 自身宽度(200px)- A减小的宽度(100px <em> (200px </em> 3/(200 <em> 3 + 300 </em> 2))) = 150px,最终B的大小为 自身宽度(300px)- B减小的宽度(100px <em> (300px </em> 2/(200 <em> 3 + 300 </em> 2))) = 250px</p>
<h4 id="简写方式"><a href="#简写方式" class="headerlink" title="简写方式"></a>简写方式</h4><p>flex是flex-grow，flex-shrink,  flex-basis  (注意写的顺序)缩写形式，大家可以记一下下面的缩写规则：</p>
<p>如：flex 取值为 none，则计算值为 0 0 auto，如下是等同的<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;<span class="attribute">flex</span>: none;&#125;</span><br><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">flex-grow</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">flex-shrink</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">flex-basis</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当 flex取值为 auto，则计算值为 1 1 auto<br>当 flex 取值为一个非负数字，则该数字为 flex-grow 值，flex-shrink 取 1，flex-basis 取 0%<br>当 flex 取值为一个长度或百分比，则视为 flex-basis 值，flex-grow 取 1，flex-shrink取 1<br>当 flex取值为两个非负数字，则分别视为 flex-grow和 flex-shrink的值，flex-basis取 0%</p>
]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>vscod插件学习</title>
    <url>/blog/2020/04/vscode-plugin-learn.html</url>
    <content><![CDATA[<p>vscode的插件可以极大的优化开发体验，下面介绍一些常有的插件。</p>
<p>1.,Vue CSS Peak</p>
<p>支持vue文件template中的css点击跳转到定义</p>
<p>2.Git Lens</p>
<p>vscode git插件，可以迅速查看文件历史，分支历史，甚至每一行的历史</p>
<p>3.Path Intellisense</p>
<p>输入提示，自动完成文件名</p>
<p>4.veture</p>
<p>Vue语法支持。包括语法高亮、语法代码提示、语法lint检测等</p>
<p>vetrue常常配合eslint,prettier使用</p>
<p>详情可见：<a href="https://www.cnblogs.com/mspeer/p/12055962.html" target="_blank" rel="noopener">https://www.cnblogs.com/mspeer/p/12055962.html</a></p>
<p>5.Vue Jump to Tag</p>
<p>ctrl+1 跳转到template</p>
<p>ctrl+2 跳转到script</p>
<p>ctrl+3 跳转到css</p>
<p>方便快速在vue文件中跳转</p>
<p>6.Vue Peek</p>
<p>查看定义，可以看到定义的源文件</p>
<p>7.vue-helper</p>
<p>支持快捷键自动导包，当使用时直接输入需要的组件，ctrl+i即可自动引入</p>
<p>8.VueHelper</p>
<p>vue api代码提示</p>
]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>Handler源码分析</title>
    <url>/blog/2020/06/handler-source-code.html</url>
    <content><![CDATA[<h3 id="消息机制简介"><a href="#消息机制简介" class="headerlink" title="消息机制简介"></a>消息机制简介</h3><p>1.消息机制的简介<br>在Android中使用消息机制，我们首先想到的就是Handler。没错，Handler是Android消息机制的上层接口。Handler的使用过程很简单，通过它可以轻松地将一个任务切换到Handler所在的线程中去执行。通常情况下，Handler的使用场景就是更新UI。<br>如下就是使用消息机制的一个简单实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Activity</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">app</span>.<span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Handler mHandler = <span class="keyword">new</span> Handler()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">            System.out.println(msg.what);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState, PersistableBundle persistentState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState, persistentState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                ...............耗时操作</span><br><span class="line">                Message message = Message.obtain();</span><br><span class="line">                message.what = <span class="number">1</span>;</span><br><span class="line">                mHandler.sendMessage(message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="消息机制的模型"><a href="#消息机制的模型" class="headerlink" title="消息机制的模型"></a>消息机制的模型</h4><p>消息机制主要包含：MessageQueue，Handler和Looper这三大部分，以及Message，下面我们一一介绍。<br>他们的工作原理像是工厂的生产线<br>Looper是发动机，MessageQueue是传送带，Handler是工人，Message则是待处理的产品。</p>
<p>1.Message：需要传递的消息，可以传递数据；</p>
<p>2.MessageQueue：消息队列，但是它的内部实现并不是用的队列，实际上是通过一个单链表的数据结构来维护消息列表，因为单链表在插入和删除上比较有优势。主要功能向消息池投递消息(MessageQueue.enqueueMessage)和取走消息池的消息(MessageQueue.next)；</p>
<p>3.Handler：消息辅助类，主要功能向消息池发送各种消息事件(Handler.sendMessage)和处理相应消息事件(Handler.handleMessage)；</p>
<p>4.Looper：不断循环执行(Looper.loop)，从MessageQueue中读取消息，按分发机制将消息分发给目标处理者。</p>
<p>Android应用程序的入口实际上是ActivityThread.main方法，在该方法中会创建Application和默认启动的Activity,并且它们关联在一起，同时也会启动Looper循环</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">Process</span>.setArgV0(<span class="string">"&lt;pre-initialized&gt;"</span>);</span><br><span class="line"></span><br><span class="line">        Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">        ActivityThread thread = <span class="keyword">new</span> ActivityThread();</span><br><span class="line">        thread.<span class="built_in">attach</span>(<span class="literal">false</span>, startSeq);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sMainThreadHandler == null) &#123;</span><br><span class="line">            sMainThreadHandler = thread.getHandler();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">            Looper.myLooper().setMessageLogging(<span class="keyword">new</span></span><br><span class="line">                    LogPrinter(Log.DEBUG, <span class="string">"ActivityThread"</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// End of event ActivityThreadMain.</span></span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">        Looper.loop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此后Looper会一直从消息队列中取消息，然后处理消息，用户或者系统通过Handler不断地往消息队列中添加消息，这些消息被不断地取出，处理，回收，使得应用迅速地运转起来。</p>
<h4 id="一个线程只有一个Looper"><a href="#一个线程只有一个Looper" class="headerlink" title="一个线程只有一个Looper"></a>一个线程只有一个Looper</h4><p>Looper通过ThreadLocal存储，一个线程只有一个，在主线程中在应用启动时就已经启动了Looper循环，所以在子线程中使用需要创建对应线程的Looper</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="meta">@Nullable</span> <span class="function">Looper <span class="title">myLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> sThreadLocal.<span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">prepareMainLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        prepare(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (Looper<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (sMainLooper != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The main Looper has already been prepared."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            sMainLooper = myLooper();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h3><p>享元模式是对象池的一种实现，它的英文名称是FlyWeight，代表轻量级的意思。享元模式用来尽量减少内存使用量，它适用于可能存在大量重复对象的场景，来缓存可共享的对象。<br>从而达到对象共享，避免创建过多对象的效果，这样可以提升性能，避免GC消耗时间与资源等。</p>
<p>享元对象中的部分状态是可以共享的，可以共享的状态称为内部状态，内部状态不会随着环境变化；不可共享的状态称为外部状态，它们会随着环境的改变而改变。</p>
<p>android消息机制中的Message中就用到了享元模式</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="function">Message <span class="title">obtain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sPool != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Message m = sPool;</span><br><span class="line">                sPool = m.next;</span><br><span class="line">                m.next = <span class="keyword">null</span>;</span><br><span class="line">                m.flags = <span class="number">0</span>; <span class="comment">// clear in-use flag</span></span><br><span class="line">                sPoolSize--;</span><br><span class="line">                <span class="keyword">return</span> m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Message();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recycleUnchecked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Mark the message as in use while it remains in the recycled object pool.</span></span><br><span class="line">        <span class="comment">// Clear out all other details.</span></span><br><span class="line">     </span><br><span class="line">        <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sPoolSize &lt; MAX_POOL_SIZE) &#123;</span><br><span class="line">                next = sPool;</span><br><span class="line">                sPool = <span class="keyword">this</span>;</span><br><span class="line">                sPoolSize++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>Message通过在内部构建一个链表来维护一个被回收的Message对象的对象池，当用户调用时会优先从池中取，如果池中没有可以复用的对象则创建这个新的Message对象.<br>这些新创建的Message对象在被使用完之后会被回收到对象池中，当下次再调用obtain函数时，它们会被复用。</p>
<p>因为Android应用是通过事件驱动的，因此如果通过new来创建Message就会创建大量重复的Message对象，导致内存占用率高，频繁GC等问题，通过享元模式创建一个大小为50的消息池，避免了上述问题的产生。</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p><strong>为什么Looper不会导致ANR</strong><br>事实上启动一个 Java 程序的入口函数是 main 方法，但是当 main 函数执行完毕之后此程序停止运行，也就是进程会自动终止。但是当我们打开一个 Activity 之后，只要我们不按下返回键 Activity 会一直显示在屏幕上，也就是 Activity 所在进程会一直处于运行状态。实际上 Looper 内部维护一个无限循环，保证 App 进程持续进行。</p>
<p>app的所有消息，包括打开页面，刷新UI都用到了Handler，阻塞主线程并不会导致ANR，消息在5S内得不到处理才是导致ANR的真正原因.</p>
<p>你可能会问：主线程都堵住了，怎么响应用户操作和回调Activity声明周期相关的方法？<br>答：application启动时，可不止一个main线程，还有其他两个Binder线程：ApplicationThread 和 ActivityManagerProxy，用来和系统进程进行通信操作，接收系统进程发送的通知。<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog3/p10.webp" alt><br>当系统受到因用户操作产生的通知时，会通过 Binder 方式跨进程通知 ApplicationThread;<br>它通过Handler机制，往 ActivityThread 的 MessageQueue 中插入消息，唤醒了主线程；<br>queue.next() 能拿到消息了,然后 dispatchMessage 完成事件分发；PS：ActivityThread 中的内部类H中有具体实现</p>
<p>死循环不会ANR，但是 dispatchMessage 中又可能会ANR哦！如果你在此执行一些耗时操作，<br>导致这个消息一直没处理完，后面又接收到了很多消息，堆积太多，就会引起ANR异常</p>
<p><strong>Handler一些问题总结</strong><br>1.能不能在子线程更新UI<br>2.能不能在子线程网络请求<br>3.为什么推荐使用Message.Obtain<br>4.同步屏障机制<br>详情可见：<a href="https://juejin.im/post/5eb3cb09518825595138db51#heading-3" target="_blank" rel="noopener">https://juejin.im/post/5eb3cb09518825595138db51#heading-3</a></p>
<h4 id="Handler内存泄漏的GCRoot是什么？"><a href="#Handler内存泄漏的GCRoot是什么？" class="headerlink" title="Handler内存泄漏的GCRoot是什么？"></a>Handler内存泄漏的GCRoot是什么？</h4><p>1.当直接在activity中声明handler时，由于后面的匿名内部类，使handler持有了activity的引用。<br>2.当任务未执行完，即message未被执行完时，message持有了messageQueue的引用。<br>3.messageQueue持有了mLooper的引用。<br>4.mLooper持有sThreadLocal 的引用。<br>5.sThreadLocal 是一个静态变量，无法被回收，最终导致了activity无法被回收，造成了内存泄漏。</p>
<p>详情可见：<a href="https://blog.csdn.net/weixin_40334045/article/details/106762338" target="_blank" rel="noopener">https://blog.csdn.net/weixin_40334045/article/details/106762338</a></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>消息通过Handler投递到消息队列，这个消息队列在Handler关联的Looper中，消息循环启动之后会不断地从队列中获取消息。获取消息之后会调用消息的callback或者分发给对应Handler的handleMessage函数进行处理，这样就将消息，消息的分发，处理隔离开来，降低各个角色的耦合。消息被处理之后会被收回到消息池中便于下次利用，这样整个应用通过不断地执行这个流程就运转起来了。</p>
<p><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/bog2/p2.jpg" alt></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>retrofit中的设计模式</title>
    <url>/blog/2020/06/retrofit-design-patern.html</url>
    <content><![CDATA[<p>Retrofit 是一个 RESTful 的 HTTP 网络请求框架的封装，网络请求的工作本质上是 OkHttp 完成，而 Retrofit 仅负责 网络请求接口的封装.</p>
<p><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/bog2/p1.webp" alt></p>
<p>一般网络请求框架做的工作如上图所示</p>
<ol>
<li>build request(API参数配置)</li>
<li>executor(这里可以有很多变体，比如有无队列，进出顺序，线程管理)</li>
<li>parse callback(解析数据，返回T给上层)</li>
</ol>
<p>retrofit所做的主要分为以下3部分：</p>
<ol>
<li>通过注解配置API参数,将resultful api拼接成真正的请求url</li>
<li><code>CallAdapter</code>(你可以把它理解成executor)，指定真正的网络请求</li>
<li><code>Converter</code>(解析数据并转换成T)</li>
</ol>
<h4 id="面向对象六大原则"><a href="#面向对象六大原则" class="headerlink" title="面向对象六大原则"></a>面向对象六大原则</h4><ul>
<li><p>单一职责原则(Single Responsibility Principle)——SRP</p>
<p>单一职责原则很好理解，就是一个类尽量只做一件事。</p>
</li>
<li><p>开闭原则(Open Close Principle)——OCP</p>
<p>开闭原则的定义是软件中的对象(类，模块，函数等)应该对于扩展是开放的，但是对于修改是关闭的。<br>即当需求发生改变的时候，我们需要对代码进行修改，这个时候我们应该尽量去扩展原来的代码，而不是去修改原来的代码，因为这样可能会引起更多的问题。</p>
</li>
<li><p>里式替换原则(Liskov Substitution Principle)——LSP</p>
<p>里式替换原则简单说来就是：所有引用基类的地方必须能够透明地使用其子类的对象。<br>里氏替换原则通俗的去讲就是：子类可以去扩展父类的功能，但是不能改变父类原有的功能</p>
<p>里氏替换和开闭原则是比较相近的，通过里式替换来达到对扩展开放，对修改关闭的效果</p>
</li>
<li><p>依赖倒置原则(Dependence Inversion Principle)——DIP</p>
<p>这个原则从名字根本看不出什么意思。高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。简单的说就是尽量面向接口编程.</p>
<p>依赖倒置原则在java语言中的表现就是：模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的。</p>
</li>
<li><p>接口隔离原则(InterfacesSergregation Principle)——ISP</p>
<p>接口隔离原则的定义是：客户端不应该依赖它不需要的接口；<br>一个类对另一个类的依赖应该建立在最小的接口上。接口最小化,过于臃肿的接口依据功能,可以将其拆分为多个接口</p>
<p>以上这些设计思想用英文的第一个字母可以组成SOLID ，满足这个5个原则的程序也被称为满足了SOLID准则。</p>
</li>
<li><p>迪米特原则(Law of Demeter)——LOD</p>
<p>迪米特原则也被称为最小知识原则，他的定义：一个对象应该对其他对象保持最小的了解。<br>因为类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大，所以这也是我们提倡的软件编程的总的原则：低耦合，高内聚。</p>
</li>
</ul>
<h4 id="retrofit中用到的设计模式"><a href="#retrofit中用到的设计模式" class="headerlink" title="retrofit中用到的设计模式"></a>retrofit中用到的设计模式</h4><ul>
<li><p>构造者模式(通过builder构建)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Retrofit retrofit =<span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">            .baseUrl(server1.url(<span class="string">"/"</span>))</span><br><span class="line">            .build();</span><br></pre></td></tr></table></figure>
<p>优点：</p>
<p>1.良好的封装性，使用建造者模式可以使客户端不必知道产品内部细节，更加安全</p>
<p>2.链式调用 ，更加简洁，易懂</p>
</li>
<li><p>外观模式（门面模式）</p>
<p>要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行。门面模式提供一个高层次的接口，使得子系统更易于使用。</p>
<p>Retrofit给我们暴露的方法和类不多。核心类就是Retrofit，我们只管配置Retrofit，然后做请求。剩下的事情就跟上层无关了，只需要等待回调。这样大大降低了系统的耦合度。对于这种写法，我们叫外观模式(门面模式)。</p>
<p>几乎所有优秀的开源library都有一个门面。比如<code>Glide.with()</code> <code>ImageLoader.load()</code> 。有个门面方便记忆，学习成本低，利于推广品牌。 Retrofit的门面就是<code>retrofit.create()</code></p>
<p>优点：</p>
<p>1.对客户程序隐藏子系统细节，减少了客户对于子系统的藕合，能够拥抱变化</p>
<p>2.外观类对子系统的接口封装，使得系统更加易用。</p>
<p>缺点：</p>
<p>1.外观类接口膨胀。有时子系统过多，使得外观类API较多，一定程度上增加了用户使用成本</p>
<p>2.外观类没有遵循开闭原则，当业务变更时，可能需要直接修改外观类。</p>
</li>
</ul>
<ul>
<li><p>动态代理</p>
<p>代理模式即为其他对象提供一种代理以控制对这个对象的访问<br>再来说动态代理。以往的动态代理和静态代理使用的场景是类似的。都想在delegate调用方法前后做一些操作。如果我的代理类有很多方法，那我得额外写很多代码，所以这时候就引入了动态代理。<br>通过动态设置delegate，可以处理不同代理的不同方法<br>动态代理则利用反射机制在运行时创建代理类。<br>动态代理常被用于在真正的操作之前或之后做一些操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object object;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxyHandler</span><span class="params">(Object object)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.object = object;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Before invoke "</span>  + method.getName());</span><br><span class="line">        method.invoke(object, args);</span><br><span class="line">        System.out.println(<span class="string">"After invoke "</span> + method.getName());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>Retrofit里的动态代理比较巧妙。实际上它根本就没有delegate。因为这个方法没有真正的实现。使用动态代理，只是单纯的为了拿到这个method上所有的注解。所有的工作都是由proxy做了</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">(<span class="keyword">final</span> Class&lt;T&gt; service)</span> </span>&#123;</span><br><span class="line">    validateServiceInterface(service);</span><br><span class="line">    <span class="keyword">return</span> (T)</span><br><span class="line">        Proxy.newProxyInstance(</span><br><span class="line">            service.getClassLoader(),</span><br><span class="line">            <span class="keyword">new</span> Class&lt;?&gt;[] &#123;service&#125;,</span><br><span class="line">            <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">              <span class="keyword">private</span> <span class="keyword">final</span> Platform platform = Platform.get();</span><br><span class="line">              <span class="keyword">private</span> <span class="keyword">final</span> Object[] emptyArgs = <span class="keyword">new</span> Object[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">              <span class="meta">@Override</span></span><br><span class="line">              <span class="keyword">public</span> <span class="meta">@Nullable</span> <span class="function">Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, @Nullable Object[] args)</span></span></span><br><span class="line"><span class="function">                  <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                <span class="comment">// If the method is a method from Object then defer to normal invocation.</span></span><br><span class="line">                <span class="keyword">if</span> (method.getDeclaringClass() == Object<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                  <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</span><br><span class="line">                &#125;</span><br><span class="line">                args = args != <span class="keyword">null</span> ? args : emptyArgs;</span><br><span class="line">                <span class="keyword">return</span> platform.isDefaultMethod(method)</span><br><span class="line">                    ? platform.invokeDefaultMethod(method, service, proxy, args)</span><br><span class="line">                    : loadServiceMethod(method).invoke(args);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>装饰模式</p>
<p>装饰模式又称包装模式，即动态地给一个对象添加一些额外的职责。</p>
<p>装饰模式与代理模式的共同点在于增强功能，但是代理的特点是添加逻辑控制，而装饰则是动态地添加功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorCallbackCall</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Call</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Executor callbackExecutor;</span><br><span class="line">    <span class="keyword">final</span> Call&lt;T&gt; delegate;</span><br><span class="line"></span><br><span class="line">    ExecutorCallbackCall(Executor callbackExecutor, Call&lt;T&gt; delegate) &#123;</span><br><span class="line">      <span class="keyword">this</span>.callbackExecutor = callbackExecutor;</span><br><span class="line">      <span class="keyword">this</span>.delegate = delegate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(<span class="keyword">final</span> Callback&lt;T&gt; callback)</span> </span>&#123;</span><br><span class="line">      Objects.requireNonNull(callback, <span class="string">"callback == null"</span>);</span><br><span class="line"></span><br><span class="line">      delegate.enqueue(<span class="keyword">new</span> Callback&lt;T&gt;() &#123;...&#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>你可以将<code>ExecutorCallbackCall</code>当作是Wrapper，而真正去执行请求的源Source是<code>OkHttpCall</code>。之所以要有个Wrapper类，是希望在源Source操作时去做一些额外操作。这里的操作就是线程转换，将子线程切换到主线程上去。</p>
<p>enqueue()方法是异步的，也就是说，当你调用<code>OkHttpCall</code>的enqueue方法，回调的callback是在子线程中的，如果你希望在主线程接受回调，那需要通过Handler转换到主线程上去。<code>ExecutorCallbackCall</code>就是用来干这个事。当然以上是原生retrofit使用的切换线程方式。如果你用rxjava，那就不会用到这个<code>ExecutorCallbackCall</code>而是<code>RxJava</code>的Call了</p>
</li>
</ul>
<ul>
<li><p>适配器模式</p>
<p>适配器模式把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起的两个类能够在一起工作(类似转接头)</p>
<p>再回来看看Retrofit，为什么我们需要转接头呢。那个被转换的是谁？我们看看<code>CallAdapter</code>的定义。<code>Adapts a {@link Call} into the type of {@code T}.</code> 这个Call是OkHttpCall，它不能被我们直接使用吗？被转换后要去实现什么特殊的功能吗？</p>
<p>我们假设下。一开始，retrofit只打算在android上使用，那就通过静态代理<code>ExecutorCallbackCall</code>来切换线程。但是后来发现rxjava挺好用啊，这样就不需要Handler来切换线程了嘛。想要实现，那得转换一下。将<code>OkHttpCall</code>转换成rxjava(<code>Scheduler</code>)的写法。再后来又支持了java8(<code>CompletableFuture</code>)。大概就是这样一个套路。</p>
<p>适配器模式就是，已经存在的<code>OkHttpCall</code>，要被不同的标准，平台来调用。设计了一个接口<code>CallAdapter</code>，让其他平台都是做不同的实现来转换，这样不花很大的代价就能再兼容一个平台</p>
</li>
<li><p>策略模式</p>
<p>策略模式定义了一系列算法，并将每一个算法封装起来，而且使他们还可以互相替换。策略模式让算法独立于使用它的客户而独立变化。</p>
<p>使用场景：</p>
<p>针对同一类型问题的多种处理方式，仅仅是具体行为有差别时</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">- <span class="keyword">private</span> CallAdapter&lt;Observable&lt;?&gt;&gt; getCallAdapter(Type returnType, Scheduler scheduler) &#123;  </span><br><span class="line">  Type observableType = getParameterUpperBound(<span class="number">0</span>, (ParameterizedType) returnType);  </span><br><span class="line">  Class&lt;?&gt; rawObservableType = getRawType(observableType);</span><br><span class="line">  <span class="keyword">if</span> (rawObservableType == Response<span class="class">.<span class="keyword">class</span>) </span>&#123;    </span><br><span class="line">    <span class="keyword">if</span> (!(observableType <span class="keyword">instanceof</span> ParameterizedType)) &#123;  </span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Response must be parameterized"</span>     </span><br><span class="line">           + <span class="string">" as Response&lt;Foo&gt; or Response&lt;? extends Foo&gt;"</span>); </span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">Type responseType=getParameterUpperBound(<span class="number">0</span>,(ParameterizedType)observableType);   </span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> ResponseCallAdapter(responseType, scheduler);  </span><br><span class="line">&#125; </span><br><span class="line"> <span class="keyword">if</span> (rawObservableType == Result<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(observableType <span class="keyword">instanceof</span> ParameterizedType))</span><br><span class="line">   &#123;      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Result must be parameterized"</span>     </span><br><span class="line">    + <span class="string">" as Result&lt;Foo&gt; or Result&lt;? extends Foo&gt;"</span>);    </span><br><span class="line">   &#125;    </span><br><span class="line">      Type responseType = getParameterUpperBound(<span class="number">0</span>, (ParameterizedType)observableType); </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ResultCallAdapter(responseType, scheduler);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> SimpleCallAdapter(observableType, scheduler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>看看retrofit中的CallAdapter是如何确立的？</p>
<p>它是根据api方法声明的returnType来创建具体的<code>CallAdapter</code>实例的</p>
<p>根据不同的策略使用不同的算法，不同的returnType声明就是set不同的Strategy</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/bog2/p2.webp" alt></p>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Viewpager与Fragment那些事儿</title>
    <url>/blog/2020/06/activity-fragment-things.html</url>
    <content><![CDATA[<h3 id="Viewpager与Fragment结合问题"><a href="#Viewpager与Fragment结合问题" class="headerlink" title="Viewpager与Fragment结合问题"></a>Viewpager与Fragment结合问题</h3><p>ViewPager + Fragment常见用法如下：<br><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">FragmentActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">ViewPager</span> m_vp;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">ArrayList</span>&lt;<span class="type">Fragment</span>&gt; fragmentList;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> void onCreate(<span class="type">Bundle</span> savedInstanceState) &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(<span class="type">R</span>.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        m_vp = (<span class="type">ViewPager</span>)findViewById(<span class="type">R</span>.id.viewpager);</span><br><span class="line"></span><br><span class="line">        mfragment1 = <span class="keyword">new</span> fragment1();</span><br><span class="line">        mfragment2 = <span class="keyword">new</span> fragment2();</span><br><span class="line">        mfragment3 = <span class="keyword">new</span> fragment3();</span><br><span class="line"></span><br><span class="line">        fragmentList = <span class="keyword">new</span> <span class="type">ArrayList</span>&lt;<span class="type">Fragment</span>&gt;();</span><br><span class="line">        fragmentList.add(mfragment1);</span><br><span class="line">        fragmentList.add(mfragment2);</span><br><span class="line">        fragmentList.add(mfragment3);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        m_vp.setAdapter(<span class="keyword">new</span> <span class="type">MyViewPagerAdapter</span>(getSupportFragmentManager()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="class"><span class="keyword">class</span> <span class="title">MyViewPagerAdapter</span> <span class="keyword">extends</span> <span class="title">FragmentPagerAdapter</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        public <span class="type">Fragment</span> getItem(int arg0) &#123;</span><br><span class="line">            <span class="keyword">return</span> fragmentList.get(arg0);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        public int getCount() &#123;</span><br><span class="line">            <span class="keyword">return</span> fragmentList.size();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>很多同学都喜欢这么写，然后还经常通过 adapter.getItem(pos)去获取对应的 fragment。<br>这种写法其实是存在很大的问题的。</p>
<p>那么问题是:<br>1.这种写法在什么情况下，会造成异常（问题以及对应的场景）？<br>2.造成该问题的原因是（原理）？<br>3.更好的写法应该是，（提供根据 position 获取对应 Fragment 方法）。</p>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>ViewPager所属Activity被Destroy（非主动finish）后重新初始化过程中，此时新创建的Fragment实例并不会在ViewPager中显示。</p>
<h4 id="为什么会这样呢？"><a href="#为什么会这样呢？" class="headerlink" title="为什么会这样呢？"></a>为什么会这样呢？</h4><p>先来看看我们定义Adapter时重写的getItem方法是在哪里被调用的<br><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">instantiateItem</span><span class="params">(@NonNull ViewGroup container, <span class="keyword">int</span> <span class="built_in">position</span>)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> itemId = getItemId(<span class="built_in">position</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do we already have this fragment?</span></span><br><span class="line">    <span class="keyword">String</span> name = makeFragmentName(container.getId(), itemId);</span><br><span class="line"></span><br><span class="line">    Fragment fragment = mFragmentManager.findFragmentByTag(name);</span><br><span class="line">    <span class="keyword">if</span> (fragment != null) &#123;</span><br><span class="line">        mCurTransaction.<span class="built_in">attach</span>(fragment);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fragment = getItem(<span class="built_in">position</span>);</span><br><span class="line">        mCurTransaction.add(container.getId(), fragment, makeFragmentName(container.getId(), itemId));</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> fragment;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在instantiateItem方法中，我们重写的getItem方法竟然不是每次都会被调用的！它会先判断FragmentManager是否已添加了目标Fragment（findFragmentByTag），如果已经添加了的话，就会把它取出来并重新关联上，而getItem方法就不会被调用了。</p>
<p>如果从FragmentManager中找不到的话，才会调用getItem获取目标Fragment，然后通过事务来添加进去</p>
<p>好，总结一下：</p>
<ul>
<li>在FragmentPagerAdapter的instantiateItem方法（这个方法会在ViewPager滑动状态变更时调用）中，每个position所对应的Fragment只会添加一次到FragmentManager里面，也就是说，我们在Adapter中重写的getItem方法，它的参数position不会出现两次相同的值。</li>
<li>当Fragment被添加时，会给这个Fragment指定一个根据itemId来区分的tag，而这个itemId就是根据getItemId方法来获取的，默认就是当前页面的索引值。</li>
</ul>
<h4 id="如何避免"><a href="#如何避免" class="headerlink" title="如何避免"></a>如何避免</h4><p>使用sparsearray 保存fragment，重写instantiateItem，destroyItem，在两个方法里面去增、删fragment。在getItem的时候，new 对应的fragment。</p>
<h3 id="FragmentStatePagerAdapter与"><a href="#FragmentStatePagerAdapter与" class="headerlink" title="FragmentStatePagerAdapter与"></a>FragmentStatePagerAdapter与</h3><p>在生产环境使用FragmentStatePagerAdapter有上报如下日志<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">java<span class="selector-class">.lang</span><span class="selector-class">.RuntimeException</span>: android<span class="selector-class">.os</span><span class="selector-class">.TransactionTooLargeException</span>: data parcel size <span class="number">20975512</span> bytes</span><br><span class="line">    at android<span class="selector-class">.app</span><span class="selector-class">.servertransaction</span>.PendingTransactionActions<span class="variable">$StopInfo</span>.run(PendingTransactionActions<span class="selector-class">.java</span>:<span class="number">161</span>)</span><br><span class="line">    at android<span class="selector-class">.os</span><span class="selector-class">.Handler</span>.handleCallback(Handler<span class="selector-class">.java</span>:<span class="number">883</span>)</span><br><span class="line">    at android<span class="selector-class">.os</span><span class="selector-class">.Handler</span>.dispatchMessage(Handler<span class="selector-class">.java</span>:<span class="number">100</span>)</span><br><span class="line">    at android<span class="selector-class">.os</span><span class="selector-class">.Looper</span>.loop(Looper<span class="selector-class">.java</span>:<span class="number">214</span>)</span><br><span class="line">    at android<span class="selector-class">.app</span><span class="selector-class">.ActivityThread</span>.main(ActivityThread<span class="selector-class">.java</span>:<span class="number">7356</span>)</span><br><span class="line">    at java<span class="selector-class">.lang</span><span class="selector-class">.reflect</span><span class="selector-class">.Method</span>.invoke(Native Method)</span><br><span class="line">    at com<span class="selector-class">.android</span><span class="selector-class">.internal</span><span class="selector-class">.os</span>.RuntimeInit<span class="variable">$MethodAndArgsCaller</span>.run(RuntimeInit<span class="selector-class">.java</span>:<span class="number">492</span>)</span><br><span class="line">    at com<span class="selector-class">.android</span><span class="selector-class">.internal</span><span class="selector-class">.os</span><span class="selector-class">.ZygoteInit</span>.main(ZygoteInit<span class="selector-class">.java</span>:<span class="number">930</span>)</span><br></pre></td></tr></table></figure></p>
<p>定位到PendingTransactionActions,分析崩溃栈，找出引发该问题的binder调用是ActivityManagerProxy.activityStopped，从中大概推知问题的发生时机在Activity stopped的时候<br>网上百度相关的解决方案，关键词是TransactionTooLargeException activityStopped，现象类似的问题、原因、解决方案如下：</p>
<p>问题原因：FragmentStatePagerAdapter的实现有缺陷，因为其默认实现会持续保存历史Fragment实例的状态数据历史，在逐渐地积累、保存数据后，最终导致发送的数据包体积超过限制200KB<br><strong>定位辅助</strong><br>获取Parcel类型数据大小，判断传递的数据是否偏大<br><figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">Parcel parcel = Parcel.obtain()<span class="comment">;</span></span><br><span class="line">int size<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">parcel.writeBundle(mState)<span class="comment">;</span></span><br><span class="line"><span class="attribute">size</span> = parcel.dataSize()<span class="comment">;</span></span><br><span class="line">parcel.recycle()<span class="comment">;</span></span><br><span class="line">return size<span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>通过以上方法可以确定传递给binder的mState对象的大小.</p>
<p><strong>解决方案</strong><br>重写FragmentStatePagerAdapter的saveState方法，使其不保存历史Fragment实例的状态数据。<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">saveState</span><span class="params">()</span></span>: Parcelable? &#123;</span><br><span class="line">        <span class="keyword">val</span> bundle = <span class="keyword">super</span>.saveState() <span class="keyword">as</span> Bundle?</span><br><span class="line">        bundle?.putParcelableArray(<span class="string">"states"</span>, <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> bundle</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="FragmentPagerAdapter和FragmentStatePagerAdapter区别"><a href="#FragmentPagerAdapter和FragmentStatePagerAdapter区别" class="headerlink" title="FragmentPagerAdapter和FragmentStatePagerAdapter区别"></a>FragmentPagerAdapter和FragmentStatePagerAdapter区别</h3><h4 id="区别1：状态保存"><a href="#区别1：状态保存" class="headerlink" title="区别1：状态保存"></a>区别1：状态保存</h4><p>根据两个类的名称就可以知道FragmentStatePagerAdapter似乎是保存状态的，我们分别去这两个类找下它们的区别，发现它们都重写了父类PageAdapter的方法:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">PagerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略 </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> POSITION_UNCHANGED = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> POSITION_NONE = -<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Parcelable <span class="title">saveState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">restoreState</span><span class="params">(Parcelable state, ClassLoader loader)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>分别查看它们的实现：</p>
<p>FragmentPagerAdapter的实现<br><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function">Parcelable <span class="title">saveState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">restoreState</span><span class="params">(Parcelable state, ClassLoader loader)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>FragmentStatePagerAdapter的实现</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Parcelable saveState() &#123;</span><br><span class="line">       Bundle state = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">if</span> (mSavedState.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           state = <span class="keyword">new</span> Bundle();</span><br><span class="line">           Fragment.SavedState[] fss = <span class="keyword">new</span> Fragment.SavedState[mSavedState.<span class="built_in">size</span>()];</span><br><span class="line">           mSavedState.toArray(fss);</span><br><span class="line">           state.putParcelableArray(<span class="string">"states"</span>, fss);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span> (<span class="built_in">int</span> i=<span class="number">0</span>; i&lt;mFragments.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">           Fragment f = mFragments.<span class="built_in">get</span>(i);</span><br><span class="line">           <span class="keyword">if</span> (f != <span class="keyword">null</span> &amp;&amp; f.isAdded()) &#123;</span><br><span class="line">               <span class="keyword">if</span> (state == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   state = <span class="keyword">new</span> Bundle();</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">String</span> <span class="built_in">key</span> = <span class="string">"f"</span> + i;</span><br><span class="line">               mFragmentManager.putFragment(state, <span class="built_in">key</span>, f);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> state;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> restoreState(Parcelable state, ClassLoader loader) &#123;</span><br><span class="line">       <span class="keyword">if</span> (state != <span class="keyword">null</span>) &#123;</span><br><span class="line">           Bundle bundle = (Bundle)state;</span><br><span class="line">           bundle.setClassLoader(loader);</span><br><span class="line">           Parcelable[] fss = bundle.getParcelableArray(<span class="string">"states"</span>);</span><br><span class="line">           mSavedState.<span class="built_in">clear</span>();</span><br><span class="line">           mFragments.<span class="built_in">clear</span>();</span><br><span class="line">           <span class="keyword">if</span> (fss != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">for</span> (<span class="built_in">int</span> i=<span class="number">0</span>; i&lt;fss.length; i++) &#123;</span><br><span class="line">                   mSavedState.<span class="built_in">add</span>((Fragment.SavedState)fss[i]);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           Iterable&lt;<span class="keyword">String</span>&gt; keys = bundle.keySet();</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">String</span> <span class="built_in">key</span>: keys) &#123;</span><br><span class="line">               <span class="keyword">if</span> (<span class="built_in">key</span>.startsWith(<span class="string">"f"</span>)) &#123;</span><br><span class="line">                   <span class="built_in">int</span> index = Integer.parseInt(<span class="built_in">key</span>.substring(<span class="number">1</span>));</span><br><span class="line">                   Fragment f = mFragmentManager.getFragment(bundle, <span class="built_in">key</span>);</span><br><span class="line">                   <span class="keyword">if</span> (f != <span class="keyword">null</span>) &#123;</span><br><span class="line">                       <span class="keyword">while</span> (mFragments.<span class="built_in">size</span>() &lt;= index) &#123;</span><br><span class="line">                           mFragments.<span class="built_in">add</span>(<span class="keyword">null</span>);</span><br><span class="line">                       &#125;</span><br><span class="line">                       f.setMenuVisibility(<span class="keyword">false</span>);</span><br><span class="line">                       mFragments.<span class="built_in">set</span>(index, f);</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       Log.w(TAG, <span class="string">"Bad fragment at key "</span> + <span class="built_in">key</span>);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>可以很容易看出只有FragmentStatePagerAdapter对Fragment的状态进行了保存，而FragmentPagerAdapter则是空实现。<br>FragmentStatePagerAdapter可以保存和恢复Fragment的状态</p>
<h4 id="区别二-实例销毁-vs-视图销毁"><a href="#区别二-实例销毁-vs-视图销毁" class="headerlink" title="区别二: 实例销毁 vs 视图销毁"></a>区别二: 实例销毁 vs 视图销毁</h4><p>除了上面的区别外，FragmentStatePagerAdapter和FragmentPagerAdapter唯一的区别就是对Fragment对象的处理了。</p>
<p>我们平常使用ViewPager + PageAdater时候需要重写很多方法，如开头的那几个案例，而ViewPager + FragmentPagerAdapter(FragmentStatePagerAdapter) 仅仅实现getItem和getCount两个方法就够了，核心方法instantiateItem和destroyItem内部已经做好了实现。</p>
<p>先看FragmentStatePagerAdapter类</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> ArrayList&lt;Fragment&gt; mFragments = <span class="keyword">new</span> ArrayList&lt;Fragment&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">instantiateItem</span><span class="params">(ViewGroup container, <span class="keyword">int</span> <span class="built_in">position</span>)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (mFragments.<span class="built_in">size</span>() &gt; <span class="built_in">position</span>) &#123;</span><br><span class="line">           Fragment f = mFragments.<span class="built_in">get</span>(<span class="built_in">position</span>);</span><br><span class="line">           <span class="keyword">if</span> (f != null) &#123;</span><br><span class="line">               <span class="keyword">return</span> f;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (mCurTransaction == null) &#123;</span><br><span class="line">           mCurTransaction = mFragmentManager.beginTransaction();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 实例化fragment(交给我们实现的getItem方法)</span></span><br><span class="line">       Fragment fragment = getItem(<span class="built_in">position</span>);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (mSavedState.<span class="built_in">size</span>() &gt; <span class="built_in">position</span>) &#123;</span><br><span class="line">           Fragment.SavedState fss = mSavedState.<span class="built_in">get</span>(<span class="built_in">position</span>);</span><br><span class="line">           <span class="keyword">if</span> (fss != null) &#123;</span><br><span class="line">               fragment.setInitialSavedState(fss);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 如果缓存 &lt;= ViewPager传入的position,说明当前位置还未存入缓存.</span></span><br><span class="line">       <span class="keyword">while</span> (mFragments.<span class="built_in">size</span>() &lt;= <span class="built_in">position</span>) &#123;</span><br><span class="line">           <span class="comment">// 先占个坑</span></span><br><span class="line">           mFragments.add(null);</span><br><span class="line">       &#125;</span><br><span class="line">       fragment.setUserVisibleHint(<span class="literal">false</span>);</span><br><span class="line">       <span class="comment">// 填坑</span></span><br><span class="line">       mFragments.<span class="built_in">set</span>(<span class="built_in">position</span>, fragment);</span><br><span class="line">       <span class="comment">// 填充视图</span></span><br><span class="line">       mCurTransaction.add(container.getId(), fragment);</span><br><span class="line">       <span class="keyword">return</span> fragment;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroyItem</span><span class="params">(ViewGroup container, <span class="keyword">int</span> <span class="built_in">position</span>, Object object)</span> </span>&#123;</span><br><span class="line">       Fragment fragment = (Fragment) object;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (mCurTransaction == null) &#123;</span><br><span class="line">           mCurTransaction = mFragmentManager.beginTransaction();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 从缓存中移除</span></span><br><span class="line">       mFragments.<span class="built_in">set</span>(<span class="built_in">position</span>, null);</span><br><span class="line">       <span class="comment">// 从FragmentManager中移除</span></span><br><span class="line">       mCurTransaction.<span class="built_in">remove</span>(fragment);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>再来看下FragmentPagerAdapter的两个实现方法：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">instantiateItem</span><span class="params">(ViewGroup container, <span class="keyword">int</span> <span class="built_in">position</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mCurTransaction == null) &#123;</span><br><span class="line">        mCurTransaction = mFragmentManager.beginTransaction();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> itemId = getItemId(<span class="built_in">position</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do we already have this fragment?</span></span><br><span class="line">    <span class="keyword">String</span> name = makeFragmentName(container.getId(), itemId);</span><br><span class="line">    Fragment fragment = mFragmentManager.findFragmentByTag(name);</span><br><span class="line">    <span class="keyword">if</span> (fragment != null) &#123;</span><br><span class="line">        mCurTransaction.<span class="built_in">attach</span>(fragment);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fragment = getItem(<span class="built_in">position</span>);</span><br><span class="line">        mCurTransaction.add(container.getId(), fragment,</span><br><span class="line">                makeFragmentName(container.getId(), itemId));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fragment != mCurrentPrimaryItem) &#123;</span><br><span class="line">        fragment.setMenuVisibility(<span class="literal">false</span>);</span><br><span class="line">        fragment.setUserVisibleHint(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fragment;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroyItem</span><span class="params">(ViewGroup container, <span class="keyword">int</span> <span class="built_in">position</span>, Object object)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mCurTransaction == null) &#123;</span><br><span class="line">        mCurTransaction = mFragmentManager.beginTransaction();</span><br><span class="line">    &#125;</span><br><span class="line">    mCurTransaction.<span class="built_in">detach</span>((Fragment)object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出：<br>FragmentStatePagerAdapter</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">mCurTransaction.<span class="builtin-name">add</span>(container.getId(), fragment);</span><br><span class="line">mCurTransaction.<span class="builtin-name">remove</span>(fragment);</span><br></pre></td></tr></table></figure>
<p>和FragmentPagerAdapter</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">mCurTransaction</span><span class="selector-class">.attach</span>(<span class="selector-tag">fragment</span>);</span><br><span class="line"><span class="selector-tag">mCurTransaction</span><span class="selector-class">.add</span>(<span class="selector-tag">container</span><span class="selector-class">.getId</span>(), <span class="selector-tag">fragment</span>,<span class="selector-tag">makeFragmentName</span>(<span class="selector-tag">container</span><span class="selector-class">.getId</span>(), <span class="selector-tag">itemId</span>));</span><br><span class="line"><span class="selector-tag">mCurTransaction</span><span class="selector-class">.detach</span>((<span class="selector-tag">Fragment</span>)<span class="selector-tag">object</span>);</span><br></pre></td></tr></table></figure>
<p>很明显，FragmentStatePagerAdapter 对fragment进行完全的添加和删除操作，而FragmentPagerAdapter 则是对视图进行attach和detach。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>FragmentStatePagerAdapter 适合大量页面，不断重建和销毁<br>FragmentPagerAdapter 适合少量页面，常驻内存。</p>
<p>参考链接：<br><a href="https://wanandroid.com/wenda/show/12424" target="_blank" rel="noopener">https://wanandroid.com/wenda/show/12424</a><br><a href="https://www.jianshu.com/p/4840994e3c43" target="_blank" rel="noopener">https://www.jianshu.com/p/4840994e3c43</a></p>
<p><strong>Fragment相关每日一问</strong><br><a href="https://wanandroid.com/wenda/show/13906" target="_blank" rel="noopener">https://wanandroid.com/wenda/show/13906</a><br><a href="https://wanandroid.com/wenda/show/13775" target="_blank" rel="noopener">https://wanandroid.com/wenda/show/13775</a><br><a href="https://www.wanandroid.com/wenda/show/12574" target="_blank" rel="noopener">https://www.wanandroid.com/wenda/show/12574</a><br><a href="https://wanandroid.com/wenda/show/12424" target="_blank" rel="noopener">https://wanandroid.com/wenda/show/12424</a><br><a href="https://www.wanandroid.com/wenda/show/11077" target="_blank" rel="noopener">https://www.wanandroid.com/wenda/show/11077</a></p>
<p><a href="https://www.jianshu.com/p/309af7276e1e" target="_blank" rel="noopener">https://www.jianshu.com/p/309af7276e1e</a><br><a href="https://www.jianshu.com/p/4840994e3c43" target="_blank" rel="noopener">https://www.jianshu.com/p/4840994e3c43</a><br>viewModel如何自动保存与恢复</p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>你能回答吗？</title>
    <url>/blog/2020/06/can-you-answer.html</url>
    <content><![CDATA[<p><strong>项目中存在什么问题，如何解决，以及你做了什么</strong></p>
<p>1.线程池的工作原理<br><a href="https://blog.csdn.net/aitangyong/article/details/38822505" target="_blank" rel="noopener">https://blog.csdn.net/aitangyong/article/details/38822505</a><br><a href="https://juejin.im/post/5b3cf259e51d45194e0b7204#heading-11" target="_blank" rel="noopener">https://juejin.im/post/5b3cf259e51d45194e0b7204#heading-11</a></p>
<p>2.synchronized锁方法和锁静态方法有什么区别？<br><a href="https://blog.csdn.net/u010842515/article/details/65443084" target="_blank" rel="noopener">https://blog.csdn.net/u010842515/article/details/65443084</a></p>
<p>3.锁的理解，什么是乐观锁，悲观锁，可重入锁<br><a href="https://blog.csdn.net/sinat_31057219/article/details/86540873" target="_blank" rel="noopener">https://blog.csdn.net/sinat_31057219/article/details/86540873</a><br>深入java虚拟机</p>
<p>4.View的事件分发流程</p>
<p>5.View的三种测量模式理解，什么时候会发生Exactly</p>
<p>6.HashMap的工作原理</p>
<p>7.怎么实现多线程下载，断点续传怎么实现<br>多线程下载实现的基本步骤如下:<a href="https://blog.csdn.net/u011277123/article/details/78913639" target="_blank" rel="noopener">https://blog.csdn.net/u011277123/article/details/78913639</a><br>断点续传：<a href="https://blog.csdn.net/zhuyu19911016520/article/details/53483149" target="_blank" rel="noopener">https://blog.csdn.net/zhuyu19911016520/article/details/53483149</a></p>
<p>8.rxjava的背压了解吗</p>
<p>9.kotlin的协程，怎么做到和rxjava的zip操作一样，等待所有结果后再处理.</p>
<p>10.两个值相等的 Integer 对象，== 比较，判断是否相等？<br><a href="https://www.jianshu.com/p/fd379f268afa" target="_blank" rel="noopener">https://www.jianshu.com/p/fd379f268afa</a><br><a href="https://blog.csdn.net/weixin_38361347/article/details/81916620" target="_blank" rel="noopener">https://blog.csdn.net/weixin_38361347/article/details/81916620</a></p>
<p>11.两个值相等的String,==比较，判断是否相等<br>通过字符串赋值的，会有字符串常量池，所以是相等的<br>通过new新创建的对象则不相等<br><a href="https://blog.csdn.net/ifwinds/article/details/80849184" target="_blank" rel="noopener">https://blog.csdn.net/ifwinds/article/details/80849184</a></p>
<p>12.Object类有哪些方法<br><a href="https://www.cnblogs.com/NoPeach/p/8460810.html" target="_blank" rel="noopener">https://www.cnblogs.com/NoPeach/p/8460810.html</a><br>clone,hashcode,toString,getClass,equals,finalize<br>wait,notify,notifyAll</p>
<p>13.你重写过 hashcode 和 equals 么，为什么重写equals时必须重写hashCode方法<br><a href="https://juejin.im/post/5ceb5ec451882505107f63e9" target="_blank" rel="noopener">https://juejin.im/post/5ceb5ec451882505107f63e9</a><br><a href="https://blog.csdn.net/xyh269/article/details/69171545" target="_blank" rel="noopener">https://blog.csdn.net/xyh269/article/details/69171545</a></p>
<p>14.为什么String要设计成不可变的<br>1)String是值传递还是引用传递<br><a href="https://blog.csdn.net/party3/article/details/78648186" target="_blank" rel="noopener">https://blog.csdn.net/party3/article/details/78648186</a><br>2)为什么是不可变的<br><a href="https://github.com/Moosphan/Android-Daily-Interview/issues/153" target="_blank" rel="noopener">https://github.com/Moosphan/Android-Daily-Interview/issues/153</a></p>
]]></content>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>Binder通信机制详解</title>
    <url>/blog/2020/06/binder-singal-learn.html</url>
    <content><![CDATA[<p>Binder通信机制是app与系统服务通信的基础，也是android四大组件的基础.在Android系统中，大量采用了Binder机制作为IPC通信方案</p>
<h3 id="为什么使用Binder"><a href="#为什么使用Binder" class="headerlink" title="为什么使用Binder"></a>为什么使用Binder</h3><p>我们都知道,android是基于Linux的，Linux原有一些进程间通信方案，按理来说使用现成的跨进程通信方式是理所应当的，那么为什么还要自已设计一个呢？</p>
<ul>
<li><p>效率<br>在移动设备上（性能受限制的设备，比如要省电），广泛地使用跨进程通信对通信机制的性能有严格的要求，Binder相对出传统的Socket方式，更加高效。Binder数据拷贝只需要一次，而管道、消息队列、Socket都需要2次，共享内存方式一次内存拷贝都不需要，但实现方式又比较复杂。</p>
</li>
<li><p>安全<br>传统的跨进程通信方式安全性低，大部分情况下接收方无法得到发送方进程的可信PID/UID,比如Socket通信ip地址是客户端手动填入，很容易进行伪造，而Binder机制从协议本身就支持对通信双方做身份校检，因而大大提升了安全性。</p>
</li>
</ul>
<h3 id="binder的整体架构"><a href="#binder的整体架构" class="headerlink" title="binder的整体架构"></a>binder的整体架构</h3><p><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/bog2/p3.jpg" alt></p>
<p>binder 机制分为四部分，binder 驱动、Service Manager、客户端、服务端。类比网络通信，Service Manager 是 DNS，binder 驱动就是路由器.<br>应用程序运行在用户空间,binder 驱动运行在内核空间，不同进程间通过 binder 驱动才能通信</p>
<h4 id="Binder通信的四个角色"><a href="#Binder通信的四个角色" class="headerlink" title="Binder通信的四个角色"></a>Binder通信的四个角色</h4><p>Client进程：使用服务的进程。<br>Server进程：提供服务的进程。<br>ServiceManager进程：ServiceManager的作用是将字符形式的Binder名字转化成Client中对该Binder的引用，使得Client能够通过Binder名字获得对Server中Binder实体的引用。<br>Binder驱动：驱动负责进程之间Binder通信的建立，Binder在进程之间的传递，Binder引用计数管理，数据包在进程之间的传递和交互等一系列底层支持。</p>
<h4 id="Binder运行机制"><a href="#Binder运行机制" class="headerlink" title="Binder运行机制"></a>Binder运行机制</h4><p>图中Client/Server/ServiceManage之间的相互通信都是基于Binder机制。既然基于Binder机制通信，那么同样也是C/S架构，则图中的3大步骤都有相应的Client端与Server端。</p>
<p>注册服务(addService)：Server进程要先注册Service到ServiceManager。该过程：Server是客户端，ServiceManager是服务端。</p>
<p>获取服务(getService)：Client进程使用某个Service前，须先向ServiceManager中获取相应的Service。该过程：Client是客户端，ServiceManager是服务端。</p>
<p>使用服务：Client根据得到的Service信息建立与Service所在的Server进程通信的通路，然后就可以直接与Service交互。该过程：client是客户端，server是服务端。</p>
<p>图中的Client,Server,Service Manager之间交互都是虚线表示，是由于它们彼此之间不是直接交互的，而是都通过与Binder驱动进行交互的，从而实现IPC通信方式。其中Binder驱动位于内核空间，Client,Server,Service Manager位于用户空间。Binder驱动和Service Manager可以看做是Android平台的基础架构，而Client和Server是Android的应用层，开发人员只需自定义实现client、Server端，借助Android的基本平台架构便可以直接进行IPC通信。</p>
<h3 id="为什么binder只需要拷贝一次"><a href="#为什么binder只需要拷贝一次" class="headerlink" title="为什么binder只需要拷贝一次"></a>为什么binder只需要拷贝一次</h3><p>Client 与 Server 处于不同进程有着不同的虚拟地址规则，所以无法直接通信。而一个页框可以映射给多个页，那么通过mmap就可以将一块物理内存分别与 Client 和 Server 的虚拟内存块进行映射。</p>
<p><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/bog2/p4.webp" alt></p>
<p>如图， Client 就只需 copy_from_user 进行一次数据拷贝，Server 进程就能读取到数据了。另外映射的虚拟内存块大小将近 1M (1M-8K)，所以 IPC 通信传输的数据量也被限制为此值。<br>这也是Intent不能传递超过1M的值的原因</p>
<h4 id="怎么理解页框和页？"><a href="#怎么理解页框和页？" class="headerlink" title="怎么理解页框和页？"></a>怎么理解页框和页？</h4><p>页框是指一块实际的物理内存，页是指程序的一块内存数据单元。内存数据一定是存储在实际的物理内存上，即页必然对应于一个页框，页数据实际是存储在页框上的。</p>
<p>页框和页一样大，都是内核对内存的分块单位。一个页框可以映射给多个页，也就是说一块实际的物理存储空间可以映射给多个进程的多个虚拟内存空间，这也是 mmap 机制依赖的基础规则。</p>
<h3 id="AIDL使用"><a href="#AIDL使用" class="headerlink" title="AIDL使用"></a>AIDL使用</h3><p>AIDL的基本使用，详情可见：<a href="https://www.jianshu.com/p/467016b4487c" target="_blank" rel="noopener">https://www.jianshu.com/p/467016b4487c</a></p>
<p>其中有两个点需要注意一下：<br>1.Stub类：Binder的实现类，服务端需要实现这个类来提供服务。<br>2.asInterface函数： 一个静态函数，用来将IBinder转换成对应的Binder的引用。先通过queryLocalInterface查询，如果服务端和客户端都是在同一个进程，那么就不需要跨进程了，直接将IRemoteService当做普通的对象来使用，否则会返回远程对象的代理对象（Proxy）</p>
<p><strong>in、out &amp; inout</strong><br>这节我们看到“MyProcess getProcess(in MyProcess clientProcess);”这个接口的参数有一个“in”修饰符，这也是一个常见的面试题，可以考察一下对方是否真的写过AIDL的代码。</p>
<blockquote>
<p>问题：AIDL中的接口函数有时会使用in、out或者inout的参数修饰符，它们各表示什么意思？在什么情况下要使用呢？</p>
</blockquote>
<p>in、out和inout表示数据的流向。大家可以把AIDL的客户端和服务端理解成两个进程（其实大多数情况也是这样才会使用AIDL），从客户端流向服务端用in表示，表示这个对象是从客户端中传递到服务端，在服务端修改这个对象不会对客户端输入的对象产生影响。</p>
<p>而out则表示，数据只能从服务端影响客户端，即客户端输入这个参数时，服务端并不能获取到客户端的具体实例中的数据，而是生成一个默认数据，但是服务端对这个默认数据的修改会影响到客户端的这个类对象实例发生相应的改变。</p>
<p>理解了in、out之后，inout自然不需要再解释了。AIDL默认支持的数据类型使用in修饰符，对于我们自定义的Parcelable对象，一般情况下我们也是使用in，如果没有必要，应该尽量避免inout</p>
<p><strong>手写一个AIDL实现</strong><br>1.Binder<br>Binder本地对象。<br>2.IBinder<br>IBinder是一个接口，它代表了一种跨进程传输的能力。<br>3.IInterface<br>IBinder负责数据传输，那么client与server端的调用契约呢？这里的IInterface代表的就是远程server对象具有什么能力。具体来说，就是aidl里面的接口。<br>4.Proxy<br>代表远程进程的Binder对象的本地代理，继承自IBinder，因而具有跨进程传输的能力。实际上，在跨越进程的时候，Binder驱动会自动完成代理对象和本地对象的转换。<br>5.Stub<br>这个类继承了Binder, 说明它是一个Binder本地对象，它实现了IInterface接口，表明它具有远程Server承诺给Client的能力；Stub是一个抽象类，具体的IInterface的相关实现需要我们手动完成。</p>
<p><strong>binder与代理模式</strong><br>aidl用到的是远程代理模式，为客户端隐藏了IPC的细节。让客户端感觉好像拿到了一个服务器端对象的句柄。<br>详情可见：<a href="https://blog.csdn.net/safsasasa/article/details/18085871" target="_blank" rel="noopener">https://blog.csdn.net/safsasasa/article/details/18085871</a></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://www.jianshu.com/p/44905b7b0cdd" target="_blank" rel="noopener">https://www.jianshu.com/p/44905b7b0cdd</a><br><a href="https://blog.csdn.net/singwhatiwanna/article/details/106654258" target="_blank" rel="noopener">https://blog.csdn.net/singwhatiwanna/article/details/106654258</a><br><a href="https://blog.csdn.net/augfun/article/details/82343249" target="_blank" rel="noopener">https://blog.csdn.net/augfun/article/details/82343249</a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>资源总结</title>
    <url>/blog/2020/06/resource-sum-up.html</url>
    <content><![CDATA[<h3 id="学习方法"><a href="#学习方法" class="headerlink" title="学习方法"></a>学习方法</h3><p>1.记住要点难点<br>2.复述复习<br>3.学完一个内容后，写博客，画思维导读</p>
<p>学习遗漏<br>1.并发AQS<br>2.垃圾回收器cms,g1等<br>3.读写锁与volatile</p>
<h3 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h3><p><a href="https://carlwe.com/2019/01/11/%E6%B5%85%E8%B0%88Android%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/" target="_blank" rel="noopener">浅谈Android内存优化</a><br><a href="https://juejin.im/post/5d3ada056fb9a07eb94fd1bc" target="_blank" rel="noopener">探索Android内存优化方法</a><br><a href="https://blog.csdn.net/weixin_43691723/article/details/106771107" target="_blank" rel="noopener">深入理解Java虚拟机（超级详细）</a><br><a href="https://mp.weixin.qq.com/s/BNDBgVHfPq0WpFs1g_xmoA" target="_blank" rel="noopener">吹爆系列：深入探索Android卡顿优化</a><br><a href="https://jsonchao.github.io/" target="_blank" rel="noopener">Deep into Android–jsonchao的博客</a></p>
<h3 id="面经"><a href="#面经" class="headerlink" title="面经"></a>面经</h3><p><a href="https://www.jianshu.com/p/5e5908ab3ea9" target="_blank" rel="noopener">2020 最新 - 今日头条 Android 面试题及答案 (已拿到 offer)</a><br><a href="https://carlwe.com/2019/12/07/Android%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86%E9%94%A6/" target="_blank" rel="noopener">Android面试题集锦</a><br><a href="https://blog.csdn.net/zhying719/article/details/106913185" target="_blank" rel="noopener">三年Android开发，跳槽腾讯音乐，历经三面终获Offer，定级T2-1（超全面试题+学习经验总结）</a><br><a href="https://juejin.im/post/5eb586d06fb9a04359028fd4" target="_blank" rel="noopener">Android| 小厂跳大厂,我是如何拿到腾讯头条美团小米的offer的</a><br><a href="https://www.jianshu.com/p/20754b1adb4d" target="_blank" rel="noopener">Android面试相关文章以及github整理</a><br><a href="https://juejin.im/post/5bf212a46fb9a049de6cf57c#heading-3" target="_blank" rel="noopener">简历书写与面试–重要</a><br><a href="https://github.com/Moosphan/Android-Daily-Interview" target="_blank" rel="noopener">每日一道面试题</a><br><a href="https://github.com/yangkun19921001/Blog" target="_blank" rel="noopener">Android 高级开发面试宝典</a><br><a href="https://www.zhihu.com/people/zzxiao-xiao-66" target="_blank" rel="noopener">字节跳动面经</a><br><a href="https://github.com/CyC2018/Markdown-Resume" target="_blank" rel="noopener">markdown简历模板</a><br><a href="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode" target="_blank" rel="noopener">Android-ReadTheFuckingSourceCode</a></p>
<h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><p>webview性能优化也可以提一下：<a href="https://juejin.im/post/5deb7e9751882512756e82d1" target="_blank" rel="noopener">https://juejin.im/post/5deb7e9751882512756e82d1</a></p>
<h3 id="前端问题"><a href="#前端问题" class="headerlink" title="前端问题"></a>前端问题</h3><p><a href="https://www.jianshu.com/p/6d8b0cab3156" target="_blank" rel="noopener">vue生命周期</a></p>
<h3 id="待学习内容"><a href="#待学习内容" class="headerlink" title="待学习内容"></a>待学习内容</h3><p>1.HashMap原理与内容<br>为什么重写equals之后还要重写hashCode</p>
<p>2.快速排序原理与实现<br>递归与非递归两种实现，原理，最坏情况</p>
<p>3.二叉树遍历<br>前中后遍历，递归非递归实现.</p>
<p>4.3次握手与4次握手<br><a href="https://yuanrengu.com/2020/77eef79f.html" target="_blank" rel="noopener">https://yuanrengu.com/2020/77eef79f.html</a></p>
<h3 id="极客时间"><a href="#极客时间" class="headerlink" title="极客时间"></a>极客时间</h3><p><a href="https://shimo.im/docs/3jyqJ6HPJkQCWGvX" target="_blank" rel="noopener">阿里、百度前端面经分享</a><br><a href="https://shimo.im/docs/GRj9XypPXRqxkdtk/" target="_blank" rel="noopener">头条、蚂蚁金服面经分享</a><br><a href="https://shimo.im/docs/YdXr6JYkdxD8yCck" target="_blank" rel="noopener">作为面试官，我是怎么考察候选人的</a></p>
<h3 id="其他资源"><a href="#其他资源" class="headerlink" title="其他资源"></a>其他资源</h3><p><a href="http://www.xwood.net/_site_domain_/_root/5870/5930/5932/t_c265267.html" target="_blank" rel="noopener">电子书下载</a></p>
]]></content>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>Jvm与字节码插桩</title>
    <url>/blog/2020/06/jvm-bytecode-stub.html</url>
    <content><![CDATA[<h3 id="编译插桩是什么"><a href="#编译插桩是什么" class="headerlink" title="编译插桩是什么"></a>编译插桩是什么</h3><p>顾名思义，所谓编译插桩就是在代码编译期间修改已有的代码或者生成新代码。实际上，我们项目中经常用到的 Dagger、ButterKnife 甚至是 Kotlin 语言，它们都用到了编译插桩的技术。</p>
<p>理解编译插桩之前，需要先回顾一下 Android 项目中 .java 文件的编译过程：<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog3/p6.png" alt></p>
<p>从上图可以看出，我们可以在 1、2 两处对代码进行改造。<br>1.在 .java 文件编译成 .class 文件时，APT、AndroidAnnotation 等就是在此处触发代码生成。<br>2.在 .class 文件进一步优化成 .dex 文件时，也就是直接操作字节码文件，也是本次主要介绍的内容。这种方式功能更加强大，应用场景也更多。但是门槛比较高，需要对字节码有一定的理解。</p>
<p>本次主要介绍第 2 种实现方式，用一张图来描述如下过程<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog3/p7.png" alt><br>一般情况下，我们经常会使用编译插桩实现如下几种功能：<br>日志埋点；<br>性能监控；<br>动态权限控制；<br>业务逻辑跳转时，校验是否已经登录；<br>甚至是代码调试等。</p>
<p>我们都知道在java文件的通过javac编译后会生成十六进制的class文件，比如我们先编写一个简单的Test.java文件<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span></span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x=<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> y=<span class="number">5</span>;</span><br><span class="line">        <span class="keyword">int</span> z=(x+y)*<span class="number">10</span>;</span><br><span class="line">        <span class="keyword">return</span> z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后我们通过 javac Test.java -g来编译为Test.class,用文本编辑器打开如下：<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog3/p8.webp" alt></p>
<p>可以看到是一堆十六进制数，但是其实这一堆十六进制数是按严格的结构拼接在一起的，按顺序分别是：魔数(cafe babe)、java版本号、常量池、访问权限标志、当前类索引、父类索引、接口索引、字段表、方法表、附加属性等十个部分，这些部分以十六进制的形式表达出来并紧凑的拼接在一起，就是上面看到的class字节码文件。<br>当然上面的十六进制文件显然不具备可阅读性，所以我们可以通过 javap -verbose Test来反编译，有兴趣的可以自己试一试，就可以看到上面说的十个部分，由于我们做字节码插桩一般和方法表关联比较大，所以我们下面着重看一下方法表，下面是反编译后的work()方法</p>
<p>由于JVM指令集是基于栈的，上面我们已经了解到了work方法的逻辑编译为class文件后变成了个指令操作码，下面我们简单看看这些指令操作码是如何配合操作数栈+本地变量表+常量池来执行add方法的逻辑的<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog3/p9.webp" alt></p>
<p>按顺序执行以下指令操作码</p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line"><span class="comment">//int x=3;</span></span><br><span class="line">iconst_3    	将int型<span class="number">3</span> 入操作数栈</span><br><span class="line">istore_1   		将操作数栈中栈顶int型数值，存入局部变量表（下标为<span class="number">1</span>的位置）</span><br><span class="line"><span class="comment">//int y=5;</span></span><br><span class="line">iconst_5     	将int型<span class="number">5</span> 入操作数栈</span><br><span class="line">istore_2   		将操作数栈中栈顶int型数值，存入局部变量表（下标为<span class="number">2</span>的位置）</span><br><span class="line"><span class="comment">// int z=(x+y)*10;</span></span><br><span class="line">iload_1    		将局部变量表中下标为<span class="number">1</span>的int型数据入栈</span><br><span class="line">iload_2    		将局部变量表中下标为<span class="number">2</span>的int型数据入栈</span><br><span class="line">iadd     		<span class="number">1</span>)将栈顶两int型数值出栈 <span class="number">2</span>)相加 <span class="number">3</span>)并将结果压入操作数栈</span><br><span class="line">bipush  <span class="number">10</span>    	<span class="number">10</span>的值扩展成int值入操作数栈</span><br><span class="line">imul        		<span class="number">1</span>)将栈顶两int型数值出栈 <span class="number">2</span>)相乘<span class="number">3</span>)并将结果压入操作数栈</span><br><span class="line">istore_3   		将操作数栈中栈顶int型数值，存入局部变量表（下标为<span class="number">3</span>的位置）</span><br><span class="line"><span class="comment">//  return z;  </span></span><br><span class="line">iload_3   		将局部变量表中下标为<span class="number">3</span>的int型数据入栈</span><br><span class="line">ireturn</span><br></pre></td></tr></table></figure>
<h3 id="通过ASM实现字节码插桩"><a href="#通过ASM实现字节码插桩" class="headerlink" title="通过ASM实现字节码插桩"></a>通过ASM实现字节码插桩</h3><p>ASM是一个十分强大的字节码处理框架，基本上可以实现任何对字节码的操作，也就是自由度和开发的掌控度很高，但是其相对来说比AspectJ上手难度要高，需要对Java字节码有一定了解，不过ASM为我们提供了访问者模式来访问字节码文件，这种模式下可以比较简单的做一些字节码操作，实现一些功能。同时ASM可以精确的只注入我们想要注入的代码，不会额外生成一些包装代码，所以性能上影响比较微小。</p>
<p>asm实现在添加了注解前的方法前后打印时间的功能<br>demo详情可见：<a href="https://github.com/shenzhen2017/ASMDemo" target="_blank" rel="noopener">https://github.com/shenzhen2017/ASMDemo</a><br>asm与transformApi结合demo: <a href="https://github.com/McoyJiang/LagouAndroidShare/tree/master/course04_%E6%93%8D%E7%BA%B5%E5%AD%97%E8%8A%82%E7%A0%81" target="_blank" rel="noopener">https://github.com/McoyJiang/LagouAndroidShare/tree/master/course04_%E6%93%8D%E7%BA%B5%E5%AD%97%E8%8A%82%E7%A0%81</a></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://juejin.im/post/5da33dc56fb9a04e35597a47" target="_blank" rel="noopener">Jvm字节码插桩</a></p>
<h3 id="robust原理"><a href="#robust原理" class="headerlink" title="robust原理"></a>robust原理</h3><p>字节码插桩的应用是相当广泛的，比如robust中就用到了字节码插桩</p>
<h4 id="robust的基本原理"><a href="#robust的基本原理" class="headerlink" title="robust的基本原理"></a>robust的基本原理</h4><p>1.打基础包时进行代码插桩，在每个方法前插入一段类型为 ChangeQuickRedirect 静态变量的逻辑。<br>2.打补丁包时，通过patch插件运行gradle脚本时，利用注解获取改动代码并将信息保存到patch.jar<br>3.加载补丁时，从patch补丁包中读取要替换的类及具体替换的方法实现， 新建 ClassLoader 去加载补丁dex。</p>
<p><a href="https://blog.csdn.net/qq_22393017/article/details/82224656" target="_blank" rel="noopener">美团热修复 Robust 原理解析</a></p>
<h4 id="TransformApi-类加载器等，待续"><a href="#TransformApi-类加载器等，待续" class="headerlink" title="TransformApi,类加载器等，待续"></a>TransformApi,类加载器等，待续</h4>]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Jvm垃圾回收机制</title>
    <url>/blog/2020/06/jvm-basic-knowledge.html</url>
    <content><![CDATA[<h3 id="什么是内存？"><a href="#什么是内存？" class="headerlink" title="什么是内存？"></a>什么是内存？</h3><p>内存是计算机中重要的部件之一，是与 CPU 进行沟通的桥梁，是 CPU 能直接寻址的存储空间，由半导体器件制成。<br>如果说数据是商品，那硬盘就是商店的仓库，内存就是商店的货架，仓库里的商品你是不能直接买的，你只能买货架上的商品。<br>每一个程序中使用的内存区域相当于是不同的货架，当一个货架上需要摆放的商品超过这个货架所能容纳的最大值，就会出现放不下的情况，也就是内存溢出。</p>
<h3 id="什么是-JVM？"><a href="#什么是-JVM？" class="headerlink" title="什么是 JVM？"></a>什么是 JVM？</h3><p>JVM（Java 虚拟机）是 Java Virtual Machine 的缩写，它是一个虚构出来的计算机，通过在实际的计算机上仿真模拟各种计算机功能来实现的。<br>JVM 有自己的硬件架构，如处理器、堆栈、寄存器等，还有对应分指令系统。<br>假如一个程序使用的内存区域是一个货架，那 JVM 就相当于是一个淘宝店铺，它不是真实存在的货架，但它和真实货架一样可以上架和下架商品，而且上架的商品数量也是有限的。<br>假如货架是在深圳，那 JVM 的平台无关性就相当于是客人可以在各个地方购买你在淘宝上发布的商品，不是只有在深圳才能购买货架上的商品。</p>
<h3 id="jvm怎么划分内存"><a href="#jvm怎么划分内存" class="headerlink" title="jvm怎么划分内存"></a>jvm怎么划分内存</h3><p><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog3/p1.webp" alt></p>
<h4 id="线程私有区"><a href="#线程私有区" class="headerlink" title="线程私有区"></a>线程私有区</h4><h5 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h5><p>程序计数器（Program Counter Register）有下面三个特点<br>(1)较小<br>程序计数器是一块较小的内存空间，它可以看作是当前线程执行的字节码的行号指示器。<br>(2)线程私有<br>为了线程切换后能恢复到正确的执行位置，每条线程都有一个私有的程序计数器。<br>(3)无异常<br>程序计数器是唯一一个在 Java 虚拟机规范中没有规定任何 OOM 情况的区域。</p>
<h5 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h5><p>虚拟机栈可以说是 Java 方法栈<br>虚拟机栈描述的是 Java 方法执行的内存模型，每个方法在执行时都会创建一个栈帧（Stack Frame），栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。</p>
<p>一个方法从调用到执行完成的过程，对应着一个栈帧在虚拟机栈中入栈到出栈的过程</p>
<h5 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h5><p>本地方法栈（Native Method Stack）的作用与虚拟机栈非常相似,只不过本地方法栈为本地方法服务</p>
<h4 id="线程共享区"><a href="#线程共享区" class="headerlink" title="线程共享区"></a>线程共享区</h4><h5 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h5><p>Java 堆（Java Heap）也就是实例堆，它有下面四个特点。<br>1.最大<br>对于大多数应用来说，Java 堆是 JVM 管理的内存中最大的一块内存区域。</p>
<p>2.线程共享<br>Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。</p>
<p>3.存放实例<br>堆的唯一作用就是存放对象实例，几乎所有的对象实例都是在这里分配内存。</p>
<p>4.GC<br>堆是垃圾收集器管理的主要区域，所以有时也叫 GC 堆</p>
<h5 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h5><p>方法区（Method Area）存储的是已被虚拟机加载的数据，它有下面2个特点。</p>
<p>1.线程共享<br>方法区和堆一样，是所有线程共享的内存区域。</p>
<p>2.存储的数据类型<br>类信息<br>常量<br>静态变量<br>即时编译器编译后的代码</p>
<h5 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h5><p>当 Java 程序出现异常时，程序会打印出对应的异常堆栈，通过这个堆栈我们可以知道方法的调用链路，而这个调用链路就是由一个个 Java 方法栈帧组成的<br>栈帧主要包括以下内容<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog3/p2.webp" alt></p>
<p>1.局部变量表<br>局部变量表中存放的编译期可知的各种数据有如下三种。<br>基本数据类型,对象引用,returnAddress 类型</p>
<p>2.操作数栈<br>操作数栈（Operand Stack）也叫操作栈，它主要用于保存计算过程的中间结果，同时作为计算过程中临时变量的存储空间</p>
<p>3.动态连接<br>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接（Dynamic Linking）</p>
<p>4.方法返回地址</p>
<h4 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h4><h5 id="为什么分为堆区和栈区？"><a href="#为什么分为堆区和栈区？" class="headerlink" title="为什么分为堆区和栈区？"></a>为什么分为堆区和栈区？</h5><p>第一，从软件设计的角度看，栈代表了处理逻辑，而堆代表了数据。这样分开，使得处理逻辑更为清晰。分而治之的思想。这种隔离、模块化的思想在软件设计的方方面面都有体现。</p>
<p>第二，堆与栈的分离，使得堆中的内容可以被多个栈共享（也可以理解为多个线程访问同一个对象）。这种共享的收益是很多的。一方面这种共享提供了一种有效的数据交互方式(如：共享内存)，另一方面，堆中的共享常量和缓存可以被所有栈访问，节省了空间。</p>
<p>第三，栈因为运行时的需要，比如保存系统运行的上下文，需要进行地址段的划分。由于栈只能向上增长，因此就会限制住栈存储内容的能力。而堆不同，堆中的对象是可以根据需要动态增长的，因此栈和堆的拆分，使得动态增长成为可能，相应栈中只需记录堆中的一个地址即可。</p>
<p>第四，面向对象就是堆和栈的完美结合。其实，面向对象方式的程序与以前结构化的程序在执行上没有任何区别。但是，面向对象的引入，使得对待问题的思考方式发生了改变，而更接近于自然方式的思考。当我们把对象拆开，你会发现，对象的属性其实就是数据，存放在堆中；而对象的行为（方法），就是运行逻辑，放在栈中。我们在编写对象的时候，其实即编写了数据结构，也编写的处理数据的逻辑。</p>
<h4 id="为什么栈运行比堆快？"><a href="#为什么栈运行比堆快？" class="headerlink" title="为什么栈运行比堆快？"></a>为什么栈运行比堆快？</h4><p>栈中的数据占内存大小在编译时是确定的,比如一个int类型就占4B,所以变量地址好计算,所以分配和销毁和访问速度都比较快.<br>堆中的数据占内存大小一般在编译时是不确定的,在运行时才能知道大小,所以其地址只有在运行时计算,而且运行时可能占内存大小还有变动,所以对这样的数据的分配,销毁和访问都非常不方便,速度也慢一些. </p>
<p>栈是编译时分配空间，而堆是动态分配（运行时分配空间），所以栈的速度快<br>cpu有专门的寄存器（esp，ebp）来操作栈，堆都是使用间接寻址的。栈快点。 </p>
<h5 id="为什么基本数据类型放在栈中"><a href="#为什么基本数据类型放在栈中" class="headerlink" title="为什么基本数据类型放在栈中"></a>为什么基本数据类型放在栈中</h5><p>为什么不把基本类型放堆中呢？因为其占用的空间一般是1~8个字节——需要空间比较少，而且因为是基本类型，所以不会出现动态增长的情况——长度固定，因此栈中存储就够了，如果把他存在堆中是没有什么意义的。可以这么说，基本类型和对象的引用都是存放在栈中，而且都是几个字节的一个数，因此在程序运行时，他们的处理方式是统一的。</p>
<p>同时这也解释了,java中传值为什么基本类型是值传递，对象是引用传递，因为对象传递传递的是引用，基本数据类型传递的是他本身。</p>
<h3 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h3><h4 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h4><p><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog3/p1.png" alt><br>给对象添加一个引用计数器。但是难以解决循环引用问题<br>从图中可以看出，如果不下小心直接把 Obj1-reference 和 Obj2-reference 置 null。则在 Java 堆当中的两块内存依然保持着互相引用无法回收。</p>
<h4 id="什么是可达性算法"><a href="#什么是可达性算法" class="headerlink" title="什么是可达性算法"></a>什么是可达性算法</h4><p>在主流的商用程序语言（Java、C# 和 Lisp 等）的主流实现中，都是通过可达性分析（Reachability Analysis）判定对象是否存活的。<br>这个算法的基本思路就是通过一系列“GC Roots”对象作为起始点，从这些节点开始向下搜索，搜索走过的路径就叫引用链。<br>当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是不可用的。</p>
<p>比如下图中的 object5、object6、object7，虽然它们互有关联，但是它们到 GC Roots 是不可达的，所以它们会被判定为可回收对象<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog3/p3.webp" alt></p>
<p>在 Java 中，不同内存区域中可作为 GC Roots 的对象包括下面几种。<br>1.虚拟机栈<br>虚拟机栈的栈帧中的局部变量表中引用的对象，比如某个方法正在使用的类字段。<br>2.方法区<br>类静态属性引用的对象<br>常量引用的对象<br>3.本地方法栈<br>本地方法栈中 Native 方法引用的对象。</p>
<h4 id="强软弱虚"><a href="#强软弱虚" class="headerlink" title="强软弱虚"></a>强软弱虚</h4><p>1.强引用<br>强引用不会回收<br>强引用指向的对象在任何时候都不会被系统回收，虚拟机即使抛出 OOM 异常，也不会回收强引用指向的对象。<br>使用 obj = null 不会触发 GC，但是在下次 GC 的时候这个强引用对象就可以被回收了。</p>
<p>2.软引用<br>软引用有用但非必需<br>软引用用于描述一些还有用但非必需的对象。<br>对于软引用关联的对象，在系统即将发生内存溢出前，会把这些对象列入回收范围中进行二次回收。</p>
<p>3.弱引用<br>弱引用的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次 GC 前。<br>在 GC 时，只要发现弱引用，不管系统堆空间使用情况如何，都会将对象进行回收。<br>软引用、弱引用适合保存可有可无的缓存数据。</p>
<p>4.虚引用<br>虚引用是最弱的一种引用关系，它有以下几个特点。<br>无法获取<br>一个对象是否有虚引用的存在，都不会对其生存时间构成影响，也无法通过虚引用取得一个对象实例。</p>
<p>收到通知<br>为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</p>
<h4 id="收集算法"><a href="#收集算法" class="headerlink" title="收集算法"></a>收集算法</h4><h5 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记/清除算法"></a>标记/清除算法</h5><p>标记-清除算法（Mark-Sweep）相当于是先把货架上有人买的、没人买的、空着的商品和位置都记录下来，然后再把没人买的商品统一进行下架。<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog3/p4.webp" alt><br>工作原理<br>第一步：标记所有需要回收的对象<br>第二步：标记完成后，统一回收所有被标记的对象</p>
<p>主要缺点：<br>一个是效率问题，标记和清除过程的效率都不高。<br>另一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致：当程序在以后的运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前出发另一次垃圾收集动作。</p>
<h5 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h5><p>为了解决效率问题，复制（Copying）收集算法出现了。<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog3/p5.webp" alt><br>工作原理<br>复制算法把可用内存按容量划分为大小相等的两块，每次只使用其中的一块。<br>当使用中的这块内存用完了，就把存活的对象复制到另一块内存上，然后把已使用的空间一次清理掉。<br>这样每次都是对半个内存区域进行回收，内存分配时也不用考虑内存碎片等复杂问题</p>
<p>优点<br>复制算法的优点是每次只对半个内存区域进行内存回收，分配内存时也不用考虑内存碎片等复杂情况，只要一动堆顶指针，按顺序分配内存即可。</p>
<p>缺点<br>浪费空间,把内存缩小一半来使用太浪费空间。<br>有时效率较低,在对象存活率高时，要进行较多的复制操作，这时效率就变低了</p>
<h5 id="标记整理算法"><a href="#标记整理算法" class="headerlink" title="标记整理算法"></a>标记整理算法</h5><p>在复制算法中，如果不想浪费 50% 的空间，就需要有额外的空间进行分配担保，以应对被使用内存中所有对象都存活的低端情况，所以养老区不能用这种算法。<br>根据养老区的特点，有人提出了一种标记-整理（Mark-Compact）算法。<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog3/p6.webp" alt><br>标记-整理算法的标记过程与标记-清除算法一样，但后续步骤是让所有存活的对象向一端移动，然后直接清理掉边界外的内存。</p>
<h5 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h5><p>当前商业虚拟机的垃圾收集 都采用分代收集，它根据对象的存活周期的不同将内存划分为几块，一般是把Java堆分为新生代和老年代。在新生代中，每次垃圾收集时都会发现有大量对象死去，只有少量存活，因此可选用复制算法来完成收集，而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用标记—清除算法或标记—整理算法来进行回收。</p>
<p><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog3/p7.webp" alt></p>
<p>年轻代的垃圾收集算法：<br>在年轻代中jvm使用的是复制算法，年轻代分三个区。一个Eden区，两个 Survivor区(一般而言)。大部分对象在Eden区中生成。当Eden区满时，还存活的对象将被复制到Survivor区（两个中的一个），当这个 Survivor区满时，此区的存活对象将被复制到另外一个Survivor区，当另外一个Survivor区也满了的时候，从第一个Survivor区复制过来的并且此时还存活的对象，将被复制到“年老区(Tenured)”。需要注意，Survivor的两个区是对称的，没先后关系，所以同一个区中可能同时存在从Eden复制过来对象，和从前一个Survivor复制过来的对象，而复制到年老区的只有从第一个Survivor区过来的对象。而且，Survivor区总有一个是空的。当survivor1区不足以存放 eden和survivor0的存活对象时，就将存活对象直接存放到老年代。</p>
<p>老年代（Old Generation）的回收算法：<br>老年代的特点是每次回收都只回收少量对象，一般使用的是Mark-Compact（标记-整理）算法。在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。内存比新生代也大很多(大概比例是1:2)，当老年代内存满时触发Major GC或Full GC，Full GC发生频率比较低，老年代对象存活时间比较长，存活率标记高。</p>
<h4 id="垃圾回收的时机"><a href="#垃圾回收的时机" class="headerlink" title="垃圾回收的时机"></a>垃圾回收的时机</h4><p>当Eden区或者Survior区不够用了<br>老年代空间不够用了<br>方法区空间不够用了<br>手动回收，System.gc()（不建议使用）</p>
<h4 id="垃圾回收分析"><a href="#垃圾回收分析" class="headerlink" title="垃圾回收分析"></a>垃圾回收分析</h4><p>内存分配策略：</p>
<ul>
<li>对象优先在Eden分配。</li>
<li>大对象直接进入老年代。</li>
<li>长期存活的对象将进入老年代。</li>
</ul>
<p>对垃圾回收策略说明以下两点：</p>
<ul>
<li>新生代GC（Minor GC）：发生在新生代的垃圾收集动作，因为Java对象大多都具有朝生夕灭的特性，因此Minor GC非常频繁，一般回收速度也比较快。</li>
<li>老年代GC（Major GC/Full GC）：发生在老年代的GC，出现了Major GC，经常会伴随至少一次Minor GC。由于老年代中的对象生命周期比较长，因此Major - GC并不频繁，一般都是等待老年代满了后才进行Full GC，而且其速度一般会比Minor GC慢10倍以上。另外，如果分配了Direct Memory，在老年代中进行Full GC时，会顺便清理掉Direct Memory中的废弃对象。</li>
</ul>
<h4 id="为什么JVM中的新生代要有两个Survivor区"><a href="#为什么JVM中的新生代要有两个Survivor区" class="headerlink" title="为什么JVM中的新生代要有两个Survivor区"></a>为什么JVM中的新生代要有两个Survivor区</h4><p>首先说说为什么要有Survivor区<br>Survivor的存在意义，就是减少被送到老年代的对象，进而减少Full GC的发生，Survivor的预筛选保证，只有经历16次Minor GC还能在新生代中存活的对象，才会被送到老年代</p>
<p>为什么要设立两个survivor区<br>置两个Survivor区最大的好处就是解决了碎片化<br>详情可见：<a href="https://blog.csdn.net/towads/article/details/79784249" target="_blank" rel="noopener">https://blog.csdn.net/towads/article/details/79784249</a></p>
<h4 id="通过工具直观查看"><a href="#通过工具直观查看" class="headerlink" title="通过工具直观查看"></a>通过工具直观查看</h4><p>通过jdk的jvisualvm工具，可以动态的看到JVM分代回收的过程<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog3/p2.png" alt></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://juejin.im/post/5d3a870df265da1b855c9d41" target="_blank" rel="noopener">探索 Java 内存管理机制</a><br><a href="https://my.oschina.net/ssdlinux/blog/2998513" target="_blank" rel="noopener">为什么jvm分为堆区和栈区</a><br><a href="https://www.cnblogs.com/fmgao-technology/p/11095873.html#_label0_1" target="_blank" rel="noopener">Java里的堆(heap)栈(stack)和方法区(method)</a><br><a href="https://blog.csdn.net/weixin_43691723/article/details/106771107" target="_blank" rel="noopener">深入理解Java虚拟机（超级详细)</a></p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发编程</title>
    <url>/blog/2020/06/java-concurrent-program.html</url>
    <content><![CDATA[<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>所谓死锁是指两个或两个以上的线程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去</p>
<p>死锁产生的必要条件：<br>产生死锁必须同时满足以下四个条件，只要其中任一条件不成立，死锁就不会发生。<br>（1）互斥条件：一个资源每次只能被一个进程使用。独木桥每次只能通过一个人。</p>
<p>（2）请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。乙不退出桥面，甲也不退出桥面。</p>
<p>（3）不剥夺条件: 进程已获得的资源，在未使用完之前，不能强行剥夺。甲不能强制乙退出桥面，乙也不能强制甲退出桥面。</p>
<p>（4）循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。如果乙不退出桥面，甲不能通过，甲不退出桥面，乙不能通过。</p>
<p>白话版<br>1.多个操作者请求多个资源<br>2.争夺资源的顺序不对<br>3.拿到资源不放手</p>
<h4 id="如何避免死锁"><a href="#如何避免死锁" class="headerlink" title="如何避免死锁"></a>如何避免死锁</h4><p>在有些情况下死锁是可以避免的。下面介绍三种用于避免死锁的技术：</p>
<p>1.加锁顺序（线程按照一定的顺序加锁）<br>2.加锁时限（线程尝试获取锁的时候加上一定的时限，超过时限则放弃对该锁的请求，并释放自己占有的锁）<br>通过Lock方法来拿锁<br>3.死锁检测</p>
<h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p>线程本地变量<br>ThreadLocal的变量是依存在Thread的本地变量中的</p>
<p><strong>ThreadLocal面试点</strong><br>1.结构（以ThreadLocal.get分析，从当前线程Thread对象取得ThreadLocalMap，ThreadLocalMap根据ThreadLocal对象取出Value）<br>2.ThreadLocalMap的哈希存储结构（开放寻址法）<br>3.ThreadLocalMap对ThreadLocal弱引用的原因<br>4.什么情况会引起内存泄漏？<br>5.脏数据回收</p>
<p>详情可见:<br><a href="https://blog.csdn.net/u010687392/article/details/50549236" target="_blank" rel="noopener">https://blog.csdn.net/u010687392/article/details/50549236</a><br><a href="https://github.com/Moosphan/Android-Daily-Interview/issues/83" target="_blank" rel="noopener">https://github.com/Moosphan/Android-Daily-Interview/issues/83</a></p>
<h3 id="CAS基本原理"><a href="#CAS基本原理" class="headerlink" title="CAS基本原理"></a>CAS基本原理</h3><p>CAS：Compare and Swap，即比较再交换。<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog3/p3.png" alt></p>
<p>jdk5增加了并发包java.util.concurrent.*,其下面的类使用CAS算法实现了区别于synchronouse同步锁的一种乐观锁。JDK 5之前Java语言是靠synchronized关键字保证同步的，这是一种独占锁，也是是悲观锁</p>
<p>对CAS的理解，CAS是一种无锁算法，CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做</p>
<p>CAS利用了现代处理器都支持的CAS指令，循环这个指令，直到成功为止。</p>
<p>1.ABA问题<br>可以通过版本控制解决<br>AtomicMarkableReference 可以解决,使用boolean变量——表示引用变量是否被更改过,不关心中间变量变化了几次<br>AtomicStampedReference 也可以解决,其中的构造方法中initialStamp（时间戳）用来唯一标识引用变量,引用变量中途被更改了几次<br>2.开销问题<br>3.只能保证一个共享变量的原子操作<br>通过AtomicRefrence解决,将多个变量打包成一个对象来使用</p>
<h4 id="悲观锁，乐观锁，可重入锁"><a href="#悲观锁，乐观锁，可重入锁" class="headerlink" title="悲观锁，乐观锁，可重入锁"></a>悲观锁，乐观锁，可重入锁</h4><h3 id="阻塞队列和线程池原理"><a href="#阻塞队列和线程池原理" class="headerlink" title="阻塞队列和线程池原理"></a>阻塞队列和线程池原理</h3><h4 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h4><p>队列即先进先出,而阻塞队列满足以下条件<br>1）支持阻塞的插入方法：意思是当队列满时，队列会阻塞插入元素的线程，直到队列不满。<br>2）支持阻塞的移除方法：意思是在队列为空时，获取元素的线程会等待队列变为非空<br>阻塞队列常用于生产者和消费者的场景，生产者是向队列里添加元素的线程，消费者是从队列里取元素的线程</p>
<h5 id="常用阻塞队列"><a href="#常用阻塞队列" class="headerlink" title="常用阻塞队列"></a>常用阻塞队列</h5><p>·ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列。<br>·LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列。<br>·PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列。<br>·DelayQueue：一个使用优先级队列实现的无界阻塞队列。<br>·SynchronousQueue：一个不存储元素的阻塞队列。<br>·LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。<br>·LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。<br>以上的阻塞队列都实现了BlockingQueue接口，也都是线程安全的</p>
<h4 id="线程池原理"><a href="#线程池原理" class="headerlink" title="线程池原理"></a>线程池原理</h4><h5 id="为什么要用线程池"><a href="#为什么要用线程池" class="headerlink" title="为什么要用线程池"></a>为什么要用线程池</h5><p>Java中的线程池是运用场景最多的并发框架，几乎所有需要异步或并发执行任务的程序都可以使用线程池。在开发过程中，合理地使用线程池能够带来3个好处。<br>第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。<br>第二：提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。假设一个服务器完成一项任务所需时间为：T1 创建线程时间，T2 在线程中执行任务的时间，T3 销毁线程时间。   如果：T1 + T3 远大于 T2，则可以采用线程池，以提高服务器性能。线程池技术正是关注如何缩短或调整T1,T3时间的技术，从而提高服务器程序性能的。它把T1，T3分别安排在服务器程序的启动和结束的时间段或者一些空闲的时间段，这样在服务器程序处理客户请求时，不会有T1，T3的开销了。<br>第三：提高线程的可管理性。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。</p>
<h5 id="各参数含义"><a href="#各参数含义" class="headerlink" title="各参数含义"></a>各参数含义</h5><p><strong>corePoolSize</strong><br>线程池的基本大小，即在没有任务需要执行的时候线程池的大小，并且只有在工作队列满了的情况下才会创建超出这个数量的线程。这里需要注意的是：在刚刚创建ThreadPoolExecutor的时候，线程并不会立即启动，而是要等到有任务提交时才会启动，除非调用了prestartCoreThread/prestartAllCoreThreads事先启动核心线程。再考虑到keepAliveTime和allowCoreThreadTimeOut超时参数的影响，所以没有任务需要执行的时候，线程池的大小不一定是corePoolSize。</p>
<p><strong>maximumPoolSize</strong><br>线程池中允许的最大线程数，线程池中的当前线程数目不会超过该值。如果队列中任务已满，并且当前线程个数小于maximumPoolSize，那么会创建新的线程来执行任务。这里值得一提的是largestPoolSize，该变量记录了线程池在整个生命周期中曾经出现的最大线程个数。为什么说是曾经呢？因为线程池创建之后，可以调用setMaximumPoolSize()改变运行的最大线程的数目。</p>
<p><strong>poolSize</strong><br>线程池中当前线程的数量，当该值为0的时候，意味着没有任何线程，线程池会终止；同一时刻，poolSize不会超过maximumPoolSize。</p>
<p><strong>阻塞队列等待</strong><br>新提交一个任务时的处理流程很明显：<br>1、如果线程池的当前大小还没有达到基本大小(poolSize &lt; corePoolSize)，那么就新增加一个线程处理新提交的任务；<br>2、如果当前大小已经达到了基本大小，就将新提交的任务提交到阻塞队列排队，等候处理workQueue.offer(command)；<br>3、如果队列容量已达上限，并且当前大小poolSize没有达到maximumPoolSize，那么就新增线程来处理任务；<br>4、如果队列已满，并且当前线程数目也已经达到上限，那么意味着线程池的处理能力已经达到了极限，此时需要拒绝新增加的任务。至于如何拒绝处理新增的任务，取决于线程池的饱和策略RejectedExecutionHandler。</p>
<p>接下来我们看下allowCoreThreadTimeOut和keepAliveTime属性的含义。在压力很大的情况下，线程池中的所有线程都在处理新提交的任务或者是在排队的任务，这个时候线程池处在忙碌状态。如果压力很小，那么可能很多线程池都处在空闲状态，这个时候为了节省系统资源，回收这些没有用的空闲线程，就必须提供一些超时机制，这也是线程池大小调节策略的一部分。通过corePoolSize和maximumPoolSize，控制如何新增线程；通过allowCoreThreadTimeOut和keepAliveTime，控制如何销毁线程。</p>
<p><strong>allowCoreThreadTimeOut</strong><br>该属性用来控制是否允许核心线程超时退出。If false,core threads stay alive even when idle.If true, core threads use keepAliveTime to time out waiting for work。如果线程池的大小已经达到了corePoolSize，不管有没有任务需要执行，线程池都会保证这些核心线程处于存活状态。可以知道：该属性只是用来控制核心线程的。</p>
<p><strong>keepAliveTime</strong><br>如果一个线程处在空闲状态的时间超过了该属性值，就会因为超时而退出。举个例子，如果线程池的核心大小corePoolSize=5，而当前大小poolSize =8，那么超出核心大小的线程，会按照keepAliveTime的值判断是否会超时退出。如果线程池的核心大小corePoolSize=5，而当前大小poolSize =5，那么线程池中所有线程都是核心线程，这个时候线程是否会退出，取决于allowCoreThreadTimeOut</p>
<h6 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h6><p><strong>线程池为什么能维持线程不释放，随时运行各种任务</strong><br><figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line">Runnable <span class="built_in">getTask</span>() &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                int state = runState;</span><br><span class="line">                <span class="keyword">if</span> (state &gt; SHUTDOWN)</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">null</span>;</span><br><span class="line">                Runnable r;</span><br><span class="line">                <span class="keyword">if</span> (state == SHUTDOWN)  <span class="comment">// Help drain queue</span></span><br><span class="line">                    r = workQueue.poll();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (poolSize &gt; corePoolSize || allowCoreThreadTimeOut)</span><br><span class="line">                    r = workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    r = workQueue.take();</span><br><span class="line">                <span class="keyword">if</span> (r != <span class="built_in">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> r;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">workerCanExit</span>()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (runState &gt;= SHUTDOWN) <span class="comment">// Wake up others</span></span><br><span class="line">                        <span class="built_in">interruptIdleWorkers</span>();</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Else retry</span></span><br><span class="line">            &#125; <span class="built_in">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                <span class="comment">// On interruption, re-check runState</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>在死循环中工作队列workQueue会一直去拿任务:<br>核心线程的会一直卡在 workQueue.take()方法，让线程一直等待，直到获取到任务，然后返回。<br>非核心线程会 workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) ，如果超时还没有拿到，下一次循环判断compareAndDecrementWorkerCount就会返回null,Worker对象的run()方法循环体的判断为null,任务结束，然后线程被系统回收。</p>
<p>通过阻塞队列take()，让线程一直等待，直到获取到任务</p>
<p><strong>如何释放核心线程？</strong><br>将allowCoreThreadTimeOut设置为true</p>
<p><strong>非核心线程能成为核心线程吗？</strong><br>线程池不区分核心线程于非核心线程，只是根据当前线程池容量状态做不同的处理来进行调整，因此看起来像是有核心线程于非核心线程，实际上是满足线程池期望达到的并发状态</p>
<h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><p><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog3/p4.png" alt></p>
<p><strong>sychronied修饰普通方法和静态方法的区别？什么是可见性?</strong><br>对象锁是用于对象实例方法，或者一个对象实例上的，类锁是用于类的静态方法或者一个类的class对象上的。我们知道，类的对象实例可以有很多个，但是每个类只有一个class对象，所以不同对象实例的对象锁是互不干扰的，但是每个类只有一个类锁。<br>但是有一点必须注意的是，其实类锁只是一个概念上的东西，并不是真实存在的，类锁其实锁的是每个类的对应的class对象。类锁和对象锁之间也是互不干扰的。<br>可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。<br>由于线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量，那么对于共享变量V，它们首先是在自己的工作内存，之后再同步到主内存。可是并不会及时的刷到主存中，而是会有一定时间差。很明显，这个时候线程 A 对变量 V 的操作对于线程 B 而言就不具备可见性了 。<br>要解决共享对象可见性这个问题，我们可以使用volatile关键字或者是加锁。</p>
<p><strong>锁分哪几种？</strong><br><a href="https://blog.csdn.net/NewRivers/article/details/103245741" target="_blank" rel="noopener">https://blog.csdn.net/NewRivers/article/details/103245741</a><br><a href="https://blog.csdn.net/qq_34337272/article/details/81072874" target="_blank" rel="noopener">https://blog.csdn.net/qq_34337272/article/details/81072874</a><br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog3/p5.png" alt></p>
<p><strong>CAS无锁编程的原理。</strong><br>使用当前的处理器基本都支持CAS()的指令，只不过每个厂家所实现的算法并不一样，每一个CAS操作过程都包含三个运算符：一个内存地址V，一个期望的值A和一个新值B，操作的时候如果这个地址上存放的值等于这个期望的值A，则将地址上的值赋为新值B，否则不做任何操作。<br>CAS的基本思路就是，如果这个地址上的值和期望的值相等，则给其赋予新值，否则不做任何事儿，但是要返回原值是多少。循环CAS就是在一个循环里不断的做cas操作，直到成功为止。<br>还可以说说CAS的三大问题。</p>
<p><strong>ReentrantLock的实现原理。</strong><br>线程可以重复进入任何一个它已经拥有的锁所同步着的代码块，synchronized、ReentrantLock都是可重入的锁。在实现上，就是线程每次获取锁时判定如果获得锁的线程是它自己时，简单将计数器累积即可，每 释放一次锁，进行计数器累减，直到计算器归零，表示线程已经彻底释放锁。<br>底层则是利用了JUC中的AQS来实现的。</p>
<p><strong>AQS原理 （小米 京东）</strong><br>是用来构建锁或者其他同步组件的基础框架，比如ReentrantLock、ReentrantReadWriteLock和CountDownLatch就是基于AQS实现的。它使用了一个int成员变量表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作。它是CLH队列锁的一种变体实现。它可以实现2种同步方式：独占式，共享式。<br>AQS的主要使用方式是继承，子类通过继承AQS并实现它的抽象方法来管理同步状态，同步器的设计基于模板方法模式，所以如果要实现我们自己的同步工具类就需要覆盖其中几个可重写的方法，如tryAcquire、tryReleaseShared等等。<br>这样设计的目的是同步组件（比如锁）是面向使用者的，它定义了使用者与同步组件交互的接口（比如可以允许两个线程并行访问），隐藏了实现细节；同步器面向的是锁的实现者，它简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、等待与唤醒等底层操作。这样就很好地隔离了使用者和实现者所需关注的领域。<br>在内部，AQS维护一个共享资源state，通过内置的FIFO来完成获取资源线程的排队工作。该队列由一个一个的Node结点组成，每个Node结点维护一个prev引用和next引用，分别指向自己的前驱和后继结点，构成一个双端双向链表。</p>
<p><strong>Synchronized的原理以及与ReentrantLock的区别。（360）</strong><br>synchronized (this)原理：涉及两条指令：monitorenter，monitorexit；再说同步方法，从同步方法反编译的结果来看，方法的同步并没有通过指令monitorenter和monitorexit来实现，相对于普通方法，其常量池中多了ACC_SYNCHRONIZED标示符。<br>JVM就是根据该标示符来实现方法的同步的：当方法被调用时，调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先获取monitor，获取成功之后才能执行方法体，方法执行完后再释放monitor。在方法执行期间，其他任何线程都无法再获得同一个monitor对象。</p>
<p>关于 monitorenter 和 monitorexit，可以理解为一把具体的锁。在这个锁中保存着两个比较重要的属性：计数器和指针。<br>计数器代表当前线程一共访问了几次这把锁；<br>指针指向持有这把锁的线程。<br>用一张图表示如下：<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog3/p8.png" alt><br>锁计数器默认为0，当执行monitorenter指令时，如锁计数器值为0 说明这把锁并没有被其它线程持有。那么这个线程会将计数器加1，并将锁中的指针指向自己。当执行monitorexit指令时，会将计数器减1。</p>
<p>区别：<br>来源：<br>lock是一个接口，而synchronized是java的一个关键字，synchronized是内置的语言实现；</p>
<p>异常是否释放锁：<br>synchronized在发生异常时候会自动释放占有的锁，因此不会出现死锁；而lock发生异常时候，不会主动释放占有的锁，必须手动unlock来释放锁，可能引起死锁的发生。（所以最好将同步代码块用try catch包起来，finally中写入unlock，避免死锁的发生。）</p>
<p>是否响应中断<br>lock等待锁过程中可以用interrupt来中断等待，而synchronized只能等待锁的释放，不能响应中断；</p>
<p>是否知道获取锁<br>Lock可以通过trylock来知道有没有获取锁，而synchronized不能；</p>
<p>Lock可以提高多个线程进行读操作的效率。（可以通过readwritelock实现读写分离）</p>
<p>在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于synchronized。所以说，在具体使用时要根据适当情况选择。</p>
<p>synchronized使用Object对象本身的wait 、notify、notifyAll调度机制，而Lock可以使用Condition进行线程之间的调度</p>
<p><strong>Synchronized做了哪些优化 （京东）</strong><br>引入如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁、逃逸分析等技术来减少锁操作的开销。<br>逃逸分析<br>如果证明一个对象不会逃逸方法外或者线程外，则可针对此变量进行优化：<br>同步消除synchronization Elimination，如果一个对象不会逃逸出线程，则对此变量的同步措施可消除。<br>锁消除和粗化<br>锁消除：虚拟机的运行时编译器在运行时如果检测到一些要求同步的代码上不可能发生共享数据竞争，则会去掉这些锁。<br>锁粗化：将临近的代码块用同一个锁合并起来。<br>消除无意义的锁获取和释放，可以提高程序运行性能</p>
<p><strong>Synchronized static与非static锁的区别和范围（小米）</strong><br>对象锁是用于对象实例方法，或者一个对象实例上的，类锁是用于类的静态方法或者一个类的class对象上的。我们知道，类的对象实例可以有很多个，但是每个类只有一个class对象，所以不同对象实例的对象锁是互不干扰的，但是每个类只有一个类锁。<br>但是有一点必须注意的是，其实类锁只是一个概念上的东西，并不是真实存在的，类锁其实锁的是每个类的对应的class对象。类锁和对象锁之间也是互不干扰的。</p>
<p><strong>volatile 能否保证线程安全？在DCL上的作用是什么？</strong><br>不能保证，在DCL的作用是：volatile是会保证被修饰的变量的可见性和 有序性，保证了单例模式下，保证在创建对象的时候的执行顺序一定是<br>1.分配内存空间<br>2.实例化对象instance<br>3.把instance引用指向已分配的内存空间,此时instance有了内存地址,不再为null了<br>的步骤, 从而保证了instance要么为null 要么是已经完全初始化好的对象</p>
<p><strong>volatile和synchronize有什么区别？（B站 小米 京东）</strong><br>volatile是最轻量的同步机制。<br>volatile保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。但是volatile不能保证操作的原子性，因此多线程下的写复合操作会导致线程安全问题。<br>关键字synchronized可以修饰方法或者以同步块的形式来进行使用，它主要确保多个线程在同一个时刻，只能有一个线程处于方法或者同步块中，它保证了线程对变量访问的可见性和排他性，又称为内置锁机制。</p>
<p><strong>什么是守护线程？你是如何退出一个线程的？</strong><br>Daemon（守护）线程是一种支持型线程，因为它主要被用作程序中后台调度以及支持性工作。这意味着，当一个Java虚拟机中不存在非Daemon线程的时候，Java虚拟机将会退出。可以通过调用Thread.setDaemon(true)将线程设置为Daemon线程。我们一般用不上，比如垃圾回收线程就是Daemon线程。<br>线程的中止：<br>要么是run执行完成了，要么是抛出了一个未处理的异常导致线程提前结束。<br>暂停、恢复和停止操作对应在线程Thread的API就是suspend()、resume()和stop()。但是这些API是过期的，也就是不建议使用的。因为会导致程序可能工作在不确定状态下。<br>安全的中止则是其他线程通过调用某个线程A的interrupt()方法对其进行中断操作，被中断的线程则是通过线程通过方法isInterrupted()来进行判断是否被中断，也可以调用静态方法Thread.interrupted()来进行判断当前线程是否被中断，不过Thread.interrupted()会同时将中断标识位改写为false</p>
<p><strong>sleep 、wait、yield 的区别，wait 的线程如何唤醒它？（东方头条）</strong><br>yield()方法：使当前线程让出CPU占有权，但让出的时间是不可设定的。也不会释放锁资源。所有执行yield()的线程有可能在进入到就绪状态后会被操作系统再次选中马上又被执行。<br>yield() 、sleep()被调用后，都不会释放当前线程所持有的锁。<br>调用wait()方法后，会释放当前线程持有的锁，而且当前被唤醒后，会重新去竞争锁，锁竞争到后才会执行wait方法后面的代码。<br>Wait通常被用于线程间交互，sleep通常被用于暂停执行，yield()方法使当前线程让出CPU占有权。<br>wait 的线程使用notify/notifyAll()进行唤醒</p>
<p><strong>sleep是可中断的么？（小米）</strong><br>sleep本身就支持中断，如果线程在sleep期间被中断，则会抛出一个中断异常。</p>
<p><strong>线程生命周期。</strong><br>Java中线程的状态分为6种：</p>
<ol>
<li>初始(NEW)：新创建了一个线程对象，但还没有调用start()方法。</li>
<li>运行(RUNNABLE)：Java线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”。<br>线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取CPU的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得CPU时间片后变为运行中状态（running）。</li>
<li>阻塞(BLOCKED)：表示线程阻塞于锁。</li>
<li>等待(WAITING)：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。</li>
<li>超时等待(TIMED_WAITING)：该状态不同于WAITING，它可以在指定的时间后自行返回。</li>
<li>终止(TERMINATED)：表示该线程已经执行完毕。<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog3/p1.jpg" alt></li>
</ol>
<p><strong>ThreadLocal是什么？</strong><br>ThreadLocal是Java里一种特殊的变量。ThreadLocal为每个线程都提供了变量的副本，使得每个线程在某一时间訪问到的并非同一个对象，这样就隔离了多个线程对数据的数据共享。<br>在内部实现上，每个线程内部都有一个ThreadLocalMap，用来保存每个线程所拥有的变量副本。<br><a href="https://juejin.im/post/6844903935132581896" target="_blank" rel="noopener">【不用背的原理】不用背的ThreadLocal原理</a><br><a href="https://zhuanlan.zhihu.com/p/192873419" target="_blank" rel="noopener">为什么ThreadLocal Key不设置为强引用</a></p>
<p><strong>线程池基本原理。</strong><br>在开发过程中，合理地使用线程池能够带来3个好处。<br>第一：降低资源消耗。第二：提高响应速度。第三：提高线程的可管理性。<br>1）如果当前运行的线程少于corePoolSize，则创建新线程来执行任务（注意，执行这一步骤需要获取全局锁）。<br>2）如果运行的线程等于或多于corePoolSize，则将任务加入BlockingQueue。<br>3）如果无法将任务加入BlockingQueue（队列已满），则创建新的线程来处理任务。<br>4）如果创建新线程将使当前运行的线程超出maximumPoolSize，任务将被拒绝，并调用RejectedExecutionHandler.rejectedExecution()方法。</p>
<p><strong>有三个线程T1，T2，T3，怎么确保它们按顺序执行？</strong><br>可以用join方法实现。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://blog.csdn.net/aitangyong/article/details/38822505" target="_blank" rel="noopener">理解ThreadPoolExecutor源码(一)线程池的corePoolSize、maximumPoolSize和poolSize</a><br><a href="https://juejin.im/post/5b3cf259e51d45194e0b7204#heading-19" target="_blank" rel="noopener">Java面试经典题：线程池专题</a></p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>常见算法题</title>
    <url>/blog/2020/06/common-algorithm-prblems.html</url>
    <content><![CDATA[<h3 id="五遍刷题法"><a href="#五遍刷题法" class="headerlink" title="五遍刷题法"></a>五遍刷题法</h3><p>1.直接看解法<br>多解法，比较解法优劣，默写好的解法<br>2.打开leetcode，直接开始写<br>多种解法比较，调优<br>3.过一天之后，再重复做题<br>4.过了一周，再来反复练、<br>5.面试前一周，恢复性训练</p>
<p><a href="https://github.com/afatcoder/LeetcodeTop" target="_blank" rel="noopener">LeetcodeTop-各大公司题库</a><br><a href="https://github.com/yuanguangxin/LeetCode" target="_blank" rel="noopener">https://github.com/yuanguangxin/LeetCode–按知识点分类</a><br><a href="https://github.com/MisterBooo/LeetCodeAnimation" target="_blank" rel="noopener">LeetCodeAnimation</a><br><a href="https://www.zhihu.com/question/24964987" target="_blank" rel="noopener">互联网公司最常见的面试算法题有哪些？</a><br><a href="https://www.zhihu.com/question/280279208/answer/1118675237" target="_blank" rel="noopener">刷题路径</a><br><a href="https://github.com/greyireland/algorithm-pattern/" target="_blank" rel="noopener">刷题模板</a><br><a href="https://github.com/gaoshengnan/LeetCode" target="_blank" rel="noopener">笙南刷题题库</a><br><a href="http://labuladong.gitbook.io/algo/" target="_blank" rel="noopener">拉布拉多算法</a><br><a href="https://github.com/labuladong/fucking-algorithm" target="_blank" rel="noopener">fucking-algorithm-拉布拉多</a></p>
<h3 id="按知识点分类题目"><a href="#按知识点分类题目" class="headerlink" title="按知识点分类题目"></a>按知识点分类题目</h3><h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><p>1.二叉树前序，中序，后序遍历.递归与非递归，两种实现<br>2.根据前序与中序确定二叉树等<br><a href="https://www.cnblogs.com/lanhaicode/p/10390147.html" target="_blank" rel="noopener">https://www.cnblogs.com/lanhaicode/p/10390147.html</a><br>3.之字形打印树<br>4.二叉树节点间最大距离</p>
<h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><h5 id="1-快速排序"><a href="#1-快速排序" class="headerlink" title="1.快速排序"></a>1.快速排序</h5><p>排序系统性学习<br><a href="https://leetcode-cn.com/problems/sort-an-array/solution/fu-xi-ji-chu-pai-xu-suan-fa-java-by-liweiwei1419/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sort-an-array/solution/fu-xi-ji-chu-pai-xu-suan-fa-java-by-liweiwei1419/</a><br>各种排序应用场景<br><strong>原理</strong><br>1.快速排序（Quicksort）是对冒泡排序的一种改进，也是采用分治法的一个典型的应用。<br>2.首先任意选取一个数据（比如数组的第一个数）作为关键数据，我们称为基准数(Pivot)，然后将所有比它小的数都放到它前面，所有比它大的数都放到它后面，这个过程称为一趟快速排序，也称为分区（partition）操作。<br>3.通过一趟快速排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数组变成有序序列</p>
<p><strong>具体规则如下：</strong><br>进行数组的遍历，将数组中的元素和基准数进行比较，为了满足所有比基准数小的数都放到基准数前面，所有比基准数大的数都放到基准数后面，我们需要遵循着这样的规则：<br>1、当前元素大于等于基准数，我们不做任何变化。<br>2、当前元素小于等于基准数时，分割指示器右移一位 ，当前元素下标小于等于分割指示器时当前元素保持不动，当前元素下标大于分割指示器时，当前元素和分割指示器所指元素交换</p>
<h3 id="4-递归非递归反转链表"><a href="#4-递归非递归反转链表" class="headerlink" title="4.递归非递归反转链表"></a>4.递归非递归反转链表</h3><h3 id="6-三色球问题"><a href="#6-三色球问题" class="headerlink" title="6.三色球问题"></a>6.三色球问题</h3><h3 id="7-手写生产者消费者模型"><a href="#7-手写生产者消费者模型" class="headerlink" title="7.手写生产者消费者模型"></a>7.手写生产者消费者模型</h3><h3 id="8-手写阻塞队列"><a href="#8-手写阻塞队列" class="headerlink" title="8.手写阻塞队列"></a>8.手写阻塞队列</h3><p><a href="https://www.cnblogs.com/keeya/p/9713686.html" target="_blank" rel="noopener">https://www.cnblogs.com/keeya/p/9713686.html</a></p>
<h3 id="大厂算法面试题库中高频出现的30道典型题"><a href="#大厂算法面试题库中高频出现的30道典型题" class="headerlink" title="大厂算法面试题库中高频出现的30道典型题"></a>大厂算法面试题库中高频出现的30道典型题</h3><p><a href="https://github.com/shenzhen2017/newImage/blob/master/blog4/%E5%A4%A7%E5%8E%82%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93%E4%B8%AD%E9%AB%98%E9%A2%91%E5%87%BA%E7%8E%B0%E7%9A%8430%E9%81%93%E5%85%B8%E5%9E%8B%E9%A2%98.pdf" target="_blank" rel="noopener">大厂算法面试题库中高频出现的30道典型题</a></p>
<h3 id="算法进阶自练题"><a href="#算法进阶自练题" class="headerlink" title="算法进阶自练题"></a>算法进阶自练题</h3><p>按知识点分类<br><a href="https://github.com/shenzhen2017/newImage/blob/master/blog4/%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6%E8%87%AA%E7%BB%83%E9%A2%98.pdf" target="_blank" rel="noopener">算法进阶自练题</a></p>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Jvm常见面试题</title>
    <url>/blog/2020/06/jvm-interview-problems.html</url>
    <content><![CDATA[<p><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog3/p9.png" alt></p>
<p><strong>JVM内存结构说一下！</strong><br>一般从两个维度出发：线程私有和线程共享。到每一个内存区域的细节点</p>
<p>Java 虚拟机栈是基于线程的。哪怕你只有一个 main() 方法，也是以线程的方式运行的。在线程的生命周期中，参与计算的数据会频繁地入栈和出栈，栈的生命周期是和线程一样的。<br>栈里的每条数据，就是栈帧。在每个 Java 方法被调用的时候，都会创建一个栈帧，并入栈。一旦完成相应的调用，则出栈。所有的栈帧都出栈后，线程也就结束了。每个栈帧，都包含四个区域：<br>局部变量表<br>操作数栈<br>动态连接<br>返回地址<br>本地方法栈是和虚拟机栈非常相似的一个区域，它服务的对象是 native 方法。<br>程序计数器是一块较小的内存空间，它的作用可以看作是当前线程所执行的字节码的行号指示器。<br>堆是 JVM 上最大的内存区域，我们申请的几乎所有的对象，都是在这里存储的。我们常说的垃圾回收，操作的对象就是堆。<br>方法区，这个区域存储的内容，包括：类的信息、常量池、方法数据、方法代码就可以</p>
<p><strong>什么情况下内存栈溢出？</strong><br>java.lang.StackOverflowError  如果出现了可能会是无限递归。<br>OutOfMemoryError：不断建立线程，JVM申请栈内存，机器没有足够的内存</p>
<p><strong>描述new一个对象的流程</strong><br>虚拟机遇到一条new指令时，首先检查是否被类加载器加载，如果没有，那必须先执行相应的类加载过程。<br>类加载就是把class加载到JVM的运行时数据区的过程<br>1）检查加载<br>首先检查这个指令的参数是否能在常量池中定位到一个类的符号引用（符号引用 ：符号引用以一组符号来描述所引用的目标），并且检查类是否已经被加载、解析和初始化过。<br>2）分配内存<br>接下来虚拟机将为新生对象分配内存。为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。<br>指针碰撞<br>如果Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”。<br>空闲列表<br>如果Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表</p>
<p>选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。<br>如果是Serial、ParNew等带有压缩的整理的垃圾回收器的话，系统采用的是指针碰撞，既简单又高效。<br>如果是使用CMS这种不带压缩（整理）的垃圾回收器的话，理论上只能采用较复杂的空闲列表</p>
<p>并发安全<br>除如何划分可用空间之外，还有另外一个需要考虑的问题是对象创建在虚拟机中是非常频繁的行为，即使是仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况</p>
<p>CAS机制<br>解决这个问题有两种方案，一种是对分配内存空间的动作进行同步处理——实际上虚拟机采用CAS配上失败重试的方式保证更新操作的原子性</p>
<p>分配缓冲<br>另一种是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块私有内存，也就是本地线程分配缓冲（Thread Local Allocation Buffer,TLAB），JVM在线程初始化时，同时也会申请一块指定大小的内存，只给当前线程使用，这样每个线程都单独拥有一个Buffer，如果需要分配内存，就在自己的Buffer上分配，这样就不存在竞争的情况，可以大大提升分配效率，当Buffer容量不够的时候，再重新从Eden区域申请一块继续使用。<br>TLAB的目的是在为新对象分配内存空间时，让每个Java应用线程能在使用自己专属的分配指针来分配空间，减少同步开销。<br>TLAB只是让每个线程有私有的分配指针，但底下存对象的内存空间还是给所有线程访问的，只是其它线程无法在这个区域分配而已。当一个TLAB用满（分配指针top撞上分配极限end了），就新申请一个TLAB。</p>
<p><strong>3）内存空间初始化</strong><br>（注意不是构造方法）内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值(如int值为0，boolean值为false等等)。这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值</p>
<p><strong>4）设置</strong><br>接下来，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息（Java classes在Java hotspot VM内部表示为类元数据）、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头之中。</p>
<p><strong>5）对象初始化</strong><br>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从Java程序的视角来看，对象创建才刚刚开始，所有的字段都还为零值。所以，一般来说，执行new指令之后会接着把对象按照程序员的意愿进行初始化(构造方法)，这样一个真正可用的对象才算完全产生出来</p>
<p>详情可见:<a href="https://crowhawk.github.io/2017/08/09/jvm_1/" target="_blank" rel="noopener">https://crowhawk.github.io/2017/08/09/jvm_1/</a></p>
<p><strong>Java对象会不会分配在栈中？</strong><br>可以，如果这个对象不满足逃逸分析，那么虚拟机在特定的情况下会走栈上分配。</p>
<p><strong>如果判断一个对象是否被回收，有哪些算法，实际虚拟机使用得最多的是什么？</strong><br>引用计数法和根可达性分析两种，用得最多是根可达性分析。</p>
<p><strong>JVM中一次完整的GC流程是怎样的？对象如何晋级到老年代？</strong><br>对象优先在新生代区中分配，若没有足够空间，Minor GC；<br>大对象（需要大量连续内存空间）直接进入老年态；长期存活的对象进入老年态。<br>如果对象在新生代出生并经过第一次MGC后仍然存活，年龄+1，若年龄超过一定限制（15），则被晋升到老年态。</p>
<p><strong>Java中的几种引用关系，他们的区别是什么？</strong><br>强引用<br>一般的Object obj = new Object() ，就属于强引用。在任何情况下，只有有强引用关联（与根可达）还在，垃圾回收器就永远不会回收掉被引用的对象。<br>软引用 SoftReference<br>一些有用但是并非必需，用软引用关联的对象，系统将要发生内存溢出（OuyOfMemory）之前，这些对象就会被回收（如果这次回收后还是没有足够的空间，才会抛出内存溢出）。<br>弱引用 WeakReference<br>一些有用（程度比软引用更低）但是并非必需，用弱引用关联的对象，只能生存到下一次垃圾回收之前，GC发生时，不管内存够不够，都会被回收。<br>虚引用 PhantomReference<br>幽灵引用，最弱（随时会被回收掉）<br>垃圾回收的时候收到一个通知，就是为了监控垃圾回收器是否正常工作</p>
<p><strong>final、finally、finalize的区别？</strong><br>在java中，final可以用来修饰类，方法和变量（成员变量或局部变量）<br>当用final修饰类的时，表明该类不能被其他类所继承。当我们需要让一个类永远不被继承，此时就可以用final修饰，但要注意：<br>final类中所有的成员方法都会隐式的定义为final方法。<br>使用final方法的原因主要有两个：<br>　　(1) 把方法锁定，以防止继承类对其进行更改。<br>　　(2) 效率，在早期的java版本中，会将final方法转为内嵌调用。但若方法过于庞大，可能在性能上不会有多大提升。因此在最近版本中，不需要final方法进行这些优化了。<br>final成员变量表示常量，只能被赋值一次，赋值后其值不再改变。<br>finally作为异常处理的一部分，它只能用在try/catch语句中，并且附带一个语句块，表示这段语句最终一定会被执行（不管有没有抛出异常），经常被用在需要释放资源的情况下<br>Object中的Finalize方法<br>即使通过可达性分析判断不可达的对象，也不是“非死不可”，它还会处于“缓刑”阶段，真正要宣告一个对象死亡，需要经过两次标记过程，一次是没有找到与GCRoots的引用链，它将被第一次标记。随后进行一次筛选（如果对象覆盖了finalize），我们可以在finalize中去拯救。<br>所以建议大家尽量不要使用finalize，因为这个方法太不可靠。在生产中你很难控制方法的执行或者对象的调用顺序，建议大家忘了finalize方法！因为在finalize方法能做的工作，java中有更好的，比如try-finally或者其他方式可以做得更好</p>
<p><strong>String s = new String(“xxx”);创建了几个对象？</strong><br>2个，<br>1、    在一开始字符串”xxx”会在加载类时，在常量池中创建一个字符串对象。<br>2、    调用 new时 会在堆内存中创建一个 String 对象，String 对象中的 char 数组将会引用常量池中字符串。</p>
<h3 id="常量池与String"><a href="#常量池与String" class="headerlink" title="常量池与String"></a>常量池与String</h3><p>常量池有很多概念，包括运行时常量池、class常量池、字符串常量池。<br>虚拟机规范只规定以上区域属于方法区，并没有规定虚拟机厂商的实现。<br>严格来说是静态常量池和运行时常量池，静态常量池是存放字符串字面量、符号引用以及类和方法的信息，而运行时常量池存放的是运行时一些直接引用。<br>运行时常量池是在类加载完成之后，将静态常量池中的符号引用值转存到运行时常量池中，类在解析之后，将符号引用替换成直接引用。<br>这两个常量池在JDK1.7版本之后，就移到堆内存中了，这里指的是物理空间，而逻辑上还是属于方法区（方法区是逻辑分区）。</p>
<p>字面量:<br>给基本类型变量赋值的方式就叫做字面量或者字面值<br>比如：int i=120; long j=10L;<br>符号引用：包括类和方法的全限定名（例如 String 这个类，它的全限定名就是 Java/lang/String）、字段的名称和描述符以及方法的名称和描述符。<br>直接引用：具体对象的索引值。</p>
<h4 id="String-对象是如何实现的？"><a href="#String-对象是如何实现的？" class="headerlink" title="String 对象是如何实现的？"></a>String 对象是如何实现的？</h4><p>了解了 String 对象的实现后，你有没有发现在实现代码中 String 类被 final 关键字修饰了，而且变量 char 数组也被 final 修饰了。我们知道类被 final 修饰代表该类不可继承，而 char[]被 final+private 修饰，代表了 String 对象不可被更改。Java 实现的这个特性叫作 String 对象的不可变性，即 String 对象一旦创建成功，就不能再对它进行改变。<br>在 Java 中，通常有两种创建字符串对象的方式，<br>一种是通过字符串常量的方式创建，如 String str=“abc”；<br>这种方式首先会检查该对象是否在字符串常量池中，如果在，就返回该对象引用，否则新的字符串将在常量池中被创建。这种方式可以减少同一个值的字符串对象的重复创建，节约内存。<br>另一种是字符串变量通过 new 形式的创建，如 String str = new String(“abc”)。<br>这种方式，首先在编译类文件时，”abc”常量字符串将会放入到常量结构中，在类加载时，“abc”将会在常量池中创建；其次，在调用 new 时，JVM 命令将会调用 String 的构造函数，同时引用常量池中的”abc” 字符串，在堆内存中创建一个 String 对象；最后，str 将引用 String 对象。</p>
<p>如果调用 intern方法，会去查看字符串常量池中是否有等于该对象的字符串的引用，如果没有会把首次遇到的字符串的引用添加到常量池中；<br>如果有，就返回常量池中的字符串引用。（这个版本都是基于JDK1.7及以后版本）</p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>ClassLoader与热修复</title>
    <url>/blog/2020/06/jvm-classloader-learn.html</url>
    <content><![CDATA[<p>class文件是Java 字节码文件。一个完整的 Java 程序是由多个 .class 文件组成的，在程序运行过程中，需要将这些 .class 文件加载到 JVM 中才可以使用。而负责加载这些 .class 文件的就是本课时要讲的类加载器（ClassLoader）</p>
<p><strong>Java 中的类何时被加载器加载</strong><br>在 Java 程序启动的时候，并不会一次性加载程序中所有的 .class 文件，而是在程序的运行过程中，动态地加载相应的类到内存中。<br>通常情况下,Java 程序中的 .class 文件会在以下 2 种情况下被 ClassLoader 主动加载到内存中：<br>1.调用类构造器<br>2.调用类中的静态（static）变量或者静态方法</p>
<h3 id="Android中的ClassLoader"><a href="#Android中的ClassLoader" class="headerlink" title="Android中的ClassLoader"></a>Android中的ClassLoader</h3><p><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog3/p14.png" alt><br>1.BootstrapClassLoader<br>用于加载framework层class文件<br>2.PathClassLoader 和 DexClassLoader<br>在 Android 虚拟机里是无法直接运行 .class 文件的，Android 会将所有的 .class 文件转换成一个 .dex 文件，并且 Android 将加载 .dex 文件的实现封装在 BaseDexClassLoader 中，而我们一般只使用它的两个子类：PathClassLoader 和 DexClassLoader。</p>
<p><strong>PathClassLoader</strong><br>当一个 App 被安装到手机后，apk 里面的 class.dex 中的 class 均是通过 PathClassLoader 来加载的</p>
<p><strong>DexClassLoader</strong><br>先来看官方对 DexClassLoader 的描述：</p>
<blockquote>
<p>A class loader that loads classes from .jar and .apk filescontaining a classes.dex entry. This can be used to execute code notinstalled as part of an application.</p>
</blockquote>
<p>很明显，对比 PathClassLoader 只能加载已经安装应用的 dex 或 apk 文件，DexClassLoader 则没有此限制，可以从 SD 卡上加载包含 class.dex 的 .jar 和 .apk 文件，这也是插件化和热修复的基础，在不需要安装应用的情况下，完成需要使用的 dex 的加载</p>
<h4 id="双亲委托机制"><a href="#双亲委托机制" class="headerlink" title="双亲委托机制"></a>双亲委托机制</h4><p>所谓双亲委派模式就是，当类加载器收到加载类或资源的请求时，通常都是先委托给父类加载器加载，也就是说，只有当父类加载器找不到指定类或资源时，自身才会执行实际的类加载过程。<br>其具体实现代码是在 ClassLoader.java 中的 loadClass 方法中，如下所示<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog3/p15.png" alt></p>
<p>解释说明：<br>1.判断该 Class 是否已加载，如果已加载，则直接将该 Class 返回。<br>2.如果该 Class 没有被加载过，则判断 parent 是否为空，如果不为空则将加载的任务委托给parent。<br>3.如果 parent == null，则直接调用 BootstrapClassLoader 加载该类。<br>4.如果 parent 或者 BootstrapClassLoader 都没有加载成功，则调用当前 ClassLoader 的 findClass 方法继续尝试加载。</p>
<p><strong>为什么需要双亲委托机制</strong><br> 1.这样可以避免重复加载，当父亲已经加载了该类的时候，就没有必要子ClassLoader再加载一次。<br> 2.考虑到安全因素，我们试想一下，如果不使用这种委托模式，那我们就可以随时使用自定义的String来动态替代java核心api中定义的类型，这样会存在非常大的安全隐患，而双亲委托的方式，就可以避免这种情况，因为String已经在启动时就被引导类加载器（Bootstrcp ClassLoader）加载，所以用户自定义的ClassLoader永远也无法加载一个自己写的String，除非你改变JDK中ClassLoader搜索类的默认算法。</p>
<p><strong>JVM在搜索类的时候，又是如何判定两个class是相同的呢？</strong><br>JVM在判定两个class是否相同时，不仅要判断两个类名是否相同，而且要判断是否由同一个类加载器实例加载的。只有两者同时满足的情况下，JVM才认为这两个class是相同的。就算两个class是同一份class字节码，如果被两个不同的ClassLoader实例所加载，JVM也会认为它们是两个不同class。比如网络上的一个Java类org.classloader.simple.NetClassLoaderSimple，javac编译之后生成字节码文件NetClassLoaderSimple.class，ClassLoaderA和ClassLoaderB这两个类加载器并读取了NetClassLoaderSimple.class文件，并分别定义出了java.lang.Class实例来表示这个类，对于JVM来说，它们是两个不同的实例对象，但它们确实是同一份字节码文件，如果试图将这个Class实例生成具体的对象进行转换时，就会抛运行时异常java.lang.ClassCaseException</p>
<p>详情可见:<a href="https://www.jianshu.com/p/2459989a09e7" target="_blank" rel="noopener">https://www.jianshu.com/p/2459989a09e7</a></p>
<h3 id="使用-DexClassLoader-实现热修复"><a href="#使用-DexClassLoader-实现热修复" class="headerlink" title="使用 DexClassLoader 实现热修复"></a>使用 DexClassLoader 实现热修复</h3><p>BaseDexClassLoader查找class的代码如下：<br><figure class="highlight monkey"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">Class</span>&lt;?&gt; <span class="title">findClass</span>(<span class="title">String</span> <span class="title">name</span>, <span class="title">List</span>&lt;<span class="title">Throwable</span>&gt; <span class="title">suppressed</span>) &#123;</span></span><br><span class="line">        <span class="keyword">for</span> (Element element : dexElements) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">Class</span>&lt;?&gt; <span class="title">clazz</span> = <span class="title">element</span>.<span class="title">findClass</span>(<span class="title">name</span>, <span class="title">definingContext</span>, <span class="title">suppressed</span>);</span></span><br><span class="line">            <span class="keyword">if</span> (clazz != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> clazz;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dexElementsSuppressedExceptions != <span class="literal">null</span>) &#123;</span><br><span class="line">            suppressed.addAll(Arrays.asList(dexElementsSuppressedExceptions));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog3/p16.png" alt></p>
<p>一个element就是一个dex，按照顺序遍历elements列表，如果找到了就返回对应class</p>
<p><strong>热修复思路</strong><br>1.找到pathList<br>2.得到补丁创建的Element[]<br>3.将原本的dexElements通过反射与补丁elements合并，补丁elements在前<br>将修改dex放在dexElements列表的前面，即可覆盖错误的class</p>
<p>注意，必须在错误类加载前修复，不然下次加载就会直接调用上次加载的内容，导致不能修复，所以常常在Application的attachBaseContext中进行修复<br>这也是tinker修复必须重启的原因.</p>
<p>根据以上思路，热修复代码如下：<br><figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> install(ClassLoader loader, List&lt;File&gt; additionalClassPathEntries,</span><br><span class="line">                                    File optimizedDirectory)</span><br><span class="line">                <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException,</span><br><span class="line">                NoSuchFieldException, InvocationTargetException, NoSuchMethodException,</span><br><span class="line">                IOException &#123;</span><br><span class="line">            <span class="comment">//找到 pathList</span></span><br><span class="line">            Field pathListField = ShareReflectUtil.findField(loader, <span class="string">"pathList"</span>);</span><br><span class="line">            <span class="keyword">Object</span> dexPathList = pathListField.<span class="built_in">get</span>(loader);</span><br><span class="line"></span><br><span class="line">            ArrayList&lt;IOException&gt; suppressedExceptions = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="comment">// 从 pathList找到 makePathElements 方法并执行</span></span><br><span class="line">            <span class="comment">// 得到补丁创建的 Element[]</span></span><br><span class="line">            <span class="keyword">Object</span>[] patchElements = makePathElements(dexPathList,</span><br><span class="line">                    <span class="keyword">new</span> ArrayList&lt;&gt;(additionalClassPathEntries), optimizedDirectory,</span><br><span class="line">                    suppressedExceptions);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将原本的 dexElements 与 makePathElements生成的数组合并</span></span><br><span class="line">            ShareReflectUtil.expandFieldArray(dexPathList, <span class="string">"dexElements"</span>, patchElements);</span><br><span class="line">            <span class="keyword">if</span> (suppressedExceptions.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (IOException e : suppressedExceptions) &#123;</span><br><span class="line">                    Log.w(TAG, <span class="string">"Exception in makePathElement"</span>, e);</span><br><span class="line">                    <span class="keyword">throw</span> e;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="MultiDex原理"><a href="#MultiDex原理" class="headerlink" title="MultiDex原理"></a>MultiDex原理</h3><p>dex 65535原因<br>Android 应用 (APK) 文件包含 Dalvik Executable (DEX) 文件形式的可执行字节码文件，这些文件包含用来运行应用的已编译代码。Dalvik Executable 规范将可在单个 DEX 文件内引用的方法总数限制为 65536，其中包括 Android 框架方法、库方法以及您自己的代码中的方法。在计算机科学领域内，术语千（简称 K）表示 1024（即 2^10）。由于 65536 等于 64 X 1024，因此这一限制称为“64K 引用限制”。<br>详情可见：<a href="https://developer.android.com/studio/build/multidex" target="_blank" rel="noopener">https://developer.android.com/studio/build/multidex</a></p>
<p><strong>解决方案</strong><br>将DexClassLoader的Element[]追加到PathClassLoader中，也就是把所有dex文件都放在了PathClassLoader的PathDexList中</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将DexClassLoader的Element[]追加到PathClassLoader中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> install(ClassLoader loader, List&lt;File&gt; additionalClassPathEntries, File optimizedDirectory) <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException, NoSuchFieldException, InvocationTargetException, NoSuchMethodException &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    Field pathListField = MultiDex.findField(loader, <span class="string">"pathList"</span>);</span><br><span class="line">    <span class="keyword">Object</span> dexPathList = pathListField.<span class="built_in">get</span>(loader);</span><br><span class="line">    ArrayList suppressedExceptions = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    MultiDex.expandFieldArray(dexPathList, <span class="string">"dexElements"</span>, makeDexElements(dexPathList, <span class="keyword">new</span> ArrayList(additionalClassPathEntries), optimizedDirectory, suppressedExceptions));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数组复制过程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> expandFieldArray(<span class="keyword">Object</span> instance, <span class="keyword">String</span> fieldName, <span class="keyword">Object</span>[] extraElements) <span class="keyword">throws</span> NoSuchFieldException, IllegalArgumentException, IllegalAccessException &#123;</span><br><span class="line">    Field jlrField = findField(instance, fieldName);</span><br><span class="line">    <span class="keyword">Object</span>[] original = (<span class="keyword">Object</span>[])((<span class="keyword">Object</span>[])jlrField.<span class="built_in">get</span>(instance));</span><br><span class="line">    <span class="keyword">Object</span>[] combined = (<span class="keyword">Object</span>[])((<span class="keyword">Object</span>[])<span class="keyword">Array</span>.newInstance(original.getClass().getComponentType(), original.length + extraElements.length));</span><br><span class="line">    System.arraycopy(original, <span class="number">0</span>, combined, <span class="number">0</span>, original.length);</span><br><span class="line">    System.arraycopy(extraElements, <span class="number">0</span>, combined, original.length, extraElements.length);</span><br><span class="line">    jlrField.<span class="built_in">set</span>(instance, combined);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Dalvik与art介绍</title>
    <url>/blog/2020/06/dalvik-and-art.html</url>
    <content><![CDATA[<h3 id="什么是-Dalvik"><a href="#什么是-Dalvik" class="headerlink" title="什么是 Dalvik"></a>什么是 Dalvik</h3><p>Dalvik 是 Google 公司自己设计用于 Android 平台的 Java 虚拟机，Android 工程师编写的 Java 或者 Kotlin 代码最终都是在这台虚拟机中被执行的。在 Android 5.0 之前叫作 DVM，5.0 之后改为 ART（Android Runtime）。</p>
<p>在整个 Android 操作系统体系中，ART 位于以下图中红框位置<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog3/p10.png" alt></p>
<blockquote>
<p>其实称 DVM/ART 为 Android 版的 Java 虚拟机，这种说法并不是很准确。虚拟机必须符合 Java 虚拟机规范，也就是要通过 JCM（Java Compliance Kit）的测试并获得授权，但是 DVM/ART 并没有得到授权。</p>
</blockquote>
<p>DVM 大多数实现与传统的 JVM 相同，但是因为 Android 最初是被设计用于手机端的，对内存空间要求较高，并且起初 Dalvik 目标是只运行在 ARM 架构的 CPU 上。针对这几种情况，Android DVM 有了自己独有的优化措施。</p>
<h3 id="Dex-文件"><a href="#Dex-文件" class="headerlink" title="Dex 文件"></a>Dex 文件</h3><p>传统 Class 文件是由一个 Java 源码文件生成的 .Class 文件，而 Android 是把所有 Class 文件进行合并优化，然后生成一个最终的 class.dex 文件。dex 文件去除了 class 文件中的冗余信息（比如重复字符常量），并且结构更加紧凑，因此在 dex 解析阶段，可以减少 I/O 操作，提高了类的查找速度</p>
<p>实际上，dex 文件在 App 安装过程中还会被进一步优化为 odex(optimized dex)</p>
<p>注意：这一优化过程也会伴随着一些副作用，最经典的就是 Android 65535 问题。出现这个问题的根本原因是在 DVM 源码中的 MemberIdsSection.java 类中，有如下一段代码：<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog3/p11.png" alt></p>
<p>如果 items 个数超过 DexFormat.MAX_MEMBER_IDX 则会报错，DexFormat.MAX_MEMBER_IDX 的值为 65535，items 代表 dex 文件中的方法个数、属性个数、以及类的个数。也就是说理论上不止方法数，我们在 java 文件中声明的变量，或者创建的类个数如果也超过 65535 个，同样会编译失败，Android 提供了 MultiDex 来解决这个问题。很多网上的文章说 65535 问题是因为解析 dex 文件到数据结构 DexFile 时，使用了 short 来存储方法的个数，其实这种说法是错误的！</p>
<p>为什么有65535限制，详情可见：<a href="https://www.jianshu.com/p/b17ce6e2388c" target="_blank" rel="noopener">https://www.jianshu.com/p/b17ce6e2388c</a><br>multidex原理可见：<br><a href="https://blog.csdn.net/hp910315/article/details/51681710" target="_blank" rel="noopener">https://blog.csdn.net/hp910315/article/details/51681710</a><br><a href="https://www.jianshu.com/p/1c5e8f281d0d" target="_blank" rel="noopener">https://www.jianshu.com/p/1c5e8f281d0d</a></p>
<h3 id="架构基于寄存器-amp-基于栈堆结构"><a href="#架构基于寄存器-amp-基于栈堆结构" class="headerlink" title="架构基于寄存器&amp;基于栈堆结构"></a>架构基于寄存器&amp;基于栈堆结构</h3><p> JVM 的指令集是基于栈结构来执行的；而 Android 却是基于寄存器的，不过这里不是直接操作硬件的寄存器，而是在内存中模拟一组寄存器。Android 字节码和 Java 字节码完全不同，Android 的字节码（smali）更多的是二地址指令和三地址指令，具体Dalvik 指令可以参考官网 Dalvik 字节码。</p>
<p><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog3/p12.png" alt></p>
<p>解释说明：</p>
<p>add-int 指令需要 3 个寄存器参数：v0、v2、v3。这个指令会将 v2 和 v3 进行相加运算，然后将结果保存在寄存器 v0 中。<br>return 指令将结果返回。<br>可以看出， Dalvik 字节码只需要 2 行指令。基于寄存器的指令明显会比基于栈的指令少，虽然增加了指令长度但却缩减了指令的数量，执行也更为快速。用一张表格来对比基于栈和基于寄存器的实现方式如下：<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog3/p13.png" alt></p>
<p><strong>总结</strong><br>对于基于栈的虚拟机来说，每一个运行时的线程，都有一个独立的栈。栈中记录了方法调用的历史，每有一次方法调用，栈中便会多一个栈桢。最顶部的栈桢称作当前栈桢，其代表着当前执行的方法。基于栈的虚拟机通过操作数栈进行所有操作。 </p>
<p>基于寄存器的虚拟机中没有操作数栈，但是有很多虚拟寄存器。其实和操作数栈相同，这些寄存器也存放在运行时栈中，本质上就是一个数组。与JVM相似，在Dalvik VM中每个线程都有自己的调用栈，方法调用的活动记录以帧为单位保存在调用栈上。</p>
<h3 id="ART与Dalvik"><a href="#ART与Dalvik" class="headerlink" title="ART与Dalvik"></a>ART与Dalvik</h3><p>Dalvik虚拟机执行的是dex字节码，解释执行。从Android 2.2版本开始，支持JIT即时编译（Just In Time）<br>在程序运行的过程中进行选择热点代码（经常执行的代码）进行编译或者优化。</p>
<p><strong>什么是JIT</strong><br>当App运行时，每当遇到一个新类，JIT编译器就会对这个类进行编译，经过编译后的代码，会被优化成相当精简的原生型指令码（即native code），这样在下次执行到相同逻辑的时候，速度就会更快。<br>那么什么是JIT呢？JIT是”Just In Time Compiler”的缩写，就是”即时编译技术”，与Dalvik虚拟机相关。当然，如果你的“这段代码”被重复执行的次数非常少，那么JIT的效果会不太明显。<br>有一点需要注意，那就是dex字节码翻译成本地机器码是发生在应用程序的运行过程中的，并且应用程序每一次重新运行的时候，都要做重做这个翻译工作，所以这个工作并不是一劳永逸，每次重新打开App，运行代码的时候，都需要JIT编译</p>
<h4 id="ART"><a href="#ART" class="headerlink" title="ART"></a>ART</h4><p>而ART（Android Runtime） 是在 Android 4.4 中引入的一个开发者选项，也是 Android 5.0 及更高版本的默认 Android 运行时。ART虚拟机执行的是本地机器码。Android的运行时从Dalvik虚拟机替换成ART虚拟机，并不要求开发者将自己的应用直接编译成目标机器码，APK仍然是一个包含dex字节码的文件。</p>
<p>Dalvik下应用在安装的过程，会执行一次优化，将dex字节码进行优化生成odex文件。而Art下将应用的dex字节码翻译成本地机器码的最恰当AOT时机也就发生在应用安装的时候。ART 引入了预先编译机制（Ahead Of Time），在安装时，ART 使用设备自带的 dex2oat 工具来编译应用，dex中的字节码将被编译成本地机器码。</p>
<p><strong>什么是AOT</strong><br>AOT是”Ahead Of Time”的缩写，指的就是ART(Anroid RunTime)这种运行方式。<br>推出AOT的其中原因之一是JIT即时编译的缺陷。前面介绍过，JIT是运行时编译，这样可以对执行次数频繁的dex代码进行编译和优化，减少以后使用时的翻译时间，虽然可以加快Dalvik运行速度，但是还是有弊病，那就是将dex翻译为本地机器码也要占用时间，所以Google在4.4之后推出了ART，用来替换Dalvik。<br>ART的策略与Dalvik不同，在ART 环境中，应用在第一次安装的时候，字节码就会预先编译成机器码，使其成为真正的本地应用。之后打开App的时候，不需要额外的翻译工作，直接使用本地机器码运行，因此运行速度提高。</p>
<p>当然ART与Dalvik相比，还是有缺点的。<br>（1）ART需要应用程序在安装时，就把程序代码转换成机器语言，所以这会消耗掉更多的存储空间，但消耗掉空间的增幅通常不会超过应用代码包大小的20%<br>（2）由于有了一个转码的过程，所以应用安装时间难免会延长</p>
<h4 id="androidN的运作方式"><a href="#androidN的运作方式" class="headerlink" title="androidN的运作方式"></a>androidN的运作方式</h4><p>ART 使用预先 (AOT) 编译，并且从 Android N混合使用AOT编译，解释和JIT。</p>
<p>1、最初安装应用时不进行任何 AOT 编译（安装又快了），运行过程中解释执行，对经常执行的方法进行JIT，经过 JIT 编译的方法将会记录到Profile配置文件中。</p>
<p>2、当设备闲置和充电时，编译守护进程会运行，根据Profile文件对常用代码进行 AOT 编译。待下次运行时直接使用。</p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>android性能优化</title>
    <url>/blog/2020/06/android-performance-optimization.html</url>
    <content><![CDATA[<h3 id="什么是性能优化"><a href="#什么是性能优化" class="headerlink" title="什么是性能优化"></a>什么是性能优化</h3><p><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog3/p17.png" alt></p>
<p>1.绘制优化<br>2.内存优化<br>3.存储优化<br>4.稳定性优化<br>5.耗电优化<br>6.apk瘦身</p>
<h3 id="启动优化"><a href="#启动优化" class="headerlink" title="启动优化"></a>启动优化</h3><h4 id="启动分类"><a href="#启动分类" class="headerlink" title="启动分类"></a>启动分类</h4><p>1.冷启动<br>2.热启动<br>3.温启动</p>
<p>启动优化一般指的就是冷启动优化</p>
<h4 id="如何对比启动时间"><a href="#如何对比启动时间" class="headerlink" title="如何对比启动时间"></a>如何对比启动时间</h4><p>adb shell am start -W packagename/MainActivity<br>adb shell am start -S -R 10 -W packagename/.MainActivity<br>-S表示每次启动前先强行停止<br>-R表示重复测试次数</p>
<p><strong>结果分析</strong><br>WaitTime 是 startActivityAndWait 这个方法的调用耗时<br>ThisTime 是指调用过程中最后一个 Activity 启动时间到这个 Activity 的 startActivityAndWait 调用结束<br>TotalTime 是指调用过程中第一个 Activity 的启动时间到最后一个 Activity 的 startActivityAndWait 结束 如果过程中只有一个 Activity ，则 TotalTime 等于 ThisTime</p>
<h4 id="优化方向"><a href="#优化方向" class="headerlink" title="优化方向"></a>优化方向</h4><p><strong>利用提前展示出来的Window,快速展示出一个画面，给用户快速反馈的体验</strong><br>1.设置背景图Theme<br>程序启动快，界面先显示背景图，然后再刷新其他界面控件。给人刷新不同步感觉<br>2.把样式设置为透明<br>给人程序启动慢感觉，界面一次性刷出来，刷新同步</p>
<p><strong>四个维度</strong><br>1.必要且耗时：启动初始化，考虑用线程来初始化<br>如tinker,MultiDex等<br>2.必要不耗时：首页绘制<br>3.非必要耗时：数据上报，插件初始化<br>4.非必要不耗时：直接去掉，在需要用的时候再加载</p>
<p><strong>思考方向</strong><br>1.分步加载<br>以大化小，优先级高的放前<br>2.异步加载<br>耗时多的异步化<br>3.延期加载<br>非必要的数据延时加载</p>
<p><strong>通用启动优化方案</strong><br>1.利用主题快速显示界面<br>2.异步初始化组件<br>3.通过梳理业务逻辑，延迟初始化组件、操作<br>4.正确使用线程<br>5.去掉无用代码、重复逻辑等</p>
<h4 id="Systrace与TraceView使用"><a href="#Systrace与TraceView使用" class="headerlink" title="Systrace与TraceView使用"></a>Systrace与TraceView使用</h4><p>Systrace功能： 分析UI卡顿问题，app启动流程，分析锁性能</p>
<p>systrace详细使用可见：<a href="https://github.com/shenzhen2017/newImage/blob/master/blog4/systrace.md" target="_blank" rel="noopener">https://github.com/shenzhen2017/newImage/blob/master/blog4/systrace.md</a></p>
<p><strong>下面介绍一些常见命令</strong><br><code>sched</code>: CPU调度的信息，非常重要；你能看到CPU在每个时间段在运行什么线程；线程调度情况，比如锁信息。<br><code>gfx</code>：Graphic系统的相关信息，包括SerfaceFlinger，VSYNC消息，Texture，RenderThread等；分析卡顿非常依赖这个。<br><code>view</code>: View绘制系统的相关信息，比如onMeasure，onLayout等；对分析卡顿比较有帮助。<br><code>am</code>：ActivityManager调用的相关信息；用来分析Activity的启动过程比较有效。</p>
<p>如：systrace.py -t 10 -o d:/mytrace.html sched gfx view am -a com.example.myapplication</p>
<p><strong>示例</strong><br><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. 测试列表滑动， 桌面滑动等流畅性问题</span><br><span class="line">gfx <span class="built_in">input</span> <span class="keyword">view</span></span><br><span class="line"><span class="number">2</span>. 若在上面的基础上 还需要分析HWUI</span><br><span class="line">gfx <span class="built_in">input</span> <span class="keyword">view</span> hwui  </span><br><span class="line"><span class="number">3</span>. 测试app启动或者进入某个界面的速度</span><br><span class="line">gfx <span class="built_in">input</span> <span class="keyword">view</span> <span class="keyword">am</span>  wm <span class="keyword">res</span></span><br><span class="line"><span class="number">4</span>. 怀疑有GC或者是IO导致的卡顿</span><br><span class="line">gfx <span class="built_in">input</span> <span class="keyword">view</span> dalvik disk </span><br><span class="line"><span class="number">5</span>. 怀疑有power相关的问题 </span><br><span class="line">gfx <span class="built_in">input</span> <span class="keyword">view</span> <span class="keyword">res</span> <span class="keyword">am</span> wm power</span><br></pre></td></tr></table></figure></p>
<p><strong>TraceView用法</strong><br><a href="https://github.com/shenzhen2017/newImage/blob/master/blog4/traceview.md" target="_blank" rel="noopener">https://github.com/shenzhen2017/newImage/blob/master/blog4/traceview.md</a><br><a href="https://www.jianshu.com/p/7e9ca2c73c97" target="_blank" rel="noopener">Android性能优化—TraceView的使用</a><br><a href="https://www.jianshu.com/p/8a24bfb4b0d6" target="_blank" rel="noopener">traceview的使用</a><br>定位卡顿问题的一般过程<br>假设 -》 验证 -》 systrace定位问题(缩小范围) -》 TraceView定位细节问题 </p>
<h3 id="UI卡顿优化"><a href="#UI卡顿优化" class="headerlink" title="UI卡顿优化"></a>UI卡顿优化</h3><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><p>卡顿：从用户角度说，App操作起来缓慢，响应不及时，列表滑动一顿一顿的，动画刷新不流畅等等一些直观感受。从系统角度来说，屏幕刷新的帧率不稳定，无法保证每秒绘制60帧，也就是说有掉帧的情况发生。<br>根本原因是cpu无法在16ms内完界面绘制</p>
<p>如果在主线程做一些耗时操作（网络请求、IO读写等），或者被其他线程挂起（GC），那么页面刷新无法在16ms内完成，就会出现掉帧的情况。</p>
<h4 id="问题检测工具"><a href="#问题检测工具" class="headerlink" title="问题检测工具"></a>问题检测工具</h4><p>当发生掉帧时，需要判断是什么原因导致了UI线程耗时过程或阻塞。这时需要借助一些开发工具来帮助定位。</p>
<h5 id="systrace"><a href="#systrace" class="headerlink" title="systrace"></a>systrace</h5><p>systrace.py 是一个命令行工具，位于 …/sdk/platform-tools/systrace目录下。在应用运行时，它可以帮助我们收集和分析所有进程的计时信息，包含了CPU调度、应用线程、磁盘活动等Android内核数据，然后生成一份HTML报告。</p>
<p>systace对检测应用UI表现非常有效，因为它可以分析你的代码和帧率来识别出问题区域，然后提出可能的解决方案</p>
<p>systrace对每一种警告类型都做出了解释：</p>
<p><strong>Scheduling delay</strong><br>渲染一帧的工作被推迟了几个毫秒，从而导致了不合格。确保UI线程上的代码不会被其他线程上完成的工作阻塞，并且后台线程（例如，网络或位图加载）在android.os.Process＃THREAD_PRIORITY_BACKGROUND中运行或更低，因此它们不太可能中断UI线程。</p>
<p><strong>Expensive measure/layout pass</strong><br>测量/布局花费了很长时间，导致掉帧，要避免在动画过程中触发重新布局。</p>
<p><strong>Long View#draw()</strong><br>记录无效的绘图命令花费了很长时间，在View或Drawable自定义视图时，要避免做耗时操作，尤其是Bitmap的分配和绘制。</p>
<p><strong>Expensive Bitmap uploads</strong><br>修改或新创建Bitmap视图要传送给GPU，如果像素总数很大，这个操作会很耗时。因此在每一帧中要尽量减少Bitmap变更的次数。</p>
<p><strong>Inefficient View alpha usage</strong><br>将alpha设置为半透明值会很耗性能，尤其是对大视图。所以最好短暂地使用alpha属性。</p>
<h5 id="traceview"><a href="#traceview" class="headerlink" title="traceview"></a>traceview</h5><p>TraceView 是 Android SDK 中内置的一个工具，它可以加载 trace 文件，用图形的形式展示代码的执行时间、次数及调用栈，便于我们分析。我们可以在Android Profiler或DDMS中启动它</p>
<p><strong>方法执行时间</strong><br>Incl Cpu Time: 执行方法X及子方法占用Cpu的时间<br>Excl Cpu Time: 执行方法X占用Cpu时间，不包含子方法</p>
<p>Incl Real Time: 执行方法X及子方法总时间<br>Excl Real Time: 执行方法x总时间</p>
<p>Cpu Time/Call: 每次执行方法X占用Cpu时间<br>Real Time/Call: 每次执行方法X总时间</p>
<p><strong>调用次数</strong><br>Calls + Recur Calls/Total: 方法X调用次数和递归调用次数<br>使用时只需要关注 Incl Real Time、Real Time/Call、Calls + Recur Calls/Total这三个指标即可，找出应用包名下的耗时方法调用后加以优化。</p>
<h4 id="常见卡顿原因及解决方案"><a href="#常见卡顿原因及解决方案" class="headerlink" title="常见卡顿原因及解决方案"></a>常见卡顿原因及解决方案</h4><h5 id="过度绘制"><a href="#过度绘制" class="headerlink" title="过度绘制"></a>过度绘制</h5><p><strong>什么是OverDraw</strong><br>Overdraw就是过度绘制，是指在一帧的时间内（16.67ms）像素被绘制了多次，理论上一个像素每次只绘制一次是最优的，但是由于重叠的布局导致一些像素会被多次绘制，而每次绘制都会对应到CPU的一组绘图命令和GPU的一些操作，当这个操作耗时超过16.67ms时，就会出现掉帧现象，也就是我们所说的卡顿，所以对重叠不可见元素的重复绘制会产生额外的开销，需要尽量减少Overdraw的发生</p>
<p><strong>查看Overdraw</strong><br>在开发者选项－调试GPU过度绘制（Show GPU Overdraw）<br>1.没有颜色： 意味着没有overdraw。像素只画了一次。<br>2.蓝色： 意味着overdraw 1倍。像素绘制了两次。大片的蓝色还是可以接受的（若整个窗口是蓝色的，可以摆脱一层）<br>3.绿色： 意味着overdraw 2倍。像素绘制了三次。中等大小的绿色区域是可以接受的但你应该尝试优化、减少它们。<br>4.浅红： 意味着overdraw 3倍。像素绘制了四次，小范围可以接受。<br>5.暗红： 意味着overdraw 4倍。像素绘制了五次或者更多。这是错误的，要修复它们。</p>
<p><strong>如何优化</strong><br>1.合理选择控件容器，推荐使用ConstraintLayout<br>2.去掉window的默认背景,去掉其他不必要的背景<br>3.使用ViewStub<br>4.使用merge<br>5.慎用alpha</p>
<h5 id="主线各耗时操作"><a href="#主线各耗时操作" class="headerlink" title="主线各耗时操作"></a>主线各耗时操作</h5><p>当主线程进行一些耗时操作时也会影响消息回调</p>
<h5 id="主线程挂起"><a href="#主线程挂起" class="headerlink" title="主线程挂起"></a>主线程挂起</h5><p>1.异步线程与主线程竞争CPU资源<br>设置异步线程优先级为Process.THREAD_PRIORITY_BACKGROUND，减少与主线程的竞争。<br>有两种设置优先级的方式：Thread.currentThread().setPriority() 和 Process.setThreadPriority()，两种设置方式相互独立，应该使用后者。<br>2.频繁GC使主线程挂起<br>内存抖动导致频繁GC，会导致主线程挂起</p>
<p>详情可见：<a href="https://blog.csdn.net/joye123/article/details/79425398" target="_blank" rel="noopener">Android性能优化之UI卡顿优化</a></p>
<h3 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h3><p>主要可以从以下3个方面来实现内存优化<br>1.降低运行时内存<br>2.代码优化<br>3.内存泄漏优化</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://carlwe.com/2019/01/11/%E6%B5%85%E8%B0%88Android%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/" target="_blank" rel="noopener">浅谈Android内存优化</a><br><a href="https://mp.weixin.qq.com/s/3QhMGVIcR1yW3xweJCa-9Q" target="_blank" rel="noopener">面试官: 说一下你做过哪些性能优化?</a></p>
<h3 id="说一下你做过哪些性能优化"><a href="#说一下你做过哪些性能优化" class="headerlink" title="说一下你做过哪些性能优化"></a>说一下你做过哪些性能优化</h3><p>主要是从更快，更省，更稳3个方面来做性能优化</p>
<h4 id="更快"><a href="#更快" class="headerlink" title="更快"></a>更快</h4><p>1).启动优化<br>1.解决白屏问题<br>给启动Activity的主题设置一个windowBackground，设置一个占位图，用户启动时可以先看到图片，提高用户体验<br>2.初始化<br>将一些不需要马上用到的第三方库延迟初始化，需要马上用到的尽量异步初始化<br>3.打开首页Activity<br>在然后就是打开首页Activity,Activity真正可见是在onResume之后，在onCreate中会执行setContentView,底层执行xml2View<br>这个方法肯定是耗时的，所以要尽量精简首页的布局，减少过度绘制，减少布局层级，多用ViewStub,Merge等来优化布局</p>
<p>2)减少UI卡顿<br>首先说说屏幕刷新的基本原理，调用invalidate刷新最后都会回调到ViewRootImpl中，然后通过scheduleTraversals向底层注册一个vsync信号监听<br>当vsync回来时，会通过JNI回调回来，向Handler回调一个异步消息，最后是ViewRootImpl去执行performTraversals，调用onMeasure,onLayout,onDraw，执行绘制wtt<br>从上面可知卡顿的原理主要有以下两种<br>1.一个是主线程有其他耗时操作，导致绘制无法在vsync信号发布后16ms内绘制<br>2.当前performTraversals方法耗时，在下一个vsync信号到来时仍然没有绘制完成，造成掉帧</p>
<p>基于以上原理，我们可以通过以下方法来避免<br>1.通过systrace大概定位大概是绘制过程中哪个步骤耗时<br>2.通过TraceView定位具体是哪个方法绘制耗时<br>3.过度绘制优化,通过开发者选项中的showGpuOverDraw来检测是否存在过度绘制</p>
<p>过度绘制优化<br>1.使用合理的布局，如ConstraintLayout<br>2.去除不必要的Window背景等<br>3.使用ViewStub,Merge等减少布局层级</p>
<h4 id="更省"><a href="#更省" class="headerlink" title="更省"></a>更省</h4><p>1)内存优化<br><strong>1.内存泄漏优化</strong><br>内存泄漏的根本原因是长生命周期的对象引用了短生命周期的对象，导致对象不可回收，典型的就如非静态Handler持有了外部类的引用<br>在项目中我使用LeakCanary来检测内存泄漏，他的基本原理是通过applicatio.registerActivityLifeCycleCallbacks来监听所有Activity的生命周期<br>当onDestroy后检测当前页面是否有内存泄漏，并分析结果<br><strong>2.内存抖动优化</strong><br>内存抖动的原因是对象频繁创建和销毁，当对象创建太多时就会触发垃圾回收，垃圾回收时会有stop the world，阻塞所有线程，就会导致卡顿<br>常常发生在onDraw或者for循环中创造对象引起的<br>通过Profiler可以定位内存抖动，首先看内存曲线是否平衡，如果不平稳的话，可以选取一段时间，看看创建对象的数量即可定位<br><strong>3.bitmap优化</strong><br>1.使用统一的bitmap加载器，图片加载框架会对图片进行缓存，使用统一的图片加载器可以减少缓存<br>2.通过inSampleSize缩放图片，在把图片载入前，通过宽高计算一个合适的采样率，避免不必要的内存占用<br>3.根据实际情况，选择不同的图片格式，不同的图片格式一个像素占据的大小不同<br>4.通过inBitmap复用Bitmap,在使用inBitmap前，每创建一个bitmap都要分配一块内存供其使用，可能会造成内存抖动<br>使用inBitmap后，多个Bitmap可以复用同一块内存.在android4.4之前，只能复用内存大小的Bitmap，android4.4之后只要比原来的内存小就行<br><strong>4.一些代码优化</strong><br>1.使用ArrayMap,SparseArray等数据结构替代HashMap等，节省内存<br>2.避免在onDraw时创建对象<br>3.对于一些大内存场景可以考虑使用跨进程，比如webview<br>4.字符串拼接使用StringBuilder而不是+</p>
<p>2)APK体积优化<br>1.使用webp代替png,jpg<br>2.使用Lint查找不必要的文件并删除<br>3.通过混淆压缩代码大小<br>4.离线资源从服务器下载，不必打入APK中</p>
<h4 id="更稳"><a href="#更稳" class="headerlink" title="更稳"></a>更稳</h4><p>1.Lint代码扫描<br>每次提交代码时,Android Studio默认都会开启代码扫描，通过Lint扫描可以有效减少代码警告与一些低级错误<br>2.使用Kotlin减少空指针问题<br>使用kotlin的符号可以有效的减少空指针问题<br>3.OutOfMemory<br>OOM的原因主要有以下两种<br>1.申请的内存超出了可用的内存<br>2.应用申请内存的速度超过GC的速度</p>
<p>解决的方法有两种<br>1.申请更大的内存，如多进程或者在mainifest中设置largeHeap<br>2.减少内存的使用<br>1)使用SpareArray等数据结构取代HashMap等<br>2)使用inSampleSize压缩图片，图片分区域加载，图片内存复用等<br>3)使用统一的图片加载框架，节省内存<br>4)使用StringBuild替代+号<br>5)避免在onDraw等循环地方创建对象<br>还有就是要避免内存泄漏，使用LeakCannary探测，同时使用Profile观察内存曲线，观察是否存在内存抖动<br>4.ANR<br>ANR是因为AMS和WMS会监听APP的响应时间，如果用户在5秒内没有触发响应事件，或者在10S内没有响应广播，20s之内没有响应Service<br>根据原因是因为在主线程进行了耗时操作，导致无法及时响应事件<br>解决方法如下：<br>1.使用StrickMode有助于在开发阶段发现主线程上的耗时操作<br>2.在开发中使用BlockCannary检查耗时操作<br>3.当发生ANR时，可以通过查看日志，与手机存储中的anr.text文件进行分析</p>
<p>5.Crash<br>线上Crash问题通过引入bugly来获取日志定位</p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>android屏幕刷新机制</title>
    <url>/blog/2020/07/android-refresh-mechanism.html</url>
    <content><![CDATA[<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>Android的屏幕刷新中涉及到最重要的三个概念（为便于理解，这里先做简单介绍）<br>CPU：执行应用层的measure、layout、draw等操作，绘制完成后将数据提交给GPU<br>GPU：进一步处理数据，并将数据缓存起来<br>屏幕：由一个个像素点组成，以固定的频率（16.6ms，即1秒60帧）从缓冲区中取出数据来填充像素点</p>
<p>总结一句话就是：CPU 绘制后提交数据、GPU 进一步处理和缓存数据、最后屏幕从缓冲区中读取数据并显示：<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog3/p11.webp" alt></p>
<h3 id="双缓冲机制"><a href="#双缓冲机制" class="headerlink" title="双缓冲机制"></a>双缓冲机制</h3><p>看完上面的流程图，我们很容易想到一个问题，屏幕是以16.6ms的固定频率进行刷新的，但是我们应用层触发绘制的时机是完全随机的（比如我们随时都可以触摸屏幕触发绘制），如果在GPU向缓冲区写入数据的同时，屏幕也在向缓冲区读取数据，会发生什么情况呢？<br>有可能屏幕上就会出现一部分是前一帧的画面，一部分是另一帧的画面，这显然是无法接受的，那怎么解决这个问题呢？</p>
<p>所以，在屏幕刷新中，Android系统引入了双缓冲机制。</p>
<p>GPU只向Back Buffer中写入绘制数据，且GPU会定期交换Back Buffer和Frame Buffer，也就是让Back Buffer 变成Frame Buffer交给屏幕进行绘制，让原先的Frame Buffer变成Back Buffer进行数据写入。<br>交换的频率也是60次/秒，这就与屏幕的刷新频率保持了同步。<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog3/p12.webp" alt></p>
<p>虽然我们引入了双缓冲机制，但是我们知道，当布局比较复杂，或设备性能较差的时候，CPU并不能保证在16.6ms内就完成绘制数据的计算，所以这里系统又做了一个处理。</p>
<p>当你的应用正在往Back Buffer中填充数据时，系统会将Back Buffer锁定。如果到了GPU交换两个Buffer的时间点，你的应用还在往Back Buffer中填充数据，GPU会发现Back Buffer被锁定了，它会放弃这次交换。</p>
<p>这样做的后果就是手机屏幕仍然显示原先的图像，这就是我们常常说的丢帧，所以为了避免丢帧的发生，我们就要尽量减少布局层级，减少不必要的View的invalidate调用，减少大量对象的创建（GC也会占用CPU时间）等等。</p>
<h3 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h3><p>在开始分析android屏幕刷新机制源码之前，我们先看几个问题<br>大伙都清楚，Android 每隔 16.6ms 会刷新一次屏幕。</p>
<p>Q1：但是大伙想过没有，这个 16.6ms 刷新一次屏幕到底是什么意思呢？是指每隔 16.6ms 调用 onDraw() 绘制一次么？</p>
<p>Q2：如果界面一直保持没变的话，那么还会每隔 16.6ms 刷新一次屏幕么？</p>
<p>Q3：界面的显示其实就是一个 Activity 的 View 树里所有的 View 都进行测量、布局、绘制操作之后的结果呈现，那么如果这部分工作都完成后，屏幕会马上就刷新么？</p>
<p>Q4：网上都说避免丢帧的方法之一是保证每次绘制界面的操作要在 16.6ms 内完成，但如果这个 16.6ms 是一个固定的频率的话，请求绘制的操作在代码里被调用的时机是不确定的啊，那么如果某次用户点击屏幕导致的界面刷新操作是在某一个 16.6ms 帧快结束的时候，那么即使这次绘制操作小于 16.6 ms，按道理不也会造成丢帧么？这又该如何理解？</p>
<p>Q5：大伙都清楚，主线程耗时的操作会导致丢帧，但是耗时的操作为什么会导致丢帧？它是如何导致丢帧发生的？</p>
<p>先给出一些初步回答<br>1.我们常说的 Android 每隔 16.6 ms 刷新一次屏幕其实是指底层会以这个固定频率来切换每一帧的画面。</p>
<p>2.这个每一帧的画面也就是我们的 app 绘制视图树（View 树）计算而来的，这个工作是交由 CPU 处理，耗时的长短取决于我们写的代码：布局复不复杂，层次深不深，同一帧内刷新的 View 的数量多不多。</p>
<p>3.CPU 绘制视图树来计算下一帧画面数据的工作是在屏幕刷新信号来的时候才开始工作的，而当这个工作处理完毕后，也就是下一帧的画面数据已经全部计算完毕，也不会马上显示到屏幕上，而是会等下一个屏幕刷新信号来的时候再交由底层将计算完毕的屏幕画面数据显示出来。</p>
<p>4.当我们的 app 界面不需要刷新时（用户无操作，界面无动画），app 就接收不到屏幕刷新信号所以也就不会让 CPU 再去绘制视图树计算画面数据工作，但是底层仍然会每隔 16.6 ms 切换下一帧的画面，只是这个下一帧画面一直是相同的内容。</p>
<p>这部分虽然说是一些基本概念，但其实也包含了一些结论了，所以可能大伙看着会有些困惑：<br>为什么界面不刷新时 app 就接收不到屏幕刷新信号了？为什么绘制视图树计算下一帧画面的工作会是在屏幕刷新信号来的时候才开始的</p>
<h3 id="ViewRootImpl源码分析"><a href="#ViewRootImpl源码分析" class="headerlink" title="ViewRootImpl源码分析"></a>ViewRootImpl源码分析</h3><p>android屏幕刷新的绝大多数工作是由ViewRootImpl实现的，具体源码分析可见：<a href="https://www.jianshu.com/p/0d00cb85fdf3" target="_blank" rel="noopener">https://www.jianshu.com/p/0d00cb85fdf3</a><br>这里直接给出一些过程介绍<br>1.我们知道一个 View 发起刷新的操作时，最终是走到了 ViewRootImpl 的 scheduleTraversals() 里去，然后这个方法会将遍历绘制 View 树的操作 performTraversals() 封装到 Runnable 里，传给 Choreographer，以当前的时间戳放进一个 mCallbackQueue 队列里，然后调用了 native 层的方法向底层注册监听下一个屏幕刷新信号事件。</p>
<p>2.当下一个屏幕刷新信号发出的时候，如果我们 app 有对这个事件进行监听，那么底层它就会回调我们 app 层的 onVsync() 方法来通知。当 onVsync() 被回调时，会发一个 Message 到主线程，将后续的工作切到主线程来执行。</p>
<p>3.切到主线程的工作就是去 mCallbackQueue 队列里根据时间戳将之前放进去的 Runnable 取出来执行，而这些 Runnable 有一个就是遍历绘制 View 树的操作 performTraversals()。在这次的遍历操作中，就会去绘制那些需要刷新的 View。</p>
<p>4.所以说，当我们调用了 invalidate()，requestLayout()，等之类刷新界面的操作时，并不是马上就会执行这些刷新的操作，而是通过 ViewRootImpl 的 scheduleTraversals() 先向底层注册监听下一个屏幕刷新信号事件，然后等下一个屏幕刷新信号来的时候，才会去通过 performTraversals() 遍历绘制 View 树来执行这些刷新操作。</p>
<h4 id="过滤一帧内重复的刷新请求"><a href="#过滤一帧内重复的刷新请求" class="headerlink" title="过滤一帧内重复的刷新请求"></a>过滤一帧内重复的刷新请求</h4><p>整体上的流程我们已经梳理出来的，但还有几点问题需要解决。我们在一个 16.6ms 的一帧内，代码里可能会有多个 View 发起了刷新请求，这是非常常见的场景了，比如某个动画是有多个 View 一起完成，比如界面发生了滑动等等。</p>
<p>按照我们上面梳理的流程，只要 View 发起了刷新请求最终都会走到 ViewRootImpl 中的 scheduleTraversals() 里去，是吧。而这个方法又会封装一个遍历绘制 View 树的操作 performTraversals() 到 Runnable 然后扔到队列里等刷新信号来的时候取出来执行，没错吧。</p>
<p>那如果多个 View 发起了刷新请求，岂不是意味着会有多次遍历绘制 View 树的操作？</p>
<p>当我们调用了一次 scheduleTraversals()之后，直到下一个屏幕刷新信号来的时候，doTraversal() 被取出来执行。在这期间重复调用 scheduleTraversals() 都会被过滤掉的。那么为什么需要这样呢？</p>
<p>其实，想想就能明白了。View 最终是怎么刷新的呢，就是在执行 performTraversals() 遍历绘制 View 树过程中层层遍历到需要刷新的 View，然后去绘制它的吧。既然是遍历，那么不管上一帧内有多少个 View 发起了刷新的请求，在这一次的遍历过程中全部都会去处理的吧。这也是我们从代码上看到的，每一个屏幕刷新信号来的时候，只会去执行一次 performTraversals()，因为只需遍历一遍，就能够刷新所有的 View 了。</p>
<p>而 performTraversals() 会被执行的前提是调用了 scheduleTraversals() 来向底层注册监听了下一个屏幕刷新信号事件，所以在同一个 16.6ms 的一帧内，只需要第一个发起刷新请求的 View 来走一遍 scheduleTraversals() 干的事就可以了，其他不管还有多少 View 发起了刷新请求，没必要再去重复向底层注册监听下一个屏幕刷新信号事件了，反正只要有一次遍历绘制 View 树的操作就可以对它们进行刷新了。</p>
<h4 id="同步屏障消息"><a href="#同步屏障消息" class="headerlink" title="同步屏障消息"></a>同步屏障消息</h4><p>我们知道，Android是基于消息机制的，每一个操作都是一个Message，如果在触发绘制的时候，消息队列中还有很多消息没有被执行，那是不是意味着要等到消息队列中的消息执行完成后，绘制消息才能被执行到，那么依然无法保证Vsync信号和绘制的同步，所以依然可能出现丢帧的现象.</p>
<p>在ViewRootImpl中会将Message有关的绘制请求设置成异步消息(msg.setAsynchronous(true))，为什么要这么做呢？</p>
<p>这时候MessageQueue#postSyncBarrier()就发挥它的作用了，简单来说，它的作用就是一个同步消息屏障，能够把我们的异步消息（也就是绘制消息）的优先级提到最高。</p>
<p>主线程的 Looper 会一直循环调用 MessageQueue 的 next() 来取出队头的 Message 执行，当 Message 执行完后再去取下一个。<br>当 next() 方法在取 Message 时发现队头是一个同步屏障的消息时，就会去遍历整个队列，只寻找设置了异步标志的消息，如果有找到异步消息，那么就取出这个异步消息来执行，否则就让 next() 方法陷入阻塞状态。<br>如果 next() 方法陷入阻塞状态，那么主线程此时就是处于空闲状态的，也就是没在干任何事。</p>
<p>所以，如果队头是一个同步屏障的消息的话，那么在它后面的所有同步消息就都被拦截住了，直到这个同步屏障消息被移除，否则主线程就一直不会去处理同步屏障后面的同步消息<br>那这么同步屏障是什么时候被移除的呢？<br>其实我们就是在我们上面提到的ViewRootImp#doTraversal()方法中。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>界面刷新的本质流程</strong><br>1.通过ViewRootImpl的scheduleTraversals()进行界面的三大流程。<br>2.调用到scheduleTraversals()时不会立即执行，而是将该操作保存到待执行队列中。并给底层的刷新信号注册监听。<br>3.当VSYNC信号到来时，会从待执行队列中取出对应的scheduleTraversals()操作，并将其加入到主线程的消息队列中。<br>4.主线程从消息队列中取出并执行三大流程: onMeasure()-onLayout()-onDraw()</p>
<p><strong>同步屏障的作用</strong><br>1.同步屏障用于阻塞住所有的同步消息(底层VSYNC的回调onVsync方法提交的消息是异步消息)<br>2.用于保证界面刷新功能的performTraversals()的优先执行。</p>
<p><strong>同步屏障的原理？</strong><br>主线程的Looper会一直循环调用MessageQueue的next方法并且取出队列头部的Message执行，遇到同步屏障(一种特殊消息)后会去寻找异步消息执行。如果没有找到异步消息就会一直阻塞下去，除非将同步屏障取出，否则永远不会执行同步消息。<br>界面刷新操作是异步消息，具有最高优先级<br>我们发送的消息是同步消息，再多耗时操作也不会影响UI的刷新操作</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://www.jianshu.com/p/0d00cb85fdf3" target="_blank" rel="noopener">Android 屏幕刷新机制</a><br><a href="https://www.jianshu.com/p/0a54aa33ba7d" target="_blank" rel="noopener">深入浅出Android屏幕刷新原理</a><br><a href="https://github.com/Moosphan/Android-Daily-Interview/issues/17" target="_blank" rel="noopener">面试题：简述一下 Android 中 UI 的刷新机制</a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>kotlin协程总结</title>
    <url>/blog/2020/07/kotlin-coroutines-sum.html</url>
    <content><![CDATA[<h3 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h3><p>进程是资源分配的最小单位，线程是CPU调度的最小单位“这样的回答感觉太抽象，都不太容易让人理解。做个简单的比喻：进程=火车，线程=车厢</p>
<p>1.线程在进程下行进（单纯的车厢无法运行）<br>2.一个进程可以包含多个线程（一辆火车可以有多个车厢）<br>3.不同进程间数据很难共享（一辆火车上的乘客很难换到另外一辆火车，比如站点换乘）<br>4.同一进程下不同线程间数据很易共享（A车厢换到B车厢很容易）<br>5.进程要比线程消耗更多的计算机资源（采用多列火车相比多个车厢更耗资源）进程间不会相互影响，<br>6.一个线程挂掉将导致整个进程挂掉（一列火车不会影响到另外一列火车，但是如果一列火车上中间的一节车厢着火了，将影响到所有车厢）<br>7.进程可以拓展到多机，进程最多适合多核（不同火车可以开在多个轨道上，同一火车的车厢不能在行进的不同的轨道上）<br>8.进程使用的内存地址可以上锁，即一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。（比如火车上的洗手间）<br>9.”互斥锁”进程使用的内存地址可以限定使用量（比如火车上的餐厅，最多只允许多少人进入，如果满了需要在门口等，等有人出来了才能进去）－“信号量”</p>
<h3 id="协程是什么"><a href="#协程是什么" class="headerlink" title="协程是什么"></a>协程是什么</h3><p>协程（Coroutines）是一种比线程更加轻量级的存在，正如一个进程可以拥有多个线程一样，一个线程可以拥有多个协程<br>协程是一种在程序中处理并发任务的方案。</p>
<p>kotlin的协程本质上基于线程实现，所以kotlin协程不属于广义上的协程，而是一个线程框架。</p>
<ol>
<li>它是 Kotlin 基于 JVM 的线程来实现的一个并发任务处理框架（或者方案）。</li>
<li>优势：<br>2.1 方便：不需要回调，用纯线性的方式就可以完成线程的切换；<br>2.2 性能：所有耗时任务可以保证一定放在后台执行，从而提高软件性能。</li>
</ol>
<h3 id="协程的性能优势"><a href="#协程的性能优势" class="headerlink" title="协程的性能优势"></a>协程的性能优势</h3><p><strong>什么时候需要切换线程</strong><br>1.工作比较耗时，放在后台<br>2.工作比较特殊，放在指定线程，一般是主线程</p>
<h3 id="suspend关键字的意义是什么"><a href="#suspend关键字的意义是什么" class="headerlink" title="suspend关键字的意义是什么"></a>suspend关键字的意义是什么</h3><p>语法层面：作为一个标记和提醒。通过报错来提醒调用者和编译器，这是一个耗时函数，需要放在后台执行。</p>
<p>编译器层面：辅助 Kotlin 编译器来把代码转换成 JVM 的字节码。</p>
<h3 id="如果不使用协程，让你自己实现一个和协程类似的框架，你认为难点在哪里？"><a href="#如果不使用协程，让你自己实现一个和协程类似的框架，你认为难点在哪里？" class="headerlink" title="如果不使用协程，让你自己实现一个和协程类似的框架，你认为难点在哪里？"></a>如果不使用协程，让你自己实现一个和协程类似的框架，你认为难点在哪里？</h3><ol>
<li>在不使用回调的前提下完成线程切换；</li>
<li>在挂起函数执行完毕时，自动判断应该回到哪个线程。</li>
</ol>
<h3 id="delay与ThreadSleep区别"><a href="#delay与ThreadSleep区别" class="headerlink" title="delay与ThreadSleep区别"></a>delay与ThreadSleep区别</h3><p>由于delay是挂起函数，因此调用delay会导致无阻塞挂起，从而允许其他协同程序执行。延迟执行完成5秒后，我们从离开的地方继续执行Coroutine。在Dispatch.Main中是用handler实现的<br>而Thread.sleep（）的情况下，由于它是一个阻塞调用，sleep()方法导致了程序暂停执行指定的时间，让出cpu该其他线程，但是他的监控状态依然保持者，当指定的时间到了又会自动恢复运行状态。<br>在调用sleep()方法的过程中，线程不会释放对象锁。</p>
<h3 id="CorountineContext与CorountineScope分别是什么含义？"><a href="#CorountineContext与CorountineScope分别是什么含义？" class="headerlink" title="CorountineContext与CorountineScope分别是什么含义？"></a>CorountineContext与CorountineScope分别是什么含义？</h3><h3 id="CorountineScope的加号代表什么意思？"><a href="#CorountineScope的加号代表什么意思？" class="headerlink" title="CorountineScope的加号代表什么意思？"></a>CorountineScope的加号代表什么意思？</h3><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://www.jianshu.com/p/e1061501bdc4" target="_blank" rel="noopener">https://www.jianshu.com/p/e1061501bdc4</a><br><a href="https://kaixue.io/kotlin-coroutines-1/" target="_blank" rel="noopener">https://kaixue.io/kotlin-coroutines-1/</a><br><a href="https://zhuanlan.zhihu.com/p/157838166" target="_blank" rel="noopener">我写了一本书，《深入理解 Kotlin 协程》</a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>时间复杂度与空间复杂度</title>
    <url>/blog/2020/07/time-space-complecity.html</url>
    <content><![CDATA[<h3 id="常见的时间复杂度"><a href="#常见的时间复杂度" class="headerlink" title="常见的时间复杂度"></a>常见的时间复杂度</h3><p><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog3/p18.png" alt></p>
<h3 id="时间复杂曲线"><a href="#时间复杂曲线" class="headerlink" title="时间复杂曲线"></a>时间复杂曲线</h3><p><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog3/p19.png" alt></p>
<h3 id="主定理"><a href="#主定理" class="headerlink" title="主定理"></a>主定理</h3><p>递归与分治算法的主定理<br>一维数组二分查找 O(logn)<br>二叉树遍历 O(n)<br>排好序的二维矩阵中二分查找 O(n)<br>归并排序 nlogn<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog4/p1.png" alt></p>
<h3 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h3><p>1.二叉树遍历时间复杂度<br>O(n)<br>2.图的遍历时间复杂度<br>O(n)<br>3.BFS,DFS时间复杂度<br>O(n)<br>因为节点只访问了一次<br>4.二分查找法<br>log(n)</p>
<h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>1.数组的长度<br>2.递归的深度<br>如果是有递归的话，空间复杂度则是递归的深度<br>如果即有数组，又有递归，则是他们的最大值 </p>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>利用设计模式封装网络请求框架</title>
    <url>/blog/2020/07/network-design-pattern.html</url>
    <content><![CDATA[<p>在项目中有这样一种场景，内外网项目有一些共同代码，其中有一些网络请求。<br>但是内外网代码所用的网络请求框架并不一致，那应该如何封装这些网络请求呢？</p>
<h3 id="原始版本"><a href="#原始版本" class="headerlink" title="原始版本"></a>原始版本</h3><p>内外网使用不同网络请求库，导致每个网络请求都要写两遍，不利于代码维护与扩展<br>项目结构大致如下：<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog4/p5.png" alt></p>
<h3 id="使用外观模式优化"><a href="#使用外观模式优化" class="headerlink" title="使用外观模式优化"></a>使用外观模式优化</h3><p>定义:要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行，门面模式提供了一个高层次的接口，使得子系统更易于使用；</p>
<p>目的:（1）门面对象是通往外界子系统内部的唯一通道；（2）通过门面对象降低程序耦合；</p>
<p>外观模式可以使客户端与第三方库（子系统）解耦，让子系统内部模块功能更容易拓展和维护。<br>同时满足单一职责原则：客户端根本不需要知道第三方系统提供什么功能甚至不需要知道第三方系统如何使用，只需要和中间门面类交互即可。<br>因为网络请求都可以大致分为get,post,patch,delete等几种类型，定义一个外观类实现这几个接口即可实现封装<br>项目结构大致如下：<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog4/p6.png" alt></p>
<p><strong>优点</strong><br>1.降低耦合，减少了系统依赖<br>2.职责分明，不管第三方库如何修改，只要不影响门面，客户都可以自由行动</p>
<p><strong>缺点</strong><br>1.当第三方库修改的时候，要需要对外观类进行修改，违反了对扩展开放，对修改关闭的开闭原则<br>2.公共库同时依赖两个网络请求库，有重复依赖.</p>
<h3 id="使用代理模式优化"><a href="#使用代理模式优化" class="headerlink" title="使用代理模式优化"></a>使用代理模式优化</h3><p>定义：给目标对象提供一个代理对象，并由代理对象控制对目标对象的引用；<br>目的：（1）通过引入代理对象的方式来间接访问目标对象，防止直接访问目标对象给系统带来的不必要复杂性； （2）通过代理对象对原有的业务增强；</p>
<p>项目结构大致如下：<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog4/p7.png" alt></p>
<p>在Application中初始化的时候，不同的项目初始化不同的代理对象，这样就实现了对不同网络框架的兼容，增强了系统了扩展性。<br>同时不同的项目只需要依赖自已的网络框架，减小了包的体积.</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="哪些地方用到了什么设计模式"><a href="#哪些地方用到了什么设计模式" class="headerlink" title="哪些地方用到了什么设计模式"></a>哪些地方用到了什么设计模式</h4><p>1.装饰模式— context源码<br>2.建造者模式——Okhttp源码解析中分析</p>
<p>3.代理模式 ——注解中讲解<br>4.享元模式——handler源码<br>5.适配器模式——RecyclerView<br>6.代理模式 —— 注解中讲解/retrofit源码中讲解<br>7.外观模式—— Glide,Retrofit</p>
<p>8.迭代器模式—— 容器中用的非常广泛<br>9.观察者设计模式——rxjava<br>10.责任链模式——Okhttp源码/事件分发源码</p>
<p>详情可见：<a href="https://alleniverson.gitbooks.io/android-source-analysis/design_patterns/proxy/" target="_blank" rel="noopener">Android设计模式源码解析</a></p>
<h4 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a>设计模式分类</h4><p><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog4/p8.png" alt></p>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap原理解析</title>
    <url>/blog/2020/07/hashmap-source-analy.html</url>
    <content><![CDATA[<h3 id="HashMap、Hashtable、ConcurrentHashMap的原理与区别"><a href="#HashMap、Hashtable、ConcurrentHashMap的原理与区别" class="headerlink" title="HashMap、Hashtable、ConcurrentHashMap的原理与区别"></a>HashMap、Hashtable、ConcurrentHashMap的原理与区别</h3><p><strong>HashTable</strong><br>1.底层数组+链表实现，无论key还是value都不能为null，线程安全，实现线程安全的方式是在修改数据时锁住整个HashTable，效率低，ConcurrentHashMap做了相关优化<br>2.初始size为11，扩容：newsize = olesize*2+1<br>3.计算index的方法：index = (hash &amp; 0x7FFFFFFF) % tab.length</p>
<p><strong>HashMap</strong><br>1.底层数组+链表实现，可以存储null键和null值，线程不安全<br>2.初始size为16，扩容：newsize = oldsize*2，size一定为2的n次幂<br>3.扩容针对整个Map，每次扩容时，原来数组中的元素依次重新计算存放位置，并重新插入<br>4.插入元素后才判断该不该扩容，有可能无效扩容（插入后如果扩容，如果没有再次插入，就会产生无效扩容）<br>5.当Map中元素总数超过Entry数组的75%，触发扩容操作，为了减少链表长度，元素分配更均匀<br>6.计算index方法：index = hash &amp; (tab.length – 1)</p>
<p><strong>ConcurrentHashMap</strong><br>1.底层采用分段的数组+链表实现，线程安全<br>2.通过把整个Map分为N个Segment，可以提供相同的线程安全，但是效率提升N倍，默认提升16倍。(读操作不加锁，由于HashEntry的value变量是 volatile的，也能保证读取到最新的值。)<br>3.Hashtable的synchronized是针对整张Hash表的，即每次锁住整张表让线程独占，ConcurrentHashMap允许多个修改操作并发进行，其关键在于使用了锁分离技术<br>4.有些方法需要跨段，比如size()和containsValue()，它们可能需要锁定整个表而而不仅仅是某个段，这需要按顺序锁定所有段，操作完毕后，又按顺序释放所有段的锁<br>5.扩容：段内扩容（段内元素超过该段对应Entry数组长度的75%触发扩容，不会对整个Map进行扩容），插入前检测需不需要扩容，有效避免无效扩容</p>
<p><a href="https://www.cnblogs.com/heyonggang/p/9112731.html" target="_blank" rel="noopener">https://www.cnblogs.com/heyonggang/p/9112731.html</a></p>
<h4 id="ConcurrentHashMap详解"><a href="#ConcurrentHashMap详解" class="headerlink" title="ConcurrentHashMap详解"></a>ConcurrentHashMap详解</h4><p><strong>JDK7：分段锁</strong><br>Segment[]和HashEntry[]长度皆为2的N次方，ConcurrentHashMap初始化后，Segment[]长度就固定不变了。扩容时，只需对某个Segment[i]中的HashEntry[]扩容（创建一个2倍长度的新HashEntry[]，旧数组中元素rehash，插入到新数组中）。</p>
<p>put时，第一次hash，定位Segment[i]，然后获取ReentrantLock锁，再次hash，定位HashEntry[i]。如果新增该元素，超过了HashEntry[]的阈值，将先进行扩容，再插入元素（HashMap是先插入元素，再进行扩容）。<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog4/p1.webp" alt></p>
<p><strong>JDK8：使用synchronized，弃用分段锁（锁粒度更小）</strong><br>put时，如果table[i]==null，则使用CAS操作把元素插入数组，插入失败，表示有其他线程已经在该位置插入元素，然后继续下次循环。此时会遇到synchronized代码块（它只锁当前Node[i]）。如果该位置是链表，则添加到链表尾部。如果该位置是红黑树，则插入树里面。当链表长度&gt;=8时，链表会转化成红黑树。<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog4/p2.webp" alt></p>
<p>详情可见：<br><a href="https://www.jianshu.com/p/ba2e5bc8970c" target="_blank" rel="noopener">Hashtable、HashMap、ConcurrentHashMap对比–区分1.7与1.8</a><br><a href="https://www.jianshu.com/p/c0642afe03e0" target="_blank" rel="noopener">深入浅出ConcurrentHashMap1.8</a></p>
<h3 id="HashMap源码分析与jdk1-7与1-8之间HashMap的区别"><a href="#HashMap源码分析与jdk1-7与1-8之间HashMap的区别" class="headerlink" title="HashMap源码分析与jdk1.7与1.8之间HashMap的区别"></a>HashMap源码分析与jdk1.7与1.8之间HashMap的区别</h3><p>详情可见：<br><a href="https://yuanrengu.com/2020/ba184259.html" target="_blank" rel="noopener">https://yuanrengu.com/2020/ba184259.html</a><br><a href="https://blog.csdn.net/zhengwangzw/article/details/104889549" target="_blank" rel="noopener">一个HashMap能跟面试官扯上半个小时</a><br><a href="https://zhuanlan.zhihu.com/p/147209395" target="_blank" rel="noopener">HashMap的21 连击！一招下来你还有多少血？</a></p>
<h3 id="为什么面试喜欢问hashmap"><a href="#为什么面试喜欢问hashmap" class="headerlink" title="为什么面试喜欢问hashmap"></a>为什么面试喜欢问hashmap</h3><p><strong>你能简述一下Java里面HashMap的实现原理吗</strong><br>HashMap底层由数组加链表结构实现<br>数组用来存放元素位置，链表用来解决hash冲突。</p>
<p>当往HashMap中添加对象时，先计算key的hashCode，然后根据hashCode计算出元素应该放到数组的哪个位置。找到对应的位置，判断该位置是否已存在该键值对，如果已存在，那么覆盖掉原来的value，如果不存在，那么放到该位置。链表的存在就是为了解决不同key出现hash冲突的问题。Java8之前一般元素会放到链表头，这样做减少操作,但是在Java8及之后都使用尾插法,因为头插法在扩容时可能导致死循环f。</p>
<p>HashMap有一个扩容因子0.75，当元素数量大于数组长度乘以扩容因子时，会触发扩容操作。扩容时，将数组长度变为原来2倍，然后将元素重新计算hashCode放到相应的位置。</p>
<p><strong>往HashMap中put元素的时候，先根据key计算hashCode，然后找到在数组中的相应位置。那么，根据hashCode是如何找到在数组中的具体位置的呢？采用什么算法？</strong><br>怎么根据hashCode找到元素在数组的位置呢？一般有点数理逻辑的人都能说出来，只要用hashCode对数组长度取模即可。如果候选人看过源码，可能会说使用位运算，hashCode&amp;(length-1)。</p>
<p><strong>底层数组的初始长度是多少？为什么会设计成这个数呢？</strong><br>底层数组默认长度是16， 每次扩容乘以2，都保证长度length是2的n次幂。原因就是这样可以使用位运算来加快计算在数组中的位置<br>数据长度为2的n次幂，可以保证位运算的结果等于取余</p>
<p><strong>扩容因子0.75， 那么什么时候会触发扩容？是数组中元素占用位置数量还是HashMap总的元素数量超过扩容因子时会扩容？</strong><br>很多人在这个问题上会掉进陷阱里。我会这样问，是数组中占用位置个数大于扩容因子的时候还是HashMap元素总数大于扩容因子的时候需要扩容？</p>
<p>如果对HashMap理解不透彻，这里很容易就答错了。这里HashMap中元素总个数达到阈值时就会扩容。很多人可能会疑问，为什么是总个数，而不是数组占用个数呢？</p>
<p>想象一下这个情况：假设有12个元素都落到了数组的同一个位置（当然现实情况这种机率非常非常小，几乎没有），数组只占用了一个位置，那么为什么要扩容呢，还有那么多位置没用呢？其实这里之所以要扩容，是有一个隐含的逻辑，如果元素总个数大于阈值，而数组占用位置没达到阈值，说明这些元素在当前长度下，分布是“不均匀”的，扩容是为了让其分布“更均匀”</p>
<p><strong>扩容的时候，你说要重新计算hashCode，但是对于一个key而言，扩容时其hashCode的值是不变的，为什么要重新计算hashCode呢？直接从旧的数组中移到新的数组相应的位置不可以么？</strong><br>这也是一个陷阱，很多人都知道扩容时要重新计算hash，重新放置元素，却不知道为何这样做。</p>
<p>有些候选人不是很清晰HashMap的实现，可能就直接掉进来了，说可以。</p>
<p>当然，更多的候选人看过文章，看过源码，可能说不可以，要重新计算。我会继续追问，为什么要重新计算呢，对于一个key而言，扩容与否，其hashCode都是不变的，平移过来岂不是效率更高？</p>
<p>其实，这是不可以的，如果可以，源码实现上也就不重新计算，重新放置了。虽然key的hashCode不会变，但是数组长度变了，在根据hashCode计算数组位置时，得出的索引值肯定是不同的，如果平移过来，会直接导致扩容前添加到HashMap中的数据无法被get()到。因为在数组中索引变了，找不到了。</p>
<p>上面说的是1.7的实现,1.8中发生了改变<br>1.7扩容时需要重新计算哈希值和索引位置，1.8并不重新计算哈希值，巧妙地采用和扩容后容量进行&amp;操作来计算新的索引位置。</p>
<p><strong>为什么1.8之后使用红黑树</strong><br>在jdk1.8中HashMap的内部结构可以看作是数组(Node&lt;K,V&gt;[] table)和链表的复合结构，数组被分为一个个桶（bucket），通过哈希值决定了键值对在这个数组中的寻址（哈希值相同的键值对，则以链表形式存储。有一点需要注意，如果链表大小超过阈值（TREEIFY_THRESHOLD,8），图中的链表就会被改造为树形（红黑树）结构。</p>
<p>1.8与1.7最大的不同就是利用了红黑树，即由数组+链表（或红黑树）组成。</p>
<p>在分析jdk1.7中HashMap的hash冲突时，不知大家是否有个疑问就是万一发生碰撞的节点非常多怎么办？如果说成百上千个节点在hash时发生碰撞，存储一个链表中，那么如果要查找其中一个节点，那就不可避免的花费O(N)的查找时间，这将是多么大的性能损失。这个问题终于在JDK1.8中得到了解决，在最坏的情况下，链表查找的时间复杂度为O(n),而红黑树一直是O(logn),这样会提高HashMap的效率</p>
<p><strong>说说你对红黑树的见解？</strong><br>红黑树即自平衡二叉查找树,所以要理解红黑树首先要理解平衡二叉树与二叉查找树<br>1.平衡二叉树<br>平衡树(Balance Tree，BT) 指的是，任意节点的子树的高度差都小于等于1<br>2.二叉查找树<br>每一个节点的比较值都必须大于或等于在它的左子树中的所有节点，并且小于或等于在它的右子树中的所有节点</p>
<p>每个节点非红即黑<br>根节点总是黑色的<br>如果节点是红色的，则它的子节点必须是黑色的（反之不一定）<br>每个叶子节点都是黑色的空节点（NIL节点）<br>从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）</p>
<p><strong>详情可见</strong></p>
<p><a href="https://www.jianshu.com/p/79b9284d8c84" target="_blank" rel="noopener">为什么面试都喜欢问HashMap</a><br><a href="https://blog.csdn.net/sinat_33921105/article/details/103847137" target="_blank" rel="noopener">害怕面试被问HashMap？这一篇就搞定了！</a><br><a href="https://blog.csdn.net/mbshqqb/article/details/79799009" target="_blank" rel="noopener">为什么面试要问hashmap 的原理</a></p>
<h3 id="为什么重写equal必须重写HashMap"><a href="#为什么重写equal必须重写HashMap" class="headerlink" title="为什么重写equal必须重写HashMap"></a>为什么重写equal必须重写HashMap</h3><p>hashCode 方法用于散列集合的查找，equals 方法用于判断两个对象是否相等。</p>
<p>为什么重写了 equals 方法，还要重写 hashCode 方法？<br>因为如果只重写了 equals 方法，两个对象 equals 返回了true，但是如果没有重写 hashCode 方法，集合还是会插入元素。这样集合中就出现了重复元素了。</p>
<p><strong>总结</strong><br>总结：<br>1.hashCode是为了提高在散列结构存储中查找的效率，在线性表中没有作用。<br>2.equals和hashCode需要同时覆盖。<br>3.若两个对象equals返回true，则hashCode有必要也返回相同的int数。<br>4.若两个对象equals返回false，则hashCode不一定返回不同的int数,但为不相等的对象生成不同hashCode值可以提高 哈希表的性能。</p>
<p>5.若两个对象hashCode返回相同int数，则equals不一定返回true。</p>
<p>6.若两个对象hashCode返回不同int数，则equals一定返回false。</p>
<p>7.同一对象在执行期间若已经存储在集合中，则不能修改影响hashCode值的相关信息，否则会导致内存泄露问题。</p>
<p>详情可见：<br><a href="https://blog.csdn.net/baidu_40389775/article/details/87173379" target="_blank" rel="noopener">https://blog.csdn.net/baidu_40389775/article/details/87173379</a><br><a href="https://blog.csdn.net/xyh269/article/details/69171545" target="_blank" rel="noopener">https://blog.csdn.net/xyh269/article/details/69171545</a><br><a href="https://juejin.im/post/5ceb5ec451882505107f63e9#heading-1" target="_blank" rel="noopener">https://juejin.im/post/5ceb5ec451882505107f63e9#heading-1</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/147209395" target="_blank" rel="noopener">HashMap的21 连击！一招下来你还有多少血？</a></p>
<h3 id="HashMap与SparseArray"><a href="#HashMap与SparseArray" class="headerlink" title="HashMap与SparseArray"></a>HashMap与SparseArray</h3><p><strong>HashMap</strong><br>1.增加<br>先计算key的hash值（装箱拆箱）<br>根据hash值找到数组位置，再往链表中添加元素O(1)</p>
<p>2.查找<br>先计算key的hash值（装箱拆箱）<br>根据hash值找到数组位置，再遍历链表</p>
<p>3.删除<br>先计算key的hash值（装箱拆箱）<br>根据hash值找到数组位置，再从链表中删除节点</p>
<p><strong>SparseArray</strong><br>1.增加<br>根据key值进行二分查找，找到可以添加元素的位置，然后插入数据，并移动其他数据</p>
<p>2.查找<br>根据key值进行二分查找，找到数组下标，取出对应value值</p>
<p>3.删除<br>先计算key的hash值（装箱拆箱）<br>根据key值进行二分查找，找到数组下标，再将元素设置为deleted</p>
<p><strong>效率对比</strong><br>1.查找：对一个数据或者是几个数据的查询.二者的差异还是非常小的.当数据量是100000条.查100000条的效率还是Map要快一点.数据量为10000的时候.这就差异性就更小.但是Map的查找的效率确实还是赢了一筹</p>
<p>2.正序插入：SparseArray在正序插入的时候，效率要比HashMap要快得多，并且还节省了一部分内存。</p>
<p>3.倒序插入：SparseArray与HashMap无论是怎样进行插入,数据量相同时,前者都要比后者要省下一部分内存,但是效率呢？在倒序插入的时候,SparseArray的插入时间和HashMap的插入时间远远不是一个数量级,由于SparseArray每次在插入的时候都要使用二分查找判断是否有相同的值被插入.因此这种倒序的情况是SparseArray效率最差的时候。</p>
<p>4.内存:在保存&lt;Integer,E&gt;时使用SparseArray去替换HashMap的主要原因还是因为内存的关系.保存的数据量无论是大还是小,Map所占用的内存始终是大于SparseArray的.数据量100000条时SparseArray要比HashMap要节约27%的内存.也就是以牺牲效率的代价去节约内存空间.我们知道Android对内存的使用是极为苛刻的.堆区允许使用的最大内存仅仅16M.很容易出现OOM现象的发生.因此在Android中内存的使用是非常的重要的.因此官方才推荐去使用SparseArray去替换HashMap&lt;Integer,E&gt;.官方也确实声明这种差异性不会超过50%.所以牺牲了部分效率换来内存其实在Android中也算是一种很好的选择吧</p>
<p><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog4/p2.png" alt></p>
<h3 id="HashMap与ArrayMap"><a href="#HashMap与ArrayMap" class="headerlink" title="HashMap与ArrayMap"></a>HashMap与ArrayMap</h3><p><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog4/p19.png" alt><br>ArrayMap内部通过两个数组保存映射关系，其中int[] mHashes按大小顺序保存Key对象hashCode值，Object[] mArray按mHashes的顺序y用相邻位置保存Key对象和Value对象。可以发现ArrayMap使用一个数组同时保存key和value对象，所以mArray长度一定是mHashes长度的2倍</p>
<p>ArrayMap相对于HashMap，无需为每个键值对创建Node对象，并且在数组中连续存放，这就是为什么ArrayMap相对HashMap要节省空间。<br>ArrayMap也是通过Key对象的hashCode方法返回int型hash值，通过一系列计算获取对应在数组中的下标。</p>
<p><strong>ArrayMap存取步骤</strong><br>第一步，调用key对象的hashCode方法获取int值<br>通过Key对象的hashCode方法，获取int型的Hash值，如果key对象为null则为0。这里和HashMap是完全一样的。<br>和之前一样，将”key对象的hashCode方法获取的int型hash值“起名为hash</p>
<p>第二步，通过二分法查找获取hash在mHashes数组中的下标index<br>mHashes中的hash值是按照有小到大的顺序(自然排序)连续摆放的，通过binarySearch获取对应hash的下标index，去mArray中查找键值对</p>
<p>第三步，mHashes下标查找mArray键值对<br>mHashes中的index<em>2即为mArray中的Key下标，index</em>2+1为Value的下标。由于存在hash碰撞的情况，而二分法查找到下标可能是多个连续相同hash值中的任意一个，所以此时需要用equals比对对命中的Key对象是否相符，不相符时，从当前index先向后再向前遍历所有相同hash值。</p>
<p>存取<br>由于是用数组中连续位置存放的，数组各元素中没有空余位置，空间占用更优。最好的情况时在最尾部增删，如果在中间增删则需要移动数组元素，这里和ArrayList原理相同不再细说。<br>index是通过二分法查找或者向后遍历获取的，插入时可以直接使用。</p>
<p><strong>总结</strong><br>ArrayMap相比HashMap更省内存，但是查找，插入效率更低.</p>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Activity启动流程</title>
    <url>/blog/2020/07/activity-startup-process.html</url>
    <content><![CDATA[<p>在手机桌面应用中点击某一个 icon 之后，实际上最终就是通过 startActivity 去打开某一个 Activity 页面。我们知道 Android 中的一个 App 就相当于一个进程，所以 startActivity 操作中还需要判断，目标 Activity 的进程是否已经创建，如果没有，则在显示 Activity 之前还需要将进程 Process 提前创建出来。</p>
<p>假设是从 ActivityA 跳转到另一个 App 中的 ActivityB，过程如下图所示<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog4/p3.png" alt><br>整个 startActivity 的流程分为 3 大部分，也涉及 3 个进程之间的交互：</p>
<p>ActivityA –&gt; ActivityManagerService（简称 AMS）<br>ActivityManagerService –&gt; ApplicationThread<br>ApplicationThread –&gt; Activity</p>
<h3 id="Activity启动流程分析"><a href="#Activity启动流程分析" class="headerlink" title="Activity启动流程分析"></a>Activity启动流程分析</h3><h4 id="一-startActivity-–-gt-ActivityManagerService"><a href="#一-startActivity-–-gt-ActivityManagerService" class="headerlink" title="(一) startActivity –&gt; ActivityManagerService"></a>(一) startActivity –&gt; ActivityManagerService</h4><p>ActivityManagerService后续简称 AMS。先放一张时序图:<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog4/p3.webp" alt></p>
<p>1.Instrumentation类主要用来监控应用程序与系统交互<br>2.红色字体标明的mMainThread是ActivityThread类型，ActivityThread可以理解为一个进程，在这就是A所在的进程<br>3.通过mMainThread获取一个ApplicationThread的引用，这个引用就是用来实现进程间通信的，具体来说就 AMS 所在的系统进程通知应用程序进程进行一系列操作，后面会用到</p>
<h4 id="二-AMS-–-gt-ApplicationThread"><a href="#二-AMS-–-gt-ApplicationThread" class="headerlink" title="(二) AMS –&gt; ApplicationThread"></a>(二) AMS –&gt; ApplicationThread</h4><p>接下来就看下在AMS中是如何一步一步执行到B进程的。这里先剧透一下: 刚才在看Instrumentation的时候，我们讲过一个ApplicationThread类，这个类是实现进程间通信的，这里AMS最终其实就是调用了B进程中的一个ApplicationThread引用，从而间接的通知B进程进行相应操作。</p>
<p>还是先上时序图：<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog4/p4.webp" alt><br>相比于startActivity–&gt;AMS，AMS–&gt;ApplicationThread流程看起来复杂好多了，实际上这里面就干了3件事</p>
<p>1 综合处理launchMode和Intent中的Flag标志位，并根据处理结果生成一个目标Activity B的对象(ActivityRecord)<br>2 判断是否需要为目标Activity B创建一个新的进程(ProcessRecord)、新的任务栈(TaskRecord)<br>3 来来回回的操作AMS或者ActivityStackSupervisor中的那几个比较核心的数据结构</p>
<p><strong>ActivityRecord,TaskRecord,ActivityStack的关系</strong><br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog4/p5.webp" alt><br>一个ActivityRecord对应一个Activity，保存了一个Activity的所有信息; 但是一个Activity可能会有多个ActivityRecord,因为Activity可以被多次启动，这个主要取决于其启动模式。<br>一个TaskRecord由一个或者多个ActivityRecord组成，这就是我们常说的任务栈，具有后进先出的特点。<br>ActivityStack则是用来管理TaskRecord的，包含了多个TaskRecord</p>
<h4 id="三-ApplicationThread-–-gt-Activity"><a href="#三-ApplicationThread-–-gt-Activity" class="headerlink" title="(三) ApplicationThread –&gt; Activity"></a>(三) ApplicationThread –&gt; Activity</h4><p>还是先上时序图：<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog4/p1.jpg" alt></p>
<h4 id="详情可见"><a href="#详情可见" class="headerlink" title="详情可见"></a>详情可见</h4><p><a href="https://mp.weixin.qq.com/s/Z14PtsmQXgIuTrbC6VVLiw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Z14PtsmQXgIuTrbC6VVLiw</a></p>
<h4 id="总结：说说Activity加载的流程"><a href="#总结：说说Activity加载的流程" class="headerlink" title="总结：说说Activity加载的流程"></a>总结：说说Activity加载的流程</h4><p>一个APP启动的入口是ActivityThread的main， 而且这个Main方法是有系统进程启动的。<br>1、 在ActivityThread main方法中， 他会自己创建自己，并调用自己的attch方法，在这个方法里会获取一个叫IActivityManager的AMS代理，调用AMS的bindApplication方法，在AMS中，系统进程会创建一个app需要的一些比较的参数，如 pid uid等等，封装完成以后通过一个IApplicationThread的app进程的代理，调用bindApplication 绑定好Application创建的一些必要信息，然后通过handle发送消息并makeApplication创建出Application。<br>2、完成application创建，调用application的oncreate方法。在完成上面操作以后，AMS进程binapplication 完成以后，会继续通过一个叫ActivityStackSupervisor 继续调用启动Activity的方法，有个关键方法叫realStartActivityLock方法，它会创建ClientTransaction对象并且将LaunchActivityItem对象传递进去，最后还是通过IApplicationThread调用schedule方法。回到APP进程中，执行ClientTransaction的LaunchActivityItem的启动Activity方法，最后调用ActivityThread的handleLaunchActivity。他会通过反射创建出一个Activity对象并且，执行attch和onCreate、onStart 以及OnResume方法。</p>
<p><a href="https://github.com/Moosphan/Android-Daily-Interview/issues/168" target="_blank" rel="noopener">https://github.com/Moosphan/Android-Daily-Interview/issues/168</a></p>
<h3 id="Window-、Activity、-View-三者关系"><a href="#Window-、Activity、-View-三者关系" class="headerlink" title="Window 、Activity、 View 三者关系"></a>Window 、Activity、 View 三者关系</h3><p><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog4/p1.gif" alt></p>
<p>Activity 类似于一个框架，负责容器生命周期及活动，窗口通过 Window 来管理；<br>Window 负责窗口管理（实际是子类 PhoneWindow），窗口的绘制和渲染交给 DecorView完成；<br>DecorView 是 View 树的根，开发人员为 Activity 定义的 layout 将成为 DecorView 的子视图 ContentParent 的子视图；<br>layout.xml 是开发人员定义的布局文件，最终 inflate 为 DecorView 的子组件；</p>
<p>1.一个 Activity 中有一个 window，也就是 PhoneWindow 对象，在 PhoneWindow 中有一个 DecorView，在 setContentView 中会将 layout 填充到此 DecorView 中。<br>2.一个应用进程中只有一个 WindowManagerGlobal 对象，因为在 ViewRootImpl 中它是 static 静态类型。<br>3.每一个 PhoneWindow 对应一个 ViewRootImple 对象。<br>4.WindowMangerGlobal 通过调用 ViewRootImpl 的 setView 方法，完成 window 的添加过程。<br>5.ViewRootImpl 的 setView 方法中主要完成两件事情：View 渲染（requestLayout）以及接收触屏事件。</p>
<p><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog4/p2.jpg" alt></p>
<p><strong>总结</strong><br>1.Window 是什么？<br>Window 是 Android 中窗口的宏观定义，主要是管理 View 的创建，以及与 ViewRootImpl 的交互，将 Activity 与 View 解耦。</p>
<p>2.Activity 与 PhoneWindow 与 DecorView 之间什么关系？<br>一个 Activity 对应一个 Window 也就是 PhoneWindow，一个 PhoneWindow 持有一个 DecorView 的实例，DecorView 本身是一个 FrameLayout。</p>
<p>详情可见：<a href="https://blog.csdn.net/freekiteyu/article/details/79408969" target="_blank" rel="noopener">https://blog.csdn.net/freekiteyu/article/details/79408969</a></p>
<h3 id="Activity启动模式"><a href="#Activity启动模式" class="headerlink" title="Activity启动模式"></a>Activity启动模式</h3><p>LaunchMode 有四种，分别为 Standard，SingleTop，SingleTask 和 SingleInstance，每种模式的实现原理一楼都做了较详细说明，下面说一下具体使用场景：</p>
<p>1.standard<br>默认模式，允许多实例<br>2.singleTop:栈顶复用<br>相比于standard，有新的启动请求时，只有在目标Activity处于当前栈顶时，才会调用onNewIntent()而不创建新实例，其他情况都和standard一致<br>实例：通知打开页面<br>3.singleTask:栈内复用模式<br>设置了singleTask启动模式的Activity，它在启动的时候，会先在系统中查找属性值affinity等于它的属性值taskAffinity的任务存在；如果存在这样的任务，它就会在这个任务中启动，否则就会在新任务中启动。因此，如果我们想要设置了singleTask启动模式的Activity在新的任务中启动，就要为它设置一个独立的taskAffinity属性值。如果设置了singleTask启动模式的Activity不是在新的任务中启动时，它会在已有的任务中查看是否已经存在相应的Activity实例，如果存在，就会把位于这个Activity实例上面的Activity全部结束掉，即最终这个Activity实例会位于任务的堆栈顶端中。<br>实例：首页<br>4.singleInstance:全局单例模式<br>和singleTask相比，不同点在于singleInstance activity所在的task只会有这一个activity<br>实例：音频播放器锁屏界面</p>
<p>详情可见：<a href="https://github.com/Moosphan/Android-Daily-Interview/issues/4" target="_blank" rel="noopener">https://github.com/Moosphan/Android-Daily-Interview/issues/4</a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>知识点思维导图总结</title>
    <url>/blog/2020/07/mind-note-sum.html</url>
    <content><![CDATA[<h3 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h3><p><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/mind/并发编程.png" alt></p>
<h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><p><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/mind/设计模式.png" alt></p>
<h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/mind/基本数据类型.png" alt></p>
]]></content>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP与UDP详解</title>
    <url>/blog/2020/07/tcp-ip-things.html</url>
    <content><![CDATA[<h3 id="TCP-IP协议族"><a href="#TCP-IP协议族" class="headerlink" title="TCP/IP协议族"></a>TCP/IP协议族</h3><p>Transmission Control Protocol/Internet Protocol的简写，中译名为传输控制协议/因特网互联协议，是Internet最基本的协议、Internet国际互联网络的基础，由网络层的IP协议和传输层的TCP协议组成。协议采用了4层的层级结构。然而在很多情况下，它是利用 IP 进行通信时所必须用到的协议群的统称。</p>
<p><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog4/p9.png" alt></p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">TCP    面向连接的、可靠的流协议</span><br><span class="line">UDP    面向无连接的通讯协议</span><br><span class="line">IP     在源地址和目的地址之间传送的数据包</span><br><span class="line">ICMP  控制报文协议</span><br><span class="line">IGMP  internet组管理协议</span><br><span class="line">ARP   地址解析协议</span><br><span class="line">RARP 反向地址转化协议</span><br></pre></td></tr></table></figure>
<h3 id="01-TCP-基本认识"><a href="#01-TCP-基本认识" class="headerlink" title="01 TCP 基本认识"></a>01 TCP 基本认识</h3><p>我们先来看看 TCP 头的格式，标注颜色的表示与本文关联比较大的字段，其他字段不做详细阐述<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog4/p3.jpg" alt></p>
<p><strong>序列号</strong>：在建立连接时由计算机生成的随机数作为其初始值，通过 SYN 包传给接收端主机，每发送一次数据，就「累加」一次该「数据字节数」的大小。用来解决网络包乱序问题。</p>
<p><strong>确认应答号</strong>：指下一次「期望」收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。用来解决不丢包的问题。</p>
<p><strong>控制位：</strong><br>ACK：该位为 1 时，「确认应答」的字段变为有效，TCP 规定除了最初建立连接时的 SYN 包之外该位必须设置为 1 。<br>RST：该位为 1 时，表示 TCP 连接中出现异常必须强制断开连接。<br>SYN：该位为 1 时，表示希望建立连，并在其「序列号」的字段进行序列号初始值的设定。<br>FIN：该位为 1 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 FIN 位置为 1 的 TCP 段</p>
<h3 id="什么是TCP"><a href="#什么是TCP" class="headerlink" title="什么是TCP"></a>什么是TCP</h3><p>TCP 是面向连接的、可靠的、基于字节流的传输层通信协议。<br><strong>面向连接</strong>：一定是「一对一」才能连接，不能像 UDP 协议 可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的；<br><strong>可靠的</strong>：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端；<br><strong>字节流</strong>：消息是「没有边界」的，所以无论我们消息有多大都可以进行传输。并且消息是「有序的」，当「前一个」消息没有收到的时候，即使它先收到了后面的字节已经收到，那么也不能扔给应用层去处理，同时对「重复」的报文会自动丢弃</p>
<h3 id="UDP-和-TCP-有什么区别呢？分别的应用场景是？"><a href="#UDP-和-TCP-有什么区别呢？分别的应用场景是？" class="headerlink" title="UDP 和 TCP 有什么区别呢？分别的应用场景是？"></a>UDP 和 TCP 有什么区别呢？分别的应用场景是？</h3><p>UDP 不提供复杂的控制机制，利用 IP 提供面向「无连接」的通信服务。<br>UDP 协议真的非常简，头部只有 8 个字节（ 64 位），UDP 的头部格式如下<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog4/p4.jpg" alt></p>
<p>目标和源端口：主要是告诉 UDP 协议应该把报文发给哪个进程。<br>包长度：该字段保存了 UDP 首部的长度跟数据的长度之和。<br>校验和：校验和是为了提供可靠的 UDP 首部和数据而设计。</p>
<h3 id="TCP和UDP区别："><a href="#TCP和UDP区别：" class="headerlink" title="TCP和UDP区别："></a>TCP和UDP区别：</h3><p>1.连接<br>TCP 是面向连接的传输层协议，传输数据前先要建立连接。<br>UDP 是不需要连接，即刻传输数据。<br>2.服务对象<br>TCP 是一对一的两点服务，即一条连接只有两个端点。<br>UDP 支持一对一、一对多、多对多的交互通信<br>3.可靠性<br>TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按需到达。<br>UDP 是尽最大努力交付，不保证可靠交付数据。<br>4.拥塞控制、流量控制<br>TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。<br>UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。<br>5.首部开销<br>TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 20 个字节，如果使用了「选项」字段则会变长的。<br>UDP 首部只有 8 个字节，并且是固定不变的，开销较小</p>
<h3 id="TCP-和-UDP-应用场景"><a href="#TCP-和-UDP-应用场景" class="headerlink" title="TCP 和 UDP 应用场景"></a>TCP 和 UDP 应用场景</h3><p>由于 TCP 是面向连接，能保证数据的可靠性交付，因此经常用于：<br>1.FTP 文件传输<br>2.HTTP / HTTPS</p>
<p>由于 UDP 面向无连接，它可以随时发送数据，再加上UDP本身的处理既简单又高效，因此经常用于：<br>1.包总量较少的通信，如 DNS 、SNMP 等<br>2.视频、音频等多媒体通信<br>3.广播通信</p>
<p><strong>为什么 UDP 头部没有「首部长度」字段，而 TCP 头部有「首部长度」字段呢？</strong><br>原因是 TCP 有可变长的「选项」字段，而 UDP 头部长度则是不会变化的，无需多一个字段去记录 UDP 的首部长度。</p>
<h3 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h3><p>TCP 是面向连接的协议，所以使用 TCP 前必须先建立连接，而建立连接是通过三次握手而进行的<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog4/p5.jpg" alt><br>1.一开始，客户端和服务端都处于 CLOSED 状态。先是服务端主动监听某个端口，处于 LISTEN 状态<br>2.客户端会随机初始化序号（client_isn），将此序号置于 TCP 首部的「序号」字段中，同时把 SYN 标志位置为 1 ，表示 SYN 报文。接着把第一个 SYN 报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于 SYN-SENT 状态。<br>3.服务端收到客户端的 SYN 报文后，首先服务端也随机初始化自己的序号（server_isn），将此序号填入 TCP 首部的「序号」字段中，其次把 TCP 首部的「确认应答号」字段填入 client_isn + 1, 接着把 SYN 和 ACK 标志位置为 1。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于 SYN-RCVD 状态<br>4.服务端收到客户端的 SYN 报文后，首先服务端也随机初始化自己的序号（server_isn），将此序号填入 TCP 首部的「序号」字段中，其次把 TCP 首部的「确认应答号」字段填入 client_isn + 1, 接着把 SYN 和 ACK 标志位置为 1。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于 SYN-RCVD 状态<br>5.客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该应答报文 TCP 首部 ACK 标志位置为 1 ，其次「确认应答号」字段填入 server_isn + 1 ，最后把报文发送给服务端，这次报文可以携带客户到服务器的数据，之后客户端处于 ESTABLISHED 状态。<br>6.服务器收到客户端的应答报文后，也进入 ESTABLISHED 状态</p>
<p>从上面的过程可以发现第三次握手是可以携带数据的，前两次握手是不可以携带数据的，这也是面试常问的题。<br>一旦完成三次握手，双方都处于 ESTABLISHED 状态，此致连接就已建立完成，客户端和服务端就可以相互发送数据了。</p>
<h4 id="为什么是三次握手？不是两次、四次？"><a href="#为什么是三次握手？不是两次、四次？" class="headerlink" title="为什么是三次握手？不是两次、四次？"></a>为什么是三次握手？不是两次、四次？</h4><p>在前面我们知道了什么是 TCP 连接：<br>用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括Socket、序列号和窗口大小称为连接。<br>所以，重要的是为什么三次握手才可以初始化Socket、序列号和窗口大小并建立 TCP 连接。</p>
<p><strong>接下来以三个方面分析三次握手的原因：</strong><br>1.三次握手才可以阻止重复历史连接的初始化（主要原因）<br>2.三次握手才可以同步双方的初始序列号<br>3.三次握手才可以避免资源浪费</p>
<p><strong>原因一：避免历史连接</strong><br>三次握手的首要原因是为了防止旧的重复连接初始化造成混乱。<br>网络环境是错综复杂的，往往并不是如我们期望的一样，先发送的数据包，就先到达目标主机，反而它很骚，可能会由于网络拥堵等乱七八糟的原因，会使得旧的数据包，先到达目标主机，那么这种情况下 TCP 三次握手是如何避免的呢</p>
<p>客户端连续发送多次 SYN 建立连接的报文，在网络拥堵等情况下：<br>1.一个「旧 SVN 报文」比「最新的 SYN 」 报文早到达了服务端；<br>2.那么此时服务端就会回一个 SYN + ACK 报文给客户端；<br>3.客户端收到后可以根据自身的上下文，判断这是一个历史连接（序列号过期或超时），那么客户端就会发送 RST 报文给服务端，表示中止这一次连接。</p>
<p>如果是两次握手连接，就不能判断当前连接是否是历史连接，三次握手则可以在客户端（发送方）准备发送第三次报文时，客户端因有足够的上下文来判断当前连接是否是历史连接：<br>1.如果是历史连接（序列号过期或超时），则第三次握手发送的报文是 RST 报文，以此中止历史连接；<br>2.如果不是历史连接，则第三次发送的报文是 ACK 报文，通信双方就会成功建立连接；<br>所以， TCP 使用三次握手建立连接的最主要原因是防止历史连接初始化了连接。</p>
<p><strong>原因二：同步双方初始序列号</strong><br>TCP 协议的通信双方， 都必须维护一个「序列号」， 序列号是可靠传输的一个关键因素，它的作用：<br>1.接收方可以去除重复的数据；<br>2.接收方可以根据数据包的序列号按序接收；<br>3.可以标识发送出去的数据包中， 哪些是已经被对方收到的；</p>
<p>可见，序列号在 TCP 连接中占据着非常重要的作用，所以当客户端发送携带「初始序列号」的 SYN 报文的时候，需要服务端回一个 ACK 应答报文，表示客户端的 SYN 报文已被服务端成功接收，那当服务端发送「初始序列号」给客户端的时候，依然也要得到客户端的应答回应，这样一来一回，才能确保双方的初始序列号能被可靠的同步。</p>
<p>四次握手其实也能够可靠的同步双方的初始化序号，但由于第二步和第三步可以优化成一步，所以就成了「三次握手」。<br>而两次握手只保证了一方的初始序列号能被对方成功接收，没办法保证双方的初始序列号都能被确认接收。</p>
<p><strong>原因三：避免资源浪费</strong><br>如果只有「两次握手」，当客户端的 SYN 请求连接在网络中阻塞，客户端没有接收到 ACK 报文，就会重新发送 SYN ，由于没有第三次握手，服务器不清楚客户端是否收到了自己发送的建立连接的 ACK 确认信号，所以每收到一个 SYN 就只能先主动建立一个连接，这会造成什么情况呢？</p>
<p>如果客户端的 SYN 阻塞了，重复发送多次 SYN 报文，那么服务器在收到请求后就会建立多个冗余的无效链接，造成不必要的资源浪费。<br>即两次握手会造成消息滞留情况下，服务器重复接受无用的连接请求 SYN 报文，而造成重复分配资源</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>TCP 建立连接时，通过三次握手能防止历史连接的建立，能减少双方不必要的资源开销，能帮助双方同步初始化序列号。序列号能够保证数据包不重复、不丢弃和按序传输。<br>不使用「两次握手」和「四次握手」的原因：<br>1.「两次握手」：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号；<br>2.「四次握手」：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。 </p>
<p><strong>为什么客户端和服务端的初始序列号 ISN 是不相同的？</strong><br>因为网络中的报文会延迟、会复制重发、也有可能丢失，这样会造成的不同连接之间产生互相影响，所以为了避免互相影响，客户端和服务端的初始序列号是随机且不同的</p>
<h3 id="syn攻击"><a href="#syn攻击" class="headerlink" title="syn攻击"></a>syn攻击</h3><p>我们都知道 TCP 连接建立是需要三次握手，假设攻击者短时间伪造不同 IP 地址的 SYN 报文，服务端每接收到一个 SYN 报文，就进入SYN_RCVD 状态，但服务端发送出去的 ACK + SYN 报文，无法得到未知 IP 主机的 ACK 应答，久而久之就会占满服务端的 SYN 接收队列（未连接队列），使得服务器不能为正常用户服务<br>防护方法具体可见：<a href="https://blog.csdn.net/bigtree_3721/article/details/77619877" target="_blank" rel="noopener">https://blog.csdn.net/bigtree_3721/article/details/77619877</a></p>
<h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p>天下没有不散的宴席，对于 TCP 连接也是这样， TCP 断开连接是通过四次挥手方式。<br>双方都可以主动断开连接，断开连接后主机中的「资源」将被释放。<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog4/p6.jpg" alt><br>1.客户端打算关闭连接，此时会发送一个 TCP 首部 FIN 标志位被置为 1 的报文，也即 FIN 报文，之后客户端进入 FIN_WAIT_1 状态。<br>2.服务端收到该报文后，就向客户端发送 ACK 应答报文，接着服务端进入 CLOSED_WAIT 状态。<br>3.客户端收到服务端的 ACK 应答报文后，之后进入 FIN_WAIT_2 状态。<br>4.等待服务端处理完数据后，也向客户端发送 FIN 报文，之后服务端进入 LAST_ACK 状态。<br>5.客户端收到服务端的 FIN 报文后，回一个 ACK 应答报文，之后进入 TIME_WAIT 状态<br>6.服务器收到了 ACK 应答报文后，就进入了 CLOSE 状态，至此服务端已经完成连接的关闭。<br>7.客户端在经过 2MSL 一段时间后，自动进入 CLOSE 状态，至此客户端也完成连接的关闭</p>
<p>你可以看到，每个方向都需要一个 FIN 和一个 ACK，因此通常被称为四次挥手。<br>这里一点需要注意是：主动关闭连接的，才有 TIME_WAIT 状态</p>
<h4 id="为什么挥手需要四次？"><a href="#为什么挥手需要四次？" class="headerlink" title="为什么挥手需要四次？"></a>为什么挥手需要四次？</h4><p>再来回顾下四次挥手双方发 FIN 包的过程，就能理解为什么需要四次了。<br>1.关闭连接时，客户端向服务端发送 FIN 时，仅仅表示客户端不再发送数据了但是还能接收数据。<br>2.服务器收到客户端的 FIN 报文时，先回一个 ACK 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 FIN 报文给客户端来表示同意现在关闭连接<br>从上面过程可知，服务端通常需要等待完成数据的发送和处理，所以服务端的 ACK 和 FIN 一般都会分开发送，从而比三次握手导致多了一次。</p>
<h4 id="为什么-TIME-WAIT-等待的时间是-2MSL？"><a href="#为什么-TIME-WAIT-等待的时间是-2MSL？" class="headerlink" title="为什么 TIME_WAIT 等待的时间是 2MSL？"></a>为什么 TIME_WAIT 等待的时间是 2MSL？</h4><p>TIME_WAIT 等待 2 倍的 MSL，比较合理的解释是： 网络中可能存在来自发送方的数据包，当这些发送方的数据包被接收方处理后又会向对方发送响应，所以一来一回需要等待 2 倍的时间。<br>比如如果被动关闭方没有收到断开连接的最后的 ACK 报文，就会触发超时重发 Fin 报文，另一方接收到 FIN 后，会重发 ACK 给被动关闭方， 一来一去正好 2 个 MSL。<br>2MSL 的时间是从客户端接收到 FIN 后发送 ACK 开始计时的。如果在 TIME-WAIT 时间内，因为客户端的 ACK 没有传输到服务端，客户端又接收到了服务端重发的 FIN 报文，那么 2MSL 时间将重新计时。</p>
<h4 id="为什么需要-TIME-WAIT-状态"><a href="#为什么需要-TIME-WAIT-状态" class="headerlink" title="为什么需要 TIME_WAIT 状态"></a>为什么需要 TIME_WAIT 状态</h4><p>主动发起关闭连接的一方，才会有 TIME-WAIT 状态。<br>需要 TIME-WAIT 状态，主要是两个原因：<br>1.防止具有相同「四元组」的「旧」数据包被收到；<br>2.保证「被动关闭连接」的一方能被正确的关闭，即保证最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭；</p>
<p><strong>原因一：防止旧连接的数据包</strong><br>假设 TIME-WAIT 没有等待时间或时间过短，被延迟的数据包抵达后会发生什么呢？</p>
<p>如果服务端在关闭连接之前发送的 SEQ = 301 报文，被网络延迟了。<br>这时有相同端口的 TCP 连接被复用后，被延迟的 SEQ = 301 抵达了客户端，那么客户端是有可能正常接收这个过期的报文，这就会产生数据错乱等严重的问题。<br>所以，TCP 就设计出了这么一个机制，经过 2MSL 这个时间，足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的</p>
<p><strong>原因二：保证连接正确关闭</strong><br>假设 TIME-WAIT 没有等待时间或时间过短，断开连接会造成什么问题呢？</p>
<p>1.客户端四次挥手的最后一个 ACK 报文如果在网络中被丢失了，此时如果客户端 TIME-WAIT 过短或没有，则就直接进入了 CLOSE 状态了，那么服务端则会一直处在 LASE-ACK 状态。<br>2.当客户端发起建立连接的 SYN 请求报文后，服务端会发送 RST 报文给客户端，连接建立的过程就会被终止。<br>如果 TIME-WAIT 等待足够长的情况就会遇到两种情况：<br>1.服务端正常收到四次挥手的最后一个 ACK 报文，则服务端正常关闭连接。<br>2.服务端没有收到四次挥手的最后一个 ACK 报文时，则会重发 FIN 关闭连接报文并等待新的 ACK 报文。</p>
<p>所以客户端在 TIME-WAIT 状态等待 2MSL 时间后，就可以保证双方的连接都可以正常的关闭。</p>
<h3 id="TCP相比UDP为什么是可靠的"><a href="#TCP相比UDP为什么是可靠的" class="headerlink" title="TCP相比UDP为什么是可靠的"></a>TCP相比UDP为什么是可靠的</h3><h4 id="1-确认和重传机制"><a href="#1-确认和重传机制" class="headerlink" title="1.确认和重传机制"></a>1.确认和重传机制</h4><p>当发送错误的时候，会发生：<br>a、超时重传机制<br>发送方发送的报文中含有序列号，每当发送一个报文后，就启动一个计时器（RTO），该计时器的时间一般是有当前网络来决定的，一个RTT指的是当一个报文从发送到接收到对应的ACK标志的时间，RTO的决定一般是发送方尝试发送几个报文，然后取平均RTT时间来决定计时器的值。 当发送一个报文以后，发送方在计时范围以内，如果没有接收到相应的ACK确认报文，那么发送方就会重传该报文。</p>
<p>b、快速重传机制<br>该机制指的是，发送方一直发送报文，不会每发一次报文就都要等待到这个报文的ACK标志才发送下个报文。 当接收方发送接受的序列号不对的时候，发送连续的3个ACK标志，告诉发送方，这个报文在传输过程中出现了丢包。发送方如果接收到某个相同序列号的三个ACK报文，那么此时立马重发该报文，不用等待计时器的时间结束</p>
<h4 id="2、流量控制（滑动窗口）"><a href="#2、流量控制（滑动窗口）" class="headerlink" title="2、流量控制（滑动窗口）"></a>2、流量控制（滑动窗口）</h4><p>发送方不能无脑的发数据给接收方，要考虑接收方处理能力。<br>如果一直无脑的发数据给对方，但对方处理不过来，那么就会导致触发重发机制，从而导致网络流量的无端的浪费。<br>为了解决这种现象发生，TCP 提供一种机制可以让「发送方」根据「接收方」的实际接收能力控制发送的数据量，这就是所谓的流量控制</p>
<p>滑动窗口的流量控制可以包括那么几个协议：<br>a、停等协议。 滑动窗口的大小为1， 每个发送报文都要等到被确认以后，发送方才继续发送下一个报文。<br>b、后退n步协议。 该协议下，滑动窗口大于1，发送方可以一直发送报文，但是当接收到接收方发送的三个连续的同一序列号的ACK报文时，说明该序列号的报文是已经丢失的，那么此时重发该丢失报文以及该报文以后的报文（包括那些已经发送的）。<br>c、选择重传。在后退n步协议当中，如果某个报文丢失。那么将要重新发送这个丢失报文及以后的所有报文（包括已经发送的），选择重传协议不用做此要求，只要重新发送丢失的报文即可。</p>
<h4 id="3-拥塞控制"><a href="#3-拥塞控制" class="headerlink" title="3.拥塞控制"></a>3.拥塞控制</h4><p>为什么要有拥塞控制呀，不是有流量控制了吗？<br>首先要明白拥塞控制与流量控制有什么不同，流量控制考虑的是单纯的发送方与接收方，这两个在全部网络过程中的两个端点。而拥塞控制考虑的是整个网络。可以想象一下，在流量控制当中，接收方跟发送方考虑的只是自己的报文有没有发送并且被接收的问题，假设现在网络阻塞，在超时重传机制当中，发送方没有发送后在计时器时间内没有接收到确认报文，就立马重新发送报文，这时候对已经拥塞的网络来说，无异于雪上加霜。所以，针对以上问题，TCP应该要有一个拥塞控制机制，不然，后果不堪设想</p>
<p>为了在「发送方」调节所要发送数据的量，定义了一个叫做「拥塞窗口」的概念。</p>
<p><strong>什么是拥塞窗口？和发送窗口有什么关系呢？</strong><br>拥塞窗口 cwnd是发送方维护的一个 的状态变量，它会根据网络的拥塞程度动态变化的。<br>我们在前面提到过发送窗口 swnd 和接收窗口 rwnd 是约等于的关系，那么由于入了拥塞窗口的概念后，此时发送窗口的值是swnd = min(cwnd, rwnd)，也就是拥塞窗口和接收窗口中的最小值。</p>
<p><strong>拥塞窗口 cwnd 变化的规则：</strong><br>只要网络中没有出现拥塞，cwnd 就会增大；<br>但网络中出现了拥塞，cwnd 就减少；<br><strong>那么怎么知道当前网络是否出现了拥塞呢？</strong><br>其实只要「发送方」没有在规定时间内接收到 ACK 应答报文，也就是发生了超时重传，就会认为网络出现了用拥塞。</p>
<h5 id="拥塞控制主要是四个算法："><a href="#拥塞控制主要是四个算法：" class="headerlink" title="拥塞控制主要是四个算法："></a>拥塞控制主要是四个算法：</h5><p>1.慢启动<br>2.拥塞避免<br>3.拥塞发生<br>4.快速恢复</p>
<p>以上就是TCP比UDP传输更可靠的原因</p>
<p><strong>详情可见</strong><br><a href="https://www.cnblogs.com/kevin-cool/p/11812971.html" target="_blank" rel="noopener">TCP/IP协议-为什么说TCP是可靠连接</a><br><a href="https://blog.csdn.net/Awille/article/details/79748193" target="_blank" rel="noopener">TCP为什么可靠、安全</a></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://zhuanlan.zhihu.com/p/125715300" target="_blank" rel="noopener">35张图解被问千百遍的TCP三次握手和四次挥手面试题</a><br><a href="https://zhuanlan.zhihu.com/p/133307545" target="_blank" rel="noopener">你还在为 TCP 重传、滑动窗口、流量控制、拥塞控制发愁吗？看完图解就不愁了</a></p>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Http协议详解</title>
    <url>/blog/2020/07/http-detail-things.html</url>
    <content><![CDATA[<h3 id="HTTP-基本概念"><a href="#HTTP-基本概念" class="headerlink" title="HTTP 基本概念"></a>HTTP 基本概念</h3><p><strong>HTTP 是什么？描述一下</strong><br>HTTP 是超文本传输协议，也就是HyperText Transfer Protocol。</p>
<p><strong>HTTP 常见的状态码，有哪些？</strong><br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog4/p7.jpg" alt><br>「301 Moved Permanently」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。<br>「302 Found」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。<br>301 和 302 都会在响应头里使用字段 Location，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。<br>「304 Not Modified」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，用于缓存控制</p>
<h3 id="说一下-GET-和-POST-的区别？"><a href="#说一下-GET-和-POST-的区别？" class="headerlink" title="说一下 GET 和 POST 的区别？"></a>说一下 GET 和 POST 的区别？</h3><p>Get 方法的含义是请求从服务器获取资源，这个资源可以是静态的文本、页面、图片视频等。<br>比如，你打开我的文章，浏览器就会发送 GET 请求给服务器，服务器就会返回文章的所有文字及资源。</p>
<p>而POST 方法则是相反操作，它向 URI 指定的资源提交数据，数据就放在报文的 body 里。<br>比如，你在我文章底部，敲入了留言后点击「提交」（暗示你们留言），浏览器就会执行一次 POST 请求，把你的留言文字放进了报文 body 里，然后拼接好 POST 请求头，通过 TCP 协议发送给服务器</p>
<h3 id="HTTP-特性"><a href="#HTTP-特性" class="headerlink" title="HTTP 特性"></a>HTTP 特性</h3><p>HTTP 最凸出的优点是「简单、灵活和易于扩展、应用广泛和跨平台」。</p>
<ol>
<li><p>简单<br>HTTP 基本的报文格式就是 header + body，头部信息也是 key-value 简单文本的形式，易于理解，降低了学习和使用的门槛。</p>
</li>
<li><p>灵活和易于扩展<br>HTTP协议里的各类请求方法、URI/URL、状态码、头字段等每个组成要求都没有被固定死，都允许开发人员自定义和扩充。<br>同时 HTTP 由于是工作在应用层（ OSI 第七层），则它下层可以随意变化。<br>HTTPS 也就是在 HTTP 与 TCP 层之间增加了 SSL/TLS 安全传输层，HTTP/3 甚至把 TCPP 层换成了基于 UDP 的 QUIC。</p>
</li>
<li><p>应用广泛和跨平台<br>互联网发展至今，HTTP 的应用范围非常的广泛，从台式机的浏览器到手机上的各种 APP，从看新闻、刷贴吧到购物、理财、吃鸡，HTTP 的应用片地开花，同时天然具有跨平台的优越性。</p>
</li>
</ol>
<h4 id="Http是无状态的"><a href="#Http是无状态的" class="headerlink" title="Http是无状态的"></a>Http是无状态的</h4><p>无状态的好处，因为服务器不会去记忆 HTTP 的状态，所以不需要额外的资源来记录状态信息，这能减轻服务器的负担，能够把更多的 CPU 和内存用来对外提供服务。<br>无状态的坏处，既然服务器没有记忆能力，它在完成有关联性的操作时会非常麻烦。<br>例如登录-&gt;添加购物车-&gt;下单-&gt;结算-&gt;支付，这系列操作都要知道用户的身份才行。但服务器不知道这些请求是有关联的，每次都要问一遍身份信息。</p>
<p>对于无状态的问题，解法方案有很多种，其中比较简单的方式用 Cookie 技术。<br>Cookie 通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。<br>相当于，在客户端第一次请求后，服务器会下发一个装有客户信息的「小贴纸」，后续客户端请求服务器的时候，带上「小贴纸」，服务器就能认得的了</p>
<h4 id="Http是明文传输的"><a href="#Http是明文传输的" class="headerlink" title="Http是明文传输的"></a>Http是明文传输的</h4><p>明文意味着在传输过程中的信息，是可方便阅读的，通过浏览器的 F12 控制台或 Wireshark 抓包都可以直接肉眼查看，为我们调试工作带了极大的便利性。<br>但是这正是这样，HTTP 的所有信息都暴露在了光天化日下，相当于信息裸奔。在传输的漫长的过程中，信息的内容都毫无隐私可言，很容易就能被窃取，如果里面有你的账号密码信息，那你号没了。</p>
<h4 id="不安全"><a href="#不安全" class="headerlink" title="不安全"></a>不安全</h4><p>HTTP 比较严重的缺点就是不安全：<br>1.通信使用明文（不加密），内容可能会被窃听。比如，账号信息容易泄漏，那你号没了。<br>2.不验证通信方的身份，因此有可能遭遇伪装。比如，访问假的淘宝、拼多多，那你钱没了。<br>3.无法证明报文的完整性，所以有可能已遭篡改。比如，网页上植入垃圾广告，视觉污染，眼没了。<br>HTTP 的安全问题，可以用 HTTPS 的方式解决，也就是通过引入 SSL/TLS 层，使得在安全上达到了极致。</p>
<h4 id="那你在说下-HTTP-1-1-的性能如何？"><a href="#那你在说下-HTTP-1-1-的性能如何？" class="headerlink" title="那你在说下 HTTP/1.1 的性能如何？"></a>那你在说下 HTTP/1.1 的性能如何？</h4><p>HTTP 协议是基于 TCP/IP，并且使用了「请求 - 应答」的通信模式，所以性能的关键就在这两点里。<br><strong>1. 长连接</strong><br>早期 HTTP/1.0 性能上的一个很大的问题，那就是每发起一个请求，都要新建一次 TCP 连接（三次握手），而且是串行请求，做了无畏的 TCP 连接建立和断开，增加了通信开销。<br>为了解决上述 TCP 连接问题，HTTP/1.1 提出了长连接的通信方式，也叫持久连接。这种方式的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。<br>持久连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。</p>
<p><strong>2. 管道网络传输</strong><br>HTTP/1.1 采用了长连接的方式，这使得管道（pipeline）网络传输成为了可能。<br>即可在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。<br>举例来说，客户端需要请求两个资源。以前的做法是，在同一个TCP连接里面，先发送 A 请求，然后等待服务器做出回应，收到后再发出 B 请求。管道机制则是允许浏览器同时发出 A 请求和 B 请求。</p>
<p>但是服务器还是按照顺序，先回应 A 请求，完成后再回应 B 请求。要是 前面的回应特别慢，后面就会有许多请求排队等着。这称为「队头堵塞」。</p>
<p><strong>3. 队头阻塞</strong><br>「请求 - 应答」的模式加剧了 HTTP 的性能问题。<br>因为当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一同被阻塞了，会招致客户端一直请求不到数据，这也就是「队头阻塞」。好比上班的路上塞车。</p>
<p>总之 HTTP/1.1 的性能一般般，后续的 HTTP/2 和 HTTP/3 就是在优化 HTTP 的性能。</p>
<h3 id="HTTP-1-1、HTTP-2、HTTP-3-演变"><a href="#HTTP-1-1、HTTP-2、HTTP-3-演变" class="headerlink" title="HTTP/1.1、HTTP/2、HTTP/3 演变"></a>HTTP/1.1、HTTP/2、HTTP/3 演变</h3><h4 id="说说-HTTP-1-1-相比-HTTP-1-0-提高了什么性能？"><a href="#说说-HTTP-1-1-相比-HTTP-1-0-提高了什么性能？" class="headerlink" title="说说 HTTP/1.1 相比 HTTP/1.0 提高了什么性能？"></a>说说 HTTP/1.1 相比 HTTP/1.0 提高了什么性能？</h4><p>HTTP/1.1 相比 HTTP/1.0 性能上的改进：<br>1.使用 TCP 长连接的方式改善了 HTTP/1.0 短连接造成的性能开销。<br>2.支持 管道（pipeline）网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。</p>
<p>但 HTTP/1.1 还是有性能瓶颈：<br>1.请求 / 响应头部（Header）未经压缩就发送，首部信息越多延迟越大。只能压缩 Body 的部分；<br>2.发送冗长的首部。每次互相发送相同的首部造成的浪费较多；<br>3.服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端一直请求不到数据，也就是队头阻塞；<br>4.没有请求优先级控制；<br>5.请求只能从客户端开始，服务器只能被动响应</p>
<h4 id="那上面的-HTTP-1-1-的性能瓶颈，HTTP-2-做了什么优化？"><a href="#那上面的-HTTP-1-1-的性能瓶颈，HTTP-2-做了什么优化？" class="headerlink" title="那上面的 HTTP/1.1 的性能瓶颈，HTTP/2 做了什么优化？"></a>那上面的 HTTP/1.1 的性能瓶颈，HTTP/2 做了什么优化？</h4><p>HTTP/2 协议是基于 HTTPS 的，所以 HTTP/2 的安全性也是有保障的。<br>那 HTTP/2 相比 HTTP/1.1 性能上的改进：</p>
<ol>
<li><p>头部压缩<br>HTTP/2 会压缩头（Header）如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你消除重复的分。<br>这就是所谓的 HPACK 算法：在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了</p>
</li>
<li><p>二进制格式<br>HTTP/2 不再像 HTTP/1.1 里的纯文本形式的报文，而是全面采用了二进制格式，头信息和数据体都是二进制，并且统称为帧（frame）：头信息帧和数据帧。<br>这样虽然对人不友好，但是对计算机非常友好，因为计算机只懂二进制，那么收到报文后，无需再将明文的报文转成二进制，而是直接解析二进制报文，这增加了数据传输的效率</p>
</li>
<li><p>数据流<br>HTTP/2 的数据包不是按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。<br>每个请求或回应的所有数据包，称为一个数据流（Stream）。每个数据流都标记着一个独一无二的编号，其中规定客户端发出的数据流编号为奇数， 服务器发出的数据流编号为偶数<br>客户端还可以指定数据流的优先级。优先级高的请求，服务器就先响应该请求。</p>
</li>
<li><p>多路复用<br>HTTP/2 是可以在一个连接中并发多个请求或回应，而不用按照顺序一一对应。<br>移除了 HTTP/1.1 中的串行请求，不需要排队等待，也就不会再出现「队头阻塞」问题，降低了延迟，大幅度提高了连接的利用率。<br>举例来说，在一个 TCP 连接里，服务器收到了客户端 A 和 B 的两个请求，如果发现 A 处理过程非常耗时，于是就回应 A 请求已经处理好的部分，接着回应 B 请求，完成后，再回应 A 请求剩下的部分。</p>
</li>
<li><p>服务器推送<br>HTTP/2 还在一定程度上改善了传统的「请求 - 应答」工作模式，服务不再是被动地响应，也可以主动向客户端发送消息。<br>举例来说，在浏览器刚请求 HTML 的时候，就提前把可能会用到的 JS、CSS 文件等静态资源主动发给客户端，减少延时的等待，也就是服务器推送</p>
</li>
</ol>
<h4 id="HTTP-2-有哪些缺陷？HTTP-3-做了哪些优化？"><a href="#HTTP-2-有哪些缺陷？HTTP-3-做了哪些优化？" class="headerlink" title="HTTP/2 有哪些缺陷？HTTP/3 做了哪些优化？"></a>HTTP/2 有哪些缺陷？HTTP/3 做了哪些优化？</h4><p>HTTP/2 主要的问题在于，多个 HTTP 请求在复用一个 TCP 连接，下层的 TCP 协议是不知道有多少个 HTTP 请求的。所以一旦发生了丢包现象，就会触发 TCP 的重传机制，这样在一个 TCP 连接中的所有的 HTTP 请求都必须等待这个丢了的包被重传回来。</p>
<p>1.HTTP/1.1 中的管道（ pipeline）传输中如果有一个请求阻塞了，那么队列后请求也统统被阻塞住了<br>2.HTTP/2 多请求复用一个TCP连接，一旦发生丢包，就会阻塞住所有的 HTTP 请求。</p>
<p>这都是基于 TCP 传输层的问题，所以 HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP！</p>
<p>大家都知道 UDP 是不可靠传输的，但基于 UDP 的 QUIC 协议 可以实现类似 TCP 的可靠性传输。<br>1.QUIC 有自己的一套机制可以保证传输的可靠性的。当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响。<br>2.TL3 升级成了最新的 1.3 版本，头部压缩算法也升级成了 QPack。<br>3.HTTPS 要建立一个连接，要花费 6 次交互，先是建立三次握手，然后是 TLS/1.3 的三次握手。QUIC 直接把以往的 TCP 和 TLS/1.3 的 6 次交互合并成了 3 次，减少了交互次数<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog4/p8.jpg" alt><br>所以， QUIC 是一个在 UDP 之上的伪 TCP + TLS + HTTP/2 的多路复用的协议。</p>
<p>QUIC 是新协议，对于很多网络设备，根本不知道什么是 QUIC，只会当做 UDP，这样会出现新的问题。所以 HTTP/3 现在普及的进度非常的缓慢，不知道未来 UDP 是否能够逆袭 TCP。</p>
<p><a href="https://www.cnblogs.com/mengff/p/12724641.html" target="_blank" rel="noopener">TCP队头阻塞和HTTP队头阻塞</a></p>
<h3 id="请简述一次http网络请求的过程"><a href="#请简述一次http网络请求的过程" class="headerlink" title="请简述一次http网络请求的过程"></a>请简述一次http网络请求的过程</h3><p>1.DNS域名解析<br>2.建立TCP连接<br>3.Web浏览器向Web服务器发送请求行命令<br>4.Web浏览器发送请求头信息<br>5.Web服务器的应答，发送响应行命令<br>6.Web服务器发送相应头信息<br>7.Web服务器向浏览器发送数据，及消息体<br>8.Web服务器关闭TCP连接</p>
<p><a href="https://www.cnblogs.com/xiaonantianmen/p/9426118.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiaonantianmen/p/9426118.html</a></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://zhuanlan.zhihu.com/p/111716047" target="_blank" rel="noopener">硬核！30 张图解 HTTP 常见的面试题</a></p>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>android webview独立进程架构</title>
    <url>/blog/2020/07/android-webview-architecture.html</url>
    <content><![CDATA[<h3 id="为什么要独立进程"><a href="#为什么要独立进程" class="headerlink" title="为什么要独立进程"></a>为什么要独立进程</h3><p>1.进程本身有内存限制<br>2.webview本身很占内存，独立进程可以节省内存资源，减少OOM<br>3.webview崩溃不影响主进程</p>
<p><strong>缺点</strong><br>通信比较麻烦</p>
<h3 id="如何实现WebView独立进程"><a href="#如何实现WebView独立进程" class="headerlink" title="如何实现WebView独立进程"></a>如何实现WebView独立进程</h3><p>WebView独立进程的实现<br>WebView独立进程的实现比较简单，只需要在AndroidManifest中找到对应的WebViewActivity，对其配置”android: process”属性即可。如下：<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;activity</span><br><span class="line">    android:<span class="attribute">name</span>=<span class="string">".remote.RemoteCommonWebActivity"</span></span><br><span class="line">    android:<span class="attribute">configChanges</span>=<span class="string">"orientation|keyboardHidden|screenSize"</span></span><br><span class="line">    android:<span class="attribute">process</span>=<span class="string">":remoteWeb"</span>/&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="WebView进程与主进程间的数据通信"><a href="#WebView进程与主进程间的数据通信" class="headerlink" title="WebView进程与主进程间的数据通信"></a>WebView进程与主进程间的数据通信</h3><p>主要通过IADL实现跨进程通信</p>
<p>IBinderPool： Webview进程和主进程的通讯可能涉及到多个AIDL Binder，从功能上来讲，我们也会把不同功能的接口写成不同的AIDL Binder，所以IBinderPool用于满足调用方根据不同类型获取不同的Binder。</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title">IBinderPool</span> &#123;</span><br><span class="line">    <span class="function">IBinder <span class="title">queryBinder</span>(<span class="params"><span class="keyword">int</span> binderCode</span>)</span>;  <span class="comment">//查找特定Binder的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>IWebAidlInterface: 最核心的AIDL Binder，这里把WebView进程对主进程的每一个调用看做一次action， 每个action都会有唯一的actionName, 主进程会提前注册好这些action，action 也有级别level，每次调用结束通过IWebAidlCallback返回结果<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IWebAidlInterface</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>actionName: 不同的action， jsonParams: 需要根据不同的action从map中读取并依次转成其他</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">     */</span></span></span></span><br><span class="line">    <span class="keyword">void</span> handleWebAction(<span class="built_in">int</span> level, <span class="built_in">String</span> actionName, <span class="built_in">String</span> jsonParams, <span class="keyword">in</span> IWebAidlCallback callback);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>IWebAidlCallback: 结果回调<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IWebAidlCallback</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> onResult(<span class="built_in">int</span> responseCode, <span class="built_in">String</span> actionName, <span class="built_in">String</span> response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Native-Web交互和接口管理"><a href="#Native-Web交互和接口管理" class="headerlink" title="Native-Web交互和接口管理"></a>Native-Web交互和接口管理</h3><p>native与js通信的方法如下所示<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog4/p1.tif" alt><br>我们主要通过调用addJavascriptInterface的方式</p>
<h4 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h4><p>简单的说，<strong>命令模式可将“动作的请求者”从“动作的执行者”对象中解耦</strong>。</p>
<p>将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化(即，可以用不同的命令对象，去参数化配置客户的请求)；对请求排队或记录请求日志，以及支持可撤销的操作。</p>
<p>这一模式的关键是一个抽象的Command类，它定义了一个执行操作的接口。其最简单的形式是一个抽象的Execute操作。具体的Command子类将接收者作为其一个实例变量，并实现Execute操作，指定接收者采取的动作。而接收者有执行该请求所需的具体信息。<br>接收者：真正执行命令的对象。任何类都可能成为一个接收者，只要它能够实现命令要求实现的相应功能。</p>
<p>详情可见：<a href="https://www.jianshu.com/p/1bf9c2c907e8" target="_blank" rel="noopener">https://www.jianshu.com/p/1bf9c2c907e8</a></p>
<p>提供了中间件dj.js，根据时间戳与随机数生成callBackId;<br>native每个页面注册对应的命令，js消息传递过来时，根据对应的actionName回调至命令注册的页面<br>调用完成后通过callBackId回调到h5中</p>
<h4 id="具体实现如下"><a href="#具体实现如下" class="headerlink" title="具体实现如下"></a>具体实现如下</h4><p>1.Native打开页面时注册接口：“webView.addJavascriptInterface(jsInterface, “webview”);” 其中jsInterface是JsRemoteInterface类的实例：<br><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">JsRemoteInterface</span> &#123;</span></span><br><span class="line">    @JavascriptInterface</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">post</span><span class="params">(<span class="keyword">String</span> cmd, <span class="keyword">String</span> param)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>2.Web页面通过“window.webview.post(cmd,JSON.stringify(para))”调用native；<br>3.Native（即Webview进程）收到调用之后，通过IWebAidlInterface实例传递给主进程执行；<br>4.主进程收到action请求之后，根据actionname分发处理，执行结束之后通过IWebAidlCallback完成进程间回调</p>
<h3 id="使用AutoService实现WebView命令解耦"><a href="#使用AutoService实现WebView命令解耦" class="headerlink" title="使用AutoService实现WebView命令解耦"></a>使用AutoService实现WebView命令解耦</h3><p>通过AutoService注解与ServiceLoader类结合，可以取得接口的所有实现</p>
<p>定义Command接口<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>Command &#123;</span><br><span class="line">    String name();</span><br><span class="line">    void execute(Map parameters, ICallbackFromMainprocessToWebViewProcessInterface callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后定义Command接口实现<br><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AutoService</span>(&#123;Command<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">CommandShowToast</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function">String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"showToast"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">final</span> Map parameters, ICallbackFromMainprocessToWebViewProcessInterface callback)</span> </span>&#123;</span><br><span class="line">        Handler <span class="keyword">handler</span> = <span class="keyword">new</span> Handler(Looper.getMainLooper());</span><br><span class="line">        <span class="keyword">handler</span>.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Toast.makeText(BaseApplication.sApplication, String.valueOf(parameters.get(<span class="string">"message"</span>)), Toast.LENGTH_SHORT).show();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在CommanManager初始化时，将实现添加至map中<br><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">private MainProcessCommandsManager()&#123;</span><br><span class="line">        ServiceLoader&lt;<span class="keyword">Command</span>&gt; serviceLoader = ServiceLoader.load(<span class="keyword">Command</span>.class);</span><br><span class="line">        for(<span class="keyword">Command</span> <span class="keyword">command</span> : serviceLoader)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!mCommands.containsKey(<span class="keyword">command</span>.name()))&#123;</span><br><span class="line">                mCommands.put(<span class="keyword">command</span>.name(), <span class="keyword">command</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>然后在js通过JsBridge调用native方法时，通过command名即可获得对应的command实现<br><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeCommand</span>(<span class="params">String commandName, Map <span class="keyword">params</span>,  ICallbackFromMainprocessToWebViewProcessInterface callback</span>)</span> &#123;</span><br><span class="line">        mCommands.<span class="keyword">get</span>(commandName).execute(<span class="keyword">params</span>, callback);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://www.jianshu.com/p/b66c225c19e2" target="_blank" rel="noopener">Android WebView独立进程解决方案</a><br><a href="https://github.com/xudjx/webprogress" target="_blank" rel="noopener">源码</a><br><a href="https://www.jianshu.com/p/086fe09188ea" target="_blank" rel="noopener">组件化之AutoService使用与源码解析</a><br><a href="https://github.com/shenzhen2017/WebViewDemo" target="_blank" rel="noopener">AutoService集成源码</a></p>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Bitmap性能优化</title>
    <url>/blog/2020/07/bitmap-performace-better.html</url>
    <content><![CDATA[<h3 id="Bitmap-占用内存分析"><a href="#Bitmap-占用内存分析" class="headerlink" title="Bitmap 占用内存分析"></a>Bitmap 占用内存分析</h3><p>默认情况下 BitmapFactory 使用 Bitmap.Config.ARGB_8888 的存储方式来加载图片内容，而在这种存储模式下，每一个像素需要占用 4 个字节。因此图片的内存大小可以使用如下公式来计算：<br>宽 <em> 高 </em> 4 = 600 <em> 600 </em> 4 = 1440000<br>Bitmap内存大小只与图片宽高与每个像素所占的大小有关</p>
<h3 id="Bitmap-加载优化"><a href="#Bitmap-加载优化" class="headerlink" title="Bitmap 加载优化"></a>Bitmap 加载优化</h3><h4 id="1-修改图片加载的-Config"><a href="#1-修改图片加载的-Config" class="headerlink" title="1.修改图片加载的 Config"></a>1.修改图片加载的 Config</h4><p>修改占用空间少的存储方式可以快速有效降低图片占用内存。比如通过 BitmapFactory.Options 的 inPreferredConfig 选项，将存储方式设置为 Bitmap.Config.RGB_565。这种存储方式一个像素占用 2 个字节，所以最终占用内存直接减半</p>
<p>另外 Options 中还有一个 inSampleSize 参数，可以实现 Bitmap 采样压缩，这个参数的含义是宽高维度上每隔 inSampleSize 个像素进行一次采集<br>如果InSampleSize设为2，因为宽高都会进行采样，所以最终图片会被缩略 4 倍</p>
<h4 id="2-Bitmap-复用"><a href="#2-Bitmap-复用" class="headerlink" title="2.Bitmap 复用"></a>2.Bitmap 复用</h4><p>场景描述<br>如果在 Android 某个页面创建很多个 Bitmap，比如有两张图片 A 和 B，通过点击某一按钮需要在 ImageView 上切换显示这两张图片</p>
<p>但是在每次调用 switchImage 切换图片时，都需要通过 BitmapFactory 创建一个新的 Bitmap 对象。当方法执行完毕后，这个 Bitmap 又会被 GC 回收，这就造成不断地创建和销毁比较大的内存对象，从而导致频繁 GC（或者叫内存抖动）。像 Android App 这种面相最终用户交互的产品，如果因为频繁的 GC 造成 UI 界面卡顿，还是会影响到用户体验的</p>
<p><strong>使用 Options.inBitmap 优化</strong><br>实际上经过第一次显示之后，内存中已经存在了一个 Bitmap 对象。每次切换图片只是显示的内容不一样，我们可以重复利用已经占用内存的 Bitmap 空间，具体做法就是使用 Options.inBitmap 参数。将inBitmap赋值为一个已经存在的Bitmap,避免重新分配内存</p>
<p>重新运行代码，并查看 Profiler 中的内存情况，可以发现不管我们切换图片多少次，内存占用始终处于一个水平线状态<br>注意：在上述 getBitmap 方法中，复用 inBitmap 之前，需要调用 canUseForInBitmap 方法来判断 reuseBitmap 是否可以被复用。这是因为 Bitmap 的复用有一定的限制：<br>在 Android 4.4 版本之前，只能重用相同大小的 Bitmap 内存区域；<br>4.4 之后你可以重用任何 Bitmap 的内存区域，只要这块内存比将要分配内存的 bitmap 大就可以。</p>
<h4 id="3-BitmapRegionDecoder-图片分片显示"><a href="#3-BitmapRegionDecoder-图片分片显示" class="headerlink" title="3.BitmapRegionDecoder 图片分片显示"></a>3.BitmapRegionDecoder 图片分片显示</h4><p>有时候我们想要加载显示的图片很大或者很长，比如手机滚动截图功能生成的图片。<br>针对这种情况，在不压缩图片的前提下，不建议一次性将整张图加载到内存，而是采用分片加载的方式来显示图片部分内容，然后根据手势操作，放大缩小或者移动图片显示区域。<br>图片分片加载显示主要是使用 Android SDK 中的 BitmapRegionDecoder 来实现</p>
<p><strong>BitmapRegionDecoder 基本使用</strong><br>首先需要使用 BitmapRegionDecoder 将图片加载到内存中，图片可以以绝对路径、文件描述符、输入流的方式传递给 BitmapRegionDecoder，如下所示：<br><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">BitmapRegionDecoder decoder = BitmapRegionDecoder.newInstance(inputStream, <span class="keyword">false</span>);</span><br><span class="line">BitmapFactory.<span class="keyword">Options</span> <span class="keyword">options</span> = <span class="keyword">new</span> BitmapFactory.<span class="keyword">Options</span>();</span><br><span class="line"><span class="keyword">options</span>.inPreferredConfig = Bitmap.Config.RGB_565;</span><br><span class="line">Bitmap bitmap = decoder.decodeRegion(<span class="keyword">new</span> Rect(<span class="number">0</span>, <span class="number">0</span>, width, regionImage.getHeight()), <span class="keyword">options</span>);</span><br><span class="line">regionImage.setImageBitmap(bitmap);</span><br></pre></td></tr></table></figure></p>
<h4 id="4-Bitmap-缓存"><a href="#4-Bitmap-缓存" class="headerlink" title="4.Bitmap 缓存"></a>4.Bitmap 缓存</h4><p>当需要在界面上同时展示一大堆图片的时候，比如 ListView、RecyclerView 等，由于用户不断地上下滑动，某个 Bitmap 可能会被短时间内加载并销毁多次。这种情况下通过使用适当的缓存，可以有效地减缓 GC 频率保证图片加载效率，提高界面的响应速度和流畅性。<br>最常用的缓存方式就是 LruCache，基本使用方式如下：<br><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> cacheSize = <span class="number">20</span> * <span class="number">1024</span> * <span class="number">1024</span>;  <span class="comment">// 20M</span></span><br><span class="line">bitmapCache = <span class="keyword">new</span> LruCache&lt;String, Bitmap&gt;(cacheSize) &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">int</span> <span class="title">sizeOf</span><span class="params">(String key, Bitmap bitmap)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 重写此方法来衡量每张图片的大小，默认返回图片数量。</span></span><br><span class="line">        <span class="function"><span class="keyword">return</span> bitmap.<span class="title">getAllocationByteCount</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文详细介绍了 Bitmap 开发中的几个常见问题：<br>1.一张图片被加载成 Bitmap 后实际占用内存是多大。<br>2.通过 Options.inBitmap 可以实现 Bitmap 的复用，但是有一定的限制。<br>3.当界面需要展示多张图片，尤其是在列表视图中，可以考虑使用 Bitmap 缓存。<br>4.如果需要展示的图片过大，可以考虑使用分片加载的策略</p>
<h3 id="自定义View"><a href="#自定义View" class="headerlink" title="自定义View"></a>自定义View</h3><p>实现自定义View主要需要解决以下3个问题<br>1.如何根据相应的属性将 UI 元素绘制到界面；<br>2.自定义控件的大小，也就是宽和高分别设置多少；<br>3.如果是 ViewGroup，如何合理安排其内部子 View 的摆放位置。</p>
<p>以上 3 个问题依次在如下 3 个方法中得到解决：<br>onDraw<br>onMeasure<br>onLayout</p>
<h4 id="onMeasure"><a href="#onMeasure" class="headerlink" title="onMeasure"></a>onMeasure</h4><p>首先我们需要弄清楚，自定义 View 为什么需要重新测量。正常情况下，我们直接在 XML 布局文件中定义好 View 的宽高，然后让自定义 View 在此宽高的区域内显示即可。但是为了更好地兼容不同尺寸的屏幕，Android 系统提供了 wrap_contetn 和 match_parent 属性来规范控件的显示规则。它们分别代表自适应大小和填充父视图的大小，但是这两个属性并没有指定具体的大小，因此我们需要在 onMeasure 方法中过滤出这两种情况，真正的测量出自定义 View 应该显示的宽高大小。</p>
<p>方法会传入 2 个参数 widthMeasureSpec 和 heightMeasureSpec。这两个参数是从父视图传递给子 View 的两个参数，看起来很像宽、高，但是它们所表示的不仅仅是宽和高，还有一个非常重要的测量模式。</p>
<p>一共有 3 种测量模式。<br>EXACTLY：表示在 XML 布局文件中宽高使用 match_parent 或者固定大小的宽高；<br>AT_MOST：表示在 XML 布局文件中宽高使用 wrap_content；<br>UNSPECIFIED：父容器没有对当前 View 有任何限制，当前 View 可以取任意尺寸，比如 ListView 中的 item。<br><figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">int widthMode = MeasureSpec.getMode(widthMeasureSpec)<span class="comment">;</span></span><br><span class="line">int heightMode = MeasureSpec.getMode(heightMeasureSpec)<span class="comment">;</span></span><br><span class="line">int measuredWidth = MeasureSpec.getSize(widthMeasureSpec)<span class="comment">;</span></span><br><span class="line">int measuredHeight = MeasureSpec.getSize(heightMeasureSpec)<span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>为什么 1 个 int 值可以代表 2 种意义呢？ 实际上 widthMeasureSpec 和 heightMeasureSpec 都是使用二进制高 2 位表示测量模式，低 30 位表示宽高具体大小。</p>
<h4 id="ViewGroup-中的-onMeasure"><a href="#ViewGroup-中的-onMeasure" class="headerlink" title="ViewGroup 中的 onMeasure"></a>ViewGroup 中的 onMeasure</h4><p>如果我们自定义的控件是一个容器，onMeasure 方法会更加复杂一些。因为 ViewGroup 在测量自己的宽高之前，需要先确定其内部子 View 的所占大小，然后才能确定自己的大小。比如如下一段代码：<br><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测量控件的宽和高</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">protected</span> <span class="function"><span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">     <span class="comment">//获得宽高的测量模式和测量值</span></span><br><span class="line">     <span class="keyword">int</span> widthMode = MeasureSpec.getMode(widthMeasureSpec);</span><br><span class="line">     <span class="keyword">int</span> widthSize = MeasureSpec.getSize(widthMeasureSpec);</span><br><span class="line">     <span class="keyword">int</span> heightSize = MeasureSpec.getSize(heightMeasureSpec);</span><br><span class="line">     <span class="keyword">int</span> heightMode = MeasureSpec.getMode(heightMeasureSpec);</span><br><span class="line"></span><br><span class="line">     <span class="comment">//获得容器中子View的个数</span></span><br><span class="line">     <span class="keyword">int</span> childCount = getChildCount();</span><br><span class="line">     <span class="comment">//记录每一行View的总宽度</span></span><br><span class="line">     <span class="keyword">int</span> totalLineWidth = <span class="number">0</span>;</span><br><span class="line">     <span class="comment">//记录每一行最高View的高度</span></span><br><span class="line">     <span class="keyword">int</span> perLineMaxHeight = <span class="number">0</span>;</span><br><span class="line">     <span class="comment">//记录当前ViewGroup的总高度</span></span><br><span class="line">     <span class="keyword">int</span> totalHeight = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childCount; i++) &#123;</span><br><span class="line">         View childView = getChildAt(i);</span><br><span class="line">         <span class="comment">//对子View进行测量</span></span><br><span class="line">         measureChild(childView, widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">         MarginLayoutParams lp = (MarginLayoutParams) childView.getLayoutParams();</span><br><span class="line">         <span class="comment">//获得子View的测量宽度</span></span><br><span class="line">         <span class="keyword">int</span> childWidth = childView.getMeasuredWidth() + lp.leftMargin + lp.rightMargin;</span><br><span class="line">         <span class="comment">//获得子View的测量高度</span></span><br><span class="line">         <span class="keyword">int</span> childHeight = childView.getMeasuredHeight() + lp.topMargin + lp.bottomMargin;</span><br><span class="line">         <span class="keyword">if</span> (totalLineWidth + childWidth &gt; widthSize) &#123;</span><br><span class="line">             <span class="comment">//统计总高度</span></span><br><span class="line">             totalHeight += perLineMaxHeight;</span><br><span class="line">             <span class="comment">//开启新的一行</span></span><br><span class="line">             totalLineWidth = childWidth;</span><br><span class="line">             perLineMaxHeight = childHeight;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="comment">//记录每一行的总宽度</span></span><br><span class="line">             totalLineWidth += childWidth;</span><br><span class="line">             <span class="comment">//比较每一行最高的View</span></span><br><span class="line">             perLineMaxHeight = Math.max(perLineMaxHeight, childHeight);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//当该View已是最后一个View时，将该行最大高度添加到totalHeight中</span></span><br><span class="line">         <span class="keyword">if</span> (i == childCount - <span class="number">1</span>) &#123;</span><br><span class="line">             totalHeight += perLineMaxHeight;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//如果高度的测量模式是EXACTLY，则高度用测量值，否则用计算出来的总高度（这时高度的设置为wrap_content）</span></span><br><span class="line">     heightSize = heightMode == MeasureSpec.EXACTLY ? heightSize : totalHeight;</span><br><span class="line">     setMeasuredDimension(widthSize, heightSize);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>上述 onMeasure 方法的主要目的有 2 个：<br>1.调用 measureChild 方法递归测量子 View；<br>2.通过叠加每一行的高度，计算出最终 FlowLayout 的最终高度 totalHeight。</p>
<h4 id="onLayout"><a href="#onLayout" class="headerlink" title="onLayout"></a>onLayout</h4><p>上面的 FlowLayout 中的 onMeasure 方法只是计算出 ViewGroup 的最终显示宽高，但是并没有规定某一个子 View 应该显示在何处位置。要定义 ViewGroup 内部子 View 的显示规则，则需要复写并实现 onLayout 方法。<br>onLayout是一个抽象方法，也就是说每一个自定义 ViewGroup 都必须主动实现如何排布子 View，具体就是遍历每一个子 View，调用 child.(l, t, r, b) 方法来为每个子 View 设置具体的布局位置。四个参数分别代表左上右下的坐标位置，一个简易的 FlowLayout 实现如下：<br><figure class="highlight processing"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> onLayout(<span class="built_in">boolean</span> changed, <span class="built_in">int</span> l, <span class="built_in">int</span> t, <span class="built_in">int</span> r, <span class="built_in">int</span> b) &#123;</span><br><span class="line">    mAllViews.<span class="built_in">clear</span>();</span><br><span class="line">    mPerLineMaxHeight.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="comment">//存放每一行的子View</span></span><br><span class="line">    List&lt;View&gt; lineViews = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//记录每一行已存放View的总宽度</span></span><br><span class="line">    <span class="built_in">int</span> totalLineWidth = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//记录每一行最高View的高度</span></span><br><span class="line">    <span class="built_in">int</span> lineMaxHeight = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/****遍历所有View，将View添加到List&lt;List&lt;View&gt;&gt;集合中**********/</span></span><br><span class="line">    <span class="comment">//获得子View的总个数</span></span><br><span class="line">    <span class="built_in">int</span> childCount = getChildCount();</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; childCount; i++) &#123;</span><br><span class="line">        View childView = getChildAt(i);</span><br><span class="line">        MarginLayoutParams lp = (MarginLayoutParams) childView.getLayoutParams();</span><br><span class="line">        <span class="built_in">int</span> childWidth = childView.getMeasuredWidth() + lp.leftMargin + lp.rightMargin;</span><br><span class="line">        <span class="built_in">int</span> childHeight = childView.getMeasuredHeight() + lp.topMargin + lp.bottomMargin;</span><br><span class="line">        <span class="keyword">if</span> (totalLineWidth + childWidth &gt; getWidth()) &#123;</span><br><span class="line">            mAllViews.<span class="built_in">add</span>(lineViews);</span><br><span class="line">            mPerLineMaxHeight.<span class="built_in">add</span>(lineMaxHeight);</span><br><span class="line">            <span class="comment">//开启新的一行</span></span><br><span class="line">            totalLineWidth = <span class="number">0</span>;</span><br><span class="line">            lineMaxHeight = <span class="number">0</span>;</span><br><span class="line">            lineViews = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        totalLineWidth += childWidth;</span><br><span class="line">        lineViews.<span class="built_in">add</span>(childView);</span><br><span class="line">        lineMaxHeight = Math.<span class="built_in">max</span>(lineMaxHeight, childHeight);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//单独处理最后一行</span></span><br><span class="line">    mAllViews.<span class="built_in">add</span>(lineViews);</span><br><span class="line">    mPerLineMaxHeight.<span class="built_in">add</span>(lineMaxHeight);</span><br><span class="line">    <span class="comment">/************遍历集合中的所有View并显示出来************/</span></span><br><span class="line">    <span class="comment">//表示一个View和父容器左边的距离</span></span><br><span class="line">    <span class="built_in">int</span> mLeft = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//表示View和父容器顶部的距离</span></span><br><span class="line">    <span class="built_in">int</span> mTop = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; mAllViews.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="comment">//获得每一行的所有View</span></span><br><span class="line">        lineViews = mAllViews.<span class="built_in">get</span>(i);</span><br><span class="line">        lineMaxHeight = mPerLineMaxHeight.<span class="built_in">get</span>(i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; lineViews.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            View childView = lineViews.<span class="built_in">get</span>(j);</span><br><span class="line">            MarginLayoutParams lp = (MarginLayoutParams) childView.getLayoutParams();</span><br><span class="line">            <span class="built_in">int</span> leftChild = mLeft + lp.leftMargin;</span><br><span class="line">            <span class="built_in">int</span> topChild = mTop + lp.topMargin;</span><br><span class="line">            <span class="built_in">int</span> rightChild = leftChild + childView.getMeasuredWidth()；</span><br><span class="line">            <span class="built_in">int</span> bottomChild = topChild + childView.getMeasuredHeight();</span><br><span class="line">            <span class="comment">//四个参数分别表示View的左上角和右下角</span></span><br><span class="line">            childView.layout(leftChild, topChild, rightChild, bottomChild);</span><br><span class="line">            mLeft += lp.leftMargin + childView.getMeasuredWidth() + lp.rightMargin;</span><br><span class="line">        &#125;</span><br><span class="line">        mLeft = <span class="number">0</span>;</span><br><span class="line">        mTop += lineMaxHeight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>详情代码可见：<a href="https://github.com/McoyJiang/LagouAndroidShare/tree/master/course15_%E8%87%AA%E5%AE%9A%E4%B9%89View/LagouCustomizedView" target="_blank" rel="noopener">自定义View</a></p>
<p><strong>measure之UNSPECIFIED的用途</strong><br>UNSPECIFIED在ScrollView中的作用，详情可见：<br><a href="https://blog.csdn.net/u012947056/article/details/81292621" target="_blank" rel="noopener">measure之UNSPECIFIED的用途</a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Recyclerview源码解析</title>
    <url>/blog/2020/07/recyclerview-source-learn.html</url>
    <content><![CDATA[<p>RV 本质上也是一个自定义控件，所以也符合自定义控件的规则。因此我们也可以沿着分析其 onMeasure -&gt; onLayout -&gt; onDraw 这 3 个方法的路线来深入研究。</p>
<p>RV 会将测量 onMeasure 和布局 onLayout 的工作委托给 LayoutManager 来执行，不同的 LayoutManager 会有不同风格的布局显示，这是一种策略模式。用一张图来描述这段过程如下：<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog4/p10.png" alt></p>
<p>详细源码分析可见：<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=67#/detail/pc?id=1870" target="_blank" rel="noopener">https://kaiwu.lagou.com/course/courseInfo.htm?courseId=67#/detail/pc?id=1870</a></p>
<h3 id="缓存复用原理-Recycler"><a href="#缓存复用原理-Recycler" class="headerlink" title="缓存复用原理 Recycler"></a>缓存复用原理 Recycler</h3><p>缓存复用是 RV 中另一个非常重要的机制，这套机制主要实现了 ViewHolder 的缓存以及复用。</p>
<p>核心代码是在 Recycler 中完成的，它是 RV 中的一个内部类，主要用来缓存屏幕内 ViewHolder 以及部分屏幕外 ViewHolder，部分代码如下<br><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> ArrayList&lt;ViewHolder&gt; mAttachedScrap = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">ArrayList&lt;ViewHolder&gt; mChangedScrap = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> ArrayList&lt;ViewHolder&gt; mCachedViews = <span class="keyword">new</span> ArrayList&lt;ViewHolder&gt;();</span><br><span class="line"></span><br><span class="line">RecycledViewPool mRecyclerPool;</span><br><span class="line"><span class="keyword">private</span> ViewCacheExtension mViewCacheExtension;</span><br></pre></td></tr></table></figure></p>
<p>Recycler 的缓存机制就是通过上图中的这些数据容器来实现的，实际上 Recycler 的缓存也是分级处理的，根据访问优先级从上到下可以分为 4 级，如下：<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog4/p11.png" alt></p>
<p>RV 之所以要将缓存分成这么多块，是为了在功能上进行一些区分，并分别对应不同的使用场景。</p>
<h4 id="第一级缓存-mAttachedScrap-amp-mChangedScrap"><a href="#第一级缓存-mAttachedScrap-amp-mChangedScrap" class="headerlink" title="第一级缓存 mAttachedScrap&amp;mChangedScrap"></a>第一级缓存 mAttachedScrap&amp;mChangedScrap</h4><p>是两个名为 Scrap 的 ArrayList，这两者主要用来缓存屏幕内的 ViewHolder。为什么屏幕内的 ViewHolder 需要缓存呢？</p>
<p>当我们下拉刷新列表中的内容，当刷新被触发时，只需要在原有的 ViewHolder 基础上进行重新绑定新的数据 data 即可，而这些旧的 ViewHolder 就是被保存在 mAttachedScrap 和 mChangedScrap 中。实际上当我们调用 RV 的 notifyXXX 方法时，就会向这两个列表进行填充，将旧 ViewHolder 缓存起来。</p>
<h4 id="第二级缓存-mCachedViews"><a href="#第二级缓存-mCachedViews" class="headerlink" title="第二级缓存 mCachedViews"></a>第二级缓存 mCachedViews</h4><p>它用来缓存移除屏幕之外的 ViewHolder，默认情况下缓存个数是 2，不过可以通过 setViewCacheSize 方法来改变缓存的容量大小。如果 mCachedViews 的容量已满，则会根据 FIFO 的规则将旧 ViewHolder 抛弃，然后添加新的 ViewHolder</p>
<p>通常情况下刚被移出屏幕的 ViewHolder 有可能接下来马上就会使用到，所以 RV 不会立即将其设置为无效 ViewHolder，而是会将它们保存到 cache 中，但又不能将所有移除屏幕的 ViewHolder 都视为有效 ViewHolder，所以它的默认容量只有 2 个</p>
<h4 id="第三级缓存-ViewCacheExtension"><a href="#第三级缓存-ViewCacheExtension" class="headerlink" title="第三级缓存 ViewCacheExtension"></a>第三级缓存 ViewCacheExtension</h4><p>这是 RV 预留给开发人员的一个抽象类，在这个类中只有一个抽象方法，如下：<br><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@Nullable</span></span><br><span class="line">public abstract View getViewForPositionAndType(<span class="variable">@NonNull</span> Recycler recycler, int position,int type);</span><br></pre></td></tr></table></figure></p>
<p>开发人员可以通过继承 ViewCacheExtension，并复写抽象方法 getViewForPositionAndType 来实现自己的缓存机制。只是一般情况下我们不会自己实现也不建议自己去添加缓存逻辑，因为这个类的使用门槛较高，需要开发人员对 RV 的源码非常熟悉。</p>
<h4 id="第四级缓存-RecycledViewPool"><a href="#第四级缓存-RecycledViewPool" class="headerlink" title="第四级缓存 RecycledViewPool"></a>第四级缓存 RecycledViewPool</h4><p>RecycledViewPool 同样是用来缓存屏幕外的 ViewHolder，当 mCachedViews 中的个数已满（默认为 2），则从 mCachedViews 中淘汰出来的 ViewHolder 会先缓存到 RecycledViewPool 中。ViewHolder 在被缓存到 RecycledViewPool 时，会将内部的数据清理，因此从 RecycledViewPool 中取出来的 ViewHolder 需要重新调用 onBindViewHolder 绑定数据。这就同最早的 ListView 中的使用 ViewHolder 复用 convertView 的道理是一致的，因此 RV 也算是将 ListView 的优点完美的继承过来。</p>
<p>RecycledViewPool 还有一个重要功能，官方对其有如下解释：<br>RecycledViewPool lets you share Views between multiple RecyclerViews.<br>可以看出，多个 RV 之间可以共享一个 RecycledViewPool，这对于多 tab 界面的优化效果会很显著。需要注意的是，RecycledViewPool 是根据 type 来获取 ViewHolder，每个 type 默认最大缓存 5 个。因此多个 RecyclerView 共享 RecycledViewPool 时，必须确保共享的 RecyclerView 使用的 Adapter 是同一个，或 view type 是不会冲突的。</p>
<h4 id="RV-是如何从缓存中获取-ViewHolder-的"><a href="#RV-是如何从缓存中获取-ViewHolder-的" class="headerlink" title="RV 是如何从缓存中获取 ViewHolder 的"></a>RV 是如何从缓存中获取 ViewHolder 的</h4><p>在上文介绍 onLayout 阶段时，有介绍在 layoutChunk 方法中通过调用 layoutState.next 方法拿到某个子 ItemView，然后添加到 RV 中。<br>最终调用 tryGetViewHolderForPositionByDeadline 方法来查找相应位置上的ViewHolder，在这个方法中会从上面介绍的 4 级缓存中依次查找<br>如果在各级缓存中都没有找到相应的 ViewHolder，则会使用 Adapter 中的 createViewHolder 方法创建一个新的 ViewHolder</p>
<h4 id="何时将-ViewHolder-存入缓存"><a href="#何时将-ViewHolder-存入缓存" class="headerlink" title="何时将 ViewHolder 存入缓存"></a>何时将 ViewHolder 存入缓存</h4><p>接下来看下 ViewHolder 被存入各级缓存的场景。<br>1.第一次 layout<br>当调用 setLayoutManager 和 setAdapter 之后，RV 会经历第一次 layout 并被显示到屏幕上<br>此时并不会有任何 ViewHolder 的缓存，所有的 ViewHolder 都是通过 createViewHolder 创建的</p>
<p>2.刷新列表<br>如果通过手势下拉刷新，获取到新的数据 data 之后，我们会调用 notifyXXX 方法通知 RV 数据发生改变，这回 RV 会先将屏幕内的所有 ViewHolder 保存在 Scrap 中<br>当缓存执行完之后，后续通过 Recycler 就可以从缓存中获取相应 position 的 ViewHolder（姑且称为旧 ViewHolder），然后将刷新后的数据设置到这些 ViewHolder 上<br>最后再将新的 ViewHolder 绘制到 RV 上</p>
<h3 id="RecyclerView与ListView区别"><a href="#RecyclerView与ListView区别" class="headerlink" title="RecyclerView与ListView区别"></a>RecyclerView与ListView区别</h3><p><strong>1.缓存机制不同</strong><br>RecyclerView比ListView多两级缓存，支持多个离ItemView缓存，支持开发者自定义缓存处理逻辑，支持所有RecyclerView共用同一个RecyclerViewPool<br>ListView(两级缓存)<br>RecyclerView(四级缓存)<br>1). mActiveViews和mAttachedScrap功能相似，意义在于快速重用屏幕上可见的列表项ItemView，而不需要重新createView和bindView；<br>2). mScrapView和mCachedViews + mReyclerViewPool功能相似，意义在于缓存离开屏幕的ItemView，目的是让即将进入屏幕的ItemView重用.</p>
<p><strong>2. 局部刷新</strong><br>RecyclerView更大的亮点在于提供了局部刷新的接口，通过局部刷新，就能避免调用许多无用的bindView。ListView和RecyclerView最大的区别在于数据源改变时的缓存的处理逻辑，ListView是”一锅端”，将所有的mActiveViews都移入了二级缓存mScrapViews，而RecyclerView则是更加灵活地对每个View修改标志位，区分是否重新bindView。</p>
<p>详情可见：<a href="https://www.jianshu.com/p/257c279a3493" target="_blank" rel="noopener">RecyclerView和ListView的区别</a></p>
<h3 id="RecyclerView性能优化"><a href="#RecyclerView性能优化" class="headerlink" title="RecyclerView性能优化"></a>RecyclerView性能优化</h3><h4 id="数据处理和视图加载分离"><a href="#数据处理和视图加载分离" class="headerlink" title="数据处理和视图加载分离"></a>数据处理和视图加载分离</h4><p>我们知道，从远端拉取数据肯定是要放在异步的，在我们拉取下来数据之后可能就匆匆把数据丢给了 VH 处理，其实，数据的处理逻辑我们也应该放在异步处理，这样 Adapter 在 notify change 后，ViewHolder 就可以简单无压力地做数据与视图的绑定逻辑，比如：</p>
<p>mTextView.setText(Html.fromHtml(data).toString());<br>这里的 Html.fromHtml(data) 方法可能就是比较耗时的，存在多个 TextView 的话耗时会更为严重，这样便会引发掉帧、卡顿，而如果把这一步与网络异步线程放在一起，站在用户角度，最多就是网络刷新时间稍长一点。</p>
<h4 id="数据优化"><a href="#数据优化" class="headerlink" title="数据优化"></a>数据优化</h4><p>分页拉取远端数据，对拉取下来的远端数据进行缓存，提升二次加载速度；对于新增或者删除数据通过 DiffUtil 来进行局部刷新数据，而不是一味全局地刷新数据。</p>
<h4 id="布局优化"><a href="#布局优化" class="headerlink" title="布局优化"></a>布局优化</h4><p>1.减少过渡绘制<br>2.减少 xml 文件 inflate 时间<br>这里的 xml 文件不仅包括 layout 的 xml，还包括 drawable 的 xml，xml 文件 inflate 出 ItemView 是通过耗时的 IO 操作，尤其当 Item 的复用几率很低的情况下，随着 Type 的增多，这种 inflate 带来的损耗是相当大的，此时我们可以用代码去生成布局，即 new View() 的方式，只要搞清楚 xml 中每个节点的属性对应的 API 即可</p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>1.如果多个 RecycledView 的 Adapter 是一样的,可以通过设置 RecyclerView.setRecycledViewPool(pool); 来共用一个 RecycledViewPool。<br>2.在ViewHolder中设置点击事件而不是在onBindViewHolder<br>3.item的高度固定时setHasFixedSize(true)</p>
<p>详情可见：<a href="https://github.com/Blankj/AndroidOfferKiller/blob/master/android/RecyclerView%20%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.md" target="_blank" rel="noopener">RecyclerView 性能优化</a></p>
<h3 id="一次RecyclerView-Crash分析"><a href="#一次RecyclerView-Crash分析" class="headerlink" title="一次RecyclerView Crash分析"></a>一次RecyclerView Crash分析</h3><p>详情可见：<a href="https://mp.weixin.qq.com/s/mwTtxk4YfYWCG4m6n_ropw" target="_blank" rel="noopener">记一次全民K歌的crash定位过程</a></p>
<p>用户使用K歌停留在动态非好友页，退后台被系统杀掉重启时，没有考虑到Fragment恢复的情况，导致在正常的Fragment下多生成了一个不可见的Fragment，之后发布了作品并对其执行了会引起数据变化的互动操作，使其layout到布局中，刷新列表后不可见的RecyclerView列表状态与Adapter数据不同步，跳转到其它Activity再返回时，触发了RecyclerView的重新布局，检测到了状态不对并抛出了异常</p>
<p>1.查看日志发现是获取缓存的情况下出现问题<br>2.具体是在验证ViewHolder的时候，一个是通过position查找，一个是通过ViewType查找<br>3.根据日志推测，可能是给同一个View设置了两个ViewHolder<br>4.后来经过分析发现，界面上产生了两个Fragment，一个可见，一个不可见，是由于退到后台系统恢复时创建的<br>5.不可见的Recyclerview中增删了数据但是没有调用notify，导致Adapter中的数据与RecyclerView中不一致<br>6.然后在onLayout中就可能会出现IllegalArgumentException</p>
<h3 id="使用RecyclerViewjPool减少UI卡顿"><a href="#使用RecyclerViewjPool减少UI卡顿" class="headerlink" title="使用RecyclerViewjPool减少UI卡顿"></a>使用RecyclerViewjPool减少UI卡顿</h3><p>在ViewPager加多Fragment切换过程中，会出现同时inflate多个layout，造成掉帧。<br>Fragment中共享RecyclerViewPool可以减少CreateViewHolder,同时可以减少ViewHolder总量，减少内存</p>
<p>我们使用RecycledViewPool，<br>1.节约了内存<br>2.减少了CreateViewHolder的资源开销。<br>3.自然更加流畅</p>
<p><strong>详情可见</strong><br><a href="https://blog.csdn.net/AndroidMsky/article/details/88427160" target="_blank" rel="noopener">RecycledViewPool的使用和堆内存分析</a><br><a href="https://www.jianshu.com/p/122e68e9ddac" target="_blank" rel="noopener">RecycledViewPool使用</a><br><a href="https://www.jianshu.com/p/4023448e8cf9" target="_blank" rel="noopener">RecycledViewPool项目中使用</a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>android事件分发详解</title>
    <url>/blog/2020/07/android-dispatch-view.html</url>
    <content><![CDATA[<h3 id="Android-touch-事件的分发是-Android-工程师必备技能之一。关于事件分发主要有几个方向可以展开深入分析："><a href="#Android-touch-事件的分发是-Android-工程师必备技能之一。关于事件分发主要有几个方向可以展开深入分析：" class="headerlink" title="Android touch 事件的分发是 Android 工程师必备技能之一。关于事件分发主要有几个方向可以展开深入分析："></a>Android touch 事件的分发是 Android 工程师必备技能之一。关于事件分发主要有几个方向可以展开深入分析：</h3><p>1.touch 事件是如何从驱动层传递给 Framework 层的 InputManagerService；<br>2.WMS 是如何通过 ViewRootImpl 将事件传递到目标窗口；<br>3.touch 事件到达 DecorView 后，是如何一步步传递到内部的子 View 中的。<br>其中与上层软件开发息息相关的就是第 3 条</p>
<h3 id="事件分发核心-dispatchTouchEvent"><a href="#事件分发核心-dispatchTouchEvent" class="headerlink" title="事件分发核心 dispatchTouchEvent"></a>事件分发核心 dispatchTouchEvent</h3><p>整个 View 之间的事件分发，实质上就是一个大的递归函数，而这个递归函数就是 dispatchTouchEvent 方法。在这个递归的过程中会适时调用 onInterceptTouchEvent 来拦截事件，或者调用 onTouchEvent 方法来处理事件。</p>
<p>先从宏观角度，纵览整个 dispatch 的源码如下：<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog4/p14.png" alt><br>如代码中的注释，dispatch 主要分为 3 大步骤：<br>1.步骤 1：判断当前 ViewGroup 是否需要拦截此 touch 事件，如果拦截则此次 touch 事件不再会传递给子 View（或者以 CANCEL 的方式通知子 View）。<br>2.步骤 2：如果没有拦截，则将事件分发给子 View 继续处理，如果子 View 将此次事件捕获，则将 mFirstTouchTarget 赋值给捕获 touch 事件的 View。<br>3.步骤 3：根据 mFirstTouchTarget 重新分发事件。<br>接下来详细的看下每一个步骤：</p>
<h4 id="步骤-1-的具体代码如下"><a href="#步骤-1-的具体代码如下" class="headerlink" title="步骤 1 的具体代码如下"></a>步骤 1 的具体代码如下</h4><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Check for interception.</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> intercepted;</span><br><span class="line"><span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">        || mFirstTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!disallowIntercept) &#123;</span><br><span class="line">        intercepted = onInterceptTouchEvent(ev);</span><br><span class="line">        ev.setAction(action); <span class="comment">// restore action in case it was changed</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        intercepted = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// There are no touch targets and this action is not an initial down</span></span><br><span class="line">    <span class="comment">// so this view group continues to intercept touches.</span></span><br><span class="line">    intercepted = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是否需要拦截的条件为：</p>
<ul>
<li>1.如果事件为 DOWN 事件，则调用 onInterceptTouchEvent 进行拦截判断；</li>
<li>2.或者 mFirstTouchTarget 不为 null，代表已经有子 View 捕获了这个事件，子 View 的 dispatchTouchEvent 返回 true 就是代表捕获 touch 事件。</li>
</ul>
<p>如果在上面步骤 1 中，当前 ViewGroup 并没有对事件进行拦截，则执行步骤 2。</p>
<h4 id="步骤-2-具体代码如下"><a href="#步骤-2-具体代码如下" class="headerlink" title="步骤 2 具体代码如下"></a>步骤 2 具体代码如下</h4><p><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog4/p15.png" alt><br>仔细看上述的代码可以看出：<br>1.图中 ① 处表明事件主动分发的前提是事件为 DOWN 事件；<br>2.图中 ② 处遍历所有子 View；<br>3.图中 ③ 处判断事件坐标是否在子 View 坐标范围内，并且子 View 并没有处在动画状态；<br>4.图中 ④ 处调用 dispatchTransformedTouchEvent 方法将事件分发给子 View，如果子 View 捕获事件成功，则将 mFirstTouchTarget 赋值给子 View。</p>
<h4 id="步骤-3-具体代码如下"><a href="#步骤-3-具体代码如下" class="headerlink" title="步骤 3 具体代码如下"></a>步骤 3 具体代码如下</h4><p><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog4/p16.png" alt><br>步骤 3 有 2 个分支判断。<br><strong>分支 1</strong><br>如果此时 mFirstTouchTarget 为 null，说明在上述的事件分发中并没有子 View 对事件进行了捕获操作。这种情况下，直接调用 dispatchTransformedTouchEvent 方法，并传入 child 为 null，最终会调用 super.dispatchTouchEvent 方法。实际上最终会调用自身的 onTouchEvent 方法，进行处理 touch 事件。<br>也就是说：如果没有子 View 捕获处理 touch 事件，ViewGroup 会通过自身的 onTouchEvent 方法进行处理。</p>
<p><strong>分支 2</strong><br>mFirstTouchTarget 不为 null，说明在上面步骤 2 中有子 View 对 touch 事件进行了捕获，则直接将当前以及后续的事件交给 mFirstTouchTarget 指向的 View 进行处理。</p>
<h4 id="为什么-DOWN-事件特殊"><a href="#为什么-DOWN-事件特殊" class="headerlink" title="为什么 DOWN 事件特殊"></a>为什么 DOWN 事件特殊</h4><p>所有 touch 事件都是从 DOWN 事件开始的，这是 DOWN 事件比较特殊的原因之一。另一个原因是 DOWN 事件的处理结果会直接影响后续 MOVE、UP 事件的逻辑。</p>
<p>在步骤 2 中，只有 DOWN 事件会传递给子 View 进行捕获判断，一旦子 View 捕获成功，后续的 MOVE 和 UP 事件是通过遍历 mFirstTouchTarget 链表，查找之前接受 ACTION_DOWN 的子 View，并将触摸事件分配给这些子 View。也就是说后续的 MOVE、UP 等事件的分发交给谁，取决于它们的起始事件 Down 是由谁捕获的。</p>
<h4 id="mFirstTouchTarget-有什么作用"><a href="#mFirstTouchTarget-有什么作用" class="headerlink" title="mFirstTouchTarget 有什么作用"></a>mFirstTouchTarget 有什么作用</h4><p>其实 mFirstTouchTarget 是一个 TouchTarget 类型的链表结构。而这个 TouchTarget 的作用就是用来记录捕获了 DOWN 事件的 View，具体保存在上图中的 child 变量。可是为什么是链表类型的结构呢？因为 Android 设备是支持多指操作的，每一个手指的 DOWN 事件都可以当做一个 TouchTarget 保存起来。在步骤 3 中判断如果 mFirstTouchTarget 不为 null，则再次将事件分发给相应的 TouchTarget。</p>
<h4 id="容易被遗漏的-CANCEL-事件"><a href="#容易被遗漏的-CANCEL-事件" class="headerlink" title="容易被遗漏的 CANCEL 事件"></a>容易被遗漏的 CANCEL 事件</h4><p>在上面的步骤 3 中，继续向子 View 分发事件的代码中，有一段比较有趣的逻辑：<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog4/p17.png" alt><br>上图红框中表明已经有子 View 捕获了 touch 事件，但是蓝色框中的 intercepted boolean 变量又是 true。这种情况下，事件主导权会重新回到父视图 ViewGroup 中，并传递给子 View 的分发事件中传入一个 cancelChild == true。</p>
<p>看一下 dispatchTransformedTouchEvent 方法的部分源码如下：<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog4/p18.png" alt><br>因为之前传入参数 cancel 为 true，并且 child 不为 null，最终这个事件会被包装为一个 ACTION_CANCEL 事件传给 child。</p>
<p><strong>什么情况下会触发这段逻辑呢？</strong><br>总结一下就是：当父视图的 onInterceptTouchEvent 先返回 false，然后在子 View 的 dispatchTouchEvent 中返回 true（表示子 View 捕获事件），关键步骤就是在接下来的 MOVE 的过程中，父视图的 onInterceptTouchEvent 又返回 true，intercepted 被重新置为 true，此时上述逻辑就会被触发，子控件就会收到 ACTION_CANCEL 的 touch 事件</p>
<p><strong>实际上有个很经典的例子可以用来演示这种情况：</strong><br>当在 Scrollview 中添加自定义 View 时，ScrollView 默认在 DOWN 事件中并不会进行拦截，事件会被传递给 ScrollView 内的子控件。只有当手指进行滑动并到达一定的距离之后，onInterceptTouchEvent 方法返回 true，并触发 ScrollView 的滚动效果。当 ScrollView 进行滚动的瞬间，内部的子 View 会接收到一个 CANCEL 事件，并丢失touch焦点。</p>
<p>因此，我们平时自定义View时，尤其是有可能被ScrollView或者ViewPager嵌套使用的控件，不要遗漏对CANCEL事件的处理，否则有可能引起UI显示异常</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>本文重点分析了 dispatchTouchEvent 的事件的流程机制，这一过程主要分 3 部分：<br>1.判断是否需要拦截 —&gt; 主要是根据 onInterceptTouchEvent 方法的返回值来决定是否拦截；<br>2.在 DOWN 事件中将 touch 事件分发给子 View —&gt; 这一过程如果有子 View 捕获消费了 touch 事件，会对 mFirstTouchTarget 进行赋值；<br>3.最后一步，DOWN、MOVE、UP 事件都会根据 mFirstTouchTarget 是否为 null，决定是自己处理 touch 事件，还是再次分发给子 View。</p>
<p><strong>然后介绍了整个事件分发中的几个特殊的点。</strong><br>1.DOWN 事件的特殊之处：事件的起点；决定后续事件由谁来消费处理；<br>2.mFirstTouchTarget 的作用：记录捕获消费 touch 事件的 View，是一个链表结构；<br>3.CANCEL 事件的触发场景：当父视图先不拦截，然后在 MOVE 事件中重新拦截，此时子 View 会接收到一个 CANCEL 事件</p>
<h3 id="view中的dispatchTouchEvent"><a href="#view中的dispatchTouchEvent" class="headerlink" title="view中的dispatchTouchEvent"></a>view中的dispatchTouchEvent</h3><p>一般情况下ViewGroup的dispatchTouchEvent方法比较好理解，就是分发给ViewGroup的子类去处理这个事件，然而为什么View也同样有这个方法呢？原因就是View 可以注册很多事件监听器，例如：单击事件(onClick)、长按事件(onLongClick)、触摸事件(onTouch)，并且View自身也有 onTouchEvent 方法，那么问题来了，这么多与事件相关的方法应该由谁管理？毋庸置疑就是 dispatchTouchEvent，所以 View 也会有事件分发</p>
<p>结论1:在dispatchTouchEvent方法中先执行onTouch方法,后执行onClick方法(onClick方法在onTouchEvent方法中的performClick方法中执行)</p>
<p>结论2:只有当34行代码if (li != null &amp;;&amp;; li.mOnTouchListener != null &amp;;&amp;; (mViewFlags &amp;; ENABLED_MASK) == ENABLED &amp;;&amp;; li.mOnTouchListener.onTouch(this, event))条件不成立时,才会调用onTouchEvent方法,此时的onTouchEvent返回值就是dispatchTouchEvent的返回值。</p>
<p>结论3:如果view为DISENABLED,则:onTouchListener里面内容不会执行,程序就会去执行onTouchEvent(event)方法,此时的onTouchEvent返回值就是dispatchTouchEvent的返回值。</p>
<p>结论4:如果onTouch方法返回true,并且消费了事件,那么就不会执行onTouchEvent方法,也就不可能执行其中的performClick方法里的onClick方法。</p>
<p>详情可见：<a href="https://www.jianshu.com/p/8527dba23512" target="_blank" rel="noopener">Android中view的dispatchTouchEvent方法源码分析</a></p>
<h3 id="滑动冲突解决"><a href="#滑动冲突解决" class="headerlink" title="滑动冲突解决"></a>滑动冲突解决</h3><h4 id="套路一-外部拦截法："><a href="#套路一-外部拦截法：" class="headerlink" title="套路一 外部拦截法："></a>套路一 外部拦截法：</h4><p>即父View根据需要对事件进行拦截。逻辑处理放在父View的onInterceptTouchEvent方法中。我们只需要重写父View的onInterceptTouchEvent方法，并根据逻辑需要做相应的拦截即可<br><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> boolean <span class="title">onInterceptTouchEvent</span>(<span class="params">MotionEvent <span class="keyword">event</span></span>)</span> &#123;</span><br><span class="line">    boolean intercepted = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> x = (<span class="keyword">int</span>) <span class="keyword">event</span>.getX();</span><br><span class="line">    <span class="keyword">int</span> y = (<span class="keyword">int</span>) <span class="keyword">event</span>.getY();</span><br><span class="line">    <span class="keyword">switch</span> (<span class="keyword">event</span>.getAction()) &#123;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_DOWN: &#123;</span><br><span class="line">            intercepted = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_MOVE: &#123;</span><br><span class="line">            <span class="keyword">if</span> (满足父容器的拦截要求) &#123;</span><br><span class="line">                intercepted = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                intercepted = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_UP: &#123;</span><br><span class="line">            intercepted = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mLastXIntercept = x;</span><br><span class="line">    mLastYIntercept = y;</span><br><span class="line">    <span class="keyword">return</span> intercepted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面伪代码表示外部拦截法的处理思路，需要注意下面几点</p>
<p>1.根据业务逻辑需要，在ACTION_MOVE方法中进行判断，如果需要父View处理则返回true，否则返回false，事件分发给子View去处理。<br>2.ACTION_DOWN 一定返回false，不要拦截它，否则根据View事件分发机制，后续ACTION_MOVE 与 ACTION_UP事件都将默认交给父View去处理！<br>3.原则上ACTION_UP也需要返回false，如果返回true，并且滑动事件交给子View处理，那么子View将接收不到ACTION_UP事件，子View的onClick事件也无法触发。而父View不一样，如果父View在ACTION_MOVE中开始拦截事件，那么后续ACTION_UP也将默认交给父View处理！</p>
<h4 id="套路二-内部拦截法："><a href="#套路二-内部拦截法：" class="headerlink" title="套路二 内部拦截法："></a>套路二 内部拦截法：</h4><p>即父View不拦截任何事件，所有事件都传递给子View，子View根据需要决定是自己消费事件还是给父View处理。这需要子View使用requestDisallowInterceptTouchEvent方法才能正常工作。下面是子View的dispatchTouchEvent方法的伪代码<br><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> boolean <span class="title">dispatchTouchEvent</span>(<span class="params">MotionEvent <span class="keyword">event</span></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> x = (<span class="keyword">int</span>) <span class="keyword">event</span>.getX();</span><br><span class="line">    <span class="keyword">int</span> y = (<span class="keyword">int</span>) <span class="keyword">event</span>.getY();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (<span class="keyword">event</span>.getAction()) &#123;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_DOWN: &#123;</span><br><span class="line">            parent.requestDisallowInterceptTouchEvent(<span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_MOVE: &#123;</span><br><span class="line">            <span class="keyword">int</span> deltaX = x - mLastX;</span><br><span class="line">            <span class="keyword">int</span> deltaY = y - mLastY;</span><br><span class="line">            <span class="keyword">if</span> (父容器需要此类点击事件) &#123;</span><br><span class="line">                parent.requestDisallowInterceptTouchEvent(<span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_UP: &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mLastX = x;</span><br><span class="line">    mLastY = y;</span><br><span class="line">    <span class="keyword">return</span> super.dispatchTouchEvent(<span class="keyword">event</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>父View需要重写onInterceptTouchEvent方法：<br><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> boolean <span class="title">onInterceptTouchEvent</span>(<span class="params">MotionEvent <span class="keyword">event</span></span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> action = <span class="keyword">event</span>.getAction();</span><br><span class="line">    <span class="keyword">if</span> (action == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用内部拦截法需要注意：</p>
<p>1.内部拦截法要求父View不能拦截ACTION_DOWN事件，由于ACTION_DOWN不受FLAG_DISALLOW_INTERCEPT标志位控制，一旦父容器拦截ACTION_DOWN那么所有的事件都不会传递给子View。<br>2.滑动策略的逻辑放在子View的dispatchTouchEvent方法的ACTION_MOVE中，如果父容器需要获取点击事件则调用 parent.requestDisallowInterceptTouchEvent(false)方法，让父容器去拦截事件。</p>
<p>详情可见：<a href="https://www.jianshu.com/p/982a83271327" target="_blank" rel="noopener">一文解决Android View滑动冲突</a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Okhttp源码分析</title>
    <url>/blog/2020/07/okhttp-source-learn.html</url>
    <content><![CDATA[<p>OkHttp是当下Android使用最频繁的网络请求框架，由Square公司开源。Google在Android4.4以后开始将源码中的HttpURLConnection底层实现替换为OKHttp，同时现在流行的Retrofit框架底层同样是使用OKHttp的。</p>
<p><strong>优点</strong></p>
<ul>
<li>支持Spdy、Http1.X、Http2、Quic以及WebSocket</li>
<li>连接池复用底层TCP(Socket)，减少请求延时</li>
<li>无缝的支持GZIP减少数据流量</li>
<li>缓存响应数据减少重复的网络请求</li>
<li>请求失败自动重试主机的其他ip，自动重定向</li>
</ul>
<h3 id="使用流程"><a href="#使用流程" class="headerlink" title="使用流程"></a>使用流程</h3><p><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog4/p12.png" alt><br>在使用OkHttp发起一次请求时，对于使用者最少存在<code>OkHttpClient</code>、<code>Request</code>与<code>Call</code>三个角色。其中<code>OkHttpClient</code>和<code>Request</code>的创建可以使用它为我们提供的<code>Builder</code>（建造者模式）。而<code>Call</code>则是把<code>Request</code>交给<code>OkHttpClient</code>之后返回的一个已准备好执行的请求</p>
<p>同时OkHttp在设计时采用的门面模式，将整个系统的复杂性给隐藏起来，将子系统接口通过一个客户端OkHttpClient统一暴露出来。</p>
<p>同时<code>Call</code>的<code>execute</code>代表了同步请求，而<code>enqueue</code>则代表异步请求。两者唯一区别在于一个会直接发起网络请求，而另一个使用OkHttp内置的线程池来进行。这就涉及到OkHttp的任务分发器。</p>
<h3 id="分发器"><a href="#分发器" class="headerlink" title="分发器"></a>分发器</h3><h4 id="同步请求"><a href="#同步请求" class="headerlink" title="同步请求"></a>同步请求</h4><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> executed(RealCall <span class="keyword">call</span>) &#123;</span><br><span class="line">	runningSyncCalls.add(<span class="keyword">call</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为同步请求不需要线程池，也不存在任何限制。所以分发器仅做一下记录。</p>
<h4 id="异步请求"><a href="#异步请求" class="headerlink" title="异步请求"></a>异步请求</h4><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> enqueue(AsyncCall <span class="keyword">call</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> (runningAsyncCalls.<span class="keyword">size</span>() &lt; maxRequests &amp;&amp; runningCallsForHost(<span class="keyword">call</span>) &lt; maxRequestsPerHost) 	  &#123;</span><br><span class="line">		runningAsyncCalls.add(<span class="keyword">call</span>);</span><br><span class="line">		executorService().execute(<span class="keyword">call</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		readyAsyncCalls.add(<span class="keyword">call</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当正在执行的任务未超过最大限制64，同时<code>runningCallsForHost(call) &lt; maxRequestsPerHost</code>同一Host的请求不超过5个，则会添加到正在执行队列，同时提交给线程池。否则先加入等待队列。</p>
<p>加入线程池直接执行没啥好说的，但是如果加入等待队列后，就需要等待有空闲名额才开始执行。因此每次执行完一个请求后，都会调用分发器的<code>finished</code>方法</p>
<h4 id="分发器线程池为什么要使用SynchronousQueue"><a href="#分发器线程池为什么要使用SynchronousQueue" class="headerlink" title="分发器线程池为什么要使用SynchronousQueue"></a>分发器线程池为什么要使用SynchronousQueue</h4><p>分发器线程池代码如下：<br><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="function">ExecutorService <span class="title">executorService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (executorService == <span class="keyword">null</span>) &#123;</span><br><span class="line">      executorService = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">          					<span class="number">0</span>,   				<span class="comment">//核心线程</span></span><br><span class="line">                            Integer.MAX_VALUE,  <span class="comment">//最大线程</span></span><br><span class="line">                            <span class="number">60</span>,					<span class="comment">//空闲线程闲置时间</span></span><br><span class="line">                            TimeUnit.SECONDS,	<span class="comment">//闲置时间单位</span></span><br><span class="line">                            <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(), <span class="comment">//线程等待队列</span></span><br><span class="line">                            Util.threadFactory(<span class="string">"OkHttp Dispatcher"</span>, <span class="keyword">false</span>) <span class="comment">//线程创建工厂</span></span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> executorService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在OkHttp的分发器中的线程池定义如上，其实就和<code>Executors.newCachedThreadPool()</code>创建的线程一样。首先核心线程为0，表示线程池不会一直为我们缓存线程，线程池中所有线程都是在60s内没有工作就会被回收。而最大线程<code>Integer.MAX_VALUE</code>与等待队列<code>SynchronousQueue</code>的组合能够得到最大的吞吐量。即当需要线程池执行任务时，如果不存在空闲线程不需要等待，马上新建线程执行任务！等待队列的不同指定了线程池的不同排队机制。一般来说，等待队列<code>BlockingQueue</code>有：<code>ArrayBlockingQueue</code>、<code>LinkedBlockingQueue</code>与<code>SynchronousQueue</code>。</p>
<p>假设向线程池提交任务时，核心线程都被占用的情况下：</p>
<p>1.<code>ArrayBlockingQueue</code>：基于数组的阻塞队列，初始化需要指定固定大小。<br>​    当使用此队列时，向线程池提交任务，会首先加入到等待队列中，当等待队列满了之后，再次提交任务，尝试加入队列就会失败，这时就会检查如果当前线程池中的线程数未达到最大线程，则会新建线程执行新提交的任务。所以最终可能出现后提交的任务先执行，而先提交的任务一直在等待。</p>
<p>2.<code>LinkedBlockingQueue</code>：基于链表实现的阻塞队列，初始化可以指定大小，也可以不指定。<br>​    当指定大小后，行为就和<code>ArrayBlockingQueu</code>一致。而如果未指定大小，则会使用默认的<code>Integer.MAX_VALUE</code>作为队列大小。这时候就会出现线程池的最大线程数参数无用，因为无论如何，向线程池提交任务加入等待队列都会成功。最终意味着所有任务都是在核心线程执行。如果核心线程一直被占，那就一直等待。</p>
<p>3.<code>SynchronousQueue</code> : 无容量的队列。<br>​    使用此队列意味着希望获得最大并发量。因为无论如何，向线程池提交任务，往队列提交任务都会失败。而失败后如果没有空闲的非核心线程，就会检查如果当前线程池中的线程数未达到最大线程，则会新建线程执行新提交的任务。完全没有任何等待，唯一制约它的就是最大线程数的个数。因此一般配合<code>Integer.MAX_VALUE</code>就实现了真正的无等待。</p>
<h3 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h3><p>OkHttp最核心的工作是在<code>getResponseWithInterceptorChain()</code>中进行，在进入这个方法分析之前，我们先来了解什么是责任链模式，因为此方法就是利用的责任链模式完成一步步的请求。<br>责任链顾名思义就是由一系列的负责者构成的一个链条，类似于工厂流水线</p>
<h4 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h4><p>责任链，顾名思义，就是用来处理相关事务责任的一条执行链，执行链上有多个节点，每个节点都有机会（条件匹配）处理请求事务，如果某个节点处理完了就可以根据实际业务需求传递给下一个节点继续处理或者返回处理完毕。</p>
<p><strong>场景</strong><br>现实中，请假的OA申请，请假天数如果是半天到1天，可能直接主管批准即可；<br>如果是1到3天的假期，需要部门经理批准；<br>如果是3天到30天，则需要总经理审批；<br>大于30天，正常不会批准。</p>
<p><a href="https://www.jianshu.com/p/9f7d9775bdda" target="_blank" rel="noopener">【设计模式】之责任链模式</a></p>
<h4 id="拦截器流程"><a href="#拦截器流程" class="headerlink" title="拦截器流程"></a>拦截器流程</h4><p>而OkHttp中的<code>getResponseWithInterceptorChain()</code>中经历的流程为<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog4/p13.png" alt><br>请求会被交给责任链中的一个个拦截器。默认情况下有五大拦截器：</p>
<ol>
<li><code>RetryAndFollowUpInterceptor</code><br>第一个接触到请求，最后接触到响应；负责判断是否需要重新发起整个请求</li>
<li><code>BridgeInterceptor</code><br>主要对 Request 中的 Head 设置默认值，比如 Content-Type、Keep-Alive、Cookie 等。</li>
<li><code>CacheInterceptor</code><br>请求前查询缓存，获得响应并判断是否需要缓存</li>
<li><code>ConnectInterceptor</code><br>负责建立与服务器地址之间的连接，也就是 TCP 链接</li>
<li><code>CallServerInterceptor</code><br>负责向服务器发送请求，并从服务器拿到远端数据结果</li>
</ol>
<h3 id="拦截器详情"><a href="#拦截器详情" class="headerlink" title="拦截器详情"></a>拦截器详情</h3><h4 id="重试及重定向拦截器"><a href="#重试及重定向拦截器" class="headerlink" title="重试及重定向拦截器"></a>重试及重定向拦截器</h4><p>第一个拦截器:<code>RetryAndFollowUpInterceptor</code>，主要就是完成两件事情：重试与重定向</p>
<p>本拦截器是整个责任链中的第一个，这意味着它会是首次接触到<code>Request</code>与最后接收到<code>Response</code>的角色，在这个拦截器中主要功能就是判断是否需要重试与重定向。</p>
<p>重试的前提是出现了<code>RouteException</code>或者<code>IOException</code>。一但在后续的拦截器执行过程中出现这两个异常，就会通过<code>recover</code>方法进行判断是否进行连接重试。</p>
<p>重定向发生在重试的判定之后，如果不满足重试的条件，还需要进一步调用<code>followUpRequest</code>根据<code>Response</code> 的响应码(当然，如果直接请求失败，<code>Response</code>都不存在就会抛出异常)。<code>followup</code>最大发生20次</p>
<h4 id="桥接拦截器"><a href="#桥接拦截器" class="headerlink" title="桥接拦截器"></a>桥接拦截器</h4><p><code>BridgeInterceptor</code>，连接应用程序和服务器的桥梁，我们发出的请求将会经过它的处理才能发给服务器，比如设置请求内容长度，编码，gzip压缩，cookie等，获取响应后保存Cookie等操作。<br>这个拦截器相对比较简单。</p>
<p>他所做的工作主要是补全请求头，<br>在补全了请求头后交给下一个拦截器处理，得到响应后，主要干两件事情：</p>
<p>1、保存cookie，在下次请求则会读取对应的数据设置进入请求头，默认的<code>CookieJar</code>不提供实现<br>2、如果使用gzip返回的数据，则使用<code>GzipSource</code>包装便于解析。</p>
<h4 id="缓存拦截器"><a href="#缓存拦截器" class="headerlink" title="缓存拦截器"></a>缓存拦截器</h4><p><code>CacheInterceptor</code>，在发出请求前，判断是否命中缓存。如果命中则可以不请求，直接使用缓存的响应。 (只会存在Get请求的缓存)<br>步骤为:<br>1、根据 Request 获取当前已有缓存的 Response（有可能为 null），并根据获取到的缓存 Response，创建 CacheStrategy 对象。<br>2.通过 CacheStrategy 判断当前缓存中的 Response 是否有效（比如是否过期），如果缓存 Response 可用则直接返回，否则调用 chain.proceed() 继续执行下一个拦截器，也就是发送网络请求从服务器获取远端 Response<br>3.如果从服务器端成功获取 Response，再判断是否将此 Response 进行缓存操作。</p>
<p><strong>总结</strong><br>1、如果从缓存获取的<code>Response</code>是null，那就需要使用网络请求获取响应；<br>2、如果是Https请求，但是又丢失了握手信息，那也不能使用缓存，需要进行网络请求；<br>3、如果判断响应码不能缓存且响应头有<code>no-store</code>标识，那就需要进行网络请求；<br>4、如果请求头有<code>no-cache</code>标识或者有<code>If-Modified-Since/If-None-Match</code>，那么需要进行网络请求；<br>5、如果响应头没有<code>no-cache</code>标识，且缓存时间没有超过极限时间，那么可以使用缓存，不需要进行网络请求；<br>6、如果缓存过期了，判断响应头是否设置<code>Etag/Last-Modified/Date</code>，没有那就直接使用网络请求否则需要考虑服务器返回304；</p>
<p>并且，只要需要进行网络请求，请求头中就不能包含<code>only-if-cached</code>，否则框架直接返回504！</p>
<h4 id="连接拦截器"><a href="#连接拦截器" class="headerlink" title="连接拦截器"></a>连接拦截器</h4><p><code>ConnectInterceptor</code>，打开与目标服务器的连接，并执行下一个拦截器<br>这个拦截器中的所有实现都是为了获得一份与目标服务器的连接，在这个连接上进行HTTP数据的收发。</p>
<h4 id="请求服务器拦截器"><a href="#请求服务器拦截器" class="headerlink" title="请求服务器拦截器"></a>请求服务器拦截器</h4><p>CallServerInterceptor 是 OkHttp 中最后一个拦截器，也是 OkHttp 中最核心的网路请求部分<br>实际完成Http发送与解析数据<br>在这个拦截器中就是完成HTTP协议报文的封装与解析</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>整个OkHttp功能的实现就在这五个默认的拦截器中，所以先理解拦截器模式的工作机制是先决条件。这五个拦截器分别为: 重试拦截器、桥接拦截器、缓存拦截器、连接拦截器、请求服务拦截器。每一个拦截器负责的工作不一样，就好像工厂流水线，最终经过这五道工序，就完成了最终的产品。</p>
<p>但是与流水线不同的是，OkHttp中的拦截器每次发起请求都会在交给下一个拦截器之前干一些事情，在获得了结果之后又干一些事情。整个过程在请求向是顺序的，而响应向则是逆序。</p>
<p>当用户发起一个请求后，会由任务分发起<code>Dispatcher</code>将请求包装并交给重试拦截器处理。</p>
<p>1、重试拦截器在交出(交给下一个拦截器)之前，负责判断用户是否取消了请求；在获得了结果之后，会根据响应码判断是否需要重定向，如果满足条件那么就会重启执行所有拦截器。</p>
<p>2、桥接拦截器在交出之前，负责将HTTP协议必备的请求头加入其中(如：Host)并添加一些默认的行为(如：GZIP压缩)；在获得了结果后，调用保存cookie接口并解析GZIP数据。</p>
<p>3、缓存拦截器顾名思义，交出之前读取并判断是否使用缓存；获得结果后判断是否缓存。</p>
<p>4、连接拦截器在交出之前，负责找到或者新建一个连接，并获得对应的socket流；在获得结果后不进行额外的处理。</p>
<p>5、请求服务器拦截器进行真正的与服务器的通信，向服务器发送数据，解析读取的响应数据。</p>
<p>在经过了这一系列的流程后，就完成了一次HTTP请求！</p>
<p><strong>OKHttp常见面试题</strong><br><a href="https://blog.csdn.net/songzi1228/article/details/101050603" target="_blank" rel="noopener">Okhttp面试简答</a><br><a href="https://blog.csdn.net/u012881042/article/details/79759203" target="_blank" rel="noopener">OkHttp中的设计模式</a><br><a href="https://www.jianshu.com/p/d04b463806c8" target="_blank" rel="noopener">应用拦截器与网络拦截器的区别</a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android View体系中的设计模式</title>
    <url>/blog/2020/07/android-view-design.html</url>
    <content><![CDATA[<p>首先，View体系的数据结构就是树形结构。ViewGroup继承View，而且ViewGroup持有View的引用，所以这不就是一个树的节点嘛。数据结构跟他的算法是相关的，所以至少你要掌握树的遍历，尤其是树的先序遍历，也就是深度遍历。<br>在view体系设计中也涉及到了几个设计模式，分别是组合模式，责任链模式，模板方法模式</p>
<h3 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h3><p>如果想实现一个树状的关系，那么就可以使用组合模式。如View和ViewGroup的关系，ViewGroup继承于View，同时也含有子View的引用集合。组合模式一般用于树形结构，所以在这里不需要展开。你只需要知道，View体系本身就是组合模式的体现。</p>
<h3 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h3><p>如果想实现一个调用可以让多个类都有机会去处理，那么可以使用责任链模式。类Node含有一个自己的引用，相当于一个链表指针，指向下一个节点。</p>
<h3 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h3><p>如果某一个功能逻辑的流程是比较固定的，但是有一定的步骤，那么可以通过模板方法模式把具体步骤交给子类去实现。</p>
<h3 id="View的Measure流程的核心"><a href="#View的Measure流程的核心" class="headerlink" title="View的Measure流程的核心"></a>View的Measure流程的核心</h3><p>为了真正关注核心点而不被其他的东西干扰带偏，所以我假定View树是一个二叉树，或者说我选取一个二叉树View树来进行分析。<br>测量就是计算每个View的大小，先来定义View类</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">abstract <span class="class"><span class="keyword">class</span> <span class="title">View</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">width</span>;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">height</span>;</span><br><span class="line">    View left;</span><br><span class="line">    View right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">View</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">measure</span><span class="params">(<span class="keyword">int</span> <span class="built_in">width</span>, <span class="keyword">int</span> <span class="built_in">height</span>)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.具体如何测量交给子类决定</span></span><br><span class="line">        onMeasure(<span class="built_in">width</span>, <span class="built_in">height</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置测量值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMeasuredDimension</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">width</span> = w;</span><br><span class="line">        <span class="built_in">height</span> = h;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="keyword">String</span>.format(<span class="string">"%d的测量结果是w=%d,h=%d"</span>, id, <span class="built_in">width</span>, <span class="built_in">height</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> abstract <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> <span class="built_in">width</span>, <span class="keyword">int</span> <span class="built_in">height</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很简陋的一个类，但是包含了最基本的要素了。measure方法里就用了模板方法模式，把具体如何测量交给子类实现。而且用final关键字，所以子类不能覆写measure，也就是说measure方法的流程不让改动。<br>注意：下文子节点是指View树的子节点，父节点是指View树的父节点，注意跟父类子类区分开。这是两回事来的。<br>好了，再来实现两个子类，不妨就叫TextView，ImageView。TextView具体的测量就是把父节点传递过来的值减去10，而ImageView是减去20</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextView</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TextView</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> myW = width - <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> myH = height - <span class="number">10</span>;</span><br><span class="line">        setMeasuredDimension(myW, myH);</span><br><span class="line">        <span class="comment">//去测量子节点</span></span><br><span class="line">        <span class="keyword">if</span> (left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            left.measure(myW, myH);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            right.measure(myW, myH);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImageView</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ImageView</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> myW = width - <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">int</span> myH = height - <span class="number">20</span>;</span><br><span class="line">        setMeasuredDimension(myW, myH);</span><br><span class="line">        <span class="comment">//去测量子节点</span></span><br><span class="line">        <span class="keyword">if</span> (left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            left.measure(myW, myH);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            right.measure(myW, myH);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大家可以看到，子节点的测量也是交给子类去负责分发测量了。跟之前讨论模板方法模式时有点不同，但是本质上是一样的。只是模板方法模式的例子是父类负责分发，这里是子类分发。<br>构造上图的View树进行测试。<br><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        View decorView = new ImageView(<span class="number">0</span>);</span><br><span class="line">        View imageView1 = new ImageView(<span class="number">1</span>);</span><br><span class="line">        View imageView2 = new ImageView(<span class="number">2</span>);</span><br><span class="line">        View textView3 = new TextView(<span class="number">3</span>);</span><br><span class="line">        View textView4 = new TextView(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        decorView.left = imageView1;</span><br><span class="line">        decorView.right = imageView2;</span><br><span class="line">        imageView1.left = textView3;</span><br><span class="line">        imageView1.right = textView4;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取window窗口大小（一般是手机屏幕大小），假设是1080x1920</span></span><br><span class="line">        int windowW = <span class="number">1080</span>;</span><br><span class="line">        int windowH = <span class="number">1920</span>;</span><br><span class="line">        decorView.measure(windowW, windowH);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">结果为：</span><br><span class="line"><span class="number">0</span>的测量结果是w=<span class="number">1060</span>,h=<span class="number">1900</span></span><br><span class="line"><span class="number">1</span>的测量结果是w=<span class="number">1040</span>,h=<span class="number">1880</span></span><br><span class="line"><span class="number">3</span>的测量结果是w=<span class="number">1030</span>,h=<span class="number">1870</span></span><br><span class="line"><span class="number">4</span>的测量结果是w=<span class="number">1030</span>,h=<span class="number">1870</span></span><br><span class="line"><span class="number">2</span>的测量结果是w=<span class="number">1040</span>,h=<span class="number">1880</span></span><br></pre></td></tr></table></figure></p>
<p>根据上图和运行结果可知，View的测量是深度遍历的。测量到一个节点时，这个节点负责去发起子节点的测量，这是责任链模式；而为了把具体测量实现交给子类，使用了模板方法模式</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://juejin.im/post/5e6e0b91f265da5716712288" target="_blank" rel="noopener">从数据结构与算法以及设计模式角度去学习View的绘制流程</a></p>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>面试经验总结</title>
    <url>/blog/2020/07/interview-exper-sum.html</url>
    <content><![CDATA[<h3 id="尚德公司面试"><a href="#尚德公司面试" class="headerlink" title="尚德公司面试"></a>尚德公司面试</h3><p>1.java有什么特性，继承有什么用处，多态有什么用处<br>2.反射是什么，在哪里用到，怎么利用反射创建一个对象<br>3.代理模式与装饰模式的区别，手写一个静态代理，一个动态代理<br>4.对象加载的过程，属性先加载还是方法先加载<br>5.垃圾回收机制与jvm结构<br>6.自定义View,事件分发机制讲一讲<br>7.http与https有什么区别<br>8.Activity启动模式，以及各启动模式生命周期问题<br>9.静态方法，静态对象为什么不能继承<br>10.Activity怎么启动Service，Activity与Service交互，Service与Thread的区别<br>11.介绍一下android动画<br>12.Launcher启动App的流程，中间有几种跨进程通信(socket)<br>13.Handler通信，Binder通信<br>14.你碰到过什么内存泄漏，怎么处理<br>15.RXJava怎么切换线程<br>16.Fragment hide show生命周期<br>17.平常有用到什么锁，synchronized底层原理是什么</p>
<h3 id="Vivo公司"><a href="#Vivo公司" class="headerlink" title="Vivo公司"></a>Vivo公司</h3><p>1.简单描述下Handler,Handler是怎么切换线程的,Handler同步屏障<br>2.Glide的缓存，有用过Glide的什么深入的API，自定义model是在Glide的什么阶段<br>3.讲讲mvc,mvp模式，presenter内存泄漏的问题<br>4.ANR了解过吗？有没有实际的ANR定位问题的经历<br>5.性能优化你做过哪些？<br>6.有什么实际解决UI卡顿优化的经历<br>7.有做过什么Bitmap优化的实际经验<br>8.项目搭建过程中有什么经验,有用到什么gradle脚本，分包有做什么操作<br>9.组件化有详细了解过吗？ARouter详细原理<br>10.讲一下事件分发机制,RecyclerView是怎么处理内部ViewClick冲突的<br>11.mainfest中配置LargeHeap，真的能分配到大内存吗？</p>
<h3 id="B站"><a href="#B站" class="headerlink" title="B站"></a>B站</h3><p>1.一个大致有序的数组如何排序，最快时间复杂度<br>2.如果叫你实现，你会怎样实现一个多主题的效果<br>3.如何自定义实现一个FlexLayout<br>4.tinker的原理是什么,还用过什么热修复框架，robust的原理是什么？<br>5.说说你对注解的了解，是怎么解析的<br>6.synchronized是公平锁还是非公平锁,ReteranLock是公平锁吗？是怎么实现的<br>7.泛型是怎么解析的，比如在retrofit中的泛型是怎么解析的<br>8.mvp与mvvm的区别，mvvm怎么更新UI,databinding用得多吗,databinding的原理？<br>9.kotlin ?的原理<br>10.在项目中有直接使用tcp,socket来发送消息吗<br>11.如何在网络框架里直接避免内存泄漏，不需要在presenter中释放订阅<br>12.生命周期都是通过什么调用的？有用过AIDL吗？<br>13.讲一下RecyclerView的缓存机制,滑动10个，再滑回去，会有几个执行onBindView<br>14.如何实现RecyclerView的局部更新，用过payload吗,notifyItemChange方法中的参数？<br>15.讲讲LinkedHashMap的数据结构<br>16.put post有什么区别<br>17.A Activity打开B Activity的生命周期变化，会有什么方法打断吗？<br>18.Fragment hide show生命周期变化<br>19.Fragment replace生命周期变化</p>
<h3 id="B站二面"><a href="#B站二面" class="headerlink" title="B站二面"></a>B站二面</h3><p>1.为什么考虑换工作<br>2.屏幕适配做过什么工作？<br>3.你们网络框架用的什么？为什么？<br>4.如果让你来开发B站的一个页面，哪一个页面可以很快入手<br>5.性能优化你做过什么工作？<br>6.h5与native通信你做过什么工作？<br>7.插件化的主要优点和缺点是什么？<br>8.你觉得B站目前的APP有什么问题？<br>9.如果产品要求你开发一个音频播放功能，你会怎么着手？预计会有什么坑？<br>10.ViewPager切换Fragment什么最耗时？<br>11.线程间同步的方法<br>12.锁之间的区别</p>
<h3 id="B站三面"><a href="#B站三面" class="headerlink" title="B站三面"></a>B站三面</h3><p>1.介绍一下你自已和项目<br>2.说说为什么考虑离职<br>3.说说对你们原来公司的印象<br>4.为什么想来B站？你在B站上常常在看什么？<br>5.期望薪资是多少？<br>6.你对搬到上海有什么想法？</p>
<h3 id="腾讯"><a href="#腾讯" class="headerlink" title="腾讯"></a>腾讯</h3><p>1.介绍一下你们项目的架构<br>2.Rxjava是怎么实现线程切换的<br>3.Rxjava自定义操作符<br>4.ARouter的原理<br>5.ARouter怎么实现接口调用<br>6.ARouter怎么实现页面拦截<br>7.MVP怎么处理内存泄漏<br>8.OkHttp怎么实现连接池<br>9.如果让你来实现一个网络框架，你会考虑什么<br>10.你做过什么性能优化的工作<br>11.热修复的原理，资源的热修复的原理,会不会有资源冲突的问题<br>12.ViewPager中嵌套ViewPager怎么处理滑动冲突<br>13.android源码中有哪些设计模式<br>14.说说binder机制的原理</p>
<h3 id="腾讯二面"><a href="#腾讯二面" class="headerlink" title="腾讯二面"></a>腾讯二面</h3><p>1.为什么考虑换一份工作？<br>2.在你们公司这几年感觉怎么样？<br>3.技术选型上，为什么这么考虑？从开发效率，产品性能，产品质量，产品体验等方面考虑<br>4.你们的产品为什么被砍掉，从哪方面考虑<br>5.在这几年里，你有做过什么觉得最有价值的工作<br>6.你还有什么要问我的吗？目前有几个offer，倾向性是怎样的？</p>
<h3 id="网易云音乐"><a href="#网易云音乐" class="headerlink" title="网易云音乐"></a>网易云音乐</h3><p>1.ViewPager2原理<br>2.LifeCycle的原理是怎样的？<br>3.ViewModel为什么在旋转屏幕后不会丢失状态<br>4.Drawable与View有什么区别,Drawable有哪些子类<br>5.属性动画更新时会回调onDraw吗？<br>6.OkHttp网络拦截器，应用拦截器?OKHttp有哪些拦截器，分别起什么作用<br>7.自定义实现一个九宫格如何实现<br>8.PathClassLoader与DexClassLoader有什么区别<br>9.这些年有做一些什么比较难的工作？<br>10.编译时注解与运行时注解，为什么retrofit要使用运行时注解？什么时候用运行时注解？<br>11.kotlin lazy使用,lazy viewmodel<br>12.有没有看一下Google官方的ViewModel demo<br>13.ViewModel在Activity初始化与在Fragment中初始化，有什么区别？<br>14.kotlin与Java互相调用有什么问题？<br>15.retrofit怎么做post请求<br>16.界面优化的一些方法，ConstraintLayout实现三等分,ConstraintLayout动画.<br>17.CoordinatorLayout自定义behavior,可以拦截什么？</p>
<h3 id="网易云音乐二面"><a href="#网易云音乐二面" class="headerlink" title="网易云音乐二面"></a>网易云音乐二面</h3><p>1.你们的项目中做过什么比较难的工作？<br>2.视频播放,一个player怎么实现预加载，避免loading<br>2.webView加载本地图片，如何从安全方面考虑<br>3.http1.0,http1.1,http1.2有什么区别<br>4.https与http有什么区别<br>5.有用过什么加密算法？AES,RAS什么原理？<br>6.android跨进程通信了解吗？共享内存用过吗？binder怎么验证pid?binder驱动了解吗？<br>7.SharedParence可以跨进程通信吗？如何改造成可以跨进程通信的.commit和apply的区别.<br>8.Seriazable与Parceable的区别<br>9.Bundle是什么数据结构?利用什么传递数据<br>10.Jvm的内存结构，Jvm的垃圾回收，方法区有什么东西？<br>11.h5与native交互，webView.loadUrl与webView.evaluateUrl区别</p>
<h3 id="网易云音乐三面"><a href="#网易云音乐三面" class="headerlink" title="网易云音乐三面"></a>网易云音乐三面</h3><p>1.有没有做过什么WebView秒开的一些优化<br>2.你们的项目中有什么难点？<br>3.native如何对h5进行鉴权，让某些页面可以调，某些页面不能调<br>4.有看过哪些框架的源码吗？<br>5.viewModel是怎么实现双向数据绑定的？<br>6.viewModel怎么实现自动处理生命周期？<br>7.图片加载优化有什么经验吗？<br>8.viewpager切换掉帧有什么处理经验？<br>9.一个wrap_content的ImageView，加载远程图片，传什么参数裁剪比较好?<br>10.两个getDrawable取得的对象，有什么区别？<br>11.补间动画与属性动画的区别，哪个效率更高？<br>12.jsBridge实现方式<br>13.平常是怎么了解一些新知识与业界动态的，最近有什么印象深刻的文章<br>14.平常抓包用什么工具？<br>15.Mvp与Mvvm有什么区别?</p>
<h3 id="跟谁学"><a href="#跟谁学" class="headerlink" title="跟谁学"></a>跟谁学</h3><p>1.项目中的Webview与native通信<br>2.项目中对WebView的功能进行了怎样的增强<br>3.synchronized跟ReentranLock有什么区别？<br>4.synchronized与ReentranLock发生异常的场景.<br>5.算法,删除数组中的重复元素<br>6.手写双检查单例模式，各个步骤有什么区别<br>7.Activity生命周期</p>
<h3 id="快手"><a href="#快手" class="headerlink" title="快手"></a>快手</h3><p>1.string,equals,==有什么区别<br>2.AsyncTask内存泄露<br>3.dispatchTouchEvent,onInterceptEvent,onTouchEvent顺序，关系<br>4.onMeasure,onLayout,onDraw关系<br>5.算法题，反转数组<br>6.算法题，链表求和<br>7.说说你对协程的理解<br>8.协程怎么取消<br>9.说说MVP与MVVM的区别</p>
<h3 id="快手二面"><a href="#快手二面" class="headerlink" title="快手二面"></a>快手二面</h3><p>1.算法题，二叉树的最大深度<br>2.如果android端和IOS端调一个接口，一个通了一个没通，你会如何解决<br>3.如果android端和IOS端调一个接口，一个比较慢，一个比较快，有什么思路<br>4.ARouter的原理是什么？如果不用ARouter，你会怎么去解藕。接口？设计接口有什么需要注意的？<br>5.h5与native交互做过什么工作？<br>6.登陆功能，登陆成功然后跳转到一个新Activity，中间涉及什么？从事件传递，网络请求,AMS交互角度分析<br>7.AMS交互调用生命周期是顺序的吗？<br>8.binder进程间通信可以调用原进程方法吗？<br>9.mvp与mvvm有什么区别？<br>10.token放在本地如何保存？如何加密比较好？</p>
<h3 id="快手三面"><a href="#快手三面" class="headerlink" title="快手三面"></a>快手三面</h3><p>1.viewModel的原理，为什么可以在Activity销毁后保存数据<br>2.mvvm双向数据绑定的原理是怎样的？ViewModel<br>3.说说你们项目中的难点是怎样的？<br>4.伪代码实现一个长按事件<br>5.实现一个下载功能的接口</p>
<h3 id="猿辅导"><a href="#猿辅导" class="headerlink" title="猿辅导"></a>猿辅导</h3><p>1.泛型有什么优点？<br>2.动态代理有什么作用？<br>3.拉圾回收的GCRoot是什么？<br>4.Handler机制了解吗？一个线程有几个Looper？为什么？<br>5.你了解协程吗？协程有什么作用？可以完全取代rxjava吗？<br>6.你们用的什么消息通信机制<br>7.你的项目有什么难点？介绍一下？<br>8.算法题，二叉树最长结点集合</p>
<h3 id="猿辅导2面"><a href="#猿辅导2面" class="headerlink" title="猿辅导2面"></a>猿辅导2面</h3><p>1.你们项目中的难点是什么？<br>2.编译期注解处理的是字节码还是java文件<br>3.你在项目中有用到什么设计模式吗？<br>4.ARouter的原理是怎样的？<br>5.插件化的原理是怎样的？<br>6.算法题，K字一组反转链表<br>7.广播与RxBus的区别，全局广播与局部广播区别</p>
<h3 id="猿辅导3面"><a href="#猿辅导3面" class="headerlink" title="猿辅导3面"></a>猿辅导3面</h3><p>1.你们项目中有什么难点？<br>2.@JavaScriptInterface为什么不通过多个方法来实现？<br>3.为什么不利用同步方法来做jsBridge交互？同步可以做异步，异步不能做同步<br>4.网络封装怎么实现？<br>5.算法题，不同面值的几个硬币，怎么求满足条件的最小值</p>
<h3 id="斗鱼"><a href="#斗鱼" class="headerlink" title="斗鱼"></a>斗鱼</h3><p>1.说说HashMap的原理<br>2.说说Java的内存分区<br>3.讲讲你对垃圾回收机制的了解，老年代有什么算法？<br>4.说说你对volatile字段有什么用途？<br>5.说说事件分发机制，怎么写一个不能滑动的ViewPager<br>6.说说你对类加载机制的了解？DexClassLoader与PathClassLoader的区别<br>7.说说插件化的原理，资源的插件化id重复如何解决？<br>8.mvp与mvvm模式的区别是什么？<br>9.JetPack组件用过哪些？lifeCycle的原理是什么？如果在onStart里面订阅，会回调onCreate吗？<br>10.单例模式有什么缺点？<br>11.说说App的启动过程,在ActivityThread的main方法里面做了什么事，什么时候启动第一个Activity？<br>12.说说你对Handler机制的了解，同步消息，异步消息等<br>13.说说你对屏幕刷新机制的了解，双重缓冲，三重缓冲，黄油模型<br>14.onCreate,onResume,onStart里面，什么地方可以获得宽高<br>15.为什么view.post可以获得宽高，有看过view.post的源码吗？<br>16.attachToWindow什么时候调用？<br>17.DataBinding的原理了解吗？</p>
<h3 id="滴滴一面"><a href="#滴滴一面" class="headerlink" title="滴滴一面"></a>滴滴一面</h3><p>1.JVM类加载机制了解吗，类什么时候会被加载？类加载的过程具体生命周期是怎样的？<br>2.Handler内存泄漏的GCRoot是什么？<br>3.动画里面用到了什么设计模式？<br>4.OkHttp里面用到了什么设计模式？<br>5.OkHttp连接池是怎么实现的？里面怎么处理SSL？<br>6.泛型为什么要擦除？kotlin的泛型了解吗？泛型的pecs原则<br>7.同步屏障<br>8.性能优化做过什么工作？<br>9.RecyclerView的缓存结构是怎样的？缓存的是什么？cachedView会执行onBindView吗?<br>10.RecyclerView嵌套RecyclerView，NestScrollView嵌套ScrollView滑动冲突<br>11.ViewGroup在Action_Move时onIntercept返回true，事件怎么传递<br>12.Launcher启动图标，有几个进程？<br>13.JMM可见性，原子性，有序性，synchronized可以保证什么？<br>14.源码中有哪里用到了AtomicInt<br>15.AQS了解吗？<br>16.Activity内LinearLayout红色wrap_content,包含View绿色wrap_content,求界面颜色<br>17.ViewModel的使用中有什么坑？<br>18.有用DSL,anko写过布局吗？<br>19.HashMap查找的时间复杂度是多少？<br>20.阿里编程规范不建议使用线程池，为什么？<br>21.四种线程池原理？<br>22.了解哪些算法？<br>23.IdleHandler用过吗？</p>
<h3 id="滴滴二面"><a href="#滴滴二面" class="headerlink" title="滴滴二面"></a>滴滴二面</h3><p>1.如何封装一个字符串转数字的工具类<br>2.如何求当前Activity View的深度<br>3.多进程怎么实现？如果启动一个多进程APP，会有几个进程运行？<br>4.反射可以反射final修饰的字段吗？<br>5.Activity与AppCompactActivity区别，Activity会打包到包里面去吗？<br>6.如何让两个线程循环交替打印<br>7.怎么中止一个线程，Thread.Interupt一定有效吗？<br>8.动画连续调用的原理是什么？<br>9.做过一些SDK的操作吗？<br>10.协程可以在Java项目中使用吗？<br>11.SharedPreference原理？读取xml是在哪个线程?<br>12.了解APK打包的过程吗？<br>13.class文件的组成？常量池里面有什么内容？<br>14.自动装箱发生在什么时候？编译期还是运行期<br>15.bugly日志收集的原理是什么？<br>16.启动优化做过什么工作？如果首页就要用到的初始化？<br>17.DataBinding原理</p>
<h3 id="滴滴3面"><a href="#滴滴3面" class="headerlink" title="滴滴3面"></a>滴滴3面</h3><p>1.插件化的原理是什么？有没有什么非运行时插件化的解决方案？<br>2.ARouter的原理是怎样的？注解处理器是处理java还是字节码<br>3.java和字节码有什么区别？<br>4.kotlin空安全的原理是什么？<br>5.性能优化做过什么工作?有用过什么工具？有没有精确测量的工具？<br>6.kotlinc与javac编译字节码有什么区别？<br>7.你在团队中是怎样一个角色？<br>8.你有没有做什么推进项目的工作<br>9.说说热修复的原理？</p>
<h4 id="字节跳动"><a href="#字节跳动" class="headerlink" title="字节跳动"></a>字节跳动</h4><p>1.你们的项目中有什么难点？<br>2.你们项目的稳定性如何？有做过什么稳定性优化的工作？<br>3.WebView性能优化做过什么工作？<br>4.AIDL in out oneWay代表什么意思？<br>5.线程池了解多少？拒绝策略有几种,为什么有newSingleThread<br>6.跨进程通信了解多少？管道了解吗？<br>7.协程介绍一下，讲一个协程的scope与context，协程的+号代表什么<br>8.Handler休眠是怎样的？epoll的原理是什么？如何实现延时消息，如果移除一个延时消息会解除休眠吗？<br>9.算法斐波那契台阶<br>10.手写生产者消息者模型<br>11.IdleHandler应用场景</p>
<h4 id="字节跳动2面"><a href="#字节跳动2面" class="headerlink" title="字节跳动2面"></a>字节跳动2面</h4><p>1.自定义圆角图片<br>2.自定义LinearLayout，怎么测量子View宽高<br>3.setFactory和setFactory2有什么区别？<br>4.插件化换肤方案<br>5.插件化的原理，startActivity hook了哪个方法<br>6.手势操作ActionCancel后怎么取消<br>7.怎么优化xml inflate的时间，涉及IO与反射。了解compose吗？<br>8.算法题：二叉树的每一层最左边节点<br>9.RecyclerView 缓存结构，RecyclerView预取，RecyclerView局部刷新<br>11.setOnTouchListener,onClickeListener和onTouchEvent的关系</p>
]]></content>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>插件化相关总结</title>
    <url>/blog/2020/07/plugin-learn-sum.html</url>
    <content><![CDATA[<h3 id="什么是插件化"><a href="#什么是插件化" class="headerlink" title="什么是插件化"></a>什么是插件化</h3><p>插件化技术最初源于免安装运行 apk 的想法，这个免安装的 apk 就可以理解为插件，而支持插件的 app 我们一般叫宿主。</p>
<h3 id="插件化解决的问题"><a href="#插件化解决的问题" class="headerlink" title="插件化解决的问题"></a>插件化解决的问题</h3><p>1.APP的功能模块越来越多，体积越来越大<br>2.模块之间的耦合度高，协同开发沟通成本越来越大<br>3.方法数目可能超过65535，APP占用的内存过大<br>4.应用之间的互相调用</p>
<h3 id="插件化与组件化的区别"><a href="#插件化与组件化的区别" class="headerlink" title="插件化与组件化的区别"></a>插件化与组件化的区别</h3><p>组件化开发就是将一个app分成多个模块，每个模块都是一个组件，开发的过程中我们可以让这些组件相互依赖或者单独调试部分组件等，但是最终发布的时候是将这些组件合并统一成一个apk，这就是组件化开发。</p>
<p>插件化开发和组件化略有不同，插件化开发是将整个app拆分成多个模块，这些模块包括一个宿主和多个插件，每个模块都是一个apk，最终打包的时候宿主apk和插件apk分开打包。</p>
<h3 id="插件化实现思路"><a href="#插件化实现思路" class="headerlink" title="插件化实现思路"></a>插件化实现思路</h3><ol>
<li>如何加载插件的类？</li>
<li>如何调用插件四大组件？</li>
<li>如何加载插件的资源？</li>
</ol>
<h3 id="加载插件类"><a href="#加载插件类" class="headerlink" title="加载插件类"></a>加载插件类</h3><h4 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h4><p><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog4/p19.png" alt><br>首先检测这个类是否已经被加载了，如果已经加载了，直接获取并返回。如果没有被加载，parent 不为 null，则调用parent的loadClass进行加载，依次递归，如果找到了或者加载了就返回，如果即没找到也加载不了，才自己去加载。这个过程就是我们常说的 双亲委托机制。</p>
<p>1、避免重复加载，当父加载器已经加载了该类的时候，就没有必要子ClassLoader再加载一次。<br>2、安全性考虑，防止核心API库被随意篡改。</p>
<h4 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h4><ol>
<li>创建插件的 DexClassLoader 类加载器，然后通过反射获取插件的 dexElements 值。</li>
<li>获取宿主的 PathClassLoader 类加载器，然后通过反射获取宿主的 dexElements 值。</li>
<li>合并宿主的 dexElements 与 插件的 dexElements，生成新的 Element[]。</li>
<li>最后通过反射将新的 Element[] 赋值给宿主的 dexElements 。</li>
</ol>
<h3 id="Hook-Activity"><a href="#Hook-Activity" class="headerlink" title="Hook Activity"></a>Hook Activity</h3><p><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog4/p20.png" alt><br><strong>Hook 是什么？</strong><br>Hook 中文意思就是 钩子。<br>简单说，它的作用就是改变代码的正常执行流程。<br>实现Hook 的技术：反射 和 动态代理</p>
<h4 id="Activity启动流程"><a href="#Activity启动流程" class="headerlink" title="Activity启动流程"></a>Activity启动流程</h4><p><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog4/p22.png" alt></p>
<h4 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h4><p><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog4/p21.png" alt><br>通过 动态代理 和 反射 实现Hook Activity</p>
<h4 id="简述Activity启动流程"><a href="#简述Activity启动流程" class="headerlink" title="简述Activity启动流程"></a>简述Activity启动流程</h4><p>Activity的启动过程，我们可以从Context的startActivity说起，其实现是ContextImpl的startActivity，然后内部会通过Instrumentation来尝试启动Activity，它会调用ams的startActivity方法，这是一个跨进程过程，当ams校验完activity的合法性后，会通过ApplicationThread回调到我们的进程，这也是一次跨进程过程，而applicationThread就是一个binder，回调逻辑是在binder线程池中完成的，所以需要通过Handler H将其切换到ui线程，第一个消息是LAUNCH_ACTIVITY，它对应handleLaunchActivity，在这个方法里完成了Activity的创建和启动。</p>
<h3 id="资源加载"><a href="#资源加载" class="headerlink" title="资源加载"></a>资源加载</h3><p>实际上，Resources 类也是通过 AssetManager 类来访问那些被编译过的应用程序资源文件的，不过在访问之前，它会先根据资源 ID 查找得到对应的资源文件名。 而 AssetManager 对象既可以通过文件名访问那些被编译过的，也可以访问没有被编译过的应用程序资源文件。</p>
<h4 id="raw文件夹和assets文件夹有什么区别"><a href="#raw文件夹和assets文件夹有什么区别" class="headerlink" title="raw文件夹和assets文件夹有什么区别"></a>raw文件夹和assets文件夹有什么区别</h4><p>raw : Android会自动的为这目录中的所有资源文件生成一个ID,这意味着很容易就可以访问到这个资源，甚至在xml 中都是可以访问的，使用ID访问速度是最快的。<br>assets : 不会生成ID，只能通过AssetManager访问，xml中不能访问，访问速度会慢些，不过操作更加方便。</p>
<h4 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h4><ol>
<li>需要创建一个 Resources 对象，用来加载插件的资源</li>
<li>Resources 的创建需要 AssetManager 对象</li>
<li>AssetManager 创建的时候，需要指定资源路径</li>
</ol>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>高质量面经总结</title>
    <url>/blog/2020/08/new-interview-sum.html</url>
    <content><![CDATA[<h3 id="高质量面经总结"><a href="#高质量面经总结" class="headerlink" title="高质量面经总结"></a>高质量面经总结</h3><p>1.<a href="https://carlwe.com/2019/12/07/Android%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86%E9%94%A6/" target="_blank" rel="noopener">Android面试题集锦</a><br>2.<a href="https://www.jianshu.com/p/670bd9bdaafe" target="_blank" rel="noopener">字节一面 凉凉 分享面经</a><br>3.<a href="https://juejin.im/post/6844904147712475149#heading-2" target="_blank" rel="noopener">Android面经分享，失业两个月，五一节前拿到offer</a><br>4.<a href="https://www.nowcoder.com/discuss/421950?type=2" target="_blank" rel="noopener">字节跳动教育部门Android社招一面二面经验</a><br>5.<a href="https://juejin.im/user/3298190612500696/posts" target="_blank" rel="noopener">蓝师傅文章总结</a><br>Glide加载Gif性能优化等相关<br>6.<a href="https://juejin.im/post/6844904155153170439#heading-38" target="_blank" rel="noopener">这些年，我所经历的所有面试｜写给正在求职的 Androider</a><br>知识点总结得很好，值得细看<br>7.<a href="https://github.com/Timdk857/Android-Architecture-knowledge-2-" target="_blank" rel="noopener">https://github.com/Timdk857/Android-Architecture-knowledge-2</a><br>包罗万象，应有尽有。<br>8.<a href="https://www.jianshu.com/u/066678cb2cd9" target="_blank" rel="noopener">字节走动_Android</a><br>各个面试点深度解析，包括源码解析，大图加载，性能优化等。<br>9.<a href="https://juejin.im/post/6870111983933325319" target="_blank" rel="noopener">Android 筑基导论</a><br>Android开发者的基础，操作系统，数据结构，设计模式等</p>
]]></content>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>Glide大图加载优化</title>
    <url>/blog/2020/07/glide-big-bitmap.html</url>
    <content><![CDATA[<h3 id="大图加载优化"><a href="#大图加载优化" class="headerlink" title="大图加载优化"></a>大图加载优化</h3><p>对于一般大小的图片，Glide的缓存优化已经足够，但对于一些大图，长图，还需要我们进行一些特殊操作<br>直接上代码<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileImageActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SubsamplingScaleImageView mageView;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_file_image);</span><br><span class="line"></span><br><span class="line">        String sUrl = <span class="string">"https://ss0.bdstatic.com/94oJfD_bAAcT8t7mm9GUKT-xh_/timg?image&amp;quality=100&amp;size=b4000_4000&amp;sec=1532588239&amp;di=78b4c6bde1cf9d1df89562241b547e72&amp;src=http://p2.qhimg.com/t011fc13354f12d1a46.jpg"</span>;</span><br><span class="line">        sUrl = <span class="string">"http://img6.16fan.com/attachments/wenzhang/201805/18/152660818716180ge.jpeg"</span>;</span><br><span class="line">        mageView = (SubsamplingScaleImageView) findViewById(R.id.imageview);</span><br><span class="line">        mageView.setMinimumScaleType(SubsamplingScaleImageView.SCALE_TYPE_CUSTOM);</span><br><span class="line">        mageView.setMinScale(<span class="number">1.0F</span>);</span><br><span class="line">        <span class="comment">//下载图片保存到本地</span></span><br><span class="line">        Glide.with(<span class="keyword">this</span>).load(sUrl).downloadOnly(<span class="keyword">new</span> SimpleTarget&lt;File&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResourceReady</span><span class="params">(File resource, GlideAnimation&lt;? <span class="keyword">super</span> File&gt; glideAnimation)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 将保存的图片地址给SubsamplingScaleImageView,这里注意设置ImageViewState设置初始显示比例</span></span><br><span class="line">                ImageSource origin = ImageSource.uri(Uri.fromFile(resource));</span><br><span class="line">                String imagePath = resource.getAbsolutePath();</span><br><span class="line">                <span class="keyword">int</span> widOrigin = ImageUtil.getWidthHeight(imagePath)[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> heiOrigin = ImageUtil.getWidthHeight(imagePath)[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">                origin.dimensions(widOrigin, heiOrigin);</span><br><span class="line"></span><br><span class="line">                setImageSpec(imagePath, mageView);</span><br><span class="line">                mageView.setImage(ImageSource.uri(Uri.fromFile(resource)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setImageSpec</span><span class="params">(<span class="keyword">final</span> String imagePath, <span class="keyword">final</span> SubsamplingScaleImageView imageView)</span> </span>&#123;</span><br><span class="line">        imageView.setMinimumScaleType(SubsamplingScaleImageView.SCALE_TYPE_START);</span><br><span class="line">        imageView.setMinScale(ImageUtil.getLongImageMinScale(<span class="keyword">this</span>, imagePath));</span><br><span class="line">        imageView.setMaxScale(ImageUtil.getLongImageMaxScale(<span class="keyword">this</span>, imagePath));</span><br><span class="line">        imageView.setDoubleTapZoomScale(ImageUtil.getLongImageMaxScale(<span class="keyword">this</span>, imagePath));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">        mageView.recycle();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用Glide的downloadOnly，将图片作为File格式下载，然后再将File作为输入置SubsamplingScaleImageView中<br>然后在SubsamplingScaleImageView中就可以进行一系列的bitmap优化操作</p>
<h3 id="SubsamplingScaleImageView源码分析"><a href="#SubsamplingScaleImageView源码分析" class="headerlink" title="SubsamplingScaleImageView源码分析"></a>SubsamplingScaleImageView源码分析</h3><p>这里以原理实现为主,详情可见下方参考资料</p>
<h4 id="1-ImageSource"><a href="#1-ImageSource" class="headerlink" title="1.ImageSource"></a>1.ImageSource</h4><p>subsampling scale image view通过这个类ImageSource去获取图片，所以我们的图片资源都需要通过ImageSource去加载，支持从assets，文件，流中加载，从源码上看他其实就是一个工具类，用于方便加载各个路径的文件</p>
<h4 id="2-fullImageSampleSize"><a href="#2-fullImageSampleSize" class="headerlink" title="2.fullImageSampleSize"></a>2.fullImageSampleSize</h4><p>.fullImageSampleSamplSize由private int calculateInSampleSize(float scale)计算出，这个值应该是我们首先应该理解的。<br>他决定了图片是否需要用BitmapRegionDecoder进行区域加载。如果他的计算结果等于1，则表示这张图的分辨率还不够大，不需要进行切割进行区域加载，所以这种情况下是最简单的，直接将图加载进入，放大缩小，移动，都是通过Matrix来实现的，所以接下来就来说一下Matrix</p>
<h4 id="3-Matrix"><a href="#3-Matrix" class="headerlink" title="3.Matrix"></a>3.Matrix</h4><p>matrix，矩阵，很多关于图片的功能都能通过他来做一些十分的变换来实现,比如图片我的位移，放缩，旋转等等。subsampling scale image view也用了matrix来实现图片的放缩和位移，主要方法是<br>matrix.setPolyToPoly(srcArray, 0, dstArray, 0, 4); 有两个数组srA，rray和dstArray<br>dstarray数组决定了图片在屏幕的位置，而大图的移动滑动就是通过他来实现的</p>
<h4 id="4-Tile"><a href="#4-Tile" class="headerlink" title="4.Tile"></a>4.Tile</h4><p>private static class Tile这个内部类就是切片类，subsampling scale image view中最重要的一个数据结构。<br><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Tile</span> &#123;</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">private</span> Rect sRect;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">int</span> sampleSize;</span><br><span class="line">       <span class="keyword">private</span> Bitmap bitmap;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">boolean</span> loading;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">boolean</span> visible;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Volatile fields instantiated once then updated before use to reduce GC.</span></span><br><span class="line">       <span class="keyword">private</span> Rect vRect;</span><br><span class="line">       <span class="keyword">private</span> Rect fileSRect;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>他的属性也很简单就是用来存储图片的一段切片信息，各种rect和bitmap和一个samplesiz其中需要区分一下各个rect</p>
<p>srect和filesrect其实是保存这个切片的原始大小区域，也就调用是mDecoder.decodeRegion(mRect, option)区域加载时传入的rect<br>vRect描述绘制在view画布中的实际位置，也就是说图片放大后的上下滑动就是通过改变这个rect结合matrix.setPolyToP()来实现的</p>
<h4 id="5-三个task"><a href="#5-三个task" class="headerlink" title="5.三个task"></a>5.三个task</h4><p>TilesInitTask，TileLoadTask  ，BitmapLoadTask<br>subsampling scale image view内部又创建了三个继承自AsyncTask的task用来在后台加载decode图从而不阻碍ui主线程，更加流畅。<br>所以当fullImageSampleSize==1时，就直接用BitmapLoadTask解码整个图片不需切割，当期大于1时，就需要用TileLoadTask区域解码分割后的图片</p>
<h4 id="Map-lt-Integer-List-gt-tileMap"><a href="#Map-lt-Integer-List-gt-tileMap" class="headerlink" title="Map&lt;Integer, List&gt; tileMap"></a>Map&lt;Integer, List<tile>&gt; tileMap</tile></h4><p>最后介绍这个框架的核心，就是这个map<br>我们知道，图片放得越大，所需要的像素分辨率就要越高才能匹配，要不然就会很模糊。相反，如果图片缩得很小，就不需要很高的分辨率，多了就浪费了。而Android中就可以根据 option.inSampleSize来对图片进行采样压缩，减小分辨率。<br>所以，根据这个原理，subsampling scale image view将其根据需要计算出不同的采样率，当做key，然后根据不同的采样率进行切割，生成List<tile><br>放大的时候，subsampling scale image view会选取合适的采样率后获取到List<tile>然后进行解码，并且，他只会解码显示的部分，也就是til.visiable为true时才会解码。否者将其回收</tile></tile></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>对比自己实现的和subsampling scale image view，后者在大图的切片方面做得更好只将大图切成若干片，在判断是否可见，如果可见就加载到内存中，否者回收；滑动时只改变矩阵的值进行简单的位移变换，进一步提升了流畅度，而且根据不同放缩比例选择合适的采样率，进一步减少内存占用。自己实现的每滑动一次就要重新解码绘制好几次，所以后者性能更高，值得学习</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://juejin.im/post/6844903693326761998#heading-1" target="_blank" rel="noopener">subsampling-scale-image-view加载长图源码分析总结</a><br><a href="https://juejin.im/post/6844903910088392712" target="_blank" rel="noopener">Android超长图加载与subsampling scale image view实现分析</a><br><a href="https://github.com/SherlockGougou/BigImageViewPager" target="_blank" rel="noopener">BigImageViewPager</a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>ANR问题定位</title>
    <url>/blog/2020/08/android-anr-analyse.html</url>
    <content><![CDATA[<h3 id="什么是ANR问题"><a href="#什么是ANR问题" class="headerlink" title="什么是ANR问题"></a>什么是ANR问题</h3><p><strong>场景</strong><br>1、触摸无响应5s<br>2、BroadCastReciver 前台处理超过10s 后台超过60s<br>3、Server 前台处理超过20s 后台超过200s</p>
<p><strong>ANR出现的类型有两种</strong><br>1、主线程耗时导致<br>2、CPU、内存、IO 占用过高资源耗尽（其他进程也可以导致）</p>
<p><strong>如何避免</strong><br>1、不要在主线程中做耗时的操作<br>2、避免CPU占用过高，简化方法，减少执行时间<br>3、避免内存占用过高，防止内存泄漏</p>
<h3 id="ANR定位具体步骤"><a href="#ANR定位具体步骤" class="headerlink" title="ANR定位具体步骤"></a>ANR定位具体步骤</h3><p>首先当然是复现ANR现象，找准ANR出现的地方，查看对应代码，如果能直接看出来问题所在，找到代码中做的错误操作那么直接修改相应代码就解决问题了。但是如果没法轻易看出问题原因，接下来就只好去Logcat中查看对应的错误日志<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">07-22 21:39:17.019 819-851/? E/ActivityManager: ANR <span class="keyword">in</span> com.xxxx.performance (com.xxxx.performance/.view.home.activity.MainActivity)</span><br><span class="line">    PID: 7398</span><br><span class="line">    Reason: Input dispatching timed out (com.xxxx.performance/com.xxxx.performance.view.home.activity.MainActivity, Waiting <span class="keyword">to</span> send non-key event because the touched window has <span class="keyword">not</span> finished processing certain input events that were delivered <span class="keyword">to</span> it over 500.0ms ago.  Wait<span class="built_in"> queue </span>length: 29.  Wait<span class="built_in"> queue </span>head age: 8579.3ms.)</span><br><span class="line">    Load: 18.22 / 18.1 / 18.18</span><br><span class="line">    CPU usage <span class="keyword">from</span> 0ms <span class="keyword">to</span> 8653ms later:</span><br><span class="line">      124% 7398/com.xxxx.performance: 118%<span class="built_in"> user </span>+ 6.5% kernel / faults: 4962 minor 7 major</span><br><span class="line">      82% 819/system_server: 28%<span class="built_in"> user </span>+ 53% kernel / faults: 10555 minor 11 major</span><br><span class="line">      23% 4402/adbd: 1%<span class="built_in"> user </span>+ 22% kernel</span><br><span class="line">      10% 996/com.android.systemui: 4.6%<span class="built_in"> user </span>+ 6.2% kernel / faults: 4677 minor 1 major</span><br><span class="line">      4.6% 2215/com.android.phone: 1.5%<span class="built_in"> user </span>+ 3.1% kernel / faults: 5411 minor</span><br><span class="line">      6.3% 6268/perfd: 3.4%<span class="built_in"> user </span>+ 2.8% kernel / faults: 134 minor</span><br><span class="line">      0.5% 1149/com.miui.whetstone: 0.1%<span class="built_in"> user </span>+ 0.3% kernel / faults: 3016 minor 1 major</span><br><span class="line">      0.2% 2097/com.xiaomi.finddevice: 0.1%<span class="built_in"> user </span>+ 0.1% kernel / faults: 2256 minor</span><br><span class="line">      0.6% 2143/com.miui.daemon: 0.2%<span class="built_in"> user </span>+ 0.3% kernel / faults: 2798 minor</span><br><span class="line">      1.2% 1076/com.xiaomi.xmsf: 0.6%<span class="built_in"> user </span>+ 0.6% kernel / faults: 2802 minor</span><br><span class="line">      0% 2122/com.android.server.telecom: 0%<span class="built_in"> user </span>+ 0% kernel / faults: 2929 minor</span><br><span class="line">      0% 2244/com.miui.contentcatcher: 0%<span class="built_in"> user </span>+ 0% kernel / faults: 1800 minor</span><br><span class="line">      0% 2267/com.mediatek.nlpservice: 0%<span class="built_in"> user </span>+ 0% kernel / faults: 2052 minor</span><br><span class="line">      0% 2166/com.xiaomi.mitunes: 0%<span class="built_in"> user </span>+ 0% kernel / faults: 1797 minor 3 major</span><br><span class="line">      0% 2190/com.fingerprints.service: 0%<span class="built_in"> user </span>+ 0% kernel / faults: 1857 minor</span><br><span class="line">      0.1% 154/mmcqd/0: 0%<span class="built_in"> user </span>+ 0.1% kernel</span><br><span class="line">      0.4% 8069/logcat: 0.3%<span class="built_in"> user </span>+ 0.1% kernel</span><br><span class="line">      <span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span></span><br></pre></td></tr></table></figure></p>
<p>大概信息如下<br><figure class="highlight gams"><table><tr><td class="code"><pre><span class="line">Process：anr发生的时间和进程，和生成traces文件的时间</span><br><span class="line"><span class="function"><span class="title">CPUusage</span></span> ... ago ：cpu在anr发生前的使用情况</span><br><span class="line"><span class="function"><span class="title">CPUusage</span></span> ...later: cpu在anr后的使用情况</span><br><span class="line">ABI:         手机的cpu架构</span><br><span class="line">HEAP:     堆的内存信息</span><br><span class="line">ANR in：包名，和类名</span><br><span class="line">Reason：原因</span><br><span class="line">TOTAL：总的CPU使用率</span><br><span class="line">prio:线程的优先级</span><br><span class="line">tid：线程锁id  主线程的id为<span class="number">1</span>  主要看这个线程的</span><br><span class="line">Sleeping：线程的状态</span><br><span class="line">sCount：线程被挂起的次数</span><br><span class="line">dsCount：线程是否被调试</span><br></pre></td></tr></table></figure></p>
<p>1.如果TOTAL的和接近100，有可能是因为当前使用的app占用的cpu太高，导致系统将你的杀死。<br>2.如果TOTAL很小，则说明线程被阻塞了，主线程在等待下条消息的进入，任务在等待时anr。<br>3.如果ioWait很高，则说明是io操作导致的</p>
<h3 id="Anr文件导出"><a href="#Anr文件导出" class="headerlink" title="Anr文件导出"></a>Anr文件导出</h3><p>如果上述还不能定位问题，则需要通过 adb pull data/anr/traces.txt 来输出日志文件<br>但新版本无法直接导出，可通过adb bugreport来实现,详情可见<br><a href="https://blog.csdn.net/denglusha737/article/details/86706909" target="_blank" rel="noopener">https://blog.csdn.net/denglusha737/article/details/86706909</a></p>
<h3 id="SharedPreference引起的ANR"><a href="#SharedPreference引起的ANR" class="headerlink" title="SharedPreference引起的ANR"></a>SharedPreference引起的ANR</h3><h4 id="首先看看SharedPreference-commit与Apply区别"><a href="#首先看看SharedPreference-commit与Apply区别" class="headerlink" title="首先看看SharedPreference commit与Apply区别"></a>首先看看SharedPreference commit与Apply区别</h4><p>apply没有返回值而commit返回boolean表明修改是否提交成功<br>apply是将修改数据原子提交到内存, 而后异步真正提交到硬件磁盘, 而commit是同步的提交到硬件磁盘，因此，在多个并发的提交commit的时候，他们会等待正在处理的commit保存到磁盘后在操作，从而降低了效率。而apply只是原子的提交到内容，后面有调用apply的函数的将会直接覆盖前面的内存数据，这样从一定程度上提高了很多效率</p>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog4/p7.webp" alt><br>ActivityThread 的这几个方法是 Activity 或 Service 的生命周期变化的时候调用的。从堆栈信息来看，组件生命周期变化，导致调用 QueueWork 中的队列处于等待状态，等待超时则发生 ANR。那么 QueuedWork 的工作机制是什么样的呢，我们从源码入手来进行分析</p>
<h4 id="SP-的-apply-到底做了什么"><a href="#SP-的-apply-到底做了什么" class="headerlink" title="SP 的 apply 到底做了什么"></a>SP 的 apply 到底做了什么</h4><p>apply的基本流程是:<br>1.首先调用commitToMemory将数据改动同步到内存中，也就是SharedPreferencesImpl的mMap(HashMap)<br>2.然后调用 QueuedWork.add(awaitCommit);将一个等待的任务加入到列表中，在Activity等的生命周期中，就是以这个为判断条件，等待写入任务执行完成的。<br>3调用enqueueDiskWrite方法的实现，将写入任务加入到队列中，写入磁盘的操作会在子线程中执行。</p>
<p>该问题是与SharedPreferences操作相关的。在我们的代码中，使用sp读写配置文件，都是采用了官方的推荐做法，调用apply提交，调用这个方法时，会首先写入内存中，然后将落盘的任务加入队列中，会在异步线程中做落盘的操作，这个操作一般来说是没有问题的，也是google官方推荐的做法。但是另一方面android的系统会在Activity的onStop,onPause等生命周期中，调用QueuedWork.waitToFinish，等待落盘的任务队列执行完成，如果任务队列中的任务很多，或者待写入的数据量很大时(sp文件是全量读写的)，在一些io性能差的中低端机型上就会很容易出现anr</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>问题直接来自于在系统在主线程的几个生命周期中去等待任务列表执行完成，那么android为什么要这样设计呢？android的应用是被托管运行的，应用在运行过程中有可能被系统回收、杀死、或者用户主动杀死，其实是在一个不确定的环境中运行，apply提交的任务，不是立即执行的，而是会加入到列表中，在未来的某一个时刻去执行，那么就存在不确定性了，有可能在执行之前应用进程被杀死了，那么写入任务就失败了。所以就在应用进程的存续时，抓紧找到一些时机去完成写入磁盘的事情，也就是在上面的几个生命周期方法中。</p>
<p>这个设计整体上是没有大问题的，但是QueuedWork.waitToFinish的方法在老版的实现上存在很大的缺陷，它使得主线程只是在等待，而没有做推动，这种情况下导致应用出现anr,进而被用户或者系统杀死进程，这样写入任务还是不能执行完成，还影响用户体验，这个是得不偿失的。8.0的版本才修复了这个缺陷。</p>
<p>老版本 的QueuedWork.waitToFinish方法实现有缺陷，可以去规避这个方法来解决这个问题，就是去清除等待锁的队列，主线程在调用这个方法时，不必去等待。可以只在Android8.0以下加入此处理。</p>
<h3 id="ContextImpl锁引起的ANR"><a href="#ContextImpl锁引起的ANR" class="headerlink" title="ContextImpl锁引起的ANR"></a>ContextImpl锁引起的ANR</h3><p>trace日志<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="string">"main"</span> prio=<span class="number">5</span> tid=<span class="number">1</span> Blocked</span><br><span class="line">group=<span class="string">"main"</span> sCount=<span class="number">1</span> dsCount=<span class="number">0</span> obj=<span class="number">0</span>x75afba88 self=<span class="number">0</span>x7fb0e96a00</span><br><span class="line">...</span><br><span class="line">at android<span class="selector-class">.app</span><span class="selector-class">.ContextImpl</span>.getPreferencesDir(ContextImpl<span class="selector-class">.java</span>:<span class="number">483</span>)</span><br><span class="line">- waiting to lock &lt;<span class="number">0</span>x0cfeaaf2&gt; (<span class="selector-tag">a</span> java<span class="selector-class">.lang</span>.Object) held by thread <span class="number">24</span></span><br><span class="line">at android<span class="selector-class">.app</span><span class="selector-class">.ContextImpl</span>.getSharedPreferencesPath(ContextImpl<span class="selector-class">.java</span>:<span class="number">665</span>)</span><br><span class="line">at android<span class="selector-class">.app</span><span class="selector-class">.ContextImpl</span>.getSharedPreferences(ContextImpl<span class="selector-class">.java</span>:<span class="number">364</span>)</span><br><span class="line">- locked &lt;<span class="number">0</span>x09b0b543&gt; (<span class="selector-tag">a</span> java<span class="selector-class">.lang</span>.Class&lt;android<span class="selector-class">.app</span>.ContextImpl&gt;)</span><br><span class="line">at android<span class="selector-class">.content</span><span class="selector-class">.ContextWrapper</span>.getSharedPreferences(ContextWrapper<span class="selector-class">.java</span>:<span class="number">174</span>)</span><br><span class="line">at android<span class="selector-class">.content</span><span class="selector-class">.ContextWrapper</span>.getSharedPreferences(ContextWrapper<span class="selector-class">.java</span>:<span class="number">174</span>)</span><br><span class="line">...</span><br><span class="line">at com<span class="selector-class">.xxx</span><span class="selector-class">.receiver</span><span class="selector-class">.xxx</span>.onReceive(xxx<span class="selector-class">.java</span>:<span class="number">36</span>)</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>这里简单解释一下，ANR无非就是UI线程Block了，所以我们找到形如 “main” prio=5 tid=1 Blocked 这样的片段，main表示主线程，prio即priority，线程优先级（这里不是重点），tid就是thread的id，即线程id，最后标记了Blocked，表示线程阻塞了。<br>接着的信息就是告诉你线程被哪个鬼lock了，关注这行：<br>waiting to lock <0x0cfeaaf2> (a java.lang.Object) held by thread 24<br>说明主线程的getPreferencesDir方法等着要去锁一个id为0x0cfeaaf2的Object类型的对象，但是被该死的tid=24的线程抢占了！让我来看看是谁，于是我们可以直接在traces文件里全局搜索0x0cfeaaf2或者tid=24这些字符串，锁定到如下日志：<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="string">"PackageProcessor"</span> daemon prio=<span class="number">5</span> tid=<span class="number">24</span> Native</span><br><span class="line">group=<span class="string">"main"</span> sCount=<span class="number">1</span> dsCount=<span class="number">0</span> obj=<span class="number">0</span>x32c06af0 self=<span class="number">0</span>x7fb0f36400</span><br><span class="line">...</span><br><span class="line">native: #<span class="number">06</span> pc <span class="number">0000000000862</span>c18 /system/framework/arm64/boot-framework<span class="selector-class">.oat</span> (Java_android_os_BinderProxy_transactNative__ILandroid_os_Parcel_2Landroid_os_Parcel_2I+<span class="number">196</span>)</span><br><span class="line">at android<span class="selector-class">.os</span><span class="selector-class">.BinderProxy</span>.transactNative(Native method)</span><br><span class="line">at android<span class="selector-class">.os</span><span class="selector-class">.BinderProxy</span>.transact(Binder<span class="selector-class">.java</span>:<span class="number">620</span>)</span><br><span class="line">at android<span class="selector-class">.os</span><span class="selector-class">.storage</span>.IMountService<span class="variable">$Stub</span><span class="variable">$Proxy</span>.mkdirs(IMountService<span class="selector-class">.java</span>:<span class="number">870</span>)</span><br><span class="line">at android<span class="selector-class">.app</span><span class="selector-class">.ContextImpl</span>.ensureExternalDirsExistOrFilter(ContextImpl<span class="selector-class">.java</span>:<span class="number">2228</span>)</span><br><span class="line">at android<span class="selector-class">.app</span><span class="selector-class">.ContextImpl</span>.getExternalFilesDirs(ContextImpl<span class="selector-class">.java</span>:<span class="number">586</span>)</span><br><span class="line">- locked &lt;<span class="number">0</span>x0cfeaaf2&gt; (<span class="selector-tag">a</span> java<span class="selector-class">.lang</span>.Object)</span><br><span class="line">at android<span class="selector-class">.app</span><span class="selector-class">.ContextImpl</span>.getExternalFilesDir(ContextImpl<span class="selector-class">.java</span>:<span class="number">569</span>)</span><br><span class="line">at android<span class="selector-class">.content</span><span class="selector-class">.ContextWrapper</span>.getExternalFilesDir(ContextWrapper<span class="selector-class">.java</span>:<span class="number">243</span>)</span><br><span class="line">at com<span class="selector-class">.xxx</span><span class="selector-class">.push</span><span class="selector-class">.log</span><span class="selector-class">.xxx</span>.writeLog2File(xxx<span class="selector-class">.java</span>:<span class="number">100</span>)</span><br><span class="line">...</span><br></pre></td></tr></table></figure></0x0cfeaaf2></p>
<p>这里很明显就看到了 locked <0x0cfeaaf2> (a java.lang.Object) ，某个和推送服务相关的writeLog2File方法调用了getExternalFilesDirs，然后此方法进一步锁住了 0x0cfeaaf2 对象，没错，这个对象和刚才主线程等待要锁的对象是同一个。<br>所以主线程被tid=24的线程阻塞了，因为两个线程需要同一把对象锁，tid=24线程一直占着茅坑，导致死锁，ANR就这么爆出来了</0x0cfeaaf2></p>
<h4 id="了解Context"><a href="#了解Context" class="headerlink" title="了解Context"></a>了解Context</h4><p>Context是一个抽象类，ContextImpl是Context的实现类（具体一些继承关系可参考Context都没弄明白，还怎么做Android开发？，某大佬写的，比较全面）。<br>那么，上面的ANR我们重点关注的对象0x0cfeaaf2到底是谁呢？根据这一行：<br>at android.app.ContextImpl.getPreferencesDir(ContextImpl.java:483)<br>我们直接Read the fucking code，看看ContextImpl中这个方法在干啥：<br><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function">File <span class="title">getPreferencesDir</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mSync) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mPreferencesDir == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mPreferencesDir = <span class="keyword">new</span> File(getDataDir(), <span class="string">"shared_prefs"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> <span class="title">ensurePrivateDirExists</span><span class="params">(mPreferencesDir)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>复制代码可见，这里涉及到shared_prefs文件的IO操作，系统考虑到线程安全，搞了个同步锁，mSync对象被锁住。这个mSync就是我们刚才反复提到的id为0x0cfeaaf2的Object对象，去看看它的实例化就知晓了：<br><figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">Object</span> mSync = <span class="keyword">new</span> <span class="keyword">Object</span>();</span><br></pre></td></tr></table></figure></p>
<p>复制代码private final，两个关键字合体了，说明这个成员是不可变的，而且是私有的，不准继承，即在Context的生命周期内全局只实例化一次，这样才能在加锁的时候保证唯一性。<br>接下来又看刚才tid=24给对象加锁的方法，源码自然也在ContextImpl中：<br><figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line"><span class="keyword">public</span> File[] getExternalFilesDirs(String <span class="class"><span class="keyword">type</span>) &#123;</span></span><br><span class="line">    synchronized (mSync) &#123;</span><br><span class="line">        File[] dirs = Environment.buildExternalStorageAppFilesDirs(getPackageName());</span><br><span class="line">        <span class="keyword">if</span> (<span class="class"><span class="keyword">type</span> !</span>= <span class="keyword">null</span>) &#123;</span><br><span class="line">            dirs = Environment.buildPaths(dirs, <span class="class"><span class="keyword">type</span>);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ensureExternalDirsExistOrFilter(dirs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>经过我反复分析traces文件，发现除了main线程在wait to lock这把锁，还有几个其它的子线程也在等待锁（有一些是访问App本地数据库的，最终调用也在ContextImpl中，和上面分析的两个方法类似）。说明当前这短暂的时间内，需要通过某个Context进行的IO操作太多了，各个线程都排着队要锁mSync，所以耗时操作不可怕，可怕的是一窝蜂全上来。自然就增大了ANR的风险。如果你反复遇到这种ANR，就应该考虑优化了。<br>最终，追溯到方法调用的源头，是在Application初始化时，各种SDK加载，以及一些业务逻辑触发。很显然，它们都是通过getApplicationContext来拿到的同一个Context引用，请求锁的也是同一个mSync对象。</p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>1.调用Context相关的IO操作，不是启个子线程就高枕无忧了，由上面分析，mSync对象锁就这么一把，该阻塞还是阻塞，和是不是主线程无关。<br>2.尽量不要在Application的初始化时刻进行太多的方法调用，尤其是针对ApplicationContext的IO操作。<br>3.在主Activity中延后初始化，用IntentService进行异步操作（因为实例化一个Service就是另一个Context对象了）等都是比较好的优化方案。<br>4.所以为什么有大佬说不要滥用SharedPreference，它的性能并不是很好，从本文分析也可知它直接可能阻塞UI线程，试图寻找其它替代品吧。</p>
<h4 id="详情可见"><a href="#详情可见" class="headerlink" title="详情可见"></a>详情可见</h4><p><a href="https://juejin.im/post/6844904052451442702" target="_blank" rel="noopener">源码茶舍之由一次简单的ANR分析深入了解Context</a></p>
<h3 id="StrickModel的使用"><a href="#StrickModel的使用" class="headerlink" title="StrickModel的使用"></a>StrickModel的使用</h3><p>StrictMode意思为严格模式，是用来检测程序中违例情况的开发者工具。最常用的场景就是检测主线程中本地磁盘和网络读写等耗时的操作</p>
<p>既然叫做严格模式，那么又严格在哪些地方呢？<br>在Android中，主线程，也就是UI线程，除了负责处理UI相关的操作外，还可以执行文件读取或者数据库读写操作（从Android 4.0 开始，网络操作禁止在主线程中执行，否则会抛出NetworkOnMainThreadException）。使用严格模式，系统检测出主线程违例的情况会做出相应的反应，如日志打印，弹出对话框亦或者崩溃等。换言之，严格模式会将应用的违例细节暴露给开发者方便优化与改善。</p>
<h4 id="具体能检测什么"><a href="#具体能检测什么" class="headerlink" title="具体能检测什么"></a>具体能检测什么</h4><p>严格模式主要检测两大问题，一个是线程策略，即TreadPolicy，另一个是VM策略，即VmPolicy。</p>
<h5 id="ThreadPolicy"><a href="#ThreadPolicy" class="headerlink" title="ThreadPolicy"></a>ThreadPolicy</h5><p>线程策略检测的内容有</p>
<p>1.自定义的耗时调用 使用detectCustomSlowCalls()开启<br>2.磁盘读取操作 使用detectDiskReads()开启<br>3.磁盘写入操作 使用detectDiskWrites()开启<br>4.网络操作 使用detectNetwork()开启</p>
<h5 id="VmPolicy"><a href="#VmPolicy" class="headerlink" title="VmPolicy"></a>VmPolicy</h5><p>虚拟机策略检测的内容有</p>
<p>1.Activity泄露 使用detectActivityLeaks()开启<br>2.未关闭的Closable对象泄露 使用detectLeakedClosableObjects()开启<br>3.泄露的Sqlite对象 使用detectLeakedSqlLiteObjects()开启<br>4.检测实例数量 使用setClassInstanceLimit()开启</p>
<p>以下的代码启用全部的ThreadPolicy和VmPolicy违例检测<br><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="params">(IS_DEBUG &amp;&amp; Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.GINGERBREAD)</span> &#123;</span><br><span class="line">    StrictMode.<span class="keyword">set</span>ThreadPolicy<span class="params">(new StrictMode.ThreadPolicy.Builder()</span><span class="string">.detectAll</span><span class="params">()</span><span class="string">.penaltyLog</span><span class="params">()</span><span class="string">.build</span><span class="params">()</span>);</span><br><span class="line">  StrictMode.<span class="keyword">set</span>VmPolicy<span class="params">(new VmPolicy.Builder()</span><span class="string">.detectAll</span><span class="params">()</span><span class="string">.penaltyLog</span><span class="params">()</span><span class="string">.build</span><span class="params">()</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://www.jianshu.com/p/cfa9ed42e379" target="_blank" rel="noopener">如何分析ANR</a><br><a href="https://juejin.im/post/6844904069731975176" target="_blank" rel="noopener">Android进阶知识：ANR的定位与解决</a><br><a href="https://www.jianshu.com/p/30c1a5ad63a3" target="_blank" rel="noopener">Android应用ANR分析</a><br><a href="https://www.jianshu.com/p/fa962a5fd939" target="_blank" rel="noopener">Android ANR问题总结</a><br><a href="https://www.jianshu.com/p/3f64caa567e5?utm_source=desktop&amp;utm_medium=timeline" target="_blank" rel="noopener">SharedPreferences ANR问题分析和解决 &amp; Android 8.0的优化</a><br><a href="https://juejin.im/post/6844904052451442702" target="_blank" rel="noopener">源码茶舍之由一次简单的ANR分析深入了解Context</a><br><a href="https://www.jianshu.com/p/9ae0f6842689" target="_blank" rel="noopener">剖析 SharedPreference apply 引起的 ANR 问题</a><br><a href="https://www.jianshu.com/p/a7f9f5cdf6f3" target="_blank" rel="noopener">ViewPager anr，页面空白问题完全解析</a><br><a href="https://juejin.im/post/6844903715313303565" target="_blank" rel="noopener">Android ANR日志分析指南</a><br><a href="https://www.jianshu.com/p/8964812972be" target="_blank" rel="noopener">如何分析ANR Log的总结</a><br><a href="https://droidyue.com/blog/2015/09/26/android-tuning-tool-strictmode/" target="_blank" rel="noopener">Android性能调优利器StrictMode</a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>组件化相关总结</title>
    <url>/blog/2020/08/component-sum-up.html</url>
    <content><![CDATA[<p>组件化相关总结</p>
<h3 id="什么是组件化"><a href="#什么是组件化" class="headerlink" title="什么是组件化"></a>什么是组件化</h3><p>组件化，就是把APP拆分成不同功能模块，形成独立组件，让宿主调用。 组件化不一定是插件化，组件化是一个更大的概念：把模块解耦，组件之间代码不依赖，宿主可以依赖组件；而插件化则具体到了技术点上，宿主通过 动态加载 来调用组件，宿主不依赖组件，达到 完全解耦 的目的（比如图片缓存就可以看成一个组件被多个 App 共用）。</p>
<p>适合于项目大 但是功能相对集中。比如 一个金融类的App 里面只包含金融的功能，金融功能又会有 借贷，理财，线下交易，把这些模块抽成单独的组件<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog4/p6.webp" alt></p>
<h4 id="组件化与插件化对比"><a href="#组件化与插件化对比" class="headerlink" title="组件化与插件化对比"></a>组件化与插件化对比</h4><p>Android程序每次更新都要下载一个完整的apk，而很多时候软件只是更新了一个小功能而已，这样的话，就显得很麻烦。如果把android程序做成主程序+插件化的形式呢，这样才利于小功能的扩展（比如一般 App 的皮肤样式就可以看成一个插件）</p>
<p>主要原理是：主要利用 Java ClassLoader 的原理，如 Android 的 DexClassLoader，可动态加载的内容包括 apk、dex、jar 等。如下<br>插件化的优势：</p>
<p>1.适应并行开发，解耦各个模块，避免模块之间的交叉依赖，加快编译速度，从而提高并行开发效率。<br>2.满足产品随时上线的需求<br>3.修复因为我们对自己要求不严格而写出来的 bug。<br>4.插件化的结果：分为稳定的 release 版本和不稳定的 snapshot 版本，每个模块都高度解耦，没有交叉依赖，不会出现一个模块依赖了另一个模块，其中一个人改了这个模块的代码，对另一个模块造成影响。</p>
<p>适合于项目超级大 但是功能相对不集中。比如 一个支付宝App 里面即包含共享单车 也包含 电影票。这种与本业务完全不同的 可以做成插件的形式</p>
<h3 id="什么是APT"><a href="#什么是APT" class="headerlink" title="什么是APT"></a>什么是APT</h3><p> APT是Annotation Processing Tool的简称,即注解处理工具。它是在编译期对代码中指定的注解进行解析，然后做一些其他处理（如通过javapoet生成新的Java文件）。我们常用的ButterKnife，其原理就是通过注解处理器在编译期扫描代码中加入的@BindView、@OnClick等注解进行扫描处理，然后生成XXX_ViewBinding类，实现了view的绑定。</p>
<h4 id="JavaPoet详解"><a href="#JavaPoet详解" class="headerlink" title="JavaPoet详解"></a>JavaPoet详解</h4><p>(1）JavaPoet是一款可以自动生成Java文件的第三方依赖<br>(2）简洁易懂的API，上手快<br>(3）让繁杂、重复的Java文件，自动化生成，提高工作效率，简化流程<br>(4) 相比原始APT方法，JavaPoet是OOP的</p>
<h3 id="ARoter框架的基本原理"><a href="#ARoter框架的基本原理" class="headerlink" title="ARoter框架的基本原理"></a>ARoter框架的基本原理</h3><p>####　为什么需要ARouter<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog4/p6.webp" alt><br>在组件化中，为了业务逻辑的彻底解耦，同时也为了每个module都可以方便的单独运行和调试，上层的各个module不会进行相互依赖(只有在正式联调的时候才会让app壳module去依赖上层的其他组件module)，而是共同依赖于base module，base module中会依赖一些公共的第三方库和其他配置。那么在上层的各个module中，如何进行通信呢？</p>
<p>我们知道，传统的Activity之间通信，通过startActivity(intent)，而在组件化的项目中，上层的module没有依赖关系(即便两个module有依赖关系，也只能是单向的依赖)，那么假如login module中的一个Activity需要启动pay_module中的一个Activity便不能通过startActivity来进行跳转。那么大家想一下还有什么其他办法呢？ 可能有同学会想到隐式跳转，这当然也是一种解决方法，但是一个项目中不可能所有的跳转都是隐式的，这样Manifest文件会有很多过滤配置，而且非常不利于后期维护。当然你用反射也可以实现跳转，但是第一：大量的使用反射跳转对性能会有影响，第二：你需要拿到Activity的类文件，在组件开发的时候，想拿到其他module的类文件是很麻烦的</p>
<p>在组件化中，我们通常都会在base_module上层再依赖一个router_module,而这个router_module就是负责各个模块之间服务暴露和页面跳转的。<br>用过ARouter路由框架的同学应该都知道，在每个需要对其他module提供调用的Activity中，都会声明类似下面@Route注解，我们称之为路由地址</p>
<p>那么这个注解有什么用呢，路由框架会在项目的编译器扫描所有添加@Route注解的Activity类，然后将route注解中的path地址和Activity.class文件一一对应保存，如直接保存在map中。为了让大家理解，我这里来使用近乎伪代码给大家简单演示一下。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//项目编译后通过apt生成如下方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HashMap&lt;String, ClassBean&gt; <span class="title">routeInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HashMap&lt;String, ClassBean&gt; route = <span class="keyword">new</span> HashMap&lt;String, ClassBean&gt;();</span><br><span class="line">    route.put(<span class="string">"/main/main"</span>, MainActivity<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    route.put(<span class="string">"/module1/module1main"</span>, Module1MainActivity<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    route.put(<span class="string">"/login/login"</span>, LoginActivity<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样我们想在app模块的MainActivity跳转到login模块的LoginActivity，那么便只需调用如下：<br><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不同模块之间启动Activity</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">(<span class="keyword">String</span> name, <span class="keyword">String</span> password)</span> </span>&#123;</span><br><span class="line">    HashMap&lt;<span class="keyword">String</span>, ClassBean&gt; route = routeInfo();</span><br><span class="line">    LoginActivity<span class="class">.<span class="keyword">class</span> <span class="title">classBean</span> = <span class="title">route</span>.<span class="title">get</span>("/<span class="title">login</span>/<span class="title">login</span>");</span></span><br><span class="line">    Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, classBean);</span><br><span class="line">    intent.putExtra(<span class="string">"name"</span>, name);</span><br><span class="line">    intent.putExtra(<span class="string">"password"</span>, password);</span><br><span class="line">    startActivity(intent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>用过ARouter的同学应该知道，用ARouter启动Activity应该是下面这个写法<br><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2. Jump with parameters</span></span><br><span class="line"><span class="selector-tag">ARouter</span><span class="selector-class">.getInstance</span>()<span class="selector-class">.build</span>(<span class="string">"/test/login"</span>)</span><br><span class="line">			<span class="selector-class">.withString</span>(<span class="string">"password"</span>, <span class="number">666666</span>)</span><br><span class="line">			<span class="selector-class">.withString</span>(<span class="string">"name"</span>, <span class="string">"小三"</span>)</span><br><span class="line">			<span class="selector-class">.navigation</span>();</span><br></pre></td></tr></table></figure></p>
<p>那么ARouter背后的原理是怎么样的呢？实际上它的核心思想跟上面讲解的是一样的，我们在代码里加入的@Route注解，会在编译时期通过apt生成一些存储path和activityClass映射关系的类文件，然后app进程启动的时候会拿到这些类文件，把保存这些映射关系的数据读到内存里(保存在map里)，然后在进行路由跳转的时候，通过build()方法传入要到达页面的路由地址，ARouter会通过它自己存储的路由表找到路由地址对应的Activity.class(activity.class = map.get(path))，然后new Intent()，当调用ARouter的withString()方法它的内部会调用intent.putExtra(String name, String value)，调用navigation()方法，它的内部会调用startActivity(intent)进行跳转，这样便可以实现两个相互没有依赖的module顺利的启动对方的Activity了。</p>
<h4 id="ARouter生成与加载文件的具体细节"><a href="#ARouter生成与加载文件的具体细节" class="headerlink" title="ARouter生成与加载文件的具体细节"></a>ARouter生成与加载文件的具体细节</h4><p>详细过程可见：<a href="https://juejin.im/post/6844903648690962446#heading-3" target="_blank" rel="noopener">https://juejin.im/post/6844903648690962446#heading-3</a><br>下面只简述大概过程<br>1.通过JavaPoet解析注解，获得注解信息和对应的类节点信息，并将这些信息写入生成的文件中，存储在hashMap中<br>2.路由框架初始化<br>要实现路由框架，需要在用户跳转之前将这些路由映射关系拿到手。拿到这些路由信息最好的时机就是在应用初始化的时候。<br>在程序启动的时候，扫描生成的类文件，获取至映射关系信息，保存起来。<br>3.路由跳转<br>获取到对应的映射关系后，就可以根据Route路径来实现跳转<br>如以所示<br><figure class="highlight gams"><table><tr><td class="code"><pre><span class="line">ARouter<span class="symbol">$</span><span class="symbol">$</span>Group<span class="symbol">$</span><span class="symbol">$</span>personal group<span class="symbol">$</span><span class="symbol">$</span>personal = new ARouter<span class="symbol">$</span><span class="symbol">$</span>Group<span class="symbol">$</span><span class="symbol">$</span>personal();</span><br><span class="line">        Map&lt;String, Class&lt;? extends ARouterPath&gt;&gt; groupMap = group<span class="symbol">$</span><span class="symbol">$</span>personal.getGroupMap();</span><br><span class="line">        Class&lt;? extends ARouterPath&gt; myClass = groupMap.get(<span class="string">"personal"</span>);</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            ARouter<span class="symbol">$</span><span class="symbol">$</span>Path<span class="symbol">$</span><span class="symbol">$</span>personal path = (ARouter<span class="symbol">$</span><span class="symbol">$</span>Path<span class="symbol">$</span><span class="symbol">$</span>personal) myClass.newInstance();</span><br><span class="line">            Map&lt;String, RouterBean&gt; pathMap = path.getPathMap();</span><br><span class="line">            RouterBean bean = pathMap.get(<span class="string">"/personal/Personal_MainActivity"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (bean != null) &#123;</span><br><span class="line">                Intent intent = new Intent(this, bean.getMyClass());</span><br><span class="line">                startActivity(intent);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="ARouter优缺点"><a href="#ARouter优缺点" class="headerlink" title="ARouter优缺点"></a>ARouter优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>1.使用注解APT实现，使用方便，耦合较低<br>2.编译期间处理注解并生成文件，没有使用反射，没有性能损耗<br>3.支持多模块使用，支持组件化<br>4.支持失败降级，支持路由拦截</p>
<h3 id="组件间通信的方法"><a href="#组件间通信的方法" class="headerlink" title="组件间通信的方法"></a>组件间通信的方法</h3><p>1.第一种组件之间的页面跳转实现简单，跳转时想传递不同类型的数据提供有相应的 API即可<br>2.第二种组件之间的自定义类和自定义方法的调用要稍微复杂点，需要 ARouter 配合架构中的 公共服务(CommonService) 实现：<br>提供服务的业务模块：<br>在公共服务(CommonService) 中声明 Service 接口 (含有需要被调用的自定义方法), 然后在自己的模块中实现这个 Service 接口, 再通过 ARouter API 暴露实现类。<br>使用服务的业务模块：<br>通过 ARouter 的 API 拿到这个 Service 接口(多态持有, 实际持有实现类), 即可调用 Service 接口中声明的自定义方法, 这样就可以达到模块之间的交互。<br>3.使用RxBus进行消息通信</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://juejin.im/post/6844904147712475149" target="_blank" rel="noopener">组件化相关面试题</a><br><a href="https://juejin.im/post/6844903648690962446#heading-0" target="_blank" rel="noopener">ARouter原理剖析及手动实现ARouter原理剖析及手动实现</a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Glide源码解析</title>
    <url>/blog/2020/08/glide-source-sum.html</url>
    <content><![CDATA[<h3 id="Glide加载流程"><a href="#Glide加载流程" class="headerlink" title="Glide加载流程"></a>Glide加载流程</h3><p><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog5/p8.png" alt></p>
<p><strong>时序图</strong><br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog5/p9.png" alt></p>
<h3 id="Glide的主要优点"><a href="#Glide的主要优点" class="headerlink" title="Glide的主要优点"></a>Glide的主要优点</h3><p>1.高度封装，使得了外观模式，使用优雅<br>2.多种图片格式的缓存，适用于更多的内容表现形式（如Gif、WebP、缩略图、Video）<br>3.生命周期集成（根据Activity或者Fragment的生命周期管理图片加载请求）<br>4.高效处理Bitmap（bitmap的复用和主动回收，减少系统回收压力）<br>5.高效的缓存策略，灵活（Picasso只会缓存原始尺寸的图片，Glide缓存的是多种规格），加载速度快且内存开销小（默认Bitmap格式的不同，使得内存开销是Picasso的一半）</p>
<h3 id="来简单介绍下Glide的缓存"><a href="#来简单介绍下Glide的缓存" class="headerlink" title="来简单介绍下Glide的缓存"></a>来简单介绍下Glide的缓存</h3><p>Glide的缓存机制，主要分为2种缓存，一种是内存缓存，一种是磁盘缓存。<br>之所以使用内存缓存的原因是：防止应用重复将图片读入到内存，造成内存资源浪费。<br>之所以使用磁盘缓存的原因是：防止应用重复的从网络或者其他地方下载和读取数据。<br>正式因为有着这两种缓存的结合，才构成了Glide极佳的缓存效果。<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog5/p10.png" alt></p>
<p><strong>读取一张图片的时候，获取顺序</strong><br>弱引用缓存-》Lru算法缓存-》磁盘缓存（如果设置了的话）</p>
<p>当我们的APP中想要加载某张图片时，先去WeakReference中去取，如果取到则返回，同时acquire+1，如果没取到则到LRUCache中去取，如果取到了则返回，并将值从LRU中删除，添加至WeakReference中<br>，如果LRU中没有，则从网络磁盘中获取对应图片</p>
<p><strong>将图片缓存的时候，写入顺序</strong><br>磁盘缓存中=&gt;弱引用缓存-》Lru算法缓存<br>当图片不存在的时候，先从网络下载图片,然后将图片存入磁盘缓存中，然后将图片存入弱引用中，glide会采用一个acquired（int）变量用来记录图片被引用的次数，<br>当acquired变量大于0的时候，说明图片正在使用中，也就是将图片放到弱引用缓存当中；<br>如果acquired变量等于0了，说明图片已经不再被使用了，那么此时会调用方法来释放资源，首先会将缓存图片从弱引用中移除，然后再将它put到LruResourceCache当中。<br>这样也就实现了正在使用中的图片使用弱引用来进行缓存，不在使用中的图片使用LruCache来进行缓存的功能</p>
<p><strong>为什么使用弱引用</strong><br>1.这样可以保护当前使用的资源不会被 LruCache 算法回收<br>2.使用弱引用，即可以缓存正在使用的强引用资源，又不阻碍系统需要回收的无引用资源。</p>
<h3 id="Glide加载一个一兆的图片（100-100），是否会压缩后再加载，放到一个300-300的view上会怎样，800-800呢，图片会很模糊，怎么处理？"><a href="#Glide加载一个一兆的图片（100-100），是否会压缩后再加载，放到一个300-300的view上会怎样，800-800呢，图片会很模糊，怎么处理？" class="headerlink" title="Glide加载一个一兆的图片（100  100），是否会压缩后再加载，放到一个300  300的view上会怎样，800*800呢，图片会很模糊，怎么处理？"></a>Glide加载一个一兆的图片（100 <em> 100），是否会压缩后再加载，放到一个300 </em> 300的view上会怎样，800*800呢，图片会很模糊，怎么处理？</h3><p>当我们调整imageview的大小时，Picasso会不管imageview大小是什么，总是直接缓存整张图片，而Glide就不一样了，它会为每个不同尺寸的Imageview缓存一张图片，也就是说不管你的这张图片有没有加载过，只要imageview的尺寸不一样，那么Glide就会重新加载一次，这时候，它会在加载的imageview之前从网络上重新下载，然后再缓存。</p>
<p>举个例子，如果一个页面的imageview是300 <em> 300像素，而另一个页面中的imageview是100 </em> 100像素，这时候想要让两个imageview像是同一张图片，那么Glide需要下载两次图片，并且缓存两张图片。<br><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;R&gt; <span class="function">LoadStatus <span class="title">load</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据请求参数得到缓存的键</span></span><br><span class="line">    EngineKey key = keyFactory.buildKey(model, signature, <span class="built_in">width</span>, <span class="built_in">height</span>, transformations,</span><br><span class="line">        resourceClass, transcodeClass, options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>看到了吧，缓存Key的生成条件之一就是控件的长宽。</p>
<h3 id="简单说一下内存泄漏的场景，如果在一个页面中使用Glide加载了一张图片，图片正在获取中，如果突然关闭页面，这个页面会造成内存泄漏吗？"><a href="#简单说一下内存泄漏的场景，如果在一个页面中使用Glide加载了一张图片，图片正在获取中，如果突然关闭页面，这个页面会造成内存泄漏吗？" class="headerlink" title="简单说一下内存泄漏的场景，如果在一个页面中使用Glide加载了一张图片，图片正在获取中，如果突然关闭页面，这个页面会造成内存泄漏吗？"></a>简单说一下内存泄漏的场景，如果在一个页面中使用Glide加载了一张图片，图片正在获取中，如果突然关闭页面，这个页面会造成内存泄漏吗？</h3><p>因为Glide 在加载资源的时候，如果是在 Activity、Fragment 这一类有生命周期的组件上进行的话，会创建一个透明的 RequestManagerFragment 加入到FragmentManager 之中，感知生命周期，当 Activity、Fragment 等组件进入不可见，或者已经销毁的时候，Glide 会停止加载资源。</p>
<p>但是如果，是在非生命周期的组件上进行时，会采用Application 的生命周期贯穿整个应用，所以 applicationManager 只有在应用程序关闭的时候终止加载。</p>
<h3 id="假如让你自己写个图片加载框架，你会考虑哪些问题"><a href="#假如让你自己写个图片加载框架，你会考虑哪些问题" class="headerlink" title="假如让你自己写个图片加载框架，你会考虑哪些问题"></a>假如让你自己写个图片加载框架，你会考虑哪些问题</h3><p>概括来说，图片加载包含封装，解析，下载，解码，变换，缓存，显示等操作。<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog5/p11.png" alt><br>1.封装参数：从指定来源，到输出结果，中间可能经历很多流程，所以第一件事就是封装参数，这些参数会贯穿整个过程；<br>2.解析路径：图片的来源有多种，格式也不尽相同，需要规范化；<br>3.读取缓存：为了减少计算，通常都会做缓存；同样的请求，从缓存中取图片（Bitmap）即可；<br>4.查找文件/下载文件：如果是本地的文件，直接解码即可；如果是网络图片，需要先下载；<br>5.解码：这一步是整个过程中最复杂的步骤之一，有不少细节；<br>6.变换：解码出Bitmap之后，可能还需要做一些变换处理（圆角，滤镜等）；<br>7.缓存：得到最终bitmap之后，可以缓存起来，以便下次请求时直接取结果；<br>8.显示：显示结果，可能需要做些动画（淡入动画，crossFade等）。</p>
<h3 id="Glide中的设计模式"><a href="#Glide中的设计模式" class="headerlink" title="Glide中的设计模式"></a>Glide中的设计模式</h3><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://juejin.im/post/6844903986412126216" target="_blank" rel="noopener">面试官：简历上最好不要写Glide，不是问源码那么简单</a><br><a href="https://blog.csdn.net/u010302765/article/details/103193470" target="_blank" rel="noopener">聊一聊关于Glide在面试中的那些事</a><br><a href="https://www.jianshu.com/p/d5c53d0e1770" target="_blank" rel="noopener">对着那Glide最新版本就是一顿暴讲 3（问题总结篇，持续更新）</a><br><a href="https://blog.csdn.net/u011418943/article/details/107026881" target="_blank" rel="noopener">Glide 缓存机制解析(为啥使用弱引用)</a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义PhotoView实现</title>
    <url>/blog/2020/08/custom-photo-view.html</url>
    <content><![CDATA[<p>我们要实现的效果是显示一张图片，然后对其进行双击放大缩小，滑动，双指放大缩小。</p>
<h3 id="1-绘制图片到屏幕中间"><a href="#1-绘制图片到屏幕中间" class="headerlink" title="1.绘制图片到屏幕中间"></a>1.绘制图片到屏幕中间</h3><p>首先我们需要将图片绘制到屏幕的中间<br><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">void</span> <span class="title">onSizeChanged</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">int</span> oldw, <span class="keyword">int</span> oldh)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onSizeChanged(w, h, oldw, oldh);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 求原始偏移量，为了让图片居中</span></span><br><span class="line">    originalOffsetX = ( getWidth() - bitmap.getWidth()) / <span class="number">2</span>f;</span><br><span class="line">    originalOffsetY = ( getHeight() - bitmap.getHeight()) / <span class="number">2</span>f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onDraw(canvas);</span><br><span class="line">    <span class="comment">// 绘制图片居中</span></span><br><span class="line">    canvas.drawBitmap(bitmap, originalOffsetX, originalOffsetY, paint);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="2-缩放和比例计算"><a href="#2-缩放和比例计算" class="headerlink" title="2.缩放和比例计算"></a>2.缩放和比例计算</h3><p>第二步，我们需要根据图片的长宽比与屏幕的长宽比，计算出图片的缩放比例<br><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">void</span> <span class="title">onSizeChanged</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">int</span> oldw, <span class="keyword">int</span> oldh)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onSizeChanged(w, h, oldw, oldh);</span><br><span class="line">	</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// if命中：宽为全屏时为小缩放</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">float</span>) bitmap.getWidth() / bitmap.getHeight() &gt; (<span class="keyword">float</span>) getWidth() / getHeight()) &#123;</span><br><span class="line">        <span class="comment">// 放大后一边全屏，一边留白叫小缩放</span></span><br><span class="line">        smallScale = (<span class="keyword">float</span>) getWidth() / bitmap.getWidth();</span><br><span class="line">        <span class="comment">// 放大后一边全屏，一边超出界面叫大缩放</span></span><br><span class="line">        bigScale = (<span class="keyword">float</span>) getHeight() / bitmap.getHeight() * OVER_SCALE_FACTOR;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        smallScale = (<span class="keyword">float</span>) getHeight() / bitmap.getHeight();</span><br><span class="line">        bigScale = (<span class="keyword">float</span>) getWidth() / bitmap.getWidth() * OVER_SCALE_FACTOR;</span><br><span class="line">    &#125;</span><br><span class="line">    currentScale = smallScale;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onDraw(canvas);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缩放图片</span></span><br><span class="line">    canvas.scale(currentScale, currentScale, getWidth() / <span class="number">2</span>f, getHeight() / <span class="number">2</span>f);</span><br><span class="line">    <span class="comment">// 绘制图片居中</span></span><br><span class="line">    canvas.drawBitmap(bitmap, originalOffsetX, originalOffsetY, paint);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3-手势处理"><a href="#3-手势处理" class="headerlink" title="3.手势处理"></a>3.手势处理</h3><p>接下来需要处理点击，滑动，双指缩放等情况下的手势</p>
<h4 id="OnDoubleTapListener"><a href="#OnDoubleTapListener" class="headerlink" title="OnDoubleTapListener"></a>OnDoubleTapListener</h4><p>300ms内点击两次才算双击。</p>
<p><strong>1.onSingleTapConfirmed–仅单击</strong><br>单击事件为什么不直接用onClick方法？</p>
<ol>
<li>onClickListener中的onClick方法与该方法冲突</li>
<li>用onClick方法，不管单击还是双击都会触发（双击就触发两次）</li>
</ol>
<p>单击按下时触发，双击时不会触发。</p>
<p><strong>2.onDoubleTap–双击</strong><br>// 发生双击时通知<br>boolean onDoubleTap(MotionEvent e);<br>双击第二次点击按下时发生回调。</p>
<p><strong>3.onDoubleTapEvent–双击手势事件</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在双击手势中发生事件时通知，包括按下、移动和抬起事件</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">onDoubleTapEvent</span><span class="params">(MotionEvent e)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>双击第二次点击时的按下，移动和抬起事件都会回调。</p>
<p><strong>4.注意点</strong><br>双击必须设置监听，要么自己调用方法<code>setOnDoubleTapListener</code>设置，要么系统帮忙调用。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果参数 listener属于 OnDoubleTapListener的对象则系统帮忙创建</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">GestureDetector</span><span class="params">(Context context, OnGestureListener listener, Handler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (listener <span class="keyword">instanceof</span> OnDoubleTapListener) &#123;</span><br><span class="line">        setOnDoubleTapListener((OnDoubleTapListener) listener);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>所以我们一般直接继承SimpleOnGestureListener，这样系统就会为我们调用双击监听方法</p>
<h4 id="onGestureListener"><a href="#onGestureListener" class="headerlink" title="onGestureListener"></a>onGestureListener</h4><p>可以重写其中的各种方法（单击事件、双击事件等等），就可以监听到单击、双击、滑动等事件，然后直接在回调方法中处理即可。</p>
<p><strong>1.onDown–按下</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 按下</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">onDown</span><span class="params">(MotionEvent e)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p><strong>2.onShowPress–触摸反馈</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 触摸反馈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onShowPress</span><span class="params">(MotionEvent e)</span></span>;</span><br></pre></td></tr></table></figure>
<p>它是在 View 被点击（按下）时调用，其作用是给用户一个视觉反馈，让用户知道我这个控件被点击了，这样的效果我们也可以用 Material design 的 ripple 实现，或者直接 drawable 写个背景也行。</p>
<p>它是一种延时回调，延迟时间是 100 ms。也就是说用户手指按下后，如果立即抬起或者事件立即被拦截，时间没有超过 100 ms的话，这条消息会被 remove 掉，也就不会触发这个回调。</p>
<p><strong>3.onSingleTapUp–单击抬起</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单击抬起</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">onSingleTapUp</span><span class="params">(MotionEvent e)</span></span>;</span><br></pre></td></tr></table></figure>
<p>单击抬起时触发，且只在双击的第一次抬起时触发。（连续点击三次，则会触发两次）</p>
<p><strong>4.onScroll–移动</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 手指按下后移动，类似 move事件</span></span><br><span class="line"><span class="comment">// e1：手指按下时的 MotionEvent</span></span><br><span class="line"><span class="comment">// e2：手指当前的 MotionEvent</span></span><br><span class="line"><span class="comment">// distanceX：在X轴上划过的距离 --- 旧位置 减去 新位置</span></span><br><span class="line"><span class="comment">// distanceY：在Y轴上划过的距离</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">onScroll</span><span class="params">(MotionEvent e1, MotionEvent e2, <span class="keyword">float</span> distanceX, <span class="keyword">float</span> distanceY)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>5.onLongPress–长按</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 长按事件回调</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onLongPress</span><span class="params">(MotionEvent e)</span></span>;</span><br></pre></td></tr></table></figure>
<p>取消长按响应</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">GestureDetector.setIsLongpressEnabled(<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure>
<p><strong>6.onFling–抛掷</strong></p>
<p>处理惯性滑动。最小滑动速度50dip/s（dp=dip）。最大8000dp/s。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抛掷（惯性滑动）</span></span><br><span class="line"><span class="comment">// e1：手指按下时的 MotionEvent，可以知道按下位置等</span></span><br><span class="line"><span class="comment">// e2：手指当前的 MotionEvent</span></span><br><span class="line"><span class="comment">// velocityX：在X轴上的运动速度（像素/秒）</span></span><br><span class="line"><span class="comment">// velocityY：在Y轴上的运动速度（像素/秒）</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">onFling</span><span class="params">(MotionEvent e1, MotionEvent e2, <span class="keyword">float</span> velocityX, <span class="keyword">float</span> velocityY)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>SimpleOnGestureListener</strong><br>实现了OnGestureListener, OnDoubleTapListener, OnContextClickListener这三个接口，并重写了接口的方法。所以我们可以 new 一个 SimpleOnGestureListener 对象，这样就不用重写接口的所有方法，而只写自己需要的方法即可。</p>
<h3 id="双击缩放实现"><a href="#双击缩放实现" class="headerlink" title="双击缩放实现"></a>双击缩放实现</h3><p>实现双击缩放<br><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建 GestureDetector对象</span></span><br><span class="line">gestureDetector = <span class="keyword">new</span> <span class="type">GestureDetector</span>(context, <span class="keyword">new</span> <span class="type">PhotoGestureListener</span>());</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PhotoGestureListener</span> <span class="keyword">extends</span> <span class="title">GestureDetector</span>.<span class="title">SimpleOnGestureListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 必须为true才表示消费事件</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public boolean onDown(<span class="type">MotionEvent</span> e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 双击处理缩放</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public boolean onDoubleTap(<span class="type">MotionEvent</span> e) &#123;</span><br><span class="line">        isEnlarge = !isEnlarge;</span><br><span class="line">        <span class="keyword">if</span> (isEnlarge) &#123;</span><br><span class="line">            currentScale = bigScale;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            currentScale = smallScale;</span><br><span class="line">        &#125;</span><br><span class="line">        invalidate();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onDoubleTap(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>必须重写onTouchEvent，因为GestureDetector里面自己重写了事件处理<br><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">return</span> gestureDetector.<span class="title">onTouchEvent</span><span class="params">(event)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="缩放效果更平滑"><a href="#缩放效果更平滑" class="headerlink" title="缩放效果更平滑"></a>缩放效果更平滑</h4><p>通过属性动画使缩放效果更平滑<br><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function">ObjectAnimator <span class="title">getScaleAnimator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (scaleAnimator == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// values必须要有，否则运行时报错</span></span><br><span class="line">        scaleAnimator = ObjectAnimator.ofFloat(<span class="keyword">this</span>,</span><br><span class="line">                <span class="string">"currentScale"</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    scaleAnimator.setFloatValues(smallScale, bigScale);</span><br><span class="line">    <span class="keyword">return</span> scaleAnimator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">float</span> <span class="title">getCurrentScale</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> currentScale;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">setCurrentScale</span><span class="params">(<span class="keyword">float</span> currentScale)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.currentScale = currentScale;</span><br><span class="line">    <span class="comment">// 属性动画变化是刷新界面</span></span><br><span class="line">    invalidate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">onDoubleTap</span><span class="params">(MotionEvent e)</span> </span>&#123;</span><br><span class="line">    isEnlarge = !isEnlarge;</span><br><span class="line">    <span class="keyword">if</span> (isEnlarge) &#123;</span><br><span class="line">        getScaleAnimator().start();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        getScaleAnimator().reverse();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">return</span> <span class="keyword">super</span>.<span class="title">onDoubleTap</span><span class="params">(e)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="手指滑动"><a href="#手指滑动" class="headerlink" title="手指滑动"></a>手指滑动</h3><p>在图片超出屏幕时，随着屏幕滑动图片<br><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">canvas.translate(offsetX, offsetY);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onScroll</span><span class="params">(MotionEvent e1, MotionEvent e2, <span class="keyword">float</span> distanceX, <span class="keyword">float</span> distanceY)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEnlarge) &#123;</span><br><span class="line">        offsetX -= distanceX;</span><br><span class="line">        offsetY -= distanceY;</span><br><span class="line">        <span class="comment">// 处理边界问题</span></span><br><span class="line">        fixOffsets();</span><br><span class="line">        invalidate();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> super.onScroll(e1, e2, distanceX, distanceY);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fixOffsets</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    offsetX = Math.<span class="built_in">min</span>(offsetX, (bitmap.getWidth() * bigScale - getWidth()) / <span class="number">2</span>);</span><br><span class="line">    offsetX = Math.<span class="built_in">max</span>(offsetX, -(bitmap.getWidth() * bigScale - getWidth()) / <span class="number">2</span>);</span><br><span class="line">    offsetY = Math.<span class="built_in">min</span>(offsetY, (bitmap.getHeight() * bigScale - getHeight()) / <span class="number">2</span>);</span><br><span class="line">    offsetY = Math.<span class="built_in">max</span>(offsetY, -(bitmap.getHeight() * bigScale - getHeight()) / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="惯性滑动"><a href="#惯性滑动" class="headerlink" title="惯性滑动"></a>惯性滑动</h3><p>在较快滑动时，当手指离开屏幕时，还会有惯性滑动<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onFling</span><span class="params">(MotionEvent down, MotionEvent event, <span class="keyword">float</span> velocityX, <span class="keyword">float</span> velocityY)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEnlarge) &#123;</span><br><span class="line">        overScroller.fling((<span class="keyword">int</span>) offsetX, (<span class="keyword">int</span>) offsetY, (<span class="keyword">int</span>) velocityX, (<span class="keyword">int</span>) velocityY,</span><br><span class="line">                -(<span class="keyword">int</span>) (bitmap.getWidth() * bigScale - getWidth()) / <span class="number">2</span>,</span><br><span class="line">                (<span class="keyword">int</span>) (bitmap.getWidth() * bigScale - getWidth()) / <span class="number">2</span>,</span><br><span class="line">                -(<span class="keyword">int</span>) (bitmap.getHeight() * bigScale - getHeight()) / <span class="number">2</span>,</span><br><span class="line">                (<span class="keyword">int</span>) (bitmap.getHeight() * bigScale - getHeight()) / <span class="number">2</span>);</span><br><span class="line">        postOnAnimation(flingRunner);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlingRunner</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 动画还在执行，返回true</span></span><br><span class="line">            <span class="keyword">if</span> (overScroller.computeScrollOffset()) &#123;</span><br><span class="line">                offsetX = overScroller.getCurrX();</span><br><span class="line">                offsetY = overScroller.getCurrY();</span><br><span class="line">                invalidate();</span><br><span class="line">                postOnAnimation(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="双指缩放-–-ScaleGestureDetector"><a href="#双指缩放-–-ScaleGestureDetector" class="headerlink" title="双指缩放 – ScaleGestureDetector"></a>双指缩放 – ScaleGestureDetector</h3><p>接下来还需要实现ScaleGestureDetector,实现双指缩放图片</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">scaleGestureListener = <span class="keyword">new</span> PhotoScaleGestureListener();</span><br><span class="line">scaleGestureDetector = <span class="keyword">new</span> ScaleGestureDetector(context, scaleGestureListener);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 双指缩放操作优先处理事件</span></span><br><span class="line">    <span class="keyword">boolean</span> result = scaleGestureDetector.onTouchEvent(event);</span><br><span class="line">    <span class="comment">// 如果不是双指缩放才处理手势事件</span></span><br><span class="line">    <span class="keyword">if</span> (!scaleGestureDetector.isInProgress()) &#123;</span><br><span class="line">        result = gestureDetector.onTouchEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PhotoScaleGestureListener</span> <span class="keyword">implements</span> <span class="title">ScaleGestureDetector</span>.<span class="title">OnScaleGestureListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> initialScale;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缩放中回调 -- 倍数，焦点</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onScale</span><span class="params">(ScaleGestureDetector detector)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// getScaleFactor：将比例因子从上一个缩放事件返回到当前事件</span></span><br><span class="line">        currentScale = initialScale * detector.getScaleFactor();</span><br><span class="line">        invalidate();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缩放前回调,返回true 消费这个缩放事件</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onScaleBegin</span><span class="params">(ScaleGestureDetector detector)</span> </span>&#123;</span><br><span class="line">        initialScale = currentScale;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缩放后回调</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onScaleEnd</span><span class="params">(ScaleGestureDetector detector)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>详细源码可见：<a href="https://github.com/shenzhen2017/PhotoView" target="_blank" rel="noopener">https://github.com/shenzhen2017/PhotoView</a></p>
<h3 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h3><p>1.实现拖拽关闭图片<br>2.滑动效果卡顿优化<br>3.对照PhotoView具体实现</p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Rxjava源码解析</title>
    <url>/blog/2020/08/rxjava-source-learn.html</url>
    <content><![CDATA[<h3 id="Observable-与-Observer-订阅的过程时序图"><a href="#Observable-与-Observer-订阅的过程时序图" class="headerlink" title="Observable 与 Observer 订阅的过程时序图"></a>Observable 与 Observer 订阅的过程时序图</h3><p><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog5/p12.png" alt></p>
<h3 id="Rxjava与标准观察者模式的区别"><a href="#Rxjava与标准观察者模式的区别" class="headerlink" title="Rxjava与标准观察者模式的区别"></a>Rxjava与标准观察者模式的区别</h3><p>中间添加了抽象层，更加解藕，可以进行map等被观察者变换，而原始的观察者模式依赖于被观察者模式中的List<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog5/p13.png" alt><br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog5/p14.png" alt></p>
<h3 id="Map操作流程分析"><a href="#Map操作流程分析" class="headerlink" title="Map操作流程分析"></a>Map操作流程分析</h3><p><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog5/p15.png" alt><br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog5/p16.png" alt></p>
<p>在这里用到了装饰者模式<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog5/p17.png" alt><br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog5/p18.png" alt></p>
<h3 id="Rxjava线程切换原理"><a href="#Rxjava线程切换原理" class="headerlink" title="Rxjava线程切换原理"></a>Rxjava线程切换原理</h3><p>1.observeOn() 只是在收到 onNext() 等消息的时候改变了从下一个开始的操作符的线程运行环境。<br>2.subscribeOn() 线程切换是在 subscribe() 订阅的时候切换，他会切换他下面订阅的操作符的运行环境，因为订阅的过程是自下而上的，所以第一个出现的 subscribeOn() 操作符反而是最后一次运行的。</p>
<h4 id="Scheduler-IO"><a href="#Scheduler-IO" class="headerlink" title="Scheduler.IO"></a>Scheduler.IO</h4><p>Scheduler.IO通过线程池实现线程切换的<br><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ScheduledRunnable scheduleActual(<span class="keyword">final</span> Runnable run, long delayTime, @NonNull TimeUnit unit, @Nullable DisposableContainer <span class="keyword">parent</span>) &#123;</span><br><span class="line">    Runnable decoratedRun = RxJavaPlugins.onSchedule(run);</span><br><span class="line">    <span class="comment">//就是个 Runnable</span></span><br><span class="line">    ScheduledRunnable sr = <span class="keyword">new</span> ScheduledRunnable(decoratedRun, <span class="keyword">parent</span>);</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">parent</span> != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">parent</span>.add(sr)) &#123;</span><br><span class="line">            <span class="keyword">return</span> sr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Future<span class="meta">&lt;?</span>&gt; f;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//判断延迟时间，然后使用线程池运行 Runnable</span></span><br><span class="line">        <span class="keyword">if</span> (delayTime &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            f = executor.submit((Callable&lt;Object&gt;)sr);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            f = executor.schedule((Callable&lt;Object&gt;)sr, delayTime, unit);</span><br><span class="line">        &#125;</span><br><span class="line">        sr.setFuture(f);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RejectedExecutionException ex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">parent</span> != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">parent</span>.remove(sr);</span><br><span class="line">        &#125;</span><br><span class="line">        RxJavaPlugins.onError(ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="AndroidSchedulers-mainThread"><a href="#AndroidSchedulers-mainThread" class="headerlink" title="AndroidSchedulers.mainThread"></a>AndroidSchedulers.mainThread</h4><p>AndroidSchedulers.mainThread通过Handler，使用Looper.getMainLoopper切换到主线程.</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">private static final class MainHolder &#123;</span><br><span class="line">    static final<span class="built_in"> Scheduler DEFAULT </span>= new HandlerScheduler(new Handler(Looper.getMainLooper()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static final<span class="built_in"> Scheduler </span>MAIN_THREAD = RxAndroidPlugins.initMainThreadScheduler(</span><br><span class="line">        new Callable&lt;Scheduler&gt;() &#123;</span><br><span class="line">            @Override public<span class="built_in"> Scheduler </span>call() throws Exception &#123;</span><br><span class="line">                return MainHolder.DEFAULT;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    public static<span class="built_in"> Scheduler </span>mainThread() &#123;</span><br><span class="line">        return RxAndroidPlugins.onMainThreadScheduler(MAIN_THREAD);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static<span class="built_in"> Scheduler </span><span class="keyword">from</span>(Looper looper) &#123;</span><br><span class="line">        <span class="keyword">if</span> (looper == <span class="literal">null</span>) throw new NullPointerException(<span class="string">"looper == null"</span>);</span><br><span class="line">        return new HandlerScheduler(new Handler(looper));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="自定义实现防抖操作符"><a href="#自定义实现防抖操作符" class="headerlink" title="自定义实现防抖操作符"></a>自定义实现防抖操作符</h3><p>rxjava自定义防抖实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewClickObservable</span> <span class="keyword">extends</span> <span class="title">Observable</span>&lt;<span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> View view;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object EVENT = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object EVENT2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ViewClickObservable</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.view = view;</span><br><span class="line"></span><br><span class="line">        EVENT2 = view;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(Observer&lt;? <span class="keyword">super</span> Object&gt; observer)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 可以干自己的</span></span><br><span class="line"></span><br><span class="line">        MyListener myListener = <span class="keyword">new</span> MyListener(view, observer);</span><br><span class="line">        observer.onSubscribe(myListener);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.view.setOnClickListener(myListener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们的包裹</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MyListener</span> <span class="keyword">implements</span> <span class="title">View</span>.<span class="title">OnClickListener</span>, <span class="title">Disposable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> View view;</span><br><span class="line">        <span class="keyword">private</span> Observer&lt;Object&gt; observer;  <span class="comment">// 存一份 下一层</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 原子性</span></span><br><span class="line">        <span class="comment">// https://www.jianshu.com/p/8a44d4a819bc</span></span><br><span class="line">        <span class="comment">// boolean  == AtomicBoolean</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AtomicBoolean isDisposable = <span class="keyword">new</span> AtomicBoolean();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyListener</span><span class="params">(View view, Observer&lt;Object&gt; observer)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.view = view;</span><br><span class="line">            <span class="keyword">this</span>.observer = observer;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (isDisposed() == <span class="keyword">false</span>) &#123;</span><br><span class="line">                observer.onNext(EVENT);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果用调用了 中断</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 如果没有中断过，才有资格，   取消view.setOnClickListener(null);</span></span><br><span class="line">            <span class="keyword">if</span> (isDisposable.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">                <span class="comment">// 主线程 很好的中断</span></span><br><span class="line">                <span class="keyword">if</span> (Looper.myLooper() == Looper.getMainLooper()) &#123;</span><br><span class="line">                    view.setOnClickListener(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 主线程，通过Handler的切换</span></span><br><span class="line">                    <span class="comment">/*new Handler(Looper.getMainLooper()) &#123;</span></span><br><span class="line"><span class="comment">                        @Override</span></span><br><span class="line"><span class="comment">                        public void handleMessage(@NonNull Message msg) &#123;</span></span><br><span class="line"><span class="comment">                            super.handleMessage(msg);</span></span><br><span class="line"><span class="comment">                            view.setOnClickListener(null);</span></span><br><span class="line"><span class="comment">                        &#125;</span></span><br><span class="line"><span class="comment">                    &#125;;*/</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">// HandlerScheduler.scheduleDirect</span></span><br><span class="line"></span><br><span class="line">                    AndroidSchedulers.mainThread().scheduleDirect(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                            view.setOnClickListener(<span class="keyword">null</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDisposed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> isDisposable.get();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自定义RxViews</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RxView</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String TAG = RxView<span class="class">.<span class="keyword">class</span>.<span class="title">getSimpleName</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们自己的操作符 == 函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Observable&lt;Object&gt; <span class="title">clicks</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ViewClickObservable(view);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RxView.clicks(button)</span><br><span class="line">.throttleFirst(<span class="number">2000</span>, TimeUnit.MILLISECONDS)</span><br><span class="line">.subscribe(<span class="keyword">new</span> Consumer&lt;Object&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Object o)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;String&gt; e)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                e.onNext(<span class="string">"Derry"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .subscribe(<span class="keyword">new</span> Consumer&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Log.d(L.TAG, <span class="string">"accept: 终点："</span> + s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>UI卡顿优化</title>
    <url>/blog/2020/08/ui-perforamce-better.html</url>
    <content><![CDATA[<p>UI卡顿的根本原因是UI线程无法在16ms内完成UI绘制。<br>下面以android大图加载为例，结合内存分析，systrace，TraceView等分析UI卡顿优化.</p>
<h3 id="两种大图加载方式对比"><a href="#两种大图加载方式对比" class="headerlink" title="两种大图加载方式对比"></a>两种大图加载方式对比</h3><h4 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h4><p><a href="https://blog.csdn.net/lmj623565791/article/details/49300989/" target="_blank" rel="noopener">Android 高清加载巨图方案 拒绝压缩图片</a><br>使用BitmapRegionDecoder分区域加载<br>源码地址可见：<a href="https://github.com/McoyJiang/LagouAndroidShare/tree/master/course18_Bitmap/LagouBitmap" target="_blank" rel="noopener">自定义大图加载–LagouBitmap</a></p>
<h4 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h4><p><a href="https://juejin.im/post/6844903910088392712" target="_blank" rel="noopener">Android超长图加载与subsampling scale image view实现分析</a><br>使用SubSamplingScaleImageView实现加载<br>源码实例可见：<a href="https://github.com/davemorrissey/subsampling-scale-image-view" target="_blank" rel="noopener">SubSamplingScaleImageView</a></p>
<h3 id="内存分析"><a href="#内存分析" class="headerlink" title="内存分析"></a>内存分析</h3><p>分别使用两种方式加载图片，滑动后使用Profiler查看内存情况<br><strong>方法1</strong><br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog5/p1.PNG" alt></p>
<p><strong>方法2</strong><br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog5/p2.PNG" alt><br>可以看出方法一存在比较严重的内存抖动，方法二的内存较为平缓<br>其原因在于方法一在内存中创建了对象，导致对象频繁创建与回收，造成内存抖动<br><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    Bitmap bm = mDecoder.decodeRegion(mRect, options);</span><br><span class="line">    canvas.drawBitmap(bm, <span class="number">0</span>, <span class="number">0</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="systrace分析"><a href="#systrace分析" class="headerlink" title="systrace分析"></a>systrace分析</h3><p><strong>方法1</strong><br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog5/p3.PNG" alt><br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog5/p4.PNG" alt></p>
<p><strong>方法2</strong><br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog5/p5.PNG" alt><br>可以看出，方法1存在掉帧情况，即无法在16ms内完成绘制工作，systraceView提示Long View#draw，即绘制时间过长<br>而方法2则不存在掉帧情况，绘制都可以在16ms内完成</p>
<p>方法一具体是什么问题导致了无法在16ms内绘制完成，我们需要在TraceView中详细定位一下</p>
<h3 id="TraceView分析"><a href="#TraceView分析" class="headerlink" title="TraceView分析"></a>TraceView分析</h3><p><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog5/p6.PNG" alt><br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog5/p7.PNG" alt></p>
<p>在TraceView中相同颜色的色块即代表一个方法的执行，可以清晰的看出图中主线程有个方法执行时间过长<br>点击后在下方会展示出详细的方法名，即BitmapRegionDecoder.decodeRegion方法<br>可以看出这是个耗时操作，在onDraw中反复调用decodeRegion方法即是掉帧的原因</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>1.在单纯使用BitmapRegionDecoder加载大图时，由于在onDraw中频繁创建对象会造成内存抖动，在onDraw中反复调用decodeRegion，这是个耗时操作，会导致掉帧</p>
<p>2.而在SubScaleSampleImageView中，将大图切片，再判断是否可见，如果可见则加入内存中，否则回收，减少了内存占用与抖动<br>同时根据不同的缩放比例选择合适的采样率，进一步减少内存占用<br>同时在子线程进行decodeRegion操作，解码成功后回调至主线程，减少UI卡顿.</p>
<h3 id="RecyclerView性能优化"><a href="#RecyclerView性能优化" class="headerlink" title="RecyclerView性能优化"></a>RecyclerView性能优化</h3><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://www.jianshu.com/p/50dcd35c3c75" target="_blank" rel="noopener">手把手讲解 性能优化案例（2）app卡顿优化</a><br><a href="https://www.jianshu.com/p/72144b627bb0" target="_blank" rel="noopener">Android 性能优化之旅4–UI卡顿分析</a><br><a href="https://juejin.im/post/6844903522845065229" target="_blank" rel="noopener">Android性能优化之UI卡顿分析之内存抖动和计算性能优化</a><br><a href="https://www.jianshu.com/p/b712e5b21709" target="_blank" rel="noopener">性能优化(7.4)-卡顿优化实例解析</a><br><a href="https://www.jianshu.com/p/122e68e9ddac" target="_blank" rel="noopener">RecycledViewPool使用</a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>插件化换肤实现</title>
    <url>/blog/2020/08/plugin-change-skin.html</url>
    <content><![CDATA[<h3 id="换肤原理"><a href="#换肤原理" class="headerlink" title="换肤原理"></a>换肤原理</h3><p>换肤其实很简单，说白了就是修改View的属性，一般就是修改字体颜色、背景、图片等；如果是一个超级简单的界面，最简单的实现方式就是点击换肤的时候把每一个View都重新设置一下属性就完事了；</p>
<p>View设置属性简单吧，问题就在于在实际项目中不可能手动去获取到每一个控件进行换肤，因为控件太多了；那么问题就变为如何获取到所有的控件进行属性设置；然后换肤，其实就是换一套皮肤，换一套资源文件对吧，如何去更换资源文件也是一个问题</p>
<h4 id="使用theme实现"><a href="#使用theme实现" class="headerlink" title="使用theme实现"></a>使用theme实现</h4><p>Activity的theme属性肯定都有用过，theme里面可以设置各种属性，更改了theme里面的属性比如颜色，我们的导航栏什么的使用了theme里面的颜色属性的控件颜色都会改变；可以从这个点入手，设置不同的theme，然后更换theme就可以实现；但是有一个问题，设置theme只有在activity的setContentView之前才有效，所以要实现换肤必须得重启Activity才能实现，而且每次新增皮肤必须重新修改源码，重新打包，这种方法感觉不太行；</p>
<h4 id="获取到所有View"><a href="#获取到所有View" class="headerlink" title="获取到所有View"></a>获取到所有View</h4><p>所以还是那个问题，如何获取到所有的View进行换肤处理；有一个点就是每个Activity都有setContentView方法，其实猜也能猜到，就是把xml布局解析成一个View对象；有点像AOP（面向切面编程）的思想，如果我们能从这个点切入，拿到每一个生成的View对象，我们就可以统一处理了</p>
<p>在createView的过程中<br><figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">View view;</span><br><span class="line"><span class="keyword">if</span> (mFactory2 != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="attr">view</span> = mFactory2.onCreateView(parent, name, context, attrs);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (mFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="attr">view</span> = mFactory.onCreateView(name, context, attrs);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="attr">view</span> = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="attr">view</span> == <span class="literal">null</span> &amp;&amp; mPrivateFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="attr">view</span> = mPrivateFactory.onCreateView(parent, name, context, attrs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="attr">view</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">    final Object <span class="attr">lastContext</span> = mConstructorArgs[<span class="number">0</span>];</span><br><span class="line">    mConstructorArgs[<span class="number">0</span>] = context;</span><br><span class="line">    try &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="attr">-1</span> == name.indexOf('.')) &#123;</span><br><span class="line">            <span class="attr">view</span> = onCreateView(parent, name, attrs);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="attr">view</span> = createView(name, <span class="literal">null</span>, attrs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        mConstructorArgs[<span class="number">0</span>] = lastContext;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">return view;</span><br></pre></td></tr></table></figure></p>
<p>我们可以在这里通过自定义mFactory的方式来创建View</p>
<h3 id="插件化换肤优点"><a href="#插件化换肤优点" class="headerlink" title="插件化换肤优点"></a>插件化换肤优点</h3><p>1.用户体验，无闪烁换肤架构<br>2.扩展和维护方便，入侵性小，低耦合<br>3.插件化开发，任何APP都是你的皮肤包<br>4.立即生效，无需要重启APP </p>
<h3 id="换肤具体流程"><a href="#换肤具体流程" class="headerlink" title="换肤具体流程"></a>换肤具体流程</h3><h4 id="1-收集XML数据"><a href="#1-收集XML数据" class="headerlink" title="1.收集XML数据"></a>1.收集XML数据</h4><p>如何去收集XML信息?<br>利用View的实例化流程,自定义SkinLayoutInflaterFactory<br>这样View的创建就会通过自定义的factoyr来创建</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityCreated</span><span class="params">(Activity activity, Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *  更新状态栏</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        SkinThemeUtils.updateStatusBarColor(activity);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *  更新布局视图</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//获得Activity的布局加载器</span></span><br><span class="line">        LayoutInflater layoutInflater = activity.getLayoutInflater();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//Android 布局加载器 使用 mFactorySet 标记是否设置过Factory</span></span><br><span class="line">            <span class="comment">//如设置过抛出一次</span></span><br><span class="line">            <span class="comment">//设置 mFactorySet 标签为false</span></span><br><span class="line">            Field field = LayoutInflater.class.getDeclaredField(<span class="string">"mFactorySet"</span>);</span><br><span class="line">            field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            field.setBoolean(layoutInflater, <span class="literal">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用factory2 设置布局加载工程</span></span><br><span class="line">        SkinLayoutInflaterFactory skinLayoutInflaterFactory = <span class="keyword">new</span> SkinLayoutInflaterFactory</span><br><span class="line">                (activity);</span><br><span class="line">        LayoutInflaterCompat.setFactory2(layoutInflater, skinLayoutInflaterFactory);</span><br><span class="line">        mLayoutInflaterFactories.<span class="built_in">put</span>(activity, skinLayoutInflaterFactory);</span><br><span class="line"></span><br><span class="line">        mObserable.addObserver(skinLayoutInflaterFactory);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-统计需要换肤的属性"><a href="#2-统计需要换肤的属性" class="headerlink" title="2.统计需要换肤的属性"></a>2.统计需要换肤的属性</h4><p>SkinAttribute记录需要的属性<br><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">private static final List&lt;String&gt; mAttributes = new ArrayList&lt;&gt;();</span><br><span class="line">    static &#123;</span><br><span class="line">        mAttributes.<span class="keyword">add</span><span class="bash">(<span class="string">"background"</span>);</span></span><br><span class="line">        mAttributes.<span class="keyword">add</span><span class="bash">(<span class="string">"src"</span>);</span></span><br><span class="line">        mAttributes.<span class="keyword">add</span><span class="bash">(<span class="string">"textColor"</span>);</span></span><br><span class="line">        mAttributes.<span class="keyword">add</span><span class="bash">(<span class="string">"drawableLeft"</span>);</span></span><br><span class="line">        mAttributes.<span class="keyword">add</span><span class="bash">(<span class="string">"drawableTop"</span>);</span></span><br><span class="line">        mAttributes.<span class="keyword">add</span><span class="bash">(<span class="string">"drawableRight"</span>);</span></span><br><span class="line">        mAttributes.<span class="keyword">add</span><span class="bash">(<span class="string">"drawableBottom"</span>);</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3-制作皮肤包"><a href="#3-制作皮肤包" class="headerlink" title="3.制作皮肤包"></a>3.制作皮肤包</h3><p>生成一个无代码的apk包即可</p>
<h3 id="4-读取皮肤包皮肤"><a href="#4-读取皮肤包皮肤" class="headerlink" title="4.读取皮肤包皮肤"></a>4.读取皮肤包皮肤</h3><p>怎么样去读取皮肤包中的资源信息<br><figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> void loadSkin(<span class="keyword">String</span> skinPath) &#123;</span><br><span class="line">        <span class="keyword">if</span> (TextUtils.isEmpty(skinPath)) &#123;</span><br><span class="line">            <span class="comment">//还原默认皮肤</span></span><br><span class="line">            SkinPreference.getInstance().reset();</span><br><span class="line">            SkinResources.getInstance().reset();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//宿主app的 resources;</span></span><br><span class="line">                Resources appResource = mContext.getResources();</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">                <span class="comment">//反射创建AssetManager 与 Resource</span></span><br><span class="line">                AssetManager assetManager = AssetManager.class.<span class="keyword">new</span><span class="type">Instance</span>();</span><br><span class="line">                <span class="comment">//资源路径设置 目录或压缩包</span></span><br><span class="line">                Method addAssetPath = assetManager.getClass().getMethod(<span class="string">"addAssetPath"</span>,</span><br><span class="line">                        <span class="keyword">String</span>.class);</span><br><span class="line">                addAssetPath.invoke(assetManager, skinPath);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//根据当前的设备显示器信息 与 配置(横竖屏、语言等) 创建Resources</span></span><br><span class="line">                Resources skinResource = <span class="keyword">new</span> <span class="type">Resources</span>(assetManager, appResource.getDisplayMetrics</span><br><span class="line">                        (), appResource.getConfiguration());</span><br><span class="line"></span><br><span class="line">                <span class="comment">//获取外部Apk(皮肤包) 包名</span></span><br><span class="line">                PackageManager mPm = mContext.getPackageManager();</span><br><span class="line">                PackageInfo info = mPm.getPackageArchiveInfo(skinPath, PackageManager</span><br><span class="line">                        .GET_ACTIVITIES);</span><br><span class="line">                <span class="keyword">String</span> packageName = info.packageName;</span><br><span class="line">                SkinResources.getInstance().applySkin(skinResource, packageName);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//记录</span></span><br><span class="line">                SkinPreference.getInstance().setSkin(skinPath);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//通知采集的View 更新皮肤</span></span><br><span class="line">        <span class="comment">//被观察者改变 通知所有观察者</span></span><br><span class="line">        setChanged();</span><br><span class="line">        notifyObservers(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="5-执行换肤"><a href="#5-执行换肤" class="headerlink" title="5.执行换肤"></a>5.执行换肤</h4><p>如何将资源包中的资源应用到运行中的APP<br>SkinManager通知SkinLayoutInflaterFactory更新UI</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//通知采集的View 更新皮肤</span></span><br><span class="line"><span class="comment">//被观察者改变 通知所有观察者</span></span><br><span class="line"><span class="selector-tag">setChanged</span>();</span><br><span class="line"><span class="selector-tag">notifyObservers</span>(null);</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">mObserable</span><span class="selector-class">.addObserver</span>(skinLayoutInflaterFactory);</span><br></pre></td></tr></table></figure>
<h3 id="源码可见"><a href="#源码可见" class="headerlink" title="源码可见"></a>源码可见</h3><p><a href="https://github.com/shenzhen2017/EnjoySkin" target="_blank" rel="noopener">https://github.com/shenzhen2017/EnjoySkin</a></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://www.zybuluo.com/Tyhj/note/1544461" target="_blank" rel="noopener">实现Android换肤</a><br><a href="https://juejin.im/post/6844903758103576583" target="_blank" rel="noopener">主流技术之网易云换肤方案</a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>android事件分发机制详解</title>
    <url>/blog/2020/08/android-touch-event.html</url>
    <content><![CDATA[<h3 id="事件处理流程"><a href="#事件处理流程" class="headerlink" title="事件处理流程"></a>事件处理流程</h3><p>从Activity至PhoneWindow至DecorView到ViewGroup<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog6/p1.png" alt></p>
<h3 id="setOnTouchListener和SetOnClickListener"><a href="#setOnTouchListener和SetOnClickListener" class="headerlink" title="setOnTouchListener和SetOnClickListener"></a>setOnTouchListener和SetOnClickListener</h3><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line">btn_click.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                Log.e(TAG, <span class="string">"onClick"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">btn_click.setOnTouchListener(<span class="keyword">new</span> View.OnTouchListener() &#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">onTouch</span><span class="params">(View v, MotionEvent event)</span> </span>&#123;</span><br><span class="line">         Log.e(TAG, <span class="string">"onTouch: "</span> + event.getAction());</span><br><span class="line"></span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure>
<p><strong>setOnTouchListener返回true和false有什么区别？</strong><br>onTouchListener返回为True，则不会走onTouchEvent,也就不会执行onClick</p>
<h3 id="事件冲突处理"><a href="#事件冲突处理" class="headerlink" title="事件冲突处理"></a>事件冲突处理</h3><p>ViewGroup，先要走分发流程，如果没人处理，就再走处理流程<br>View，只能走处理流程</p>
<h4 id="分发流程"><a href="#分发流程" class="headerlink" title="分发流程"></a>分发流程</h4><p><strong>down–确定事件给谁</strong><br>1.先看是否拦截后自己处理（即不分发下去）<br>2.分发下去：<br>    排序<br>    遍历分发<br>    领取事件的View 处理事件<br>3.没人领取，再看下自己是否处理事件</p>
<p><strong>move–处理事件</strong><br>1.先看是否拦截后自己处理（即不分发下去）<br>2.分发下去：<br>    直接由down事件确定的view处理</p>
<p><strong>注意</strong><br>View只有处理了down事件，才可以处理后续事件<br>叶子节点如果down事件没有处理，Move事件也处理不了</p>
<p>在Down时分发事件，在Move时就不再分发了<br>但是在Move时仍然可以通过onInterceptTouchEvent拦截</p>
<p><strong>onMove中拦截会触发cancel事件后</strong><br>1.子View将接收至Action_Cancel<br>2.mFirstTouchTarget将置为null<br>3.由于mFirstTouchTarget置为空了，后续操作都被拦截了</p>
<h3 id="SwipeRefreshLayout与ViewPager滑动冲突"><a href="#SwipeRefreshLayout与ViewPager滑动冲突" class="headerlink" title="SwipeRefreshLayout与ViewPager滑动冲突"></a>SwipeRefreshLayout与ViewPager滑动冲突</h3><p><a href="https://www.jianshu.com/p/2579c5b5e7bd" target="_blank" rel="noopener">解决SwipeRefreshLayout和ViewPager滑动冲突的三种方案</a></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://yummylau.com/2018/03/05/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90_2018-03-05_Touch%E4%BA%8B%E4%BB%B6%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" target="_blank" rel="noopener">Android View体系之Touch事件传递源码解析</a></p>
<p><a href="https://www.jianshu.com/p/3581fcf302fd" target="_blank" rel="noopener">一个view事件分发，面试官6连问直击灵魂，我被虐的体无完肤</a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>UML类图中箭头与线条的含义</title>
    <url>/blog/2020/08/uml-knowledge-learn.html</url>
    <content><![CDATA[<h3 id="泛化"><a href="#泛化" class="headerlink" title="泛化"></a>泛化</h3><p>概念：泛化表示一个更泛化的元素和一个更具体的元素之间的关系。泛化是用于对继承进行建模的UML元素。在Java中，用extends关键字表示。<br>表示方式：用实线空心箭头表示。<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog6/p1.webp" alt></p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>概念：实现是一种类与接口的关系，表示类是接口所有特征和行为的实现，在程序中一般通过类实现接口来描述。<br>表示方式：用虚线空心三角形箭头表示，实现类指向接口。<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog6/p2.webp" alt></p>
<h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><p>概念：是一种使用的关系，即一个类的实现需要另一个类的协助。在Java中，方法参数需要传入另一个类的对象，就表示依赖这个类<br>表示方式：虚线箭头。<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog6/p3.webp" alt><br>注意：类A需要用到类B，类A指向类B</p>
<h3 id="关联"><a href="#关联" class="headerlink" title="关联"></a>关联</h3><p>概念：表示类与类之间的联接,它使一个类知道另一个类的属性和方法，这种关系比依赖更强、不存在依赖关系的偶然性、关系也不是临时性的，一般是长期性的。<br>在Java中，一个类的全局变量引用了另一个类，就表示关联了这个类<br>表示方式：实线箭头<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog6/p4.webp" alt><br>注意：类A中用到类B属性，类A指向类B。</p>
<h3 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h3><p>概念：聚合关联关系的一种特例，是强的关联关系。聚合是整体和个体之间的关系，即has-a的关系，整体与个体可以具有各自的生命周期，部分可以属于多个整体对象，也可以为多个整体对象共享。程序中聚合和关联关系是一致的，只能从语义级别来区分</p>
<p>表示方式：尾部为空心菱形的实线箭头（也可以没箭头）。<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog6/p5.webp" alt><br>注意：类A中用到类B属性，类A指向类B。</p>
<h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><p>概念：组合也是关联关系的一种特例。组合是一种整体与部分的关系，即contains-a的关系，比聚合更强。部分与整体的生命周期一致，整体的生命周期结束也就意味着部分的生命周期结束，组合关系不能共享。程序中组合和关联关系是一致的，只能从语义级别来区分。</p>
<p>表示方式：尾部为实心菱形的实现箭头（也可以没箭头）<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog6/p6.webp" alt><br>注意：Head是Dog的一部分，Dog指向Head</p>
<h3 id="依赖，关联，聚合，组合之间的关系"><a href="#依赖，关联，聚合，组合之间的关系" class="headerlink" title="依赖，关联，聚合，组合之间的关系"></a>依赖，关联，聚合，组合之间的关系</h3><p>1.依赖(Dependency)关系是类与类之间的联接。依赖关系表示一个类依赖于另一个类的定义。例如，一个人(Person)可以买车(car)和房子(House)，Person类依赖于Car类和House类的定义，因为Person类引用了Car和House。与关联不同的是，Person类里并没有Car和House类型的属性，Car和House的实例是以参量的方式传入到buy()方法中去的。一般而言，依赖关系在Java语言中体现为局域变量、方法的形参，或者对静态方法的调用。</p>
<p>2.关联(Association）关系是类与类之间的联接，它使一个类知道另一个类的属性和方法。关联可以是双向的，也可以是单向的。在Java语言中，关联关系一般使用成员变量来实现。</p>
<p>3.聚合(Aggregation) 关系是关联关系的一种，是强的关联关系。聚合是整体和个体之间的关系。例如，汽车类与引擎类、轮胎类，以及其它的零件类之间的关系便整体和个体的关系。与关联关系一样，聚合关系也是通过实例变量实现的。但是关联关系所涉及的两个类是处在同一层次上的，而在聚合关系中，两个类是处在不平等层次上的，一个代表整体，另一个代表部分。</p>
<p>4.组合(Composition) 关系是关联关系的一种，是比聚合关系强的关系。它要求普通的聚合关系中代表整体的对象负责代表部分对象的生命周期，组合关系是不能共享的。代表整体的对象需要负责保持部分对象和存活，在一些情况下将负责代表部分的对象湮灭掉。代表整体的对象可以将代表部分的对象传递给另一个对象，由后者负责此对象的生命周期。换言之，代表部分的对象在每一个时刻只能与一个对象发生组合关系，由后者排他地负责生命周期。部分和整体的生命周期一样。</p>
<p>详细示例可见：<a href="https://blog.csdn.net/zhengzhb/article/details/7190158" target="_blank" rel="noopener">https://blog.csdn.net/zhengzhb/article/details/7190158</a></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://www.jianshu.com/p/d1d45efcfac1" target="_blank" rel="noopener">UML图六种箭头含义</a><br><a href="https://blog.csdn.net/zhengzhb/article/details/7190158" target="_blank" rel="noopener">谈一谈自己对依赖、关联、聚合和组合之间区别的理解</a></p>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>屏幕适配方案</title>
    <url>/blog/2020/08/screen-adapter-way.html</url>
    <content><![CDATA[<h3 id="在没有更好的适配方案之前，我们是如何做的？"><a href="#在没有更好的适配方案之前，我们是如何做的？" class="headerlink" title="在没有更好的适配方案之前，我们是如何做的？"></a>在没有更好的适配方案之前，我们是如何做的？</h3><p>我记得刚出来工作实习时，没有经验，做得最多的事情就是写一些简单界面。那时还没有现在这么多适配方案，所以都会在心理默记，在适合的地方多使用wrap_content,match_parent,layout_weight等属性，这样更容易适配各种手机。而现在有了比较完善的适配方案，写起布局来反而有些忽略最根本的东西，有适配方案兜底，不害怕却变得“大胆”。所有的适配方案都是辅助，合适的时候使用wrap_content,match_parent,layout_weigh，依然是我们写布局的时候需要去思考的，适配方案是在此基础上去完善，不是替代它们</p>
<h3 id="为什么需要做适配？"><a href="#为什么需要做适配？" class="headerlink" title="为什么需要做适配？"></a>为什么需要做适配？</h3><p>我们做Android开发的，整天都在吐槽Android的屏幕尺寸，屏幕分辨率的碎片化太严重。可是安卓不是有dp吗?dp是设备独立像素，dp会在不同分辨率和尺寸的手机上代表不同的真实像素，在不同手机上看起来就差不多了，再加上在合适的时候使用wrap_content,match_parent,layout_weigh，为什么还不能完成所有的手机适配？要回答这个问题，我们就先来看看dp是如何转化为px的，代码如下：<br><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">float</span> <span class="title">applyDimension</span>(<span class="params"><span class="keyword">int</span> unit, <span class="keyword">float</span> <span class="keyword">value</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     DisplayMetrics metrics</span>)</span></span><br><span class="line"><span class="function"></span>  &#123;</span><br><span class="line">      <span class="keyword">switch</span> (unit) &#123;</span><br><span class="line">      <span class="keyword">case</span> COMPLEX_UNIT_PX:</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">value</span>;</span><br><span class="line">      <span class="keyword">case</span> COMPLEX_UNIT_DIP:<span class="comment">//重点关注这里</span></span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">value</span> * metrics.density;</span><br><span class="line">      <span class="keyword">case</span> COMPLEX_UNIT_SP:</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">value</span> * metrics.scaledDensity;</span><br><span class="line">      <span class="keyword">case</span> COMPLEX_UNIT_PT:</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">value</span> * metrics.xdpi * (<span class="number">1.0f</span>/<span class="number">72</span>);</span><br><span class="line">      <span class="keyword">case</span> COMPLEX_UNIT_IN:</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">value</span> * metrics.xdpi;</span><br><span class="line">      <span class="keyword">case</span> COMPLEX_UNIT_MM:</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">value</span> * metrics.xdpi * (<span class="number">1.0f</span>/<span class="number">25.4f</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>不管我们在布局文件里面用的是什么单位，最后都会转换为px，这是Android的标准单位。现在只关注dp转换为px这一项,来看value * metrics.density这一项，value是我们写布局时候的dp值，metrics.density跟踪代码就是context.getResources().getDisplayMetrics().density,而density=densityDpi/160,也就是density是屏幕密度dpi和160的一个比值，到这里就能知道，px转化为dp和屏幕密度dpi有关。</p>
<p>dpi是软件概念上的像素密度，这个是人为指定的，还有一个ppi也是像素密度，这个是物理上的，客观存在的。软件上的像素密度一般是会参考物理上的像素密度后人为去指定的，指定数值一般都是120、160、240、320、480，像几部相同分辨率不同尺寸的手机的ppi可能分别是是430,440,450，可能安卓系统指定的都是480dpi,dpi/160就会是一个相对固定的数值，这样导致软件上的dpi和真实的像素密度存在比较大的差距，比如现在1080P的手机不全都是480dpi，还有一些是420dpi，一个100dp<em>100dp的控件，480dpi手机是300px,而420dpi的手机就是262.5px，但是安卓可能让420dpi的手机也指定为480dpi,这样100dp</em>100dp算出的就是300px，本来实际的应该是262.5px，这样就会比我们本来预期的占据的比例要大，在手机上的显示还是有挺大差别的。还有的手机也不会去参考真实的像素密度然后给一个软件意义上的像素密度，而是直接用真实的像素密度,比如1080P的手机，就是用真实的像素420dpi,但是去匹配图片的时候，依然会去匹配xxhdpi文件夹下的图片，这个时候也有可能出现图片失真问题，这种情况也是需要做适配的原因.</p>
<h3 id="今日头条适配方案"><a href="#今日头条适配方案" class="headerlink" title="今日头条适配方案"></a>今日头条适配方案</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>今日头条屏幕适配方案的核心原理在于，根据以下公式算出 density<br>当前设备屏幕总宽度（单位为像素）/ 设计图总宽度（单位为 dp) = density<br>density 的意思就是 1 dp 占当前设备多少像素</p>
<p>density 在每个设备上都是固定的，DPI / 160 = density，屏幕的总 px 宽度 / density = 屏幕的总 dp 宽度<br>但是不同手机的DPI可能是不同的</p>
<p>今日头条的公式为：<br>当前设备屏幕总宽度（单位为像素）/  设计图总宽度（单位为 dp) = density<br>这个公式就是把上面公式中的 屏幕的总 dp 宽度 换成 设计图总宽度，原理都是一样的，只要 density 根据不同的设备进行实时计算并作出改变，就能保证 设计图总宽度 不变，也就完成了适配</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>从dp和px的转换公式 ：px = dp * density<br>可以看出，如果设计图宽为360dp，想要保证在所有设备计算得出的px值都正好是屏幕宽度的话，我们只能修改 density 的值。</p>
<p>通过阅读源码，我们可以得知，density 是 DisplayMetrics 中的成员变量，而 DisplayMetrics 实例通过 Resources#getDisplayMetrics 可以获得，而Resouces通过Activity或者Application的Context获得。</p>
<p>下面假设设计图宽度是750dp，以宽维度来适配。</p>
<p>那么适配后的 density = 设备真实宽(单位px) / 750，接下来只需要把我们计算好的 density 在系统中修改下即可</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">setCustomDensity</span><span class="params">(@NonNull AppCompatActivity activity, @NonNull <span class="keyword">final</span> Application application)</span> </span>&#123;</span><br><span class="line">        DisplayMetrics metrics = application.getResources().getDisplayMetrics();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == sNonCompatDensity) &#123;</span><br><span class="line">            sNonCompatDensity = metrics.density;</span><br><span class="line">            sNonCompatScaledDensity = metrics.scaledDensity;</span><br><span class="line">            application.registerComponentCallbacks(<span class="keyword">new</span> ComponentCallbacks() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onConfigurationChanged</span><span class="params">(Configuration newConfig)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="keyword">null</span> != newConfig &amp;&amp; newConfig.fontScale &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        sNonCompatScaledDensity = application.getResources().getDisplayMetrics().scaledDensity;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onLowMemory</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> targetDensity = metrics.widthPixels / <span class="number">750</span>f;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> targetScaledDensity = targetDensity * (sNonCompatScaledDensity / sNonCompatDensity);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> targetDensityDpi = (<span class="keyword">int</span>) (<span class="number">160</span> * targetDensity);</span><br><span class="line"></span><br><span class="line">        metrics.density = targetDensity;</span><br><span class="line">        metrics.scaledDensity = targetScaledDensity;</span><br><span class="line">        metrics.densityDpi = targetDensityDpi;</span><br><span class="line"></span><br><span class="line">        DisplayMetrics activityMetrics = activity.getResources().getDisplayMetrics();</span><br><span class="line">        activityMetrics.density = targetDensity;</span><br><span class="line">        activityMetrics.scaledDensity = targetScaledDensity;</span><br><span class="line">        activityMetrics.densityDpi = targetDensityDpi;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>同时在 Activity#onCreate 方法中调用下。代码比较简单，也没有涉及到系统非公开api的调用，因此理论上不会影响app稳定性</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>1.使用成本非常低，操作非常简单，使用该方案后在页面布局时不需要额外的代码和操作，这点可以说完虐其他屏幕适配方案<br>2.侵入性非常低，该方案和项目完全解耦，在项目布局时不会依赖哪怕一行该方案的代码，而且使用的还是 Android 官方的 3.API，意味着当你遇到什么问题无法解决，想切换为其他屏幕适配方案时，基本不需要更改之前的代码，整个切换过程几乎在瞬间完成，会少很多麻烦，节约很多时间，试错成本接近于 0<br>4.可适配三方库的控件和系统的控件(不止是是 Activity 和 Fragment，Dialog、Toast 等所有系统控件都可以适配)，由于修改的 density 在整个项目中是全局的，所以只要一次修改，项目中的所有地方都会受益<br>5.不会有任何性能的损耗</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://juejin.im/post/6844904177903075342" target="_blank" rel="noopener">搞懂这几个问题，就掌握了屏幕适配原理</a><br><a href="https://juejin.im/post/6844903697000972295" target="_blank" rel="noopener">今日头条屏幕适配方案终极版正式发布!</a><br><a href="https://juejin.im/post/6844903661819133960#heading-1" target="_blank" rel="noopener">骚年你的屏幕适配方式该升级了!-今日头条适配方案</a><br><a href="https://mp.weixin.qq.com/s/d9QCoBP6kV9VSWvVldVVwA" target="_blank" rel="noopener">一种极低成本的Android屏幕适配方式</a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android动画与策略模式</title>
    <url>/blog/2020/08/animation-and-starge.html</url>
    <content><![CDATA[<h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p>策略模式定义了一系列的算法，并将每一个算法封装起来，而且使他们可以相互替换。策略模式让算法独立于使用它的客户而独立变化。</p>
<p>通常如果一个问题有多个解决方案时，最简单的方式就是利用if-else来根据不同的情景选择不同的解决方案<br>但这种简单的方案问题太多，例如耦合性太高，代码臃肿，不符合开闭原则。可以使用策略模式优化</p>
<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>1.针对同一类型问题的多种处理方式，仅仅是具体行为有差别<br>2.需要安全地封装多种同一类型的操作时<br>3.出现同一抽象类有多个子类，而且又需要使用if-else或者swithc-case来具体实现行为对象</p>
<p>例如实现一个公共交通工具的费用计算器<br>1.定义策略抽象类或接口<br><figure class="highlight zephir"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CalculateStrategy</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 按距离来计算价格</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> miles 公里</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回价格</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> calculatePrice(<span class="keyword">int</span> miles);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.实现具体接口<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>公交车</span><br><span class="line"><span class="comment">// 公交车价格计算策略</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BusStrategy</span> <span class="keyword">implements</span> <span class="title">CalculateStrategy</span> &#123;</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 北京公交车,10里之内1块钱,超过十公里之后每加一块钱可以乘5公里</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> miles 公里</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> calculatePrice(<span class="keyword">int</span> miles) &#123;</span><br><span class="line">        <span class="comment">// 超过10公里的总距离</span></span><br><span class="line">        <span class="keyword">int</span> extraTotal = miles - <span class="number">10</span>;</span><br><span class="line">        <span class="comment">// 超过的距离是5公里的倍数</span></span><br><span class="line">        <span class="keyword">int</span> extraFactor = extraTotal / <span class="number">5</span>;</span><br><span class="line">        <span class="comment">// 超过的距离对5公里的取余</span></span><br><span class="line">        <span class="keyword">int</span> fraction = extraTotal % <span class="number">5</span>;</span><br><span class="line">        <span class="comment">// 价格计算</span></span><br><span class="line">        <span class="keyword">int</span> price = <span class="number">1</span> + extraFactor * <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> fraction &gt; <span class="number">0</span> ? ++price : price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">....</span><br></pre></td></tr></table></figure></p>
<p>3.策略控制类<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 公交出行价格计算器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TranficCalculator</span> &#123;</span></span><br><span class="line">    CalculateStrategy mStrategy;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStrategy</span><span class="params">(CalculateStrategy mStrategy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mStrategy = mStrategy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculatePrice</span><span class="params">(<span class="keyword">int</span> km)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mStrategy.calculatePrice(km);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>4.调用方法<br><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">       TranficCalculator calculator = <span class="keyword">new</span> TranficCalculator();</span><br><span class="line">       calculator.setStrategy(<span class="keyword">new</span> BusStrategy());</span><br><span class="line">       System.out.<span class="built_in">println</span>(<span class="string">"公交车乘16公里的价格 : "</span> + calculator.calculatePrice(<span class="number">16</span>));</span><br><span class="line">       calculator.setStrategy(<span class="keyword">new</span> TaxiStrategy());</span><br><span class="line">       System.out.<span class="built_in">println</span>(<span class="string">"出租车乘16公里的价格 : "</span> + calculator.calculatePrice(<span class="number">16</span>));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>通过以上代码可以得知，使用if-else解决问题，代码臃肿，逻辑复杂，难以升级和维护，没有结构可言。<br>而策略模式则通过建立抽象，将不同策略构建成一个具体的策略实现，通过不同的策略实现算法替换。<br>在简化逻辑，结构的同时，增强了系统的可读性，稳定性，扩展性，这对于较为复杂的业务逻辑显得更为直观，扩展也更为方便。</p>
<h3 id="动画中的策略模式"><a href="#动画中的策略模式" class="headerlink" title="动画中的策略模式"></a>动画中的策略模式</h3><h4 id="时间插值器"><a href="#时间插值器" class="headerlink" title="时间插值器"></a>时间插值器</h4><p>时间插值器的作用是根据时间流逝的百分比来计算当前属性改变的百分比。<br>系统内置的包括有线性插值器，加速减速插值器，减速插值器。这些插值器的使用就是典型的策略模式<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog6/p3.png" alt></p>
<h4 id="ValueAnimator流程图"><a href="#ValueAnimator流程图" class="headerlink" title="ValueAnimator流程图"></a>ValueAnimator流程图</h4><p><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog6/p4.png" alt></p>
<h4 id="ObjectAnimator流程图"><a href="#ObjectAnimator流程图" class="headerlink" title="ObjectAnimator流程图"></a>ObjectAnimator流程图</h4><p><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog6/p5.png" alt></p>
<h3 id="属性动画会调用onDraw吗？那么他是如何刷新UI？"><a href="#属性动画会调用onDraw吗？那么他是如何刷新UI？" class="headerlink" title="属性动画会调用onDraw吗？那么他是如何刷新UI？"></a>属性动画会调用onDraw吗？那么他是如何刷新UI？</h3><p>Q1：我们知道，Animation 动画内部其实是通过 ViewRootImpl 来监听下一个屏幕刷新信号，并且当接收到信号时，从 DecorView 开始遍历 View 树的绘制过程中顺带将 View 绑定的动画执行。那么，属性动画（Animator）原理也是这样么？如果不是，那么它又是怎么实现的？</p>
<p>Q2：属性动画（Animator）区别于 Animation 动画的就是它是有对 View 的属性进行修改的，那么它又是怎么实现的，原理又是什么？</p>
<p>Q3：属性动画（Animator）调用了 start() 之后做了些什么呢？何时开始处理当前帧的动画工作？内部又进行了哪些计算呢？</p>
<p><strong>回答</strong><br>1.ValueAnimator 属性动画调用了 start() 之后，会先去进行一些初始化工作，包括变量的初始化、通知动画开始事件；</p>
<p>2.然后通过 AnimationHandler 将其自身 this 添加到 mAnimationCallbacks 队列里，AnimationHandller 是一个单例类，为所有的属性动画服务，列表里存放着所有正在进行或准备开始的属性动画；</p>
<p>3.如果当前存在要运行的动画，那么 AnimationHandler 会去通过 Choreographer 向底层注册监听下一个屏幕刷新信号，当接收到信号时，它的 mFrameCallback 会开始进行工作，工作的内容包括遍历列表来分别处理每个属性动画在当前帧的行为，处理完列表中的所有动画后，如果列表还不为 0，那么它又会通过 Choreographer 再去向底层注册监听下一个屏幕刷新信号事件，如此反复，直至所有的动画都结束。</p>
<p>4.AnimationHandler 遍历列表处理动画是在 doAnimationFrame() 中进行，而具体每个动画的处理逻辑则是在各自，也就是 ValueAnimator 的 doAnimationFrame() 中进行，各个动画如果处理完自身的工作后发现动画已经结束了，那么会将其在列表中的引用赋值为空，AnimationHandler 最后会去将列表中所有为 null 的都移除掉，来清理资源。</p>
<p>5.每个动画 ValueAnimator 在处理自身的动画行为时，首先，如果当前是动画的第一帧，那么会根据是否有”跳过片头”（setCurrentPlayTime()）来记录当前动画第一帧的时间 mStartTime 应该是什么。</p>
<p>6.第一帧的动画其实也就是记录 mStartTime 的时间以及一些变量的初始化而已，动画进度仍然是 0，所以下一帧才是动画开始的关键，但由于属性动画的处理工作是在绘制界面之前的，那么有可能因为绘制耗时，而导致 mStartTime 记录的第一帧时间与第二帧之间隔得太久，造成丢了开头的多帧，所以如果是这种情况下，会进行 mStartTime 的修正。</p>
<p>7.修正的具体做法则是当绘制工作完成后，此时，再根据当前时间与 mStartTime 记录的时间做比较，然后进行修正。</p>
<p>8.如果是在动画过程中的某一帧才出现绘制耗时现象，那么，只能表示无能为力了，丢帧是避免不了的了，想要解决就得自己去分析下为什么绘制会耗时；而如果是在第一帧是出现绘制耗时，那么，系统还是可以帮忙补救一下，修正下 mStartTime 来达到避免丢帧。</p>
<p><strong>详情可见</strong><br><a href="https://www.jianshu.com/p/46f48f1b98a9" target="_blank" rel="noopener">属性动画 ValueAnimator 运行原理全解析</a></p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://www.jianshu.com/p/b75ea294f983" target="_blank" rel="noopener">android源码中使用的设计模式（行为型–策略模式）</a><br><a href="https://www.cnblogs.com/anni-qianqian/p/7762730.html" target="_blank" rel="noopener">《Android源码设计模式》–策略模式</a><br><a href="https://www.jianshu.com/p/46f48f1b98a9" target="_blank" rel="noopener">属性动画 ValueAnimator 运行原理全解析</a></p>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>kotlin与Java泛型</title>
    <url>/blog/2020/08/kotlin-java-type.html</url>
    <content><![CDATA[<p>Java的泛型是伪泛型<br>Java泛型这个特性是从JDK 1.5才开始加入的，因此为了兼容之前的版本，Java泛型的实现采取了“伪泛型”的策略，即Java在语法上支持泛型，但是在编译阶段会进行所谓的“类型擦除”（Type Erasure），将所有的泛型表示（尖括号中的内容）都替换为具体的类型（其对应的原生态类型），就像完全没有泛型一样。</p>
<p>也正是因为这个原因，我们在使用 Gson 反序列化对象的时候除了制定泛型参数，还需要传入一个 class<br><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">public &lt;<span class="literal">T</span>&gt; <span class="literal">T</span> fromJson(String json, Class&lt;<span class="literal">T</span>&gt; classOfT) throws JsonSyntaxException &#123; </span><br><span class="line">   <span class="keyword">...</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面我们说一点儿不太一样的。在 Kotlin 当中有一个关键字叫做 reified ，还有一个叫做 inline ，后者可以将函数定义为内联函数，前者可以将内联函数的泛型参数当做真实类型使用，我们先来看例子：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T&gt;</span> Gson.<span class="title">fromJson</span><span class="params">(json: <span class="type">String</span>)</span></span>: T&#123; </span><br><span class="line">     <span class="keyword">return</span> fromJson(json, T::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>) </span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>这是一个 Gson 的扩展方法，有了这个之后我们就无须在 Kotlin 当中显式的传入一个 class 对象就可以直接反序列化 json 了。</p>
<p>这个会让人感觉到有点儿迷惑，实际上由于是内联的方法调用，T 的类型在编译时就可以确定的</p>
<h3 id="PECS"><a href="#PECS" class="headerlink" title="PECS"></a>PECS</h3><p>最后看一下什么是PECS（Producer Extends Consumer Super）原则，已经很好理解了。<br>1、频繁往外读取内容的，适合用上界Extends。<br>2、经常往里插入的，适合用下界Super。</p>
<p>详情可见：<a href="https://my.oschina.net/u/3990817/blog/3055968" target="_blank" rel="noopener">困扰多年的Java泛型 extends T&gt; super T&gt;，终于搞清楚了！</a></p>
<h3 id="变型：泛型和子类型化"><a href="#变型：泛型和子类型化" class="headerlink" title="变型：泛型和子类型化"></a>变型：泛型和子类型化</h3><h4 id="子类和子类型"><a href="#子类和子类型" class="headerlink" title="子类和子类型"></a>子类和子类型</h4><p>Int是Number的子类。<br>Int类型是Int?类型的子类型，他们都对应Int类。</p>
<p>一个非空类型是它的非空版本的子类型，但他们都对应同一个类。</p>
<p>List是一个类，List<string>\List<int>是类型。<br>明白子类和子类型很重要。</int></string></p>
<h4 id="不变型"><a href="#不变型" class="headerlink" title="不变型"></a>不变型</h4><p>一个泛型类，例如MutableList–如果对于任意的两个类型A和B，Mutable<a>既不是Mutable<b>的父类型，也不是它的父类型，那么该泛型类就称为在该类型参数是不变型。</b></a></p>
<p>Java中所有的类都是不变型的</p>
<h4 id="协变：保留子类型化"><a href="#协变：保留子类型化" class="headerlink" title="协变：保留子类型化"></a>协变：保留子类型化</h4><p>一个协变类是一个泛型类(我们以Poducer<t>类为例)，如果A是B的子类型，那么Producer<a>也是Producer<b>的子类型；我们说子类型化被保留了。</b></a></t></p>
<p>Kotlin中，要声明在某个类型参数上是可以协变的，在该类型参数的名称前加out关键字即可<br>一个不可变的例子：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">feed</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">"Animal is feeding."</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Herd</span>&lt;<span class="type">T : Animal</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> size: <span class="built_in">Int</span> = <span class="number">10</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">(index: <span class="type">Int</span>)</span></span>: Animal? &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">feedAllAnimal</span><span class="params">(animals: <span class="type">Herd</span>&lt;<span class="type">Animal</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until animals.size) &#123;</span><br><span class="line">        animals.<span class="keyword">get</span>(i)?.feed()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> : <span class="type">Animal</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">feed</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">"Cat is feeding."</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">takeCareOfCats</span><span class="params">(cats: <span class="type">Herd</span>&lt;<span class="type">Cat</span>&gt;)</span></span> &#123;</span><br><span class="line">    feedAllAnimal(cats)<span class="comment">//comile error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>很遗憾，在上面的例子中我们不能把猫群当做动物群被照顾。</p>
<p>在没有使用任何通配符的类型参数上，泛型类在类型参数上是不变型的。</p>
<p>那么我们怎样才能让猫群也能被当做动物群被照顾呢，答案很简单，只需要修改Herd类如下即可：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Herd</span>&lt;<span class="type">out T : Animal</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> size: <span class="built_in">Int</span> = <span class="number">10</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">(index: <span class="type">Int</span>)</span></span>: Animal? &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Kotlin中的MutableList<out t>和Java中的MutableList&lt;? extends T&gt;是一个意思。</out></p>
<p>Kotlin中的MutableList<in t>和Java中的MutableList&lt;? super T&gt;是一个意思。</in></p>
<p>MutableList&lt;*&gt;的投影为MutableList<out any?>。</out></p>
<p>Kotlin中MyType&lt;*&gt;对应Java中的MyType&lt;?&gt;。</p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://juejin.im/entry/6844903486841159694" target="_blank" rel="noopener">Kotlin 泛型详解</a><br><a href="https://www.jianshu.com/p/9f5e355a1e65" target="_blank" rel="noopener">Kotlin泛型-你可能需要知道这些</a><br><a href="https://my.oschina.net/u/3990817/blog/3055968" target="_blank" rel="noopener">困扰多年的Java泛型 extends T&gt; super T&gt;，终于搞清楚了！</a></p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Lifecycle源码解析</title>
    <url>/blog/2020/08/lifecycle-source-learn.html</url>
    <content><![CDATA[<p>Lifecycle可以有效的避免内存泄漏和解决android生命周期的常见难题<br>Livecycle是一个表示android生命周期及状态的对象<br>LivecycleOwner用于连接有生命周期的对象<br>LivecycleObserver用于观察查LifecycleOwner</p>
<h3 id="LifeCycle使用"><a href="#LifeCycle使用" class="headerlink" title="LifeCycle使用"></a>LifeCycle使用</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">lifecycle</span><span class="selector-class">.addObserver</span>(<span class="selector-tag">mPresenter</span>)</span><br></pre></td></tr></table></figure>
<h3 id="LifeCycle原理分析"><a href="#LifeCycle原理分析" class="headerlink" title="LifeCycle原理分析"></a>LifeCycle原理分析</h3><p>看一下LifecycleRegister 类中的addObserver方法<br>这里你会发现生成了一个ObserverWithState，然后放入FastSafeIterableMap里，这个类<br>是一个自定义列表，用于保存观察者并可在遍历期间处理删除/添加。<br><figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserverWithState</span> </span>&#123;</span><br><span class="line">        State mState;</span><br><span class="line">        LifecycleEventObserver mLifecycleObserver;</span><br><span class="line"></span><br><span class="line">        ObserverWithState(LifecycleObserver observer, State initialState) &#123;</span><br><span class="line">            mLifecycleObserver = Lifecycling.lifecycleEventObserver(observer);</span><br><span class="line">            mState = initialState;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        void dispatchEvent(LifecycleOwner owner, Event event) &#123;</span><br><span class="line">            State <span class="keyword">new</span><span class="type">State</span> = getStateAfter(event);</span><br><span class="line">            mState = min(mState, <span class="keyword">new</span><span class="type">State</span>);</span><br><span class="line">            mLifecycleObserver.onStateChanged(owner, event);</span><br><span class="line">            mState = <span class="keyword">new</span><span class="type">State</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> FastSafeIterableMap&lt;LifecycleObserver, ObserverWithState&gt; mObserverMap =</span><br><span class="line">            <span class="keyword">new</span> <span class="type">FastSafeIterableMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure></p>
<p>AppCompatActivity 实现了LifecycleOwner接口，同时持有实现了Lifecycle的LifecycleRegistry对象，这个对象就可以将其理解为观察者模式中的Observable，LifecycleRegistr聚合多个LifecycleObserver，生命周期改变时通知LifecycleObserver进行相应的方法调用。<br><figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">    * This <span class="literal">is</span> <span class="keyword">only</span> used <span class="keyword">for</span> apps that have<span class="built_in"> not</span> switched <span class="keyword">to</span> Fragments <span class="number">1.1</span>.<span class="number">0</span>, <span class="keyword">where</span> this</span><br><span class="line">    * behavior <span class="literal">is</span> provided <span class="keyword">by</span> <span class="xml"><span class="tag">&lt;<span class="name">code</span>&gt;</span>androidx.activity.ComponentActivity<span class="tag">&lt;/<span class="name">code</span>&gt;</span></span>.</span><br><span class="line">    */</span><br><span class="line">   private LifecycleRegistry mLifecycleRegistry = new LifecycleRegistry(this);</span><br></pre></td></tr></table></figure></p>
<p>AppCompatActivity 继承的extends androidx.core.app.ComponentActivity中的onCretae方法<br>ReportFragment.injectIfNeededIn(this);<br>就是在当前的Activity里添加一个ReportFragment<br><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">injectIfNeededIn</span>(<span class="params">Activity activity</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">29</span>) &#123;</span><br><span class="line">            <span class="comment">// On API 29+, we can register for the correct Lifecycle callbacks directly</span></span><br><span class="line">            activity.registerActivityLifecycleCallbacks(</span><br><span class="line">                    <span class="keyword">new</span> LifecycleCallbacks());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Prior to API 29 and to maintain compatibility with older versions of</span></span><br><span class="line">        <span class="comment">// ProcessLifecycleOwner (which may not be updated when lifecycle-runtime is updated and</span></span><br><span class="line">        <span class="comment">// need to support activities that don't extend from FragmentActivity from support lib),</span></span><br><span class="line">        <span class="comment">// use a framework fragment to get the correct timing of Lifecycle events</span></span><br><span class="line">        android.app.FragmentManager manager = activity.getFragmentManager();</span><br><span class="line">        <span class="keyword">if</span> (manager.findFragmentByTag(REPORT_FRAGMENT_TAG) == <span class="literal">null</span>) &#123;</span><br><span class="line">            manager.beginTransaction().<span class="keyword">add</span>(<span class="keyword">new</span> ReportFragment(), REPORT_FRAGMENT_TAG).commit();</span><br><span class="line">            <span class="comment">// Hopefully, we are the first to make a transaction.</span></span><br><span class="line">            manager.executePendingTransactions();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>再看ReportFragment的生命周期函数<br>你会发现都调用了dispatch()方法，</p>
<p>而dispatch()方法则会判断Activity是否实现了LifecycleOwner接口，如果实现了该接口就调用LifecycleRegister的handleLifecycleEvent()<br>这样生命周期的状态就会借由LifecycleRegistry通知给各个LifecycleObserver从而调用其中对应Lifecycle.Event的方法。这种通过Fragment来感知Activity生命周期的方法其实在Glide的中也是有体现的。<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> dispatch(<span class="meta">@NonNull</span> Activity activity, <span class="meta">@NonNull</span> Lifecycle.Event event) &#123;</span><br><span class="line">        <span class="keyword">if</span> (activity <span class="keyword">instanceof</span> LifecycleRegistryOwner) &#123;</span><br><span class="line">            ((LifecycleRegistryOwner) activity).getLifecycle().handleLifecycleEvent(event);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (activity <span class="keyword">instanceof</span> LifecycleOwner) &#123;</span><br><span class="line">            Lifecycle lifecycle = ((LifecycleOwner) activity).getLifecycle();</span><br><span class="line">            <span class="keyword">if</span> (lifecycle <span class="keyword">instanceof</span> LifecycleRegistry) &#123;</span><br><span class="line">                ((LifecycleRegistry) lifecycle).handleLifecycleEvent(event);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>回到handleLifecycleEvent方法中<br>State next = getStateAfter(event);<br>事件发生的时候，先得到当前activity应该出现的下一个状态<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog6/p2.png" alt></p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> void sync() &#123;</span><br><span class="line">        LifecycleOwner lifecycleOwner = mLifecycleOwner.<span class="keyword">get</span>();</span><br><span class="line">        <span class="keyword">if</span> (lifecycleOwner == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalStateException</span>(<span class="string">"LifecycleOwner of this LifecycleRegistry is already"</span></span><br><span class="line">                    + <span class="string">"garbage collected. It is too late to change lifecycle state."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!isSynced()) &#123;</span><br><span class="line">            mNewEventOccurred = <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// no need to check eldest for nullability, because isSynced does it for us.</span></span><br><span class="line">            <span class="keyword">if</span> (mState.compareTo(mObserverMap.eldest().getValue().mState) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                backwardPass(lifecycleOwner);</span><br><span class="line">            &#125;</span><br><span class="line">            Entry&lt;LifecycleObserver, ObserverWithState&gt; <span class="keyword">new</span><span class="type">est</span> = mObserverMap.<span class="keyword">new</span><span class="type">est</span>();</span><br><span class="line">            <span class="keyword">if</span> (!mNewEventOccurred &amp;&amp; <span class="keyword">new</span><span class="type">est</span> != <span class="literal">null</span></span><br><span class="line">                    &amp;&amp; mState.compareTo(<span class="keyword">new</span><span class="type">est</span>.getValue().mState) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                forwardPass(lifecycleOwner);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mNewEventOccurred = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>接下来就是调用onStateChanged(),来通知 实现了 LifecycleObserver的类，生命周期发生了变化<br><figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">void dispatchEvent(LifecycleOwner owner, Event event) &#123;</span><br><span class="line">            State <span class="keyword">new</span><span class="type">State</span> = getStateAfter(event);</span><br><span class="line">            mState = min(mState, <span class="keyword">new</span><span class="type">State</span>);</span><br><span class="line">            mLifecycleObserver.onStateChanged(owner, event);</span><br><span class="line">            mState = <span class="keyword">new</span><span class="type">State</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="LiveData使用"><a href="#LiveData使用" class="headerlink" title="LiveData使用"></a>LiveData使用</h3><p>LiveData是一种具有生命周期感知能力的可观察数据持有类<br>LiveData可以保证屏幕上的显示内容和数据一直保持同步<br>特点：<br>1.LiveData了解UI界面的状态，如果activity不在屏幕上显示，livedata不会触发没必要的界面更新，如果activity已经被销毁，会自动清空与observer的连接，意外的调用就不会发生<br>2.LiveData是一个LifecycleOwner,他可以直接感知activity或fragment的生命周期<br>setValue只能在主线程运行<br>postValue只能在子线程中运行</p>
<p>LiveData数据转换<br>map()  可以转换liveData的输出<br>switchMap()    更改被liveData观察的对象<br>MediatorLiveData  提供自定义数据转换</p>
<p><strong>为什么界面不可见时LiveData不更新？</strong><br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> void considerNotify(ObserverWrapper observer) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!observer.mActive) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Check latest state b4 dispatch. Maybe it changed state but we didn't get the event yet.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// we still first check observer.active to keep it as the entrance for events. So even if</span></span><br><span class="line">        <span class="comment">// the observer moved to an active state, if we've not received that event, we better not</span></span><br><span class="line">        <span class="comment">// notify for a more predictable notification order.</span></span><br><span class="line">        <span class="keyword">if</span> (!observer.shouldBeActive()) &#123;</span><br><span class="line">            observer.activeStateChanged(<span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (observer.mLastVersion &gt;= mVersion) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        observer.mLastVersion = mVersion;</span><br><span class="line">        observer.mObserver.onChanged((T) mData);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>在considerNotify时，如果界面不可见则不更新，保留Data，在重新可见时再触发onChanged.</p>
<h3 id="LiveData原理分析"><a href="#LiveData原理分析" class="headerlink" title="LiveData原理分析"></a>LiveData原理分析</h3><h4 id="observe做为入口"><a href="#observe做为入口" class="headerlink" title="observe做为入口"></a>observe做为入口</h4><p>使用LifecycleBoundObserver把观察者和被观察者包装在一起<br>绑定wrapper作为观察者</p>
<h4 id="绑定完成后，使用setValue与postValue通知观察者"><a href="#绑定完成后，使用setValue与postValue通知观察者" class="headerlink" title="绑定完成后，使用setValue与postValue通知观察者"></a>绑定完成后，使用setValue与postValue通知观察者</h4><h5 id="setValue中"><a href="#setValue中" class="headerlink" title="setValue中"></a>setValue中</h5><p>dispatchingValue（null）<br>if (initiator != null)<br>参数传null和不传null的区别就是如果传null将会通知所有的观察者，反之仅仅通知传入的观察者。<br>for (Iterator&lt;Map.Entry&lt;Observer&lt;? super T&gt;, ObserverWrapper&gt;&gt; iterator =<br>通知所有的观察者通过遍历 mObservers ，将所有的 ObserverWrapper 拿到，实际上就是我们上面提到的 LifecycleBoundObserver，通知观察者调用considerNotify()方法，这个方法就是通知的具体实现了。</p>
<p>considerNotify()<br>先用2个if判断出被观察者对应的activity状态是否为显示<br>发送通知 onChanged（）被调用 </p>
<h5 id="postValue中"><a href="#postValue中" class="headerlink" title="postValue中"></a>postValue中</h5><p>切换线程到主线程中去执行setValue</p>
<h3 id="LiveDataBus实现"><a href="#LiveDataBus实现" class="headerlink" title="LiveDataBus实现"></a>LiveDataBus实现</h3><p>通过一个集合统一管理所有的LiveData<br>设计中的BUG：<br>原来的执行顺序new LiveData–&gt;绑定observer–&gt;setValue执行onChanged<br>而我们的BUS在用时可能出现 new LiveData–&gt;setValue执行onChanged–&gt;绑定observer<br>处理方案，通过反射让第一次setValue不起效即可</p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>android开发者书籍推荐</title>
    <url>/blog/2020/08/android-read-books.html</url>
    <content><![CDATA[<p>1.《Java编程思想》</p>
<p>2.《Effective Java》</p>
<p>3.《突破Java程序员基本功的16门课》</p>
<p>4.《深入理解Java虚拟机》</p>
<p>5.《Android高级工程师进阶》</p>
<p>6.《Android研发录》</p>
<p>7.《Android开发艺术探索》</p>
<p>8.《打造高质量Android应用》</p>
<p>9.《Android应用性能优化》</p>
<p>10.《安卓内核剖析》</p>
<p>11.《深入安卓卷１》</p>
<p>12.《深入安卓卷２》</p>
<p>13.《Android系统源代码情景分析》</p>
<h3 id="代码封装与优雅"><a href="#代码封装与优雅" class="headerlink" title="代码封装与优雅"></a>代码封装与优雅</h3><p>1.《JAVA 开发手册-嵩山版》<br>2.《代码整洁之道》<br>3.《代码质量》<br>4.《重构与模式》<br>5.《企业应用架构模式》<br>6.《大话设计模式》</p>
<h3 id="组内推荐"><a href="#组内推荐" class="headerlink" title="组内推荐"></a>组内推荐</h3><p>1.《Head First设计模式》<br>2.《重构第二版》<br>3.《深入理解Java虚拟机第二版》<br>4.《Effective Java》<br>5.《码农翻身》<br>6.《敏捷软件开发：原则、模式与实践》</p>
]]></content>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>Viewmodel源码解析</title>
    <url>/blog/2020/09/viewmodel-source-learn.html</url>
    <content><![CDATA[<p>ViewModel主要有以下优点：<br>1.可以提供和管理UI界面数据。(将加载数据与数据恢复从 Activity or Fragment中解耦)<br>2.可感知生命周期的组件。<br>3.不会因配置改变而销毁。<br>4.可以配合 LiveData 使用。<br>5.多个 Fragment 可以共享同一 ViewModel。</p>
<h3 id="ViewModel-与-Activity-的绑定过程"><a href="#ViewModel-与-Activity-的绑定过程" class="headerlink" title="ViewModel 与 Activity 的绑定过程"></a>ViewModel 与 Activity 的绑定过程</h3><p>一般情况下使用 ViewModel，我们一般会先声明自己的 ViewModel，并在 Activity 中的 onCreate 方法中使用 ViewModelProviders 来创建 ViewModel。 如下代码所示：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">MyViewModel model = ViewModelProviders.of(<span class="keyword">this</span>).<span class="keyword">get</span>(MyViewModel<span class="class">.<span class="keyword">class</span>);</span></span><br></pre></td></tr></table></figure></p>
<p>在谷歌的最新代码中，不推荐使用 ViweModelProviders(注意是有s的呦) ，而是直接使用 ViewModelProvider 的构造函数来创建 ViewModelProvider 对象。</p>
<p>ViewModelProvider 类需要我们传递 ViewModelStore 与 Factory 对象。其构造函数声明如下：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用ViewModelStoreOwner对象构造函数</span></span><br><span class="line"><span class="keyword">public</span> ViewModelProvider(<span class="meta">@NonNull</span> ViewModelStoreOwner owner) &#123;</span><br><span class="line">    <span class="keyword">this</span>(owner.getViewModelStore(), owner <span class="keyword">instanceof</span> HasDefaultViewModelProviderFactory</span><br><span class="line">            ? ((HasDefaultViewModelProviderFactory) owner).getDefaultViewModelProviderFactory()</span><br><span class="line">            : NewInstanceFactory.getInstance());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用ViewModelStoreOwner与Factory对象的构造函数</span></span><br><span class="line"><span class="keyword">public</span> ViewModelProvider(<span class="meta">@NonNull</span> ViewModelStoreOwner owner, <span class="meta">@NonNull</span> Factory factory) &#123;</span><br><span class="line">    <span class="keyword">this</span>(owner.getViewModelStore(), factory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用ViewModelStore与Factory对象的构造函数</span></span><br><span class="line"><span class="keyword">public</span> ViewModelProvider(<span class="meta">@NonNull</span> ViewModelStore store, <span class="meta">@NonNull</span> Factory factory) &#123;</span><br><span class="line">    mFactory = factory;</span><br><span class="line">    mViewModelStore = store;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Factory-接口介绍"><a href="#Factory-接口介绍" class="headerlink" title="Factory 接口介绍"></a>Factory 接口介绍</h3><p>在 ViewModelProvider 中，Factory 主要用于创建 ViewModel，Factory 的声明如下<br><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">public</span> <span class="selector-tag">interface</span> <span class="selector-tag">Factory</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过给定的Class对象创建ViewModel对象</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param modelClass 所需ViewModel的Class对象</span></span><br><span class="line"><span class="comment">     * @param &lt;T&gt;        ViewModel的泛型参数</span></span><br><span class="line"><span class="comment">     * @return 新创建的ViewModel对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="variable">@NonNull</span></span><br><span class="line">    &lt;T extends ViewModel&gt; T create(<span class="variable">@NonNull</span> Class&lt;T&gt; modelClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过实现 Factory 接口，我们可以实现自己想要的工厂以创建所需的 ViewModel。在 Android 中有多个类都实现了该接口(如 KeyedFactory, AndroidViewModelFactory)，这里以默认的 NewInstanceFactory 为例：<br><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">NewInstanceFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> NewInstanceFactory sInstance;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function">NewInstanceFactory <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            sInstance = <span class="keyword">new</span> NewInstanceFactory();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"ClassNewInstance"</span>)</span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T <span class="keyword">extends</span> ViewModel&gt; <span class="function">T <span class="title">create</span><span class="params">(@NonNull Class&lt;T&gt; modelClass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//默认使用对应ViewModel类无参的构造函数创建实例对象</span></span><br><span class="line">            <span class="function"><span class="keyword">return</span> modelClass.<span class="title">newInstance</span><span class="params">()</span></span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Cannot create an instance of "</span> + modelClass, e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Cannot create an instance of "</span> + modelClass, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>默认情况下， NewInstanceFactory 会调用 ViewModel 的无参构造函数创建实例对象，当然如果你需要在 ViewModel 中使用其他参数，你也可以传递自定义的 Factory</p>
<h3 id="ViewModelStore-介绍"><a href="#ViewModelStore-介绍" class="headerlink" title="ViewModelStore 介绍"></a>ViewModelStore 介绍</h3><p>ViewModelStore 内部维护了一个 HashMap，其 key 为 DEFAULT_KEY + ViewModel的Class对象底层类规范名称，其 value 为对应 ViewModel 对象。每个 Activity 与 Fragment 都对应着一个 ViewModelStore ，用于存储所需的 ViewModel。ViewModelStore 类声明如下所示<br>DEFAULT_KEY 值为：”androidx.lifecycle.ViewModelProvider.DefaultKey”<br><figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class ViewModelStore &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">HashMap</span>&lt;<span class="keyword">String</span>, ViewModel&gt; mMap = <span class="keyword">new</span> <span class="keyword">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> put(<span class="keyword">String</span> <span class="built_in">key</span>, ViewModel viewModel) &#123;</span><br><span class="line">        ViewModel oldViewModel = mMap.put(<span class="built_in">key</span>, viewModel);</span><br><span class="line">        <span class="keyword">if</span> (oldViewModel != <span class="keyword">null</span>) &#123;</span><br><span class="line">            oldViewModel.onCleared();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ViewModel <span class="built_in">get</span>(<span class="keyword">String</span> <span class="built_in">key</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> mMap.<span class="built_in">get</span>(<span class="built_in">key</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Set&lt;<span class="keyword">String</span>&gt; keys() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HashSet&lt;&gt;(mMap.keySet());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当内部的 ViewModel 不再使用时，清除所占的内存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="built_in">clear</span>() &#123;</span><br><span class="line">        <span class="keyword">for</span> (ViewModel vm : mMap.values()) &#123;</span><br><span class="line">            <span class="comment">//下面调用ViewModel的clear方法</span></span><br><span class="line">            vm.<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        mMap.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Activity-中创建与获取-ViewModel-流程"><a href="#Activity-中创建与获取-ViewModel-流程" class="headerlink" title="Activity 中创建与获取 ViewModel 流程"></a>Activity 中创建与获取 ViewModel 流程</h3><p>ViewModel 最终的创建与获取，需要 ViewProvider 类调用 get(Class<t> modelClass)方法（该方法内部通过 ViewModelStore 与 Factory 的配合，创建并保存了所需的 ViewModel 对象），具体代码如下所示：<br><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T <span class="keyword">extends</span> ViewModel&gt; T <span class="keyword">get</span>(<span class="meta">@NonNull</span> Class&lt;T&gt; modelClass) &#123;</span><br><span class="line">       <span class="built_in">String</span> canonicalName = modelClass.getCanonicalName();</span><br><span class="line">       <span class="keyword">if</span> (canonicalName == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Local and anonymous classes can not be ViewModels"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">get</span>(DEFAULT_KEY + <span class="string">":"</span> + canonicalName, modelClass);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></t></p>
<p>该方法内部会调用 get(String key, Class<t> modelClass) 方法：<br><figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line">public &lt;T extends ViewModel&gt; T <span class="built_in">get</span>(<span class="comment">@NonNull String key, @</span>NonNull Class&lt;T&gt; modelClass) &#123;</span><br><span class="line">       <span class="comment">//👇根据key值从ViewModelStore中取对应的ViewModel</span></span><br><span class="line">       ViewModel viewModel = mViewModelStore.get(<span class="built_in">key</span>);</span><br><span class="line">       <span class="comment">//👇判断所传入的Class对象是否是ViewModel的Class类或其子类的对象，如果是，直接返回</span></span><br><span class="line">       <span class="keyword">if</span> (modelClass.isInstance(viewModel)) &#123;</span><br><span class="line">           <span class="keyword">if</span> (mFactory instanceof OnRequeryFactory) &#123;</span><br><span class="line">               ((OnRequeryFactory) mFactory).<span class="built_in">onRequery</span>(viewModel);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> (T) viewModel;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//noinspection StatementWithEmptyBody</span></span><br><span class="line">           <span class="keyword">if</span> (viewModel != <span class="built_in">null</span>) &#123;</span><br><span class="line">               <span class="comment">// <span class="doctag">TODO:</span> log a warning.</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//👇如果为null，根据传入的Factory创建新的VideModel</span></span><br><span class="line">       <span class="keyword">if</span> (mFactory instanceof KeyedFactory) &#123;</span><br><span class="line">           viewModel = ((KeyedFactory) (mFactory)).<span class="keyword">create</span>(<span class="built_in">key</span>, modelClass);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           viewModel = (mFactory).<span class="keyword">create</span>(modelClass);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//👇将新的 ViewModel 存入ViewModelStore，并返回</span></span><br><span class="line">       mViewModelStore.put(<span class="built_in">key</span>, viewModel);</span><br><span class="line">       <span class="keyword">return</span> (T) viewModel;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></t></p>
<p>在该方法中，会在 ViewModelStore 中根据传入的 key 获取并保存 ViewModel。其具体逻辑如下：</p>
<p>1.根据 key 值从 ViewModelStore 中取对应的 ViewModel。<br>2.判断所传入的 Class 对象是否是 ViewModel 的 Class 类或其子类的对象，如果是，直接返回。(当 Object.isInstance(class) 接受的参数为 null 时，该方法会返回 false）<br>3.如果获取的 ViewModel 为 null，会根据传入的 Factory 对象创建新的 VideModel，并将创建好的 ViewModel 放入 ViewModelStore中。<br>4.Activity 中创建与获取 ViewModel 的整体流程如下所示<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog6/p7.webp" alt></p>
<h3 id="ViewModel-在-Activity-中不会因配置改变而销毁的原理"><a href="#ViewModel-在-Activity-中不会因配置改变而销毁的原理" class="headerlink" title="ViewModel 在 Activity 中不会因配置改变而销毁的原理"></a>ViewModel 在 Activity 中不会因配置改变而销毁的原理</h3><p>我们都知道 ViewModel 不会因为 Activity 的配置发生改变而销毁，ViewModel 作用域如下所示：<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog6/p8.webp" alt><br>观察上图，我相信小伙伴们肯定有如下疑惑：</p>
<p>当 Activity 因配置发生改变时，系统会重新创建一个新的 Activity 。那老的 Activity 中的 ViewModel 是如何传递给新的 Activity 的呢？<br>ViewModel 又是如何感知配置是否改变，进而判断是否销毁的呢？<br>要解决如上问题，我们需要了解 Android 中数据恢复的方式以及 Activity 生命周期中 ViewModel 实际处理流程。</p>
<h3 id="数据恢复的常见方式"><a href="#数据恢复的常见方式" class="headerlink" title="数据恢复的常见方式"></a>数据恢复的常见方式</h3><p>在 Android 系统中，需要数据恢复有如下两种场景：<br>场景1：资源相关的配置发生改变导致 Activity 被杀死并重新创建。<br>场景2：资源内存不足导致低优先级的 Activity 被杀死。<br>针对上述场景，分别对应三种不同的数据恢复方式。</p>
<p>对应场景1，不考虑在清单文件中配置 android:configChanges 的特殊情况</p>
<h4 id="使用-onSaveInstanceState-与-onRestoreInstanceState"><a href="#使用-onSaveInstanceState-与-onRestoreInstanceState" class="headerlink" title="使用 onSaveInstanceState 与 onRestoreInstanceState"></a>使用 onSaveInstanceState 与 onRestoreInstanceState</h4><p>使用 onSaveInstanceState 与 onRestoreInstanceState 方法，能处理场景1与场景2的情况。当你的界面数据简单且轻量时，例如原始数据类型或简单对象（比如 String)，则我们可以采用该方式。如果你需要恢复的数据较为复杂，那你应该考虑使用 ViewModle + onSaveInstanceState() (为什么要配合使用，会在下文进行讲解)，因为使用 onSaveInstanceState() 会导致序列化或反序列化，而这，有一定的时间消耗。</p>
<h4 id="使用-Fragment-的-setRetainInstance"><a href="#使用-Fragment-的-setRetainInstance" class="headerlink" title="使用 Fragment 的 setRetainInstance"></a>使用 Fragment 的 setRetainInstance</h4><p>当配置发生改变时，Fragment 会随着宿主 Activity 销毁与重建，当我们调用 Fragment 中的 setRetainInstance(true) 方法时，系统允许 Fragment 绕开销毁-重建的过程。使用该方法，将会发送信号给系统，让 Activity 重建时，保留 Fragment 的实例。需要注意的是：</p>
<p>使用该方法后，不会调用 Fragment 的 onDestory() 方法，但仍然会调用 onDetach() 方法<br>使用该方法后，不会调用 Fragment 的 onCreate(Bundle) 方法。因为 Fragment 没有被重建。<br>使用该方法后，Fragment 的 onAttach(Activity) 与 onActivityCreated(Bundle) 方法仍然会被调用。</p>
<h4 id="使用-onRetainNonConfigurationInstance-与-getLastNonConfigurationInstance"><a href="#使用-onRetainNonConfigurationInstance-与-getLastNonConfigurationInstance" class="headerlink" title="使用 onRetainNonConfigurationInstance 与 getLastNonConfigurationInstance"></a>使用 onRetainNonConfigurationInstance 与 getLastNonConfigurationInstance</h4><p>在 Activity 中提供了 onRetainNonConfigurationInstance 方法，用于处理配置发生改变时数据的保存。随后在重新创建的 Activity 中调用 getLastNonConfigurationInstance 获取上次保存的数据。我们不能直接重写上述方法，如果想在 Activity 中自定义想要恢复的数据，需要我们调用上述两个方法的内部方法：</p>
<p>onRetainCustomNonConfigurationInstance()<br>getLastCustomNonConfigurationInstance()<br>注意：onRetainNonConfigurationInstance 方法系统调用时机介于 onStop - onDestory 之间，getLastNonConfigurationInstance 方法可在 onCreate 与 onStart 方法中调用。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> void onCreate(<span class="meta">@Nullable</span> <span class="type">Bundle</span> savedInstanceState) &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(<span class="type">R</span>.layout.activity_main);</span><br><span class="line">        <span class="type">String</span> name = (<span class="type">String</span>) getLastCustomNonConfigurationInstance();</span><br><span class="line">        <span class="keyword">if</span> (!<span class="type">TextUtils</span>.isEmpty(name)) &#123;</span><br><span class="line">            <span class="comment">//获取恢复后的数据，执行相应操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//你可以可以在onStart中,获取恢复的数据</span></span><br><span class="line"><span class="comment">//    @Override</span></span><br><span class="line"><span class="comment">//    protected void onStart() &#123;</span></span><br><span class="line"><span class="comment">//        super.onStart();</span></span><br><span class="line"><span class="comment">//        String name = (String) getLastCustomNonConfigurationInstance();</span></span><br><span class="line"><span class="comment">//        if (!TextUtils.isEmpty(name)) &#123;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public <span class="type">Object</span> onRetainCustomNonConfigurationInstance() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"AndyJennifer"</span>;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Android 3.0 后，官方推荐使用 Fragment#setRetainInstance(true) 的方式进行数据的恢复。之所以推荐这种方式，个人猜测是为了降低 Activity 的冗余，将数据恢复的任务从 Activity 抽离出来，这更符合单一职责的设计模式</p>
<h4 id="几种数据恢复方式的总结"><a href="#几种数据恢复方式的总结" class="headerlink" title="几种数据恢复方式的总结"></a>几种数据恢复方式的总结</h4><p>通过了解数据恢复的几种方式，我们能得到如下对比图<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog6/p9.webp" alt></p>
<h3 id="ViewModel-的恢复"><a href="#ViewModel-的恢复" class="headerlink" title="ViewModel 的恢复"></a>ViewModel 的恢复</h3><p>ViewModel 在官方设计之初就倾向于在配置改变时进行数据的恢复。考虑到数据恢复时的效率，官方最终采用了 onRetainNonConfigurationInstance 的方式来恢复 ViewModel 。</p>
<p>知道了 ViewModel 的恢复方式，那现在一起来解决我们之前的疑惑。当 Activity 因配置发生改变时，系统会重新创建一个新的 Activity 。那老的 Activity 中的 ViewModel 是如何传递给新的 Activity ？</p>
<p>在 Androidx 中的 Activity 的最新代码中，官方重写了 onRetainNonConfigurationInstance 方法，在该方法中保存了 ViewModelStore (ViweModelStore 中存储了 ViewModel )，进而也保存了 ViewModel，具体代码如下所示：</p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">public final Object onRetainNonConfigurationInstance() &#123;</span><br><span class="line">    Object <span class="attr">custom</span> = onRetainCustomNonConfigurationInstance();</span><br><span class="line"></span><br><span class="line">    ViewModelStore <span class="attr">viewModelStore</span> = mViewModelStore;</span><br><span class="line">    <span class="keyword">if</span> (<span class="attr">viewModelStore</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">        NonConfigurationInstances <span class="attr">nc</span> =</span><br><span class="line">                (NonConfigurationInstances) getLastNonConfigurationInstance();</span><br><span class="line">        <span class="keyword">if</span> (nc != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="attr">viewModelStore</span> = nc.viewModelStore;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="attr">viewModelStore</span> == <span class="literal">null</span> &amp;&amp; <span class="attr">custom</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">        return <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //将ViewModel存储在 NonConfigurationInstances 对象中</span><br><span class="line">    NonConfigurationInstances <span class="attr">nci</span> = new NonConfigurationInstances();</span><br><span class="line">    nci.<span class="attr">custom</span> = custom;</span><br><span class="line">    nci.<span class="attr">viewModelStore</span> = viewModelStore;</span><br><span class="line">    return nci;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当新的 Activity 重新创建，并调用 ViewModelProviders.of(this).get(xxxModel.class) 时，又会在 getViewModelStore() 方法中获取老 Activity 保存的 ViewModelStore。那么也就拿到了 ViewModel。具体代码如下所示</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ViewModelStore getViewModelStore() &#123;</span><br><span class="line">    <span class="keyword">if</span> (getApplication() == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalStateException</span>(<span class="string">"Your activity is not yet attached to the "</span></span><br><span class="line">                + <span class="string">"Application instance. You can't request ViewModel before onCreate call."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mViewModelStore == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//👇获取保存的NonConfigurationInstances，</span></span><br><span class="line">        NonConfigurationInstances nc =</span><br><span class="line">                (NonConfigurationInstances) getLastNonConfigurationInstance();</span><br><span class="line">        <span class="keyword">if</span> (nc != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//👇从该对象中获取ViewModelStore</span></span><br><span class="line">            mViewModelStore = nc.viewModelStore;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mViewModelStore == <span class="literal">null</span>) &#123;</span><br><span class="line">            mViewModelStore = <span class="keyword">new</span> <span class="type">ViewModelStore</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mViewModelStore;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://www.jianshu.com/p/e0504ff99e16" target="_blank" rel="noopener">Jetpack明星组件 —ViewModel 这些知识点你必须知道！</a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>DataBinding双向数据绑定原理</title>
    <url>/blog/2020/09/data-binding-source.html</url>
    <content><![CDATA[<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>1.在项目中配置允许使用DataBinding<br><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">dataBinding&#123;</span></span><br><span class="line">        <span class="string">enabled</span> <span class="literal">true</span></span><br><span class="line">    <span class="string">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>2.在xml中引入data<br><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">&lt;<span class="class"><span class="keyword">data</span>&gt;</span></span><br><span class="line">     &lt;variable</span><br><span class="line">            name=<span class="string">"user"</span></span><br><span class="line">            <span class="class"><span class="keyword">type</span>="com.example.databinding_demo_20200329.<span class="type">User</span>" /&gt;</span></span><br><span class="line">    &lt;/<span class="class"><span class="keyword">data</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>3.赋值<br><figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">binding= DataBindingUtil.<span class="built_in">set</span>ContentView(this,R.layout.activity_main);</span><br><span class="line"><span class="keyword">user</span>=new User(<span class="string">"name"</span>,<span class="string">"123"</span>);</span><br><span class="line">binding.<span class="built_in">set</span>User(<span class="keyword">user</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="XML编译后"><a href="#XML编译后" class="headerlink" title="XML编译后"></a>XML编译后</h3><p>xml编译后生成两个文件<br>app/build/imtermediates/data_binding_layout_info_type_merge/debug/activity_main-layout.xml<br>描述data和相关类的路径<br>app/build/imtermediates/incremental/mergeDebugResources/stripped.dir/layout/activity_main.xml<br>真正的布局文件，加上了tag</p>
<h3 id="双向绑定原理"><a href="#双向绑定原理" class="headerlink" title="双向绑定原理"></a>双向绑定原理</h3><h4 id="从setVariable-id-value-开始分析"><a href="#从setVariable-id-value-开始分析" class="headerlink" title="从setVariable(id,value)开始分析"></a>从setVariable(id,value)开始分析</h4><h5 id="三种情况下会生成BR文件的内容"><a href="#三种情况下会生成BR文件的内容" class="headerlink" title="三种情况下会生成BR文件的内容"></a>三种情况下会生成BR文件的内容</h5><p>1.xml中中设置variable的name属性<br>2.VM继承BaseObservable，将某个成员变量加上@Bindable注解<br>3.VM继承BaseObservable，将get,set,is开头的方法加上@Bindable注解</p>
<h5 id="setUser方法分析"><a href="#setUser方法分析" class="headerlink" title="setUser方法分析"></a>setUser方法分析</h5><p><strong>updateRegistration注册监听器</strong></p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">boolean</span> <span class="title">updateRegistration</span><span class="params">(<span class="keyword">int</span> localFieldId, Observable observable)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> <span class="title">updateRegistration</span><span class="params">(localFieldId, observable, CREATE_PROPERTY_LISTENER)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">boolean</span> <span class="title">updateRegistration</span><span class="params">(<span class="keyword">int</span> localFieldId, ObservableList observable)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> <span class="title">updateRegistration</span><span class="params">(localFieldId, observable, CREATE_LIST_LISTENER)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">boolean</span> <span class="title">updateRegistration</span><span class="params">(<span class="keyword">int</span> localFieldId, ObservableMap observable)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> <span class="title">updateRegistration</span><span class="params">(localFieldId, observable, CREATE_MAP_LISTENER)</span></span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>三个重载的方法，分别对应Observable ，ObservableList 和ObservableMap</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> updateRegistration(<span class="keyword">int</span> localFieldId, Object observable,</span><br><span class="line">            CreateWeakListener listenerCreator) &#123;</span><br><span class="line">        <span class="keyword">if</span> (observable == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="function"><span class="keyword">return</span> <span class="title">unregisterFrom</span><span class="params">(localFieldId)</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line">        WeakListener listener = mLocalFieldObservers[localFieldId];</span><br><span class="line">        <span class="keyword">if</span> (listener == <span class="keyword">null</span>) &#123;</span><br><span class="line">            registerTo(localFieldId, observable, listenerCreator);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (listener.getTarget() == observable) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//nothing to do, same object</span></span><br><span class="line">        &#125;</span><br><span class="line">        unregisterFrom(localFieldId);</span><br><span class="line">        registerTo(localFieldId, observable, listenerCreator);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>registerTo就是注册监听器，unregisterFrom就是删除监听器<br>1.observable传进来为null，删除监听器<br>2.mLocalFieldObservers[localFieldId]为空，也就是第一次注册，那么就注册监听器<br>3.mLocalFieldObservers[localFieldId]不为空并且里面的监听器和传进来监听器不一致，先删除监听器，再重新注册新的监听器</p>
<p><strong>registerTo注册监听器</strong><br>listenerCreator就是之前的那个CREATE_PROPERTY_LISTENER，<br>调用create方法就是调用 return new WeakPropertyListener(viewDataBinding, localFieldId).getListener()</p>
<p><strong>WeakPropertyListener类</strong><br><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WeakPropertyListener</span> <span class="keyword">extends</span> <span class="title">Observable</span>.<span class="title">OnPropertyChangedCallback</span></span></span><br><span class="line"><span class="class">            <span class="keyword">implements</span> <span class="title">ObservableReference</span>&lt;<span class="title">Observable</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> WeakListener&lt;Observable&gt; mListener;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">WeakPropertyListener</span><span class="params">(ViewDataBinding binder, <span class="keyword">int</span> localFieldId)</span> </span>&#123;</span><br><span class="line">            mListener = <span class="keyword">new</span> WeakListener&lt;Observable&gt;(binder, localFieldId, <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> WeakListener&lt;Observable&gt; getListener() &#123;</span><br><span class="line">            <span class="keyword">return</span> mListener;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">addListener</span><span class="params">(Observable <span class="keyword">target</span>)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">target</span>.addOnPropertyChangedCallback(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">removeListener</span><span class="params">(Observable <span class="keyword">target</span>)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">target</span>.removeOnPropertyChangedCallback(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">setLifecycleOwner</span><span class="params">(LifecycleOwner lifecycleOwner)</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onPropertyChanged</span><span class="params">(Observable sender, <span class="keyword">int</span> propertyId)</span> </span>&#123;</span><br><span class="line">            ViewDataBinding binder = mListener.getBinder();</span><br><span class="line">            <span class="keyword">if</span> (binder == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Observable obj = mListener.getTarget();</span><br><span class="line">            <span class="keyword">if</span> (obj != sender) &#123;</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// notification from the wrong object?</span></span><br><span class="line">            &#125;</span><br><span class="line">            binder.handleFieldChange(mListener.mLocalFieldId, sender, propertyId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WeakListener</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ViewDataBinding</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ObservableReference&lt;T&gt; mObservable;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> mLocalFieldId;</span><br><span class="line">        <span class="keyword">private</span> T mTarget;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> WeakListener(ViewDataBinding binder, <span class="keyword">int</span> localFieldId,</span><br><span class="line">                ObservableReference&lt;T&gt; observable) &#123;</span><br><span class="line">            <span class="keyword">super</span>(binder, sReferenceQueue);</span><br><span class="line">            mLocalFieldId = localFieldId;</span><br><span class="line">            mObservable = observable;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">setLifecycleOwner</span><span class="params">(LifecycleOwner lifecycleOwner)</span> </span>&#123;</span><br><span class="line">            mObservable.setLifecycleOwner(lifecycleOwner);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">setTarget</span><span class="params">(T object)</span> </span>&#123;</span><br><span class="line">            unregister();</span><br><span class="line">            mTarget = object;</span><br><span class="line">            <span class="keyword">if</span> (mTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mObservable.addListener(mTarget);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">unregister</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">boolean</span> unregistered = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (mTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mObservable.removeListener(mTarget);</span><br><span class="line">                unregistered = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mTarget = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span> unregistered;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="function">T <span class="title">getTarget</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> mTarget;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protected</span> <span class="function">ViewDataBinding <span class="title">getBinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            ViewDataBinding binder = get();</span><br><span class="line">            <span class="keyword">if</span> (binder == <span class="keyword">null</span>) &#123;</span><br><span class="line">                unregister(); <span class="comment">// The binder is dead</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> binder;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>内部有一个包装类WeakListener，主要用于避免ViewDataBinding内存泄漏，同时储存VM对象</p>
<p>这样mLocalFieldObservers就储存了一个WeakListener对象，这个WeakListener既持有ViewDataBinding的引用，也持有VM的引用，还持有WeakPropertyListener的引用。<br>registerTo最后调用了listener.setTarget(observable)方法，<br>这个方法就是调用WeakPropertyListener 的addListener方法，<br>也就是调用VM的addOnPropertyChangedCallback(this)</p>
<p>addOnPropertyChangedCallback(this)中new了一个PropertyChangeRegistry的实例<br>然后把WeakPropertyListener这个监听器设置给PropertyChangeRegistry<br>这样VM就持有了PropertyChangeRegistry的引用，也就建立了和ViewDataBinding的联系</p>
<p><strong>unregisterFrom删除监听器</strong><br>调用WeakPropertyListener的unregister方法，然后把刚才建立的联系取消掉</p>
<p><strong>注册完成后</strong><br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog6/p6.png" alt></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter基础知识</title>
    <url>/blog/2020/09/flutter-basic-learn.html</url>
    <content><![CDATA[<h3 id="开发方式演进"><a href="#开发方式演进" class="headerlink" title="开发方式演进"></a>开发方式演进</h3><h4 id="1-原生开发"><a href="#1-原生开发" class="headerlink" title="1.原生开发"></a>1.原生开发</h4><p>开发成本大<br>原生开发一般都要维护Android、iOS两个开发团队，版本迭代时，人力成本，开发成本，测试成本都会变大。</p>
<p>动态化需求<br>当需求发生变化时，纯原生应用大多数需要通过版本升级来更新内容，不发版也可以更新应用内容的需求就变的迫在眉睫。</p>
<h4 id="2-WebView开发"><a href="#2-WebView开发" class="headerlink" title="2.WebView开发"></a>2.WebView开发</h4><p>WebView担任JavaScript与原生API之间通信的Bridge桥梁。<br>用于在JavaScript与原生之间通信的工具称之为WebView JavaScript Bridge(JsBridge)。</p>
<p>这种方式，能够很好的解决跨平台与动态更新的需求但是，我们都知道android <code>WebView</code>的渲染效率很差，同时<code>JavaScript</code>是解释型语言，它不需要编译，在运行时候解释执行，这就导致JavaScript的执行性能太低了<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog6/p7.png" alt></p>
<h3 id="3-RN开发"><a href="#3-RN开发" class="headerlink" title="3.RN开发"></a>3.RN开发</h3><p>为了突破使用<code>WebView</code>进行渲染的性能问题，2015年4月，Facebook开源了JS框架 <code>React</code> 在原生移动应用平台的衍生产物——<code>React Native</code>。RN将渲染交给原生，而不是直接在HTML中完成<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog6/p8.png" alt></p>
<p>我们编写的依旧是<code>JavaScript</code>代码。这时候，我们使用JS写好UI后，会组成一个<strong>Virtual DOM</strong>。然后通过Bridge将VD发给原生层去进行UI的创建。这种方式看起来与原生开发非常相似，我们在进行原生开发的时候，写好XML布局再由Java对这个布局XML进行解析，然后通过反射创建对应的View，这个XML就是一个界面的配置文件。而使用RN，我们的配置则由XML变成了JS编写。不同的是我们在原生开发中，xml是静态的配置，而RN中要更新UI，又需要经历一次Bridge传递的过程。同时如果需要在RN中调用原生API也需要通过bridge来进行传递。<br>这样导致需要频繁的跨桥调用，bridge 的成本太高了。</p>
<p>虽然RN底层是使用原生进行绘制，但是毕竟中间多了一层Bridge，也就是多了一层中介，你租房是希望能直接与房东进行交流还是和中介公司？很显然，去中介公司进行租房，你将花费一些代价。所以RN多了一层中介——Bridge，它绝无可能与原生的性能相媲美，但是为了跨平台，这点代价不是致命的。你会因为中介需要多付中介费，就完全靠自己去找房东个人租房子吗？</p>
<h3 id="Flutter"><a href="#Flutter" class="headerlink" title="Flutter"></a>Flutter</h3><p>之前我们了解到，现有的跨平台技术的工作机制。根据之前的了解，我们是不是设想如果拥有一个框架，我们编写的代码直接会根据打包的平台编译为此平台本身的原生代码，在运行时期直接执行这些编译后的原生代码，就和我们进行原生开发一样，不再需要Bridge来担任中介的角色，是不是能够拥有最优秀的性能</p>
<p>Flutter的工作机制和我们预想的一样，他正是通过将它的代码根据不同的平台编译为对应平台的机器码，这样就不需要Bridge的存在了。Flutter自己嵌入了一个 Dart VM，我们编写的代码会被编译成ARM的机器码，在Android中就是通过Dart VM所在的libflutter.so完成我们自己编写的代码生成的机器码的载入执行。<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog6/p10.png" alt></p>
<blockquote>
<p>Android真机一般都是ARM架构的，模拟器是X86或者x86_64</p>
<p>IOS真机一般也是ARM，模拟器早期都是I386，在5s的模拟器后好像都是x86_64了。</p>
</blockquote>
<h4 id="Flutter架构"><a href="#Flutter架构" class="headerlink" title="Flutter架构"></a>Flutter架构</h4><p>Flutter框架整体拥有两层架构，由上往下，第一层是Framework类库层，提供给我们在开发时所使用的各种Widget、动画等。而第二层则是Engine引擎层，我们上面所说的Dart VM也就处于这一层<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog6/p9.png" alt></p>
<h3 id="Dart"><a href="#Dart" class="headerlink" title="Dart"></a>Dart</h3><p>与其它跨平台框架使用JavaScript作为其开发语言不同的是，Flutter使用的是:Dart</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点:"></a>特点:</h4><p>1.基于JIT的快速开发周期<br>Flutter在开发阶段采用JIT模式，这样就避免了每次改动都要进行编译，极大的节省了开发时间；</p>
<p>2.基于AOT的发布包<br>Flutter在发布时可以通过AOT生成高效的ARM代码以保证应用性能</p>
<p>JIT（Just In Time，即使编译）在程序执行期间即时编译为本地代码。<br>AOT（Ahead Of Time，静态编译） 程序运行前编译成本地机器码。</p>
<p>3.单线程<br>不需要锁，不存在数据竞争和变量状态同步，也没有线程上下文切换的性能损耗和锁导致的卡顿。</p>
<p>4.垃圾回收<br>多生代无锁垃圾回收器，专门为UI框架中常见的大量Widgets对象创建和销毁优化。</p>
<p><strong>Flutter特点</strong><br>类似Flutter这种框架的出现是必然的，现有的跨平台框架，比如RN都是基于JS，由于JS的执行性能，导致跨平台应用性能一直无法突破瓶颈。而Flutter在Debug使用JIT编译，支持热重载，能够提高我们的开发效率，而Release中利用AOT直接编译成机器码，能够达到更好的性能。</p>
<p>从设计角度而言，Flutter提供了非常丰富的Widget组件，能够让我们非常轻松的实现Android或者IOS风格的UI效果。</p>
<p>​Flutter作为Google官方孵化的项目，拥有更加规范与完善的生态圈，依托官方就是它最大的优势之一。像IOS中的热更新，被苹果官方一句话就让你的努力白费了，但是如果是IOS官方推出的热更新还用担心这样的问题吗？</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://www.jianshu.com/p/c974397b96c5" target="_blank" rel="noopener">Flutter原理与实践</a><br><a href="https://zhuanlan.zhihu.com/p/36861174" target="_blank" rel="noopener">Flutter原理简解</a><br><a href="https://www.jianshu.com/p/5c0d1255cbf3" target="_blank" rel="noopener">Flutter 进阶之路 ————跨平台架构实现</a><br><a href="https://www.zhihu.com/question/289992028" target="_blank" rel="noopener">Flutter 是如何做到性能直逼 native 的?</a></p>
]]></content>
      <tags>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>Darta基础语法</title>
    <url>/blog/2020/09/dart-basic-grammer.html</url>
    <content><![CDATA[<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>变量是一个引用,未初始化的变量值是null<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span> name1 = <span class="string">'Lance'</span>;</span><br><span class="line"><span class="keyword">var</span> name2 = <span class="string">'Lance'</span>;</span><br><span class="line"><span class="built_in">dynamic</span> name3 = <span class="string">'Lance'</span>;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'<span class="subst">$name1</span> <span class="subst">$name2</span> <span class="subst">$name3</span>'</span>);</span><br><span class="line"><span class="comment">//变量是一个引用，上面的name1、name2与name3的变量都引用了 一个内容为 “Lance” 的 String 对象。</span></span><br></pre></td></tr></table></figure></p>
<p>可以用Object、var与dynamic声明的变量赋任何类型的值，但是背后的原理却是非常不同。<br><strong>1、Object：</strong><br>与Java一样Object是所有类的基类，Object声明的变量可以是任意类型。（在 Dart 中 甚至连 数字、方法和 <code>null</code> 都是对象，比如int。）</p>
<p><strong>2、var：</strong><br>声明的变量在赋值的那一刻，决定了它是什么类型。</p>
<p><strong>3、dynamic：</strong><br>不是在编译时候确定实际类型的, 而是在运行时。dynamic声明的变量行为与Object一样</p>
<h3 id="final与const"><a href="#final与const" class="headerlink" title="final与const"></a>final与const</h3><p>如果不打算改变一个变量，可以使用final和const，它们可以替代任何类型，只能在声明时初始化，且不能改变。</p>
<p>final与const从使用上根本看不出区别，但是final是运行时常量，而const是编译器常量，它的值在编译期就可以确定，编译时常量能够让代码运行的更高效</p>
<p>类的变量可以为 <code>final</code> 但是不能是 <code>const</code> 。如果 const 变量在类中，需要定义为<code>static const</code>静态常量</p>
<h3 id="内置的类型"><a href="#内置的类型" class="headerlink" title="内置的类型"></a>内置的类型</h3><p>与Java的八大内置基本数据类型不同，Dart 内置支持下面这些类型：</p>
<ul>
<li>numbers</li>
<li>strings</li>
<li>booleans</li>
<li>lists (也被称之为 <em>arrays</em>)</li>
<li>maps</li>
<li>runes (用于在字符串中表示 Unicode 字符)</li>
<li>symbols</li>
</ul>
<h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h3><p>常见的操作符就没什么可说的了，主要来看看Java所没有的。</p>
<h4 id="类型判定操作符"><a href="#类型判定操作符" class="headerlink" title="类型判定操作符"></a>类型判定操作符</h4><p><code>as</code>、 <code>is</code>、 和 <code>is!</code> 操作符是在运行时判定对象 类型的操作符<br>as 类型转换<br>is 如果对象是指定的类型返回 True<br>is! 如果对象是指定的类型返回 False</p>
<h4 id="赋值操作符"><a href="#赋值操作符" class="headerlink" title="赋值操作符"></a>赋值操作符</h4><p><code>=</code>、<code>+=</code>、<code>\=</code>、<code>*=</code>这些不必多说，还有一个 <code>??=</code> 操作符用来指定 值为 null 的变量的值<br><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">b</span> <span class="string">??=</span> <span class="string">value;</span> <span class="string">//</span> <span class="string">如果</span> <span class="string">b</span> <span class="string">是</span> <span class="literal">null</span><span class="string">，则</span> <span class="string">value</span> <span class="string">赋值给</span> <span class="string">b；</span></span><br><span class="line">             <span class="string">//</span> <span class="string">如果不是</span> <span class="literal">null</span><span class="string">，则</span> <span class="string">b</span> <span class="string">的值保持不变</span></span><br></pre></td></tr></table></figure></p>
<h4 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h4><p>Dart 有两个特殊的操作符可以用来替代 <a href="http://dart.goodev.org/guides/language/language-tour#if-and-else" target="_blank" rel="noopener">if-else</a> 语句：</p>
<ul>
<li><p><code>condition ? expr1 : expr2</code></p>
<p>如果 <em>condition</em> 是 true，执行 <em>expr1</em> (并返回执行的结果)； 否则执行 <em>expr2</em> 并返回其结果。</p>
</li>
<li><p><code>expr1 ?? expr2</code></p>
<p>如果 <em>expr1</em> 不为null，返回其值； 否则执行 <em>expr2</em> 并返回其结果。</p>
</li>
</ul>
<h4 id="级联操作符"><a href="#级联操作符" class="headerlink" title="级联操作符"></a>级联操作符</h4><p>级联操作符 (<code>..</code>) 可以在同一个对象上 连续调用多个函数以及访问成员变量。 使用级联操作符可以避免创建临时变量， 并且写出来的代码看起来更加流畅：<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">//StringBuffer write就是Java的append</span></span><br><span class="line"><span class="keyword">var</span> sb = <span class="keyword">new</span> <span class="built_in">StringBuffer</span>();</span><br><span class="line">sb..write(<span class="string">'foo'</span>)..write(<span class="string">'bar'</span>);</span><br></pre></td></tr></table></figure></p>
<h4 id="安全操作符"><a href="#安全操作符" class="headerlink" title="安全操作符"></a>安全操作符</h4><p>Dart提供了 <code>?.</code>操作符。左边的操作对象 如果 为 null 则返回 null<br><figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">String</span> sb;</span><br><span class="line"><span class="comment">//空指针</span></span><br><span class="line"><span class="keyword">print</span>(sb.length);</span><br><span class="line"><span class="keyword">print</span>(sb?.length);</span><br></pre></td></tr></table></figure></p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="可选命名参数"><a href="#可选命名参数" class="headerlink" title="可选命名参数"></a>可选命名参数</h4><p>把方法的参数放到 <code>{}</code> 中就变成可选 命名参数<br><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(&#123;<span class="keyword">int</span> i, <span class="keyword">int</span> j&#125;)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(i == <span class="keyword">null</span> || j == <span class="keyword">null</span>)&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> i + j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>调用方法的时候，可以使用这种形式 <code>paramName: value</code> 来指定命名参数。例如：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="comment">//无必须参数</span></span><br><span class="line"><span class="function"><span class="title">add</span><span class="params">()</span></span></span><br><span class="line"><span class="comment">//选择传递参数</span></span><br><span class="line"><span class="function"><span class="title">add</span><span class="params">(i:<span class="number">1</span>)</span></span></span><br><span class="line"><span class="comment">//位置无关</span></span><br><span class="line"><span class="function"><span class="title">add</span><span class="params">(i:<span class="number">1</span>, j:<span class="number">2</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">add</span><span class="params">(j:<span class="number">1</span>, i:<span class="number">2</span>)</span></span></span><br></pre></td></tr></table></figure>
<h4 id="可选位置参数"><a href="#可选位置参数" class="headerlink" title="可选位置参数"></a>可选位置参数</h4><p>把方法的参数放到 <code>[]</code> 中就变成可选 位置参数，传值时按照参数位置顺序传递<br><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span>(<span class="params">[<span class="keyword">int</span> i, <span class="keyword">int</span> j]</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(i == <span class="literal">null</span> || j == <span class="literal">null</span>)&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> i + j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1赋值给i</span></span><br><span class="line"><span class="keyword">add</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 按照顺序赋值</span></span><br><span class="line"><span class="keyword">add</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure></p>
<h4 id="默认参数值"><a href="#默认参数值" class="headerlink" title="默认参数值"></a>默认参数值</h4><p>在定义方法的时候，可选参数可以使用 <code>=</code> 来定义可选参数的默认值。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">([<span class="keyword">int</span> i = <span class="number">1</span>, <span class="keyword">int</span> j = <span class="number">2</span>])</span> </span>=&gt; i + j;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(&#123;<span class="keyword">int</span> i = <span class="number">1</span>, <span class="keyword">int</span> j = <span class="number">2</span>&#125;)</span> </span>=&gt; i + j;</span><br></pre></td></tr></table></figure></p>
<h4 id="匿名方法"><a href="#匿名方法" class="headerlink" title="匿名方法"></a>匿名方法</h4><p>没有名字的方法，称之为匿名方法，也可以称之为 lambda 或者 closure 闭包。匿名方法的声明为：<br><figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">([Type] param1, …) &#123; </span><br><span class="line">  codeBlock; </span><br><span class="line">&#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>如<br><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">list</span> = [<span class="string">'apples'</span>, <span class="string">'oranges'</span>, <span class="string">'grapes'</span>, <span class="string">'bananas'</span>, <span class="string">'plums'</span>];</span><br><span class="line"><span class="keyword">list</span>.<span class="keyword">forEach</span>((i) &#123;</span><br><span class="line">  <span class="keyword">print</span>(<span class="keyword">list</span>[i]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>和 Java 不同的是，所有的 Dart 异常是非检查异常。 方法不一定声明了他们所抛出的异常， 并且不要求你捕获任何异常。</p>
<p>Dart 提供了 <code>Exception</code>和<code>Error</code> 类型， 以及一些子类型。你还 可以定义自己的异常类型。但是， Dart 代码可以 抛出任何非 null 对象为异常，不仅仅是实现了 <code>Exception</code> 或者<code>Error</code> 的对象。<br><figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">Exception</span>(<span class="string">'这是一个异常'</span>);</span><br><span class="line"><span class="keyword">throw</span> <span class="string">'这是一个异常'</span>;</span><br><span class="line"><span class="keyword">throw</span> <span class="number">123</span>;</span><br></pre></td></tr></table></figure></p>
<p>与Java不同之处在于捕获异常部分，Dart中捕获异常同样是使用<code>catch</code>语句，但是Dart中的<code>catch</code>无法指定异常类型。需要结合<code>on</code>来使用，基本语法如下</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="keyword">throw</span> <span class="number">123</span>;</span><br><span class="line">&#125; <span class="keyword">on</span> <span class="built_in">int</span> <span class="keyword">catch</span>(e)&#123;</span><br><span class="line">	<span class="comment">//使用 on 指定捕获int类型的异常对象       </span></span><br><span class="line">&#125; <span class="keyword">catch</span>(e,s)&#123;</span><br><span class="line">    <span class="comment">//函数 catch() 可以带有一个或者两个参数， 第一个参数为抛出的异常对象， 第二个为堆栈信息 ( StackTrace 对象)</span></span><br><span class="line">    <span class="keyword">rethrow</span>; <span class="comment">//使用 `rethrow` 关键字可以 把捕获的异常给 重新抛出</span></span><br><span class="line">&#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><h4 id="工厂构造函数"><a href="#工厂构造函数" class="headerlink" title="工厂构造函数"></a>工厂构造函数</h4><p>当实现一个使用<code>factory</code> 关键词修饰的构造函数时，这个构造函数不必创建类的新实例。例如，一个工厂构造函数 可能从缓存中获取一个实例并返回，或者 返回一个子类型的实例。（工厂构造函数无法访问 <code>this</code>）<br>工厂构造函数可以实现单例<br><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用工厂构造实现单例</span></span><br><span class="line"><span class="keyword">class</span> Manager &#123;</span><br><span class="line">  <span class="keyword">static</span> Manager <span class="number">_</span><span class="keyword">instance</span>;</span><br><span class="line">  <span class="comment">//和static是一样的, 区别是factory毕竟是构造函数，需要返回一个实例，而static是静态方法。</span></span><br><span class="line">  factory Manager<span class="variable">.getInstance</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">_</span><span class="keyword">instance</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="number">_</span><span class="keyword">instance</span> =  <span class="keyword">new</span> Manager<span class="variable">._internal</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">_</span><span class="keyword">instance</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  static Manager getInstance() &#123;</span></span><br><span class="line"><span class="comment">//    if (_instance == null) &#123;</span></span><br><span class="line"><span class="comment">//      _instance = new Manager._internal();</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    return _instance;</span></span><br><span class="line"><span class="comment">//  &#125;</span></span><br><span class="line">  Manager<span class="variable">._internal</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="Getters-和-Setters"><a href="#Getters-和-Setters" class="headerlink" title="Getters 和 Setters"></a>Getters 和 Setters</h4><p>Dart中每个实例变量都隐含的具有一个 getter， 如果变量不是 final 的则还有一个 setter。可以通过实现 getter 和 setter 来创建新的属性， 使用 <code>get</code> 和 <code>set</code> 关键字定义 getter 和 setter：<br><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rect</span> &#123;</span></span><br><span class="line">  num left;</span><br><span class="line">  num top;</span><br><span class="line">  num <span class="built_in">width</span>;</span><br><span class="line">  num <span class="built_in">height</span>;</span><br><span class="line"></span><br><span class="line">  Rect(<span class="keyword">this</span>.left, <span class="keyword">this</span>.top, <span class="keyword">this</span>.<span class="built_in">width</span>, <span class="keyword">this</span>.<span class="built_in">height</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//使用 get定义了一个 right 属性</span></span><br><span class="line">  num <span class="built_in">get</span> right             =&gt; left + <span class="built_in">width</span>;</span><br><span class="line">  <span class="function"><span class="built_in">set</span> <span class="title">right</span><span class="params">(num value)</span>  </span>=&gt; left = value - <span class="built_in">width</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  var <span class="built_in">rect</span> = Rect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">  <span class="built_in">print</span>(<span class="built_in">rect</span>.right); <span class="comment">//10</span></span><br><span class="line">  <span class="built_in">rect</span>.right = <span class="number">15</span>;</span><br><span class="line">  <span class="built_in">print</span>(<span class="built_in">rect</span>.left);  <span class="comment">//5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="可覆写的操作符"><a href="#可覆写的操作符" class="headerlink" title="可覆写的操作符"></a>可覆写的操作符</h4><p>把已经定义的、有一定功能的操作符进行重新定义<br>比如：List就重写了[]<br><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> x;</span><br><span class="line">  <span class="keyword">int</span> y;</span><br><span class="line">  <span class="comment">//返回值 参数随你定义</span></span><br><span class="line">  Point <span class="keyword">operator</span> +(Point <span class="built_in">point</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> Point(x + <span class="built_in">point</span>.x, y + <span class="built_in">point</span>.y);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p1 = Point(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">var p2 = p1 + Point(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">print</span>(p2.x); <span class="comment">///3</span></span><br><span class="line"><span class="built_in">print</span>(p2.y); <span class="comment">///3</span></span><br></pre></td></tr></table></figure></p>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>使用 <code>abstract</code> 修饰符定义一个抽象类。抽象类中允许出现无方法体的方法<br><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">abstract <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> &#123;</span></span><br><span class="line">  <span class="keyword">String</span> name;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">printName</span><span class="params">()</span></span>; <span class="comment">//抽象方法，不需要在方法前声明 abstract</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>抽象类不能被实例化，除非定义工厂方法并返回子类<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> name;</span><br><span class="line">  <span class="comment">//默认构造方法</span></span><br><span class="line">  Parent(<span class="keyword">this</span>.name);</span><br><span class="line">  <span class="comment">//工厂方法返回Child实例</span></span><br><span class="line">  <span class="keyword">factory</span> Parent.test(<span class="built_in">String</span> name)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Child(name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">void</span> printName();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// extends 继承抽象类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">  Child(<span class="built_in">String</span> name) : <span class="keyword">super</span>(name);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> printName() &#123;</span><br><span class="line">    <span class="built_in">print</span>(name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> p = Parent.test(<span class="string">"Lance"</span>);</span><br><span class="line">  <span class="built_in">print</span>(p.runtimeType); <span class="comment">//输出实际类型 Child</span></span><br><span class="line">  p.printName();    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>与Java不同，Dart中没有<code>interface</code>关键字，<strong>Dart中每个类都隐式的定义了一个包含所有实例成员的接口</strong>， 并且这个类实现了这个接口。如果你想 创建类 A 来支持 类 B 的 方法，而不想继承 B 的实现， 则类 A 应该实现 B 的接口。<br><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">class</span> <span class="selector-tag">Listener</span>&#123;</span><br><span class="line">  <span class="selector-tag">void</span> <span class="selector-tag">onComplete</span>()&#123;&#125;</span><br><span class="line">  <span class="selector-tag">void</span> <span class="selector-tag">onFailure</span>()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">class</span> <span class="selector-tag">MyListsner</span> <span class="selector-tag">implements</span> <span class="selector-tag">Listener</span>&#123;</span><br><span class="line">  <span class="selector-tag">MyListsner</span>()&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable">@override</span></span><br><span class="line">  void onComplete() &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="variable">@override</span></span><br><span class="line">  void onFailure() &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>与继承的区别在于：<br>1、单继承，多实现。<br>2、继承可以有选择的重写父类方法并且可以使用<code>super</code>，实现强制重新定义接口所有成员</p>
<h3 id="可调用的类"><a href="#可调用的类" class="headerlink" title="可调用的类"></a>可调用的类</h3><p>如果 Dart 类实现了 <code>call()</code> 函数则 可以当做方法来调用。<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Closure</span> </span>&#123;</span><br><span class="line">  call(<span class="built_in">String</span> a, <span class="built_in">String</span> b) =&gt; <span class="string">'<span class="subst">$a</span> <span class="subst">$b</span>!'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="keyword">var</span> c = <span class="keyword">new</span> Closure();</span><br><span class="line">  <span class="keyword">var</span> out = c(<span class="string">"Hello"</span>,<span class="string">"Dart"</span>);</span><br><span class="line">  <span class="built_in">print</span>(out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="混合mixins"><a href="#混合mixins" class="headerlink" title="混合mixins"></a>混合mixins</h3><p>Mixins 是一种在多类继承中重用 一个类代码的方法。它的基本形式如下<br><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">//被mixin(混入)的类不能有构造函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>  </span>&#123;</span><br><span class="line">  void a()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line">  void b()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">with</span> <span class="title">A</span>,<span class="title">B</span></span>&#123;</span><br><span class="line">  void c()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>with</code>后面跟着需要混入的类，被<code>mixin</code>(混入)的类不能有构造函数。现在的 <code>C</code>拥有了三个方法（a、b与c）。假设A与B 存在相同的方法，以最右侧的混入类为主，比如：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="type">String</span> getMessage() =&gt; '<span class="type">A</span>';</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">  <span class="type">String</span> getMessage() =&gt; '<span class="type">B</span>';</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AB</span> <span class="keyword">with</span> <span class="title">A</span>, <span class="title">B</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BA</span>  <span class="keyword">with</span> <span class="title">B</span>, <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">void printMessage(obj) =&gt; print(obj.getMessage());</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">  printMessage(<span class="type">AB</span>()); <span class="comment">//输出 B</span></span><br><span class="line">  printMessage(<span class="type">BA</span>()); <span class="comment">//输出 A</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继承与mixins是兼容的</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="type">String</span> getMessage() =&gt; '<span class="type">A</span>';</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">  <span class="type">String</span> getMessage() =&gt; '<span class="type">B</span>';</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">P</span></span>&#123;</span><br><span class="line">  <span class="type">String</span> getMessage() =&gt; '<span class="type">P</span>';</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AB</span> <span class="keyword">extends</span> <span class="title">P</span> <span class="keyword">with</span> <span class="title">A</span>, <span class="title">B</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BA</span> <span class="keyword">extends</span> <span class="title">P</span> <span class="keyword">with</span> <span class="title">B</span>, <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">//可以简写成：</span></span><br><span class="line"><span class="comment">//class AB = P with A, B;</span></span><br><span class="line"><span class="comment">//class BA = P with B, A;</span></span><br><span class="line">void printMessage(obj) =&gt; print(obj.getMessage());</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">  printMessage(<span class="type">AB</span>()); <span class="comment">//输出 B</span></span><br><span class="line">  printMessage(<span class="type">BA</span>()); <span class="comment">//输出 A</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mixins弥补了接口和继承的不足，继承只能单继承，而接口无法复用实现，mixins却可以多混入并且能利用到混入类的具体实现：<br><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Swimming</span></span>&#123;</span><br><span class="line">    void swimming()&#123;</span><br><span class="line">        print(<span class="string">"游泳"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Jump</span></span>&#123;</span><br><span class="line">    void jump()&#123;</span><br><span class="line">        print(<span class="string">"跳跃"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//只能单继承，如果需要Jump，只能以implements的形式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lance</span> <span class="keyword">extends</span> <span class="title">Swimming</span> <span class="title">implements</span> <span class="title">Jump</span></span>&#123;</span><br><span class="line">  <span class="comment">//实现接口</span></span><br><span class="line">    void jump()&#123;</span><br><span class="line">        print(<span class="string">"跳跃"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//但是实际上，我们经常不需要重新实现Jump方法，复用Jump所实现的jump方法就可以了</span></span><br><span class="line"><span class="comment">//这时使用混合能够更加方便</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lance1</span> <span class="keyword">with</span> <span class="title">Swimming</span>, <span class="title">Jump</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>《HeadFirst设计模式》笔记1</title>
    <url>/blog/2020/09/headfirst-pattern-one.html</url>
    <content><![CDATA[<h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><p>1.找出应用中可能需要变化之处，把他们独立出来，不要和那些不需要变化的代码混合在一起<br>2.多用组合，少用继承<br>详情可见<br><a href="https://juejin.im/post/6844903713988050958#heading-10" target="_blank" rel="noopener">为什么组合优于继承</a></p>
<h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p>策略模式定义了算法族，分别封装起来，让它们之间可以相互替换，此模式让算法的变化独立于使用算法的客户。</p>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>AQS源码学习</title>
    <url>/blog/2020/09/aqs-lock-learn.html</url>
    <content><![CDATA[<h3 id="什么是AQS"><a href="#什么是AQS" class="headerlink" title="什么是AQS"></a>什么是AQS</h3><p>队列同步器AbstractQueuedSynchronizer（以下简称同步器或AQS），是用来构建锁或者其他同步组件的基础框架，它使用了一个int成员变量表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作。并发包的大师（Doug Lea）期望它能够成为实现大部分同步需求的基础。</p>
<p>AQS的主要使用方式是继承，子类通过继承AQS并实现它的抽象方法来管理同步状态，在AQS里由一个int型的state来代表这个状态，在抽象方法的实现过程中免不了要对同步状态进行更改，这时就需要使用同步器提供的3个方法（getState()、setState(int newState)和compareAndSetState(int expect,int update)）来进行操作，因为它们能够保证状态的改变是安全的。</p>
<p>在实现上，子类推荐被定义为自定义同步组件的静态内部类，AQS自身没有实现任何同步接口，它仅仅是定义了若干同步状态获取和释放的方法来供自定义同步组件使用，同步器既可以支持独占式地获取同步状态，也可以支持共享式地获取同步状态，这样就可以方便实现不同类型的同步组件（ReentrantLock、ReentrantReadWriteLock和CountDownLatch等）</p>
<p>同步器是实现锁（也可以是任意同步组件）的关键，在锁的实现中聚合同步器。可以这样理解二者之间的关系：<br>锁是面向使用者的，它定义了使用者与锁交互的接口（比如可以允许两个线程并行访问），隐藏了实现细节；<br>同步器面向的是锁的实现者，它简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、等待与唤醒等底层操作。锁和同步器很好地隔离了使用者和实现者所需关注的领域。</p>
<p>实现者需要继承同步器并重写指定的方法，随后将同步器组合在自定义同步组件的实现中，并调用同步器提供的模板方法，而这些模板方法将会调用使用者重写的方法。</p>
<h3 id="AQS设计模式"><a href="#AQS设计模式" class="headerlink" title="AQS设计模式"></a>AQS设计模式</h3><p><strong>模板方法模式</strong><br>同步器的设计基于模板方法模式。模板方法模式的意图是，定义一个操作中的算法的骨架，而将一些步骤的实现延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。我们最常见的就是Activity中的生命周期</p>
<p>AQS中即用到了模板方法模式</p>
<h3 id="CLH"><a href="#CLH" class="headerlink" title="CLH"></a>CLH</h3><p>CLH队列锁即Craig, Landin, and Hagersten (CLH) locks。<br>CLH队列锁也是一种基于链表的可扩展、高性能、公平的自旋锁，申请线程仅仅在本地变量上自旋，它不断轮询前驱的状态，假设发现前驱释放了锁就结束自旋。<br>当一个线程需要获取锁时：<br>1.创建一个的QNode，将其中的locked设置为true表示需要获取锁，myPred表示对其前驱结点的引用<br>2.线程A对tail域调用getAndSet方法，使自己成为队列的尾部，同时获取一个指向其前驱结点的引用myPred。线程B需要获得锁，同样的流程再来一遍<br>3.线程就在前驱结点的locked字段上旋转，直到前驱结点释放锁(前驱节点的锁值 locked == false)<br>4.当一个线程需要释放锁时，将当前结点的locked域设置为false，同时回收前驱结点<br>前驱结点释放锁，线程A的myPred所指向的前驱结点的locked字段变为false，线程A就可以获取到锁。<br>CLH队列锁的优点是空间复杂度低（如果有n个线程，L个锁，每个线程每次只获取一个锁，那么需要的存储空间是O（L+n），n个线程有n个myNode，L个锁有L个tail）。CLH队列锁常用在SMP体系结构下。<br>Java中的AQS是CLH队列锁的一种变体实现。</p>
<h3 id="ReentrantLock的实现"><a href="#ReentrantLock的实现" class="headerlink" title="ReentrantLock的实现"></a>ReentrantLock的实现</h3><h4 id="锁的可重入"><a href="#锁的可重入" class="headerlink" title="锁的可重入"></a>锁的可重入</h4><p>重进入是指任意线程在获取到锁之后能够再次获取该锁而不会被锁所阻塞，该特性的实现需要解决以下两个问题。<br>1）线程再次获取锁。锁需要去识别获取锁的线程是否为当前占据锁的线程，如果是，则再次成功获取。<br>2）锁的最终释放。线程重复n次获取了锁，随后在第n次释放该锁后，其他线程能够获取到该锁。锁的最终释放要求锁对于获取进行计数自增，计数表示当前锁被重复获取的次数，而锁被释放时，计数自减，当计数等于0时表示锁已经成功释放。<br>nonfairTryAcquire方法增加了再次获取同步状态的处理逻辑：通过判断当前线程是否为获取锁的线程来决定获取操作是否成功，如果是获取锁的线程再次请求，则将同步状态值进行增加并返回true，表示获取同步状态成功。同步状态表示锁被一个线程重复获取的次数。<br>如果该锁被获取了n次，那么前(n-1)次tryRelease(int releases)方法必须返回false，而只有同步状态完全释放了，才能返回true。可以看到，该方法将同步状态是否为0作为最终释放的条件，当同步状态为0时，将占有线程设置为null，并返回true，表示释放成功。</p>
<h3 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h3><p>ReentrantLock的构造函数中，默认的无参构造函数将会把Sync对象创建为NonfairSync对象，这是一个“非公平锁”；而另一个构造函数ReentrantLock(boolean fair)传入参数为true时将会把Sync对象创建为“公平锁”FairSync。<br>nonfairTryAcquire(int acquires)方法，对于非公平锁，只要CAS设置同步状态成功，则表示当前线程获取了锁，而公平锁则不同。tryAcquire方法，该方法与nonfairTryAcquire(int acquires)比较，唯一不同的位置为判断条件多了hasQueuedPredecessors()方法，即加入了同步队列中当前节点是否有前驱节点的判断，如果该方法返回true，则表示有线程比当前线程更早地请求获取锁，因此需要等待前驱线程获取并释放锁之后才能继续获取锁。</p>
<h3 id="手写独占锁"><a href="#手写独占锁" class="headerlink" title="手写独占锁"></a>手写独占锁</h3><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *类说明：实现我们自己独占锁,不可重入</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelfLock</span> <span class="keyword">implements</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 静态内部类，自定义同步器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*判断处于占用状态*/</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="function"><span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getState()==<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*获得锁*/</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="function"><span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(compareAndSetState(<span class="number">0</span>,<span class="number">1</span>))&#123;</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*释放锁*/</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="function"><span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(getState()==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            &#125;</span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            setState(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 返回一个Condition，每个condition都包含了一个condition队列*/</span></span><br><span class="line">        <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 仅需要将操作代理到Sync上即可*/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	System.out.println(Thread.currentThread().getName()+<span class="string">" ready get lock"</span>);</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">" already got lock"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> sync.<span class="title">tryAcquire</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	System.out.println(Thread.currentThread().getName()+<span class="string">" ready release lock"</span>);</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">" already released lock"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> sync.<span class="title">newCondition</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> sync.<span class="title">isHeldExclusively</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">hasQueuedThreads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> sync.<span class="title">hasQueuedThreads</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>AQS是用来构建锁或者其他同步组件的基础框架，比如ReentrantLock、ReentrantReadWriteLock和CountDownLatch就是基于AQS实现的。它使用了一个int成员变量表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作。它是CLH队列锁的一种变体实现。它可以实现2种同步方式：独占式，共享式。<br>AQS的主要使用方式是继承，子类通过继承AQS并实现它的抽象方法来管理同步状态，同步器的设计基于模板方法模式，所以如果要实现我们自己的同步工具类就需要覆盖其中几个可重写的方法，如tryAcquire、tryReleaseShared等等。<br>这样设计的目的是同步组件（比如锁）是面向使用者的，它定义了使用者与同步组件交互的接口（比如可以允许两个线程并行访问），隐藏了实现细节；同步器面向的是锁的实现者，它简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、等待与唤醒等底层操作。这样就很好地隔离了使用者和实现者所需关注的领域。<br>在内部，AQS维护一个共享资源state，通过内置的FIFO来完成获取资源线程的排队工作。该队列由一个一个的Node结点组成，每个Node结点维护一个prev引用和next引用，分别指向自己的前驱和后继结点，构成一个双端双向链表。</p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Dart异步编程</title>
    <url>/blog/2020/09/dart-async-program.html</url>
    <content><![CDATA[<h3 id="isolate机制"><a href="#isolate机制" class="headerlink" title="isolate机制"></a>isolate机制</h3><p>Dart是基于单线程模型的语言。但是在开发当中我们经常会进行耗时操作比如网络请求，这种耗时操作会堵塞我们的代码，所以在Dart也有并发机制，名叫<strong>isolate</strong>。APP的启动入口<code>main</code>函数就是一个类似Android主线程的一个主isolate。和Java的Thread不同的是，Dart中的isolate无法共享内存</p>
<p><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog6/p11.png" alt></p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:isolate'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  i = <span class="number">10</span>;</span><br><span class="line">  <span class="comment">//创建一个消息接收器</span></span><br><span class="line">  ReceivePort receivePort = <span class="keyword">new</span> ReceivePort();</span><br><span class="line">  <span class="comment">//创建isolate</span></span><br><span class="line">  Isolate.spawn(isolateMain, receivePort.sendPort);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//接收其他isolate发过来的消息</span></span><br><span class="line">  receivePort.listen((message) &#123;</span><br><span class="line">    <span class="comment">//发过来sendPort,则主isolate也可以向创建的isolate发送消息</span></span><br><span class="line">    <span class="keyword">if</span> (message <span class="keyword">is</span> SendPort) &#123;</span><br><span class="line">      message.send(<span class="string">"好呀好呀!"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">"接到子isolate消息:"</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// <span class="markdown">新isolate的入口函数</span></span></span><br><span class="line"><span class="keyword">void</span> isolateMain(SendPort sendPort) &#123;</span><br><span class="line">  <span class="comment">// isolate是内存隔离的，i的值是在主isolate定义的所以这里获得null</span></span><br><span class="line">  <span class="built_in">print</span>(i);</span><br><span class="line"></span><br><span class="line">  ReceivePort receivePort = <span class="keyword">new</span> ReceivePort();</span><br><span class="line">  sendPort.send(receivePort.sendPort);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向主isolate发送消息</span></span><br><span class="line">  sendPort.send(<span class="string">"去大保健吗？"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  receivePort.listen((message) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"接到主isolate消息:"</span> + message);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="event-loop"><a href="#event-loop" class="headerlink" title="event-loop"></a>event-loop</h3><p>可以看到代码中，我们接收消息使用了<code>listene</code>函数来监听消息。假设我们现在在main方法最后加入<code>sleep</code>休眠，会不会影响<code>listene</code>回调的时机？<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:io'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'dart:isolate'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  i = <span class="number">10</span>;</span><br><span class="line">  <span class="comment">//创建一个消息接收器</span></span><br><span class="line">  ReceivePort receivePort = <span class="keyword">new</span> ReceivePort();</span><br><span class="line">  <span class="comment">//创建isolate</span></span><br><span class="line">  Isolate.spawn(isolateMain, receivePort.sendPort);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//接收其他isolate发过来的消息</span></span><br><span class="line">  receivePort.listen((message) &#123;</span><br><span class="line">    <span class="comment">//发过来sendPort,则主isolate也可以向创建的isolate发送消息</span></span><br><span class="line">    <span class="keyword">if</span> (message <span class="keyword">is</span> SendPort) &#123;</span><br><span class="line">      message.send(<span class="string">"好呀好呀!"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">"接到子isolate消息:"</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//增加休眠，是否会影响listen的时机？</span></span><br><span class="line">  sleep(<span class="built_in">Duration</span>(seconds: <span class="number">2</span>));</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"休眠完成"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// <span class="markdown">新isolate的入口函数</span></span></span><br><span class="line"><span class="keyword">void</span> isolateMain(SendPort sendPort) &#123;</span><br><span class="line">  <span class="comment">// isolate是内存隔离的，i的值是在主isolate定义的所以这里获得null</span></span><br><span class="line">  <span class="built_in">print</span>(i);</span><br><span class="line"></span><br><span class="line">  ReceivePort receivePort = <span class="keyword">new</span> ReceivePort();</span><br><span class="line">  sendPort.send(receivePort.sendPort);</span><br><span class="line">  <span class="comment">// 向主isolate发送消息</span></span><br><span class="line">  sendPort.send(<span class="string">"去大保健吗？"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  receivePort.listen((message) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"接到主isolate消息:"</span> + message);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>结果是大概2s后，我们的<code>listene</code>才打印出其他isolate发过来的消息。同Android Handler类似，在Dart运行环境中也是靠事件驱动的，通过event loop不停的从队列中获取消息或者事件来驱动整个应用的运行，isolate发过来的消息就是通过loop处理。但是不同的是在Android中每个线程只有一个Looper所对应的MessageQueue，而Dart中有两个队列，一个叫做<strong>event queue(事件队列)</strong>，另一个叫做<strong>microtask queue(微任务队列)</strong>。</p>
<p><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog6/p12.png" alt><br>Dart在执行完main函数后，就会由Loop开始执行两个任务队列中的Event。首先Loop检查微服务队列，依次执行Event，当微服务队列执行完后，就检查Event queue队列依次执行，在执行Event queue的过程中，没执行完一个Event就再检查一次微服务队列。所以微服务队列优先级高，可以利用微服务进行插队</p>
<p>我们先来看个例子:<br><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:io'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main()&#123;</span><br><span class="line">  <span class="keyword">new</span> <span class="keyword">File</span>(<span class="string">"/Users/enjoy/a.txt"</span>).readAsString().then((content)&#123;</span><br><span class="line">      <span class="keyword">print</span>(content);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>文件内容永远也无法打印出来，因为main函数还没执行完。而then方法是由Loop检查Event queue执行的。<br>如果需要往微服务中插入Event进行插队：<br><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:async'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'dart:io'</span>;</span><br><span class="line"><span class="comment">//结果是限制性了microtask然后执行then方法。</span></span><br><span class="line"><span class="keyword">void</span> main()&#123;</span><br><span class="line">  <span class="keyword">new</span> <span class="keyword">File</span>(<span class="string">"/Users/enjoy/a.txt"</span>).readAsString().then((content)&#123;</span><br><span class="line">      <span class="keyword">print</span>(content);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">//future内部就是调用了 scheduleMicrotask</span></span><br><span class="line">  Future.microtask(()&#123;</span><br><span class="line">    <span class="keyword">print</span>(<span class="string">"future: excute microtask"</span>);</span><br><span class="line"></span><br><span class="line">  &#125;);</span><br><span class="line"><span class="comment">//  scheduleMicrotask(()&#123;</span></span><br><span class="line"><span class="comment">//    print("");</span></span><br><span class="line"><span class="comment">//  &#125;);</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h3><p>在 Dart 库中随处可见 Future 对象，通常异步函数返回的对象就是一个 Future。 当一个 future <em>执行完后</em>，他里面的值 就可以使用了，可以使用 <code>then()</code> 来在 future 完成的时候执行其他代码。Future对象其实就代表了在事件队列中的一个事件的结果。</p>
<h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当给到一个不存在的文件地址时会发生异常，这时候可以利用catchError捕获此异常。</span></span><br><span class="line"><span class="comment">//then().catchError() 模式就是异步的 try-catch。</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">File</span>(<span class="string">"/Users/enjoy/a1.txt"</span>).readAsString().then((content) &#123;</span><br><span class="line">    <span class="built_in">print</span>(content);</span><br><span class="line">  &#125;).catchError((e, s) &#123;</span><br><span class="line">    <span class="built_in">print</span>(s);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<h4 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h4><p><code>then()</code>的返回值同样是一个future对象，可以利用队列的原理进行组合异步任务</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">File</span>(<span class="string">"/Users/enjoy/a.txt"</span>).readAsString().then((content) &#123;</span><br><span class="line">   <span class="built_in">print</span>(content);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//1被转化为 Future&lt;int&gt;类型 返回</span></span><br><span class="line"> &#125;).then((i)&#123;</span><br><span class="line">   <span class="built_in">print</span>(i);</span><br><span class="line"> &#125;).catchError((e, s) &#123;</span><br><span class="line">   <span class="built_in">print</span>(s);</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure>
<p>上面的方式是等待执行完成读取文件之后，再执行一个新的future。如果我们需要等待一组任务都执行完成再统一处理一些事情，可以通过<code>wait()</code>完成。<br><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">Future readDone = <span class="keyword">new</span> <span class="built_in">File</span>(<span class="string">"/Users/enjoy/a.txt"</span>).readAsString();</span><br><span class="line">  <span class="comment">//延迟3s</span></span><br><span class="line">  Future delayedDone = Future.delayed(Duration(seconds: <span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">  Future.wait([readDone, delayedDone]).then((values) &#123;</span><br><span class="line">     <span class="built_in">print</span>(values[<span class="number">0</span>]);<span class="comment">//第一个future的结果</span></span><br><span class="line">     <span class="built_in">print</span>(values[<span class="number">1</span>]);<span class="comment">//第二个future的结果</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h3><p>Stream(流) 在 Dart API 中也经常出现，表示发出的一系列的异步数据。 Stream 是一个异步数据源，它是 Dart 中处理异步事件流的统一 API。</p>
<p>​    Future 表示稍后获得的一个数据，所有异步的操作的返回值都用 Future 来表示。但是 Future 只能表示一次异步获得的数据。而 Stream 表示多次异步获得的数据。比如 IO 处理的时候，每次只会读取一部分数据和一次性读取整个文件的内容相比，Stream 的好处是处理过程中内存占用较小。而 File 的 <code>readAsString()</code>是一次性读取整个文件的内容进来，虽然获得完整内容处理起来比较方便，但是如果文件很大的话就会导致内存占用过大的问题。<br><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">File</span>(<span class="string">"/Users/enjoy/app-release.apk"</span>).openRead().<span class="built_in">listen</span>((List&lt;<span class="keyword">int</span>&gt; bytes) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"stream执行"</span>); <span class="comment">//执行多次</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">File</span>(<span class="string">"/Users/enjoy/app-release.apk"</span>).readAsBytes().then((_)&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"future执行"</span>); <span class="comment">//执行1次</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></p>
<p><code>listen()</code>其实就是订阅这个Stream，它会返回一个<code>StreamSubscription</code>订阅者。订阅者肯定就提供了取消订阅的<code>cancel()</code>，去掉后我们的listen中就接不到任何信息了。除了<code>cancel()</code>取消方法之外，我们还可以使用<code>onData()</code>重置listene方法，<code>onDone</code>监听完成等等操作。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">StreamSubscription&lt;List&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">listen</span> = <span class="keyword">new</span> <span class="built_in">File</span>(<span class="string">"/Users/enjoy/app-release.apk"</span>).openRead().<span class="built_in">listen</span>((List&lt;<span class="keyword">int</span>&gt; bytes) &#123;</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">"stream执行"</span>);</span><br><span class="line"> &#125;);</span><br><span class="line"> <span class="built_in">listen</span>.onData((_)&#123;</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">"替代listene"</span>);</span><br><span class="line"> &#125;);</span><br><span class="line"> <span class="built_in">listen</span>.onDone(()&#123;</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">"结束"</span>);</span><br><span class="line"> &#125;);</span><br><span class="line"> <span class="built_in">listen</span>.onError((e,s)&#123;</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">"异常"</span>);</span><br><span class="line"> &#125;);</span><br><span class="line"> <span class="comment">//暂停，如果没有继续则会退出程序</span></span><br><span class="line"> <span class="built_in">listen</span>.pause();</span><br><span class="line"> <span class="comment">//继续</span></span><br><span class="line"> <span class="built_in">listen</span>.resume();</span><br></pre></td></tr></table></figure>
<h3 id="广播模式"><a href="#广播模式" class="headerlink" title="广播模式"></a>广播模式</h3><p>Stream有两种订阅模式：单订阅和多订阅。单订阅就是只能有一个订阅者，上面的使用我们都是单订阅模式，而广播是可以有多个订阅者。通过 Stream.asBroadcastStream() 可以将一个单订阅模式的 Stream 转换成一个多订阅模式的 Stream，isBroadcast 属性可以判断当前 Stream 所处的模式。<br><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">var stream = <span class="keyword">new</span> <span class="built_in">File</span>(<span class="string">"/Users/enjoy/app-release.apk"</span>).openRead();</span><br><span class="line">  stream.<span class="built_in">listen</span>((List&lt;<span class="keyword">int</span>&gt; bytes) &#123;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">//错误 单订阅只能有一个订阅者</span></span><br><span class="line"><span class="comment">//  stream.listen((_)&#123;</span></span><br><span class="line"><span class="comment">//    print("stream执行");</span></span><br><span class="line"><span class="comment">//  &#125;);</span></span><br><span class="line"></span><br><span class="line">  var broadcastStream = <span class="keyword">new</span> <span class="built_in">File</span>(<span class="string">"/Users/enjoy/app-release.apk"</span>).openRead().asBroadcastStream();</span><br><span class="line">  broadcastStream.<span class="built_in">listen</span>((_)&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"订阅者1"</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  broadcastStream.<span class="built_in">listen</span>((_)&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"订阅者2"</span>);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></p>
<p>需要注意的是，多订阅模式如果没有及时添加订阅者则可能丢数据</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">//默认是单订阅</span></span><br><span class="line">  <span class="keyword">var</span> stream = Stream.fromIterable([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">  <span class="comment">//3s后添加订阅者 不会丢失数据</span></span><br><span class="line">  <span class="keyword">new</span> Timer(<span class="keyword">new</span> <span class="built_in">Duration</span>(seconds: <span class="number">3</span>), () =&gt; stream.listen(<span class="built_in">print</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">//创建一个流管理器 对一个stream进行管理</span></span><br><span class="line">  <span class="keyword">var</span> streamController = StreamController.broadcast();</span><br><span class="line">  <span class="comment">//添加</span></span><br><span class="line">  streamController.add(<span class="number">1</span>);</span><br><span class="line">  <span class="comment">//先发出事件再订阅 无法接到通知</span></span><br><span class="line">  streamController.stream.listen((i)&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"broadcast:<span class="subst">$i</span>"</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">//记得关闭</span></span><br><span class="line">  streamController.close();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//这里没有丢失，因为stream通过asBroadcastStream转为了多订阅，但是本质是单订阅流，并不改变原始 stream 的实现特性</span></span><br><span class="line">  <span class="keyword">var</span> broadcastStream = Stream.fromIterable([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]).asBroadcastStream();</span><br><span class="line">  <span class="keyword">new</span> Timer(<span class="keyword">new</span> <span class="built_in">Duration</span>(seconds: <span class="number">3</span>), () =&gt; broadcastStream.listen(<span class="built_in">print</span>));</span><br></pre></td></tr></table></figure>
<h3 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h3><p>使用<code>async</code>和<code>await</code>的代码是异步的，但是看起来很像同步代码。当我们需要获得A的结果，再执行B，时，你需要<code>then()-&gt;then()</code>,但是利用<code>async</code>与<code>await</code>能够非常好的解决回调地狱的问题：<br><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">//async 表示这是一个异步方法,await必须再async方法中使用</span></span><br><span class="line"><span class="comment">//异步方法只能返回 void和Future</span></span><br><span class="line"><span class="function">Future&lt;<span class="keyword">String</span>&gt; <span class="title">readFile</span><span class="params">()</span> async </span>&#123;</span><br><span class="line">  <span class="comment">//await 等待future执行完成再执行后续代码</span></span><br><span class="line">  <span class="keyword">String</span> content = await <span class="keyword">new</span> <span class="built_in">File</span>(<span class="string">"/Users/xiang/enjoy/a.txt"</span>).readAsString();</span><br><span class="line">  <span class="keyword">String</span> content2 = await <span class="keyword">new</span> <span class="built_in">File</span>(<span class="string">"/Users/xiang/enjoy/a.txt"</span>).readAsString();</span><br><span class="line">  <span class="comment">//自动转换为 future</span></span><br><span class="line">  <span class="keyword">return</span> content;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="利用多订阅广播，实现一个Event-Bus"><a href="#利用多订阅广播，实现一个Event-Bus" class="headerlink" title="利用多订阅广播，实现一个Event-Bus"></a>利用多订阅广播，实现一个Event-Bus</h3><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:async'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventBus</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> EventBus _instance;</span><br><span class="line">  StreamController _streamController;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">factory</span> EventBus.getDefault() &#123;</span><br><span class="line">    <span class="keyword">return</span> _instance ??= EventBus._internal();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  EventBus._internal() &#123;</span><br><span class="line">    _streamController = StreamController.broadcast();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  StreamSubscription&lt;T&gt; regiest&lt;T&gt;(<span class="keyword">void</span> onData(T event)) &#123;</span><br><span class="line">    <span class="comment">///<span class="markdown">todo 需要返回订阅者，所以不能使用下面这种形式</span></span></span><br><span class="line"><span class="comment">//   return _streamController.stream.listen((event) &#123;</span></span><br><span class="line"><span class="comment">//      if (event is T) &#123;</span></span><br><span class="line"><span class="comment">//        onData(event);</span></span><br><span class="line"><span class="comment">//      &#125;</span></span><br><span class="line"><span class="comment">//    &#125;);</span></span><br><span class="line">    <span class="comment">///<span class="markdown">没有指定类型，全类型注册</span></span></span><br><span class="line">    <span class="keyword">if</span> (T == <span class="built_in">dynamic</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> _streamController.stream.listen(onData);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">///<span class="markdown">筛选出 类型为 T 的数据,获得只包含T的Stream</span></span></span><br><span class="line">      Stream&lt;T&gt; stream =</span><br><span class="line">          _streamController.stream.where((type) =&gt; type <span class="keyword">is</span> T).cast&lt;T&gt;();</span><br><span class="line">      <span class="keyword">return</span> stream.listen(onData);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> post(event) &#123;</span><br><span class="line">    _streamController.add(event);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> destroy() &#123;</span><br><span class="line">    _streamController.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  EventBus.getDefault().regiest((s) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"全类型注册:<span class="subst">$s</span>"</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  EventBus.getDefault().regiest&lt;<span class="built_in">String</span>&gt;((s) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"字符串注册:<span class="subst">$s</span>"</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  EventBus.getDefault().regiest&lt;<span class="built_in">int</span>&gt;((s) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"int注册:<span class="subst">$s</span>"</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  EventBus.getDefault().post(<span class="string">"哈哈"</span>);</span><br><span class="line">  EventBus.getDefault().post(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  EventBus.getDefault().post(<span class="number">10086.11</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>你应该知道的Git常用操作</title>
    <url>/blog/2020/09/git-flow-learn.html</url>
    <content><![CDATA[<h3 id="常规的提交代码流程"><a href="#常规的提交代码流程" class="headerlink" title="常规的提交代码流程"></a>常规的提交代码流程</h3><p>0.首先执行git pull –rebase 拉取最新代码</p>
<p>1.修改完本地代码后，执行git add .,将所有改动暂存</p>
<p>2.执行git status,查看当前文件状态，确保要提交的文件都已经暂存</p>
<p>3.执行git commit -m “ADD:hello world”，提交一个新的commit</p>
<p>4.确认代码已经改完了，准备push到远程仓库，在此被前还有再执行一遍git pull –rebase 来合并远程仓库的最新代码，因为在修改代码这段时间 可能有其他人的新提交。</p>
<p>5.如果上一步遇到冲突，需要处理完冲突才能继续，推荐使用Android Studio的冲突处理工具“项目-》右键-》Git-&gt;Resolve Conflicts”</p>
<p>6.冲突处理完成后，执行git push origin master将代码提交到远程master分支(假设当前在master分支上)</p>
<p>7.所有push的代码都会经过Gerrit,review完成后才会合并到远程仓库，push完成后就可以通知其他人review了</p>
<p>8.review的基本流程，发现问题-》修改代码-》执行git add. 将最新改动暂存-》执行git commit -amend 将改动添加到刚才的commit中去 -》 git push将代码推送到Gerrit -》重复直到review通过.</p>
<p><a href="https://www.douban.com/note/318248317/" target="_blank" rel="noopener">https://www.douban.com/note/318248317/</a></p>
<h4 id="git-amend使用"><a href="#git-amend使用" class="headerlink" title="git amend使用"></a>git amend使用</h4><p>有时你提交过代码之后，发现一个地方改错了，你下次提交时不想保留上一次的记录；或者你上一次的commit message的描述有误，这时候你可以使用接下来的这个命令：git commit –amend。</p>
<p>git amend适用于本地commit或者CodeReview，如果用于已经推送到远程的commit，需要合并代码<br>详情可见：<a href="https://zhuanlan.zhihu.com/p/100243017" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/100243017</a></p>
<h4 id="git合并多个提交"><a href="#git合并多个提交" class="headerlink" title="git合并多个提交"></a>git合并多个提交</h4><p>有时候在一个分支的多次意义相近的 commit，会把整个提交历史搞得很混乱，此时可以将一部分的 commit 合并为一个 commit，以美化整个 commit 历史，可以使用 rebase 的方法来合并多次 commit，主要步骤如下：<br><a href="https://www.cnblogs.com/zhaoyingjie/p/10259715.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhaoyingjie/p/10259715.html</a></p>
<h4 id="git删除某个commit"><a href="#git删除某个commit" class="headerlink" title="git删除某个commit"></a>git删除某个commit</h4><p>同样的，利用 git 压缩 rebase 指令来删除某个 commit，过程和以上是类似的；<br><a href="https://www.cnblogs.com/zhaoyingjie/p/10259715.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhaoyingjie/p/10259715.html</a></p>
<h4 id="为什么推荐使用git-merge-–no-ff"><a href="#为什么推荐使用git-merge-–no-ff" class="headerlink" title="为什么推荐使用git merge –no-ff"></a>为什么推荐使用git merge –no-ff</h4><p>在merge代码时，推荐使用–no-ff模式<br><a href="https://www.jianshu.com/p/418323ed2b03" target="_blank" rel="noopener">https://www.jianshu.com/p/418323ed2b03</a></p>
<h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><h4 id="合并branchA到branchB的常规操作"><a href="#合并branchA到branchB的常规操作" class="headerlink" title="合并branchA到branchB的常规操作"></a>合并branchA到branchB的常规操作</h4><p>1.git checkout branchB 切换到branchB</p>
<p>2.git pull –rebase 拉取branchB的最新代码</p>
<p>3.git merge origin/branchA 合并branchA最新代码</p>
<p>4.处理可能遇到的冲突</p>
<p>5.检查两个分支合并的commit-id无误后，执行git push origin barnchB将代码提交到远程的branchB分支</p>
<h4 id="包含submodule的分支切换"><a href="#包含submodule的分支切换" class="headerlink" title="包含submodule的分支切换"></a>包含submodule的分支切换</h4><p>1.A分支切换到B分支时，必做！！</p>
<p>git status，查看子module状态</p>
<p>2.发现子module有新提交</p>
<p>切换分支时，子module不会跟着更新，新的分支可能引用的不是当前的节点了</p>
<p>所以需要git submodule update –init –recursive更新一下。</p>
<p>再次执行git status查看状态。通常情况下都会没问题</p>
<p>3.发现子module有为untraced文件</p>
<p>A分支存在一子module,但是B分支没有。这时切换到B的时候，这个子module中包含的文件就当做是未提交的文件了。</p>
<p>这种情况下执行：git submodule foreach –recursive git clean -ffd</p>
<p>或者进入对应目录，手动执行git clean -ffd</p>
<p>4.发现子module有modified</p>
<p>A分支不包含B分支存在的一个module,但是有一个文件夹是B分支的子module名字，执行update时，这个子module不会被checkout,所以内容还是A的样子</p>
<p>这种情况下执行：git submodule foreach –recursive git checkout . 或者进入对应子module,手动执行git checkout .</p>
<h4 id="分支命名规范"><a href="#分支命名规范" class="headerlink" title="分支命名规范"></a>分支命名规范</h4><p>1.feature分支格式:feature/featureName,注意大小写，例如：feature/appDaily</p>
<p>2.release分支格式：releases/1.0.x在封版日，将所有需求合并到该分支，之后的灰度和全量候bug都在上面完成</p>
<p>3.hotfixes分支格式：hotfix/version,例如：hotfix/3.18.1</p>
<p>4.tag格式：[version],示例:3.17.0     3.17.0_grey</p>
<h4 id="分支工作流程"><a href="#分支工作流程" class="headerlink" title="分支工作流程"></a>分支工作流程</h4><p>1.master:管理发布状态，使用标签记录发布版本号</p>
<p>2.develop:日常开发分支</p>
<p>3.release:为每次发布做准备，分离develop分支，在完成发布后merge到master的develop分支</p>
<p>4.hotfixes:快速修复上线后的bug</p>
<p>5.feature:用于跨发布周期的，独立的功能开发。</p>
<h4 id="日常工作流程"><a href="#日常工作流程" class="headerlink" title="日常工作流程"></a>日常工作流程</h4><p>1.日常在develop开发</p>
<p>2.如果有比较大的功能或者其他需求，那么新开分支：feature/xxx 来做，并在这个分支上进行打包和提测。</p>
<p>3.在封版日，将该版本上线的需求合并到develop，然后将开个新的分支release/版本号(如release/1.0.1),将develop合并至该分支。</p>
<p>4.灰度阶段，在releases/版本号 分支上修复BUG，打包并发布，同时在对应的commit上打上tag:{版本号}_grey</p>
<p>5.官网及全量阶段，在修复完成后，打包并发官网和全量，同时在对应的commit上打上tag:{版本号}。之后将releases/{版本号}分支合并到master与develop</p>
<p>6.灰度，官网全量过程中，如果需要发小版本，仍然在该分支进行，完成后，打上tag</p>
<p>7.如果在全量发布后，发现线上有问题，那么在对应的master分支上新开分支hotfix/{版本号}来修复，并升级版本号，修复完成后发版，同时在对应的commit上打上tag:{版本号}，然后将hotfix合并到master，同时将合并到develop</p>
<h4 id="git-commit-message规范"><a href="#git-commit-message规范" class="headerlink" title="git commit message规范"></a>git commit message规范</h4><p>所有commit message，除了merge时系统自动生成的，均应遵循以下格式</p>
<p>OPERATION: description</p>
<p>一次提交可以有多个OPERATION,但最好只有一个，多个OPERATION一行一个。</p>
<table>
<thead>
<tr>
<th>OPERATION</th>
<th>何时使用</th>
<th>description应该写什么</th>
</tr>
</thead>
<tbody>
<tr>
<td>ADD</td>
<td>增加功能/文件</td>
<td>增加了什么功能/文件(文件太多可以写目录)</td>
</tr>
<tr>
<td>MOD</td>
<td>修改功能/文件</td>
<td>修改了什么功能/文件, 以及修改原因</td>
</tr>
<tr>
<td>DEL</td>
<td>删除功能/文件</td>
<td>删除了什么功能/文件, 以及删除原因</td>
</tr>
<tr>
<td>FIX</td>
<td>修复 bug</td>
<td>说明解决的问题是什么, 如果在 jira 上有相应 bug 报告, 要写 ISSUE_ID</td>
</tr>
<tr>
<td>RFCT</td>
<td>重构</td>
<td>重构了什么</td>
</tr>
<tr>
<td>CLN</td>
<td>清理</td>
<td>清理了什么</td>
</tr>
</tbody>
</table>
<h3 id="git-stash使用"><a href="#git-stash使用" class="headerlink" title="git stash使用"></a>git stash使用</h3><p>（1）git stash save “save message”  : 执行存储时，添加备注，方便查找，只有git stash 也要可以的，但查找时不方便识别。</p>
<p>（2）git stash list  ：查看stash了哪些存储</p>
<p>（3）git stash show ：显示做了哪些改动，默认show第一个存储,如果要显示其他存贮，后面加stash@{$num}，比如第二个 git stash show stash@{1}</p>
<p>（4）git stash show -p : 显示第一个存储的改动，如果想显示其他存存储，命令：git stash show  stash@{$num}  -p ，比如第二个：git stash show  stash@{1}  -p</p>
<p>（5）git stash apply :应用某个存储,但不会把存储从存储列表中删除，默认使用第一个存储,即stash@{0}，如果要使用其他个，git stash apply stash@{$num} ， 比如第二个：git stash apply stash@{1} </p>
<p>（6）git stash pop ：命令恢复之前缓存的工作目录，将缓存堆栈中的对应stash删除，并将对应修改应用到当前的工作目录下,默认为第一个stash,即stash@{0}，如果要应用并删除其他stash，命令：git stash pop stash@{$num} ，比如应用并删除第二个：git stash pop stash@{1}</p>
<p>（7）git stash drop stash@{$num} ：丢弃stash@{$num}存储，从列表中删除这个存储</p>
<p>（8）git stash clear ：删除所有缓存的stash</p>
<h3 id="git常用指令"><a href="#git常用指令" class="headerlink" title="git常用指令"></a>git常用指令</h3><h4 id="1-还原指令"><a href="#1-还原指令" class="headerlink" title="1.还原指令"></a>1.还原指令</h4><p>git reset –hard HEAD</p>
<h4 id="2-远程分支强制覆盖本地"><a href="#2-远程分支强制覆盖本地" class="headerlink" title="2.远程分支强制覆盖本地"></a>2.远程分支强制覆盖本地</h4><p>git fetch –all<br>git reset –hard origin/master </p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://blog.csdn.net/xingbaozhen1210/article/details/81386269" target="_blank" rel="noopener">GitFlow详解教程</a><br><a href="https://www.cnblogs.com/zndxall/archive/2018/09/04/9586088.html" target="_blank" rel="noopener">git stash 用法总结和注意点</a></p>
]]></content>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>mac快捷键总结</title>
    <url>/blog/2020/09/mac-shortcurt-sum.html</url>
    <content><![CDATA[<p>1.显示Docker<br>Control+F3</p>
<p>2.回到桌面<br>Control+上箭头</p>
<p>3.切换输入法<br>Control+空格键</p>
<p>4.调节音量<br>在偏好者设置中添加到状态栏中即可。</p>
<p>5.Android Studio查找文件<br>Command+O 查找类<br>Command+SHIFT+O 查找文件</p>
<p>6.软件最大化而不是全屏<br>在全屏图标处按住Alt键，然后点击加号即可<br><a href="https://yshare.site/question/3645.html" target="_blank" rel="noopener">https://yshare.site/question/3645.html</a></p>
<p>7.HomeBrew安装<br>HomeBrew安装经常因为网络问题安装不上，可以通过以下解决<br><a href="https://www.cnblogs.com/hanxianlong/p/12738848.html" target="_blank" rel="noopener">https://www.cnblogs.com/hanxianlong/p/12738848.html</a></p>
<p>8.在当前目录打开终端<br><a href="https://juejin.im/post/6844903789812531213" target="_blank" rel="noopener">https://juejin.im/post/6844903789812531213</a></p>
<p>9.mac强制退出应用<br><a href="https://jingyan.baidu.com/article/597a06433fa222312b5243b9.html" target="_blank" rel="noopener">https://jingyan.baidu.com/article/597a06433fa222312b5243b9.html</a></p>
<p>10.AS返回上一步<br>Ctrl+Alt+←返回上一次浏览位置back</p>
<p>11.mac 剪切<br>文字剪切 Command+X<br>文件剪切 复制后粘贴的时候用 option+command+v 就剪切了！</p>
<p>12.QQ截图快捷键<br>在QQ for Mac上,control+command+A是QQ的默认的截图键<br>微信截图快捷鍵，自定义为control+command+5</p>
]]></content>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>APM性能监控资源总结</title>
    <url>/blog/2020/09/apm-learn-resource.html</url>
    <content><![CDATA[<h3 id="启动优化"><a href="#启动优化" class="headerlink" title="启动优化"></a>启动优化</h3><p>1.<a href="https://www.jianshu.com/p/59d636695d42" target="_blank" rel="noopener">Android 之 ViewTreeObserver 全面解析</a><br>2.<a href="https://zhuanlan.zhihu.com/p/39907230" target="_blank" rel="noopener">Android自动化页面测速在美团的实践</a><br>3.<a href="https://github.com/didi/DoraemonKit#%E5%BC%80%E5%8F%91%E8%83%8C%E6%99%AF" target="_blank" rel="noopener">DoraemonKit开源框架</a><br>4.<a href="https://github.com/facebookincubator/profilo" target="_blank" rel="noopener">profilo-facebook线上性能监测框架</a><br>5.<a href="https://coding.imooc.com/class/308.html#Anchor" target="_blank" rel="noopener">国内Top团队大牛带你玩转Android性能分析与优化</a><br>6.<a href="https://blog.csdn.net/wangkai0681080/article/details/82659516" target="_blank" rel="noopener">ASM插桩实现Android端无埋点性能监控</a></p>
]]></content>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>Android进阶指南</title>
    <url>/blog/2020/09/android-advaned-helper.html</url>
    <content><![CDATA[<p>1.<a href="https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&amp;mid=2247485711&amp;idx=1&amp;sn=f779f491ef0fb164121adb3ac7fd7530&amp;chksm=f98e4da5cef9c4b3f65efe4938bb38cd8f952eaaa4a5f17bd6147bcd7dbf6518087d99adb05d&amp;mpshare=1&amp;scene=23&amp;srcid=0929eQfivi2Q5MConE7Xg6Sc&amp;sharer_sharetime=1601376602229&amp;sharer_shareid=17e96c8cb0ea8c114a87ec308f18ec71%23rd" target="_blank" rel="noopener">读者问：小林怎么学操作系统和计算机网络呀？</a></p>
<p>2.<a href="https://juejin.im/post/6870111983933325319" target="_blank" rel="noopener">Android 筑基导论</a></p>
<p>3.<a href="https://mp.weixin.qq.com/s/kW5wu7GM7pMRRvN-dQvE2g" target="_blank" rel="noopener">外卖客户端容器化架构的演进</a></p>
<p>4.<a href="https://class.imooc.com/sale/mobilearchitect" target="_blank" rel="noopener">移动端架构师课程</a></p>
<p>5.<a href="https://github.com/woai3c/nand2tetris" target="_blank" rel="noopener">手把手实现一个编译器</a></p>
]]></content>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>从一道面试题说起--View测量源码解析</title>
    <url>/blog/2020/10/view-bg-detail.html</url>
    <content><![CDATA[<p>在之前的面试中，曾经碰到过这样一个问题</p>
<blockquote>
<p>Activity内LinearLayout红色wrap_content,包含View蓝色wrap_content,求界面颜色</p>
</blockquote>
<p>在下想当然的认为，既然都是wrap_content，界面颜色应该是白色。<br>但是正确答案是蓝色<br>下面就来分析下具体原因</p>
<h3 id="如何理解View的测量"><a href="#如何理解View的测量" class="headerlink" title="如何理解View的测量"></a>如何理解View的测量</h3><p>首先根据官方文档我们能够明确：measure()的过程是自上而下的。<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog7/p1.png" alt><br>requestLayout()方法会调用到View的measure()中，而measure()又会调用到自身的onMeasure()中。而measure()并不是一个可重写的方法，所以既然测量是自上而下，那咱们就从外围LinearLayout中的omMeasure()开始。</p>
<h3 id="LinearLayout的onMeasure"><a href="#LinearLayout的onMeasure" class="headerlink" title="LinearLayout的onMeasure()"></a>LinearLayout的onMeasure()</h3><p>onMeasure()中比较简单，但是这里我们需要明确一下，这个方法的参数是什么含义：</p>
<p>MeasureSpec就不用多说了，记录当前View的尺寸和测量模式<br>另外明确一点，这里的MeasureSpec是父View的<br><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> widthMeasureSpec horizontal space requirements as imposed by the parent.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> heightMeasureSpec vertical space requirements as imposed by the parent.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mOrientation == VERTICAL) &#123;</span><br><span class="line">        measureVertical(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        measureHorizontal(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里咱们就选measureVertical()追进去，方法里的边界条件非常的多，但其中对于子View的测量过程比较的简单，遍历所有的子View，挨个调用measureChildBeforeLayout()方法，而这个方法最终会走到ViewGroup中的measureChildWithMargins()：<br><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChildWithMargins</span><span class="params">(View child,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> parentWidthMeasureSpec, <span class="keyword">int</span> widthUsed,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> parentHeightMeasureSpec, <span class="keyword">int</span> heightUsed)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这个方法主要就是做了一件事情：通过子View的LayoutParams和父View的MeasureSpec来决定子View的MeasureSpec</span></span><br><span class="line">    <span class="keyword">final</span> MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</span><br><span class="line">            mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin</span><br><span class="line">                    + widthUsed, lp.<span class="built_in">width</span>);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</span><br><span class="line">            mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin</span><br><span class="line">                    + heightUsed, lp.<span class="built_in">height</span>);</span><br><span class="line"></span><br><span class="line">    child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="生成子View的MeasureSpec"><a href="#生成子View的MeasureSpec" class="headerlink" title="生成子View的MeasureSpec"></a>生成子View的MeasureSpec</h3><p>这部分逻辑主要在getChildMeasureSpec()方法中，我们直接追进去就好了：</p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line"> public static int getChildMeasureSpec(int spec, int padding, int childDimension) &#123;</span><br><span class="line">    // 省略部分初始化代码</span><br><span class="line">    switch (specMode) &#123; </span><br><span class="line">        case MeasureSpec.EXACTLY: </span><br><span class="line">            <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123; </span><br><span class="line">                <span class="attr">resultSize</span> = childDimension;</span><br><span class="line">                <span class="attr">resultMode</span> = MeasureSpec.EXACTLY;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="attr">childDimension</span> == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">                <span class="attr">resultSize</span> = size;</span><br><span class="line">                <span class="attr">resultMode</span> = MeasureSpec.EXACTLY;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="attr">childDimension</span> == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">                <span class="attr">resultSize</span> = size;</span><br><span class="line">                <span class="attr">resultMode</span> = MeasureSpec.AT_MOST;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        case MeasureSpec.AT_MOST: </span><br><span class="line">            <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="attr">resultSize</span> = childDimension;</span><br><span class="line">                <span class="attr">resultMode</span> = MeasureSpec.EXACTLY;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="attr">childDimension</span> == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">                <span class="attr">resultSize</span> = size;</span><br><span class="line">                <span class="attr">resultMode</span> = MeasureSpec.AT_MOST;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="attr">childDimension</span> == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">                <span class="attr">resultSize</span> = size;</span><br><span class="line">                <span class="attr">resultMode</span> = MeasureSpec.AT_MOST;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        case MeasureSpec.UNSPECIFIED: </span><br><span class="line">            <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="attr">resultSize</span> = childDimension;</span><br><span class="line">                <span class="attr">resultMode</span> = MeasureSpec.EXACTLY;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="attr">childDimension</span> == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">                <span class="attr">resultSize</span> = View.sUseZeroUnspecifiedMeasureSpec ? <span class="number">0</span> : size;</span><br><span class="line">                <span class="attr">resultMode</span> = MeasureSpec.UNSPECIFIED;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="attr">childDimension</span> == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">                <span class="attr">resultSize</span> = View.sUseZeroUnspecifiedMeasureSpec ? <span class="number">0</span> : size;</span><br><span class="line">                <span class="attr">resultMode</span> = MeasureSpec.UNSPECIFIED;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    return MeasureSpec.makeMeasureSpec(resultSize, resultMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这部分代码，就是Google定的规则，也没什么好说的。总结起来就是《Android开发艺术探索》中的那张图：<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog7/p2.png" alt> </p>
<p>看了这个，咱们就可以思考一下咱们开篇遇到的问题：父View（LinearLayout）是wrap_content，子View是wrap_parent，那么子View的MeasureSpec是什么样子？<br>有了上边的分析，我们很容易得出答案：parentSize + AT_MOST。因此咱们就知道这种场景下，子View的wrap_parent意味自己的宽高就是父View的宽高。那么此时父View的宽高是多少呢？<br>由于这里的父View已经是根View了，那么它的外边便是DecorView，而DecorView的MeasureSpec相对简单些，直接基于Window的宽高和自身的LayoutParams进行计算。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getRootMeasureSpec</span><span class="params">(<span class="keyword">int</span> windowSize, <span class="keyword">int</span> rootDimension)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> measureSpec;</span><br><span class="line">    <span class="keyword">switch</span> (rootDimension) &#123;</span><br><span class="line">        <span class="keyword">case</span> ViewGroup.LayoutParams.MATCH_PARENT:</span><br><span class="line">            measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ViewGroup.LayoutParams.WRAP_CONTENT:</span><br><span class="line">            measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> measureSpec;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">    setContentView(view, <span class="keyword">new</span> ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此这种场景下，DecorView的MeasureSpec是屏幕宽高 + EXACTLY，那么父View（LinearLayout）的宽高就很明确了：parentSize + AT_MOST。</p>
<p>1.子View（TextView）的MeasureSpec是parentSize + AT_MOST<br>2.父View（LinearLayout）的MeasureSpec是parentSize + AT_MOST<br>3.DecorView的MeasureSpec是屏幕的size + EXACTLY</p>
<h3 id="执行子View的measure-方法"><a href="#执行子View的measure-方法" class="headerlink" title="执行子View的measure()方法"></a>执行子View的measure()方法</h3><p>接下来咱们去看一看子View的measure()方法，上述的部分我们已经知道measureChildWithMargins()方法中会基于父View的MeasureSpec和子View的LayoutParams计算子View的MeasureSpec然后调用子View的measure()：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">        setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),</span><br><span class="line">                getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getDefaultSize</span><span class="params">(<span class="keyword">int</span> <span class="built_in">size</span>, <span class="keyword">int</span> measureSpec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="built_in">size</span>;</span><br><span class="line">        <span class="keyword">int</span> specMode = MeasureSpec.getMode(measureSpec);</span><br><span class="line">        <span class="keyword">int</span> specSize = MeasureSpec.getSize(measureSpec);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (specMode) &#123;</span><br><span class="line">        <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</span><br><span class="line">            result = <span class="built_in">size</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MeasureSpec.AT_MOST:</span><br><span class="line">        <span class="keyword">case</span> MeasureSpec.EXACTLY:</span><br><span class="line">            result = specSize;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>从代码中可以看出，View的宽度即为父View传过来的宽高，即屏幕宽高。<br>因此效果为全屏显示蓝色。</p>
<h3 id="参加资料"><a href="#参加资料" class="headerlink" title="参加资料"></a>参加资料</h3><p><a href="https://juejin.im/post/6877731252871364615" target="_blank" rel="noopener">来解释一下这个简单布局为什么是这个效果吧！</a><br><a href="https://juejin.im/post/6890152854649225230" target="_blank" rel="noopener">Android视图体系—View的工作流程</a><br><a href="https://juejin.cn/post/6893699917458604046" target="_blank" rel="noopener">深入理解自定义ViewGroup的布局测量过程</a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>DoKit原理学习</title>
    <url>/blog/2020/10/dokit-principle-learn.html</url>
    <content><![CDATA[<h3 id="函数耗时统计"><a href="#函数耗时统计" class="headerlink" title="函数耗时统计"></a>函数耗时统计</h3><h4 id="现有技术的缺点"><a href="#现有技术的缺点" class="headerlink" title="现有技术的缺点"></a>现有技术的缺点</h4><p>现有统计函数耗时的方法，一般是利用TraceView或者dmtracedump等。<br>这些工具可以提供包括cpu执行时间 ，调用次数以及函数调用树等信息。</p>
<p>这些工具虽然十分强大，但是他们的问题在于信息量大，上手困难，想要在繁杂的信息中找出你所需要的性能瓶颈点难度可想而知。<br>一般的新手根本没有耐心和经验去操作，有时候甚至懒得去使用这个工具。</p>
<h4 id="DoKit解决方案"><a href="#DoKit解决方案" class="headerlink" title="DoKit解决方案"></a>DoKit解决方案</h4><p>通过ASM字节码框架+Plugin Transform来实现</p>
<h4 id="寻找指定的代码插桩节点"><a href="#寻找指定的代码插桩节点" class="headerlink" title="寻找指定的代码插桩节点"></a>寻找指定的代码插桩节点</h4><p>对于开发者来说，我们的最终的目的是为了在项目运行过程中第一时间发现有哪些函数耗时过长从而导致UI卡顿，然后对指定的慢函数进行耗时统计并给出友好的数据结构呈现。<br>所以，既然要统计一个函数的耗时，我们就必须要在一个函数开始和结束的地方插桩，最后相减即可得出一个函数方法的耗时时间。</p>
<p>如下所示：<br><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleepMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="built_in">begin</span> = System.currentTimeMillis();</span><br><span class="line">        Log.i(TAG, <span class="string">"我是耗时函数"</span>);</span><br><span class="line">        <span class="keyword">long</span> costTime = System.currentTimeMillis() - <span class="built_in">begin</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>其中costTime即为当前函数的执行时间，我们只需要将costTime根据函数的类名+函数名作为key保存在Map中，然后再根据一定的算法在运行期间去绑定函数的上下级调用关系。<br>最终在入口函数执行结束时将结果在控制台中打印出来即可。</p>
<h4 id="插入指定的Plugin-Transform"><a href="#插入指定的Plugin-Transform" class="headerlink" title="插入指定的Plugin Transform"></a>插入指定的Plugin Transform</h4><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://juejin.im/post/6844904154624688136" target="_blank" rel="noopener">滴滴DoKit Android核心原理揭秘之函数耗时</a><br><a href="https://www.jianshu.com/p/16ed4d233fd1" target="_blank" rel="noopener">【Android】函数插桩（Gradle + ASM）</a></p>
]]></content>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>利用子模块实现代码复用</title>
    <url>/blog/2020/10/git-submodule-resue.html</url>
    <content><![CDATA[<p>在项目中存在这样一种场景<br>两个项目有一些公共代码，为了实现这些代码的复用，需要将这部分代码抽取出来维护<br>那么如何维护这部分代码，如何保证这部分代码的更新？</p>
<p>我们可以通过多个项目依赖公共项目的方式实现，这样公共代码自成一个仓库<br>详情可见：<a href="https://shenzhen2017.github.io/blog/2019/01/common-android-library.html">https://shenzhen2017.github.io/blog/2019/01/common-android-library.html</a></p>
<p>本文主要介绍通过子模块实现代码复用</p>
<h3 id="子模块的添加"><a href="#子模块的添加" class="headerlink" title="子模块的添加"></a>子模块的添加</h3><p>添加子模块非常简单，命令如下:</p>
<p>Git submodule add <url><path></path></url></p>
<p>其中url为子模块的路径，path为该子模块存储的目录，如：</p>
<p>git submodule add <a href="https://github.com/shenzhen2017/Submoduletest.git" target="_blank" rel="noopener">https://github.com/shenzhen2017/Submoduletest.git</a> submodule</p>
<p>执行成功后，git status会看到项目中修改了.gitmodules,并增加了一个新文件(为刚刚添加的路径)</p>
<p>Git diff –cached查看修改内容可以看到增加了子模块，并且新文件下为子模块的提交hash摘要</p>
<p>git commit提交即完成子模块的添加</p>
<h3 id="子模块的使用"><a href="#子模块的使用" class="headerlink" title="子模块的使用"></a>子模块的使用</h3><p>克隆项目后，默认子模块目录下无任何内容。可以在项目根目录下执行以下命令</p>
<p>Git submodule update –init –recursive</p>
<h3 id="子模块的更新"><a href="#子模块的更新" class="headerlink" title="子模块的更新"></a>子模块的更新</h3><p>子模块的维护者提交了更新后，使用子模块的项目必须手动更新项目。</p>
<p>在项目中，进入子模块目录下，执行git pull更新，查看git log 查看相应提交。</p>
<p>完成后返回到项目目录，可以看到子模块有待提交的更新，使用git add提交即可。</p>
<p>详情可见：<a href="https://blog.csdn.net/guotianqing/article/details/82391665" target="_blank" rel="noopener">https://blog.csdn.net/guotianqing/article/details/82391665</a></p>
]]></content>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>android启动优化总结</title>
    <url>/blog/2020/10/android-start-optimization.html</url>
    <content><![CDATA[<h3 id="冷启动流程总结"><a href="#冷启动流程总结" class="headerlink" title="冷启动流程总结"></a>冷启动流程总结</h3><p>Click Event    -&gt;     IPC     -&gt;     Process.start     -&gt;      ActivityThread -&gt;    bindApplication      -&gt;      LifeCycle    -&gt;     ViewRootImpl</p>
<p>首先，用户进行了一个点击操作，这个点击事件它会触发一个IPC的操作，之后便会执行到Process的start方法中，这个方法是用于进程创建的，接着，便会执行到ActivityThread的main方法，这个方法可以看做是我们单个App进程的入口，相当于Java进程的main方法，在其中会执行消息循环的创建与主线程Handler的创建，创建完成之后，就会执行到 bindApplication 方法，在这里使用了反射去创建 Application以及调用了 Application相关的生命周期，Application结束之后，便会执行Activity的生命周期，在Activity生命周期结束之后，最后，就会执行到 ViewRootImpl，这时才会进行真正的一个页面的绘制。</p>
<h3 id="冷启动分析及其优化方向"><a href="#冷启动分析及其优化方向" class="headerlink" title="冷启动分析及其优化方向"></a>冷启动分析及其优化方向</h3><h4 id="冷启动涉及的相关任务"><a href="#冷启动涉及的相关任务" class="headerlink" title="冷启动涉及的相关任务"></a>冷启动涉及的相关任务</h4><p>1.首先，会启动App<br>2.然后，加载空白Window<br>3.最后，创建进程<br>需要注意的是，这些都是系统的行为，一般情况下我们是无法直接干预的。<br><strong>随后任务</strong><br>1.首先，创建Application<br>2.启动主线程<br>3.创建MainActivity<br>4.加载布局<br>5.布置屏幕<br>6.首帧绘制</p>
<h4 id="优化方向"><a href="#优化方向" class="headerlink" title="优化方向"></a>优化方向</h4><p>我们的优化方向就是 Application和Activity的生命周期 这个阶段，因为这个阶段的时机对于我们来说是可控的。</p>
<h3 id="启动耗时检测"><a href="#启动耗时检测" class="headerlink" title="启动耗时检测"></a>启动耗时检测</h3><h4 id="1-查看LogCat"><a href="#1-查看LogCat" class="headerlink" title="1.查看LogCat"></a>1.查看LogCat</h4><p>在Android Studio Logcat中过滤关键字“Displayed”，可以看到对应的冷启动耗时日志。</p>
<h4 id="2、adb-shell"><a href="#2、adb-shell" class="headerlink" title="2、adb shell"></a>2、adb shell</h4><p>使用adb shell获取应用的启动时间<br><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 其中的AppstartActivity全路径可以省略前面的packageName</span></span><br><span class="line"><span class="selector-tag">adb</span> <span class="selector-tag">shell</span> <span class="selector-tag">am</span> <span class="selector-tag">start</span> <span class="selector-tag">-W</span> <span class="selector-attr">[packageName]</span>/<span class="selector-attr">[AppstartActivity全路径]</span></span><br></pre></td></tr></table></figure></p>
<h4 id="3、代码打点（函数插桩）"><a href="#3、代码打点（函数插桩）" class="headerlink" title="3、代码打点（函数插桩）"></a>3、代码打点（函数插桩）</h4><p>可以写一个统计耗时的工具类来记录整个过程的耗时情况。其中需要注意的有：<br>1.在上传数据到服务器时建议根据用户ID的尾号来抽样上报。<br>2.在项目中核心基类的关键回调函数和核心方法中加入打点。</p>
<p>主要在以下几个方面需要打点：<br>1.应用程序的生命周期节点。<br>2.启动时需要初始化的重要方法，例如数据库初始化，读取本地的一些数据。<br>3.其他耗时的一些算法。</p>
<p>打点开始以Application的attachBaseContext为标准<br>结束则以Activity的onWindowFocusChanged</p>
<p><strong>特点</strong><br>精确，可带到线上，但是代码有侵入性，修改成本高</p>
<h3 id="通过AOP统计耗时"><a href="#通过AOP统计耗时" class="headerlink" title="通过AOP统计耗时"></a>通过AOP统计耗时</h3><h3 id="线上监控"><a href="#线上监控" class="headerlink" title="线上监控"></a>线上监控</h3><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>需要准确地统计启动耗时。</p>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>1、启动结束的统计时机<br>是否是使用界面显示且用户真正可以操作的时间作为启动结束时间。<br>2、启动时间扣除逻辑<br>闪屏、广告和新手引导这些时间都应该从启动时间里扣除。<br>3、启动排除逻辑<br>Broadcast、Server拉起，启动过程进入后台都需要排除统计。<br>4、使用什么指标来衡量启动速度的快慢？<br>平均启动时间的问题<br>一些体验很差的用户很可能被平均了。</p>
<h4 id="建议的指标"><a href="#建议的指标" class="headerlink" title="建议的指标"></a>建议的指标</h4><p>1、快开慢开比<br>如2s快开比，5s慢开比，可以看到有多少比例的用户体验好，多少比例的用户比较糟糕。</p>
<p>2、90%用户的启动时间<br>如果90%用户的启动时间都小于5s，那么90%区间的启动耗时就是5s。</p>
<p>5、启动的类型有哪几种？<br>首次安装启动<br>覆盖安装启动<br>冷启动（指标）<br>热启动（反映程序的活跃或保活能力）</p>
<h3 id="启动优化常规方案"><a href="#启动优化常规方案" class="headerlink" title="启动优化常规方案"></a>启动优化常规方案</h3><p>启动过程中的常见问题<br>1、点击图标很久都不响应：预览窗口被禁用或设置为透明。<br>2、首页显示太慢：初始化任务太多。<br>3、首页显示后无法进行操作：太多延迟初始化任务占用主线程CPU时间片。</p>
<p><strong>优化区域</strong><br>Application、Activity创建以及回调等过程。</p>
<h4 id="1、主题切换"><a href="#1、主题切换" class="headerlink" title="1、主题切换"></a>1、主题切换</h4><p>使用Activity的windowBackground主题属性预先设置一个启动图片（layer-list实现），在启动后，在Activity的onCreate()方法中的super.onCreate()前再setTheme(R.style.AppTheme)。</p>
<p>优点<br>1.使用简单。<br>2.避免了启动白屏和点击启动图标不响应的情况。</p>
<p>缺点<br>1.治标不治本，表面上产生一种快的感觉。<br>2.对于中低端机，总的闪屏时间会更长，建议只在Android6.0/7.0以上才启用“预览闪屏”方案，让手机性能好的用户可以有更好的体验。</p>
<h4 id="2、第三方库懒加载"><a href="#2、第三方库懒加载" class="headerlink" title="2、第三方库懒加载"></a>2、第三方库懒加载</h4><p>按需初始化，特别是针对于一些应用启动时不需要初始化的库，可以等到用时才进行加载。</p>
<h4 id="3-异步初始化"><a href="#3-异步初始化" class="headerlink" title="3.异步初始化"></a>3.异步初始化</h4><p>异步优化最优解：异步启动器</p>
<h4 id="4-延迟初始化"><a href="#4-延迟初始化" class="headerlink" title="4.延迟初始化"></a>4.延迟初始化</h4><p>延迟优化最优解：延迟启动器</p>
<h4 id="5-Multidex预加载优化"><a href="#5-Multidex预加载优化" class="headerlink" title="5.Multidex预加载优化"></a>5.Multidex预加载优化</h4><p>我们都知道，安装或者升级后首次 MultiDex 花费的时间过于漫长，我们需要进行Multidex的预加载优化。</p>
<h5 id="优化步骤"><a href="#优化步骤" class="headerlink" title="优化步骤"></a>优化步骤</h5><p>android 5.0以下需要对APP做Multidex优化</p>
<p>1、启动时单独开一个进程去异步进行Multidex的第一次加载，即Dex提取和Dexopt操作。<br>2、此时，主进程Application进入while循环，不断检测Multidex操作是否完成。<br>3、执行到Multidex时，则已经发现提取并优化好了Dex，直接执行。MultiDex执行完之后主进程Application继续执行ContentProvider初始化和Application的onCreate方法。</p>
<p><a href="https://github.com/lanshifu/MultiDexTest" target="_blank" rel="noopener">Multidex优化Demo地址</a><br><a href="https://juejin.im/post/6844904079206907911" target="_blank" rel="noopener">抖音BoostMultiDex优化实践：Android低版本上APP首次启动时间减少80%（一）</a></p>
<p><strong>注意</strong><br>5.0以上默认使用ART，在安装时已将Class.dex转换为oat文件了，无需优化，所以应判断只有在主进程及SDK 5.0以下才进行Multidex的预加载。</p>
<h4 id="6-闪屏页与主页的绘制优化"><a href="#6-闪屏页与主页的绘制优化" class="headerlink" title="6.闪屏页与主页的绘制优化"></a>6.闪屏页与主页的绘制优化</h4><p>主页绘制优化，首页页面懒加载，添加占位布局，当切换到对应tab后再加载相关布局</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://juejin.im/post/6844904093786308622" target="_blank" rel="noopener">深入探索Android启动速度优化（上）</a></p>
]]></content>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>Charels抓包配置</title>
    <url>/blog/2020/10/charels-catch-sum.html</url>
    <content><![CDATA[<p>1.Charels的配置，证书的安装等<br><a href="https://www.jianshu.com/p/831c0114179f" target="_blank" rel="noopener">接口测试之——Charles抓包及常见问题解决</a></p>
<p>2.小米手机无法安装证书解决办法<br><a href="https://blog.csdn.net/mp624183768/article/details/103954786" target="_blank" rel="noopener">小米手机无法安装crt证书</a></p>
<p>3.抓包乱码解决方法<br><a href="https://www.cnblogs.com/puresoul/p/7365761.html" target="_blank" rel="noopener">charles抓包显示乱码解决方法</a></p>
<p>4.使用mapLocal展示本地数据<br>使用breakPoint也可以拦截并返回本地数据，但是需要快速填写，如果超时则会请求超时<br>使用mapLocal可以持久化拦截并返回本地数据<br>注意mapLocal时需要去除query参数</p>
<p><a href="https://www.jianshu.com/p/a1e21264ef42" target="_blank" rel="noopener">charles非常实用的map local功能小结</a></p>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>《深入理解Android内核设计思想》读书笔记1</title>
    <url>/blog/2020/10/android-kernal-read.html</url>
    <content><![CDATA[<h3 id="Android系统总体架构"><a href="#Android系统总体架构" class="headerlink" title="Android系统总体架构"></a>Android系统总体架构</h3><p><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog7/p3.jpg" alt></p>
<h4 id="1-内核层"><a href="#1-内核层" class="headerlink" title="1.内核层"></a>1.内核层</h4><p>Android底层基于linux.严格意义上讲，它是Linux系统的一个变种。<br>Android选择在Linux内核的基础上搭建自己的运行平台有几个好处<br>1）避开了与硬件直接打交道<br>2）基于Linux系统的驱动开发可扩展性强</p>
<p>2.硬件抽象层<br>既然Linux内核是专职与硬件打交道，为什么又需要一个硬件抽象层呢？<br>一方面HAL希望定义硬件驱动的接口来进一步降低Android系统与硬件的耦合度。<br>另一方面linux遵循GPL协议(Android开源部分基于Apache协议)，意味着其下的所有驱动都应该是开源的，这点对于部厂商是无法接受的。因此Android提供了一种打擦边球的做法来规避这类问题</p>
<p>3.系统运行库层<br>这一层中包含了支撑整个系统运行的基础库。这些库多数由c/c++实现，因此也被称为C库层，以区别于应用程序框架层。<br>这一层包括WebKit,OpenGL,SQLite等</p>
<p>4.应用程序框架层<br>这一层又被层为Java库层<br>它一方面为上层应用程序提供了API接口，另一方面也包括了不少系统级服务进程的实现，是与Android开发者关系最直接的一层</p>
<p>5.应用程序层<br>即一般程序员开发的应用程序，也是大家接触最多的一层</p>
<h4 id="Android系统特点"><a href="#Android系统特点" class="headerlink" title="Android系统特点"></a>Android系统特点</h4><p>1.开放与扩展性<br>2.合理的分层架构<br>3.易用强大的SDK<br>4.不断改进的交互界面<br>5.逐步完善的生态系统<br>6.阵营良莠不齐<br>7。系统运行速度有待改装<br>8.兼容性问题</p>
<h3 id="操作系统基础"><a href="#操作系统基础" class="headerlink" title="操作系统基础"></a>操作系统基础</h3><h4 id="计算机体系结构"><a href="#计算机体系结构" class="headerlink" title="计算机体系结构"></a>计算机体系结构</h4><p>硬件是软件的基石，所有软件功能最后是由硬件来实现的。<br>因此要彻底理解软件，没有一点硬件基础是不行的。<br>当然硬件是一个笼统而宽泛的概念，让所有软件工程师理解电子元器件的电气特性是不现实的。<br>而计算机体系结构作为一门学科，是软件和硬件的抽象体，也是所有开发者的入门课。<br>它对于我们理解程序设计，尤其是操作系统原理，有十分重要的意义。</p>
<h5 id="冯诺依曼结构"><a href="#冯诺依曼结构" class="headerlink" title="冯诺依曼结构"></a>冯诺依曼结构</h5><p>冯诺依曼在1945年的论文中提出了两个对计算机领域有着深远影响的观点<br>1.使用二进制取代十进制<br>他认为这将极大简化计算机设备的逻辑线路<br>2.程序存储<br>除了二进制，他还建议计算机能实现程序存储和程序控制。<br>具体而言，程序指令和数据都存放在同一内存存储器中，因此他们的宽度是一样的。<br>不过数据与程序共享同一总线在一定程序上也成了制约冯诺依曼机器的瓶颈</p>
<p>冯诺依曼结构主要包括了运算器，控制器，输入输出设备等元素</p>
<h5 id="哈佛结构"><a href="#哈佛结构" class="headerlink" title="哈佛结构"></a>哈佛结构</h5><p>哈佛结构并不是作为冯诺依曼结构的对立面出现的，相反，他们都属于stored-program类型体系<br>区别就在于哈佛结构的指令与数据不保存在同一个存储器中，这是哈佛结构对冯诺依曼结构的改进</p>
<p>他们的关系如图所示<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog7/p4.png" alt></p>
<p>这意味着<br>1.指令与数据可以有不同的数据宽度<br>2.执行速度更快</p>
<p>由于取指令与取数据无法同步进行，所以冯诺依曼结构的执行不占优势<br>而哈佛结构的计算机可以在执行操作的同时预读下一条指令，效率更高。<br>哈佛结构的缺点在于架构复杂且需要两个存储器，因此通常用在对速度有要求，同时预算较高的场合。<br>目前市面上使用哈佛架构的芯片包括ARM9,ARM11等</p>
<p>不论是何种结构，它们所包含的基本组成是一样的</p>
<ul>
<li>中央处理器（cpu）</li>
<li>内存储器</li>
<li>I/O设备(输入与输出设备)</li>
</ul>
<p>无论是哪款操作系统(Android,IOS,Windows)，都是建构在计算机体系结构上的,脱离了这一点，操作系统就会变成无源之水。</p>
<h4 id="什么是操作系统"><a href="#什么是操作系统" class="headerlink" title="什么是操作系统"></a>什么是操作系统</h4><p>操作系统肩负两大重任</p>
<ul>
<li><p>1.面向下层<br>管理硬件。这里的三件是笼统的概念，它包含了CPU，内存，各种I/O设备等系统中所有硬件组成元素。</p>
</li>
<li><p>2.面向下层<br>一方面，操作系统需要为用户提供可用的人机交互界面；另一方面，它还负责为第三方程序的研发提供便捷，可靠，高效的API。<br>这样上层应用的设计实现就不用直接面向硬件，从而大缩短了应用开发的时间。</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog7/p5.png" alt><br>由此，我们可以给操作系统下一个简洁的定义</p>
<blockquote>
<p>计算机操作系统是负责管理硬件，并为上层应用提供稳定编程接口和人机交互界面的软件集合。</p>
</blockquote>
<p>这一概念虽然浅显，却是我们在学习操作系统时的指南针。因为它指出了操作系统最核心的工作：<strong>硬件管理与抽象</strong><br>任何类型的操作系统都逃不出这个范畴。</p>
<h3 id="进程间通信的经典实现"><a href="#进程间通信的经典实现" class="headerlink" title="进程间通信的经典实现"></a>进程间通信的经典实现</h3><p>操作系统的难点包括了进程和内存管理，硬件的驱动支持等，这些正是linux的长处，也是Android选择linux内核的原因所在,下面我们就来看下进程间通信的经典实现</p>
<p>我们知道，操作系统的进程通常运行在独立的内存空间中，并且有严厉的机制来防止进程间的非法访问。<br>但这不代表进程间不允许互相通信，相反，进程间通信是操作系统中一个重要概念，应用非常广泛。<br>举个实用的例子，我们常用的Windows中的剪切板，就可以让用户轻松的将数据拷贝到另一个毫无关联的程序中。</p>
<p>广义的讲，进程间通信(IPC)是指运行在不同进程(不论是否在同一机器)中的若干线程间的数据交换。<br>如图所示：<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog7/p6.png" alt><br>下面我们了解下几种常见的IPC机制</p>
<h4 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h4><p>共享内存是一种常见的进程间通信机制<br>两个进程可以直接共享访问一块内存区域，减少了数据的复制，因而在速度上有比较明显的优势<br>实现共享内存的步骤如下所示：<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog7/p7.png" alt></p>
<p>1.创建内存共享区域<br>进程1首先通过操作系统提供的API从内存中申请一块内存共享区域。<br>生成的共享内存块将与某个特定的key绑定</p>
<p>2.映射共享内存区<br>成功创建共享内存区域后，我们需要将它映射到进程1的空间中才能进一步操作</p>
<p>3.访问共享内存区<br>进程1已经创建了共享内存，进程2如何访问它呢？<br>就是通过步骤1的key,访问后进程2同样将这块区域，映射到进程2的空间</p>
<p>4.进程间的通信机制<br>共享内存的各个进程实现了内存映射后，便可以利用该区域实现信息交换。<br>由于共享内存本身没有同步机制，所以参与通信的进程需要自己协商处理。</p>
<p>5.撤销内存映射区域<br>完成了进程间通信后，各个进程都需要撤销之间的映射操作</p>
<p>6.删除内存共享区域<br>最后需要删除内存共享区域，以便回收内存</p>
<h4 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h4><p>管道也是一种常见的进程间通信方式，它适用于所有POSIX系统与Windows系统。</p>
<p>Pipe这个词很形象的描述了通信双方的行为，即进程A与进程B<br>1.分立管道两边，进行数据的传输通信<br>2.管道是单向的，意味着一个进程中如果既要读又要写的话，需要建立两根管道<br>3.一要管道同时具有写入端与读取端，比如进程A写入数据，进程2就可以读取了<br>4.管道有容量限制，即当Pipe满的时候，写操作将被阻塞，反之读操作将被阻塞</p>
<h5 id="UNIX-DOMAIN-Socket"><a href="#UNIX-DOMAIN-Socket" class="headerlink" title="UNIX DOMAIN Socket"></a>UNIX DOMAIN Socket</h5><p>不少人是接触了TCP/IP协议才接触到Socket的，它在网络通信领域获得了广泛的应用，被称为Network Socket.<br>对于同一个机器上的进程通信，Network Socket也可以实现，只是执行效率未必让人满意</p>
<p>UNIX DOMAIN Socket（UDS）是专门针对单机内的进程间通信提出来的，有时也被称为IPC Socket。<br>两者虽然使用方法上类似，原理却大不相同。<br>Network Socket是以TCP/IP协议栈为基础的，需要分包重组等一系列操作<br>而UDS因为是本机内的安全可靠操作，实现机制上不依赖这些协议。</p>
<p>Android中用得最多的一种IPC机制就是Binder，其次就是UDS<br>使用UDS进行进程间通信的流程如下所示：<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog7/p8.png" alt><br>1.服务端监听IPC请求<br>2.客户端发起IPC申请<br>3.双方建立起IPC连接<br>4.客户端向服务端发送数据</p>
<h3 id="同步机制的经典实现"><a href="#同步机制的经典实现" class="headerlink" title="同步机制的经典实现"></a>同步机制的经典实现</h3><p>既然操作系统支持多个进程(多个线程)的并发执行，那么它们之间难免会出现相互制约的情况。<br>比如两个进程需要共享唯一的硬件设备，或者同一块内存区域。<br>又或者像流水线一样，进程的工作依赖于另一方对共享资源处理的结果。<br>同步机制不仅是操作系统的实现重点，在程序设计中也具有举足轻重的作用，因而我们有必要对其深入了解。</p>
<p>从定义上来讲，如果多个(包括两个)进程间存在时序关系，需要协同工作以完成一项任务，则称为同步;<br>如果它们并不满足协同的条件，而只是因为共享具有排他性的资源时所产生的关系，则称为互斥。</p>
<h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><p>信号量与PV原语操作是由Dijkstra 发明的，也是使用最为广泛的互斥方法之一。它包括以下几个元素:<br>1.SemaphoreS (信号量);<br>2.OperationP (来自荷兰语proberen， 意为test)， 有时也表达为wait();<br>3.OperationV (来自荷兰语verhogen,意为increment)， 有时也表达为signal()。</p>
<p>Semaphore S用于指示共享资源的可用数量。P原语可以减小S计数，V则增加它的计数。<br>由此可知当某个进程想进入共享区时，首先要执行P操作;<br>同理，想退出共享区时执行V操作。<br>PV原语都属于原子操作(Atomic Operations)，意味着它们的执行过程是不允许被中断的。</p>
<p>描述PV原语如图所示<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog7/p9.png" alt></p>
<p><strong>P操作执行过程</strong><br>1.信号量S自减1<br>2.如果此时 S仍然≥0,说明共享资源此时是允许访问的，因而调用者将直接返回，然后开始操作共享资源;<br>3.否则的话就要等待别人主动释放资源，这种情况下调用者会被加入等待队列中，直到后续被唤醒;<br>4.当某人释放了 共享资源后，处于等待队列中的相关(取决于具体情况)对象会被唤醒，此时该对象就具备了资源的访问权。</p>
<p><strong>V操作的执行过程</strong><br>1.信号量S自增1;<br>2.此时如果S&gt;0， 说明当前没有希望访问资源的等待者，所以直接返回;<br>3.否则V操作要唤醒等待队列中的相关对象，对应P操作中的最后一步。</p>
<p>由此可见，Dijkstra的信号量机制只需要有限的几个元素和简单的操作就能解决同步问题，这<br>也是它能产生深远影响的一大原因。</p>
<h4 id="Mutex"><a href="#Mutex" class="headerlink" title="Mutex"></a>Mutex</h4><p>Mutex是Mutual Exclusion的缩写，其释义为互斥体。那么，它和Semaphore有什么区别和联系呢?</p>
<p>根据计算机领域的普遍观点，如果资源允许多个对象同时访问，称为Counting Semaphores;<br>而对于只允许取值0或1 (即locked/unlocked)的Semaphore，则叫作Binary Semaphore。</p>
<p>后者可以认为与本小节的Mutex 具有相同的性质。换句话说，Mutex 通常是对某一排他资源的共享控制<br>要么这个资源被占用(locked),要么就是可以访问的(unlocked)。</p>
<p>在很多操作系统中,Binary Semaphore和Mutex没有本质差异，前者是特定的Semaphore机制，而后者相较于Semaphore在实现上则更为简单。</p>
<h4 id="管程-Monitor"><a href="#管程-Monitor" class="headerlink" title="管程(Monitor)"></a>管程(Monitor)</h4><p>管程是对Semaphore机制的延伸和改善，是一种控制更为简单的同步手段.</p>
<p>根据前面的分析，我们知道Semaphore机制要求用户成对配套地使用P和V操作原语。</p>
<p>对于简单的应用场合，这不容易引发问题。而一旦涉及庞大且复杂的系统，就难免让人产生“不识庐山真面目，只缘身在此山中”的感觉。<br>这就好比C/C++语言中的new/delete操作，假如只是简短的几句代码，通常不会产生内存泄露的问题。<br>可如果是写一个操作系统呢?其中的工作量大得惊人，而且一定会是由很多人协作完成的。在这种情况下，如果没有很好的机制来约束内存的分配和释放，那么产生内存泄露、野指针等问题的可能性就很大了。</p>
<p>采用Semaphore机制的程序易读性相对较差，对于信号量的管理也分散在各个参与对象中，因而有可能由此引发一系列问题，如死锁、进程饿死等。为了使资源的互斥访问更利于维护，科学家们提出了管程的概念。如下:</p>
<p><strong>管程(Monitor) 是可以被多个进程/线程安全访问的对象(object) 或模块(module)</strong><br>管程中的方法都是受mutual exclusion保护的，意味着在同一时刻只允许有-一个访问者使用它们。另外，管程还具备如下属性:<br>1.安全性<br>2.互斥性<br>3.共享性</p>
<h3 id="Android中的同步机制"><a href="#Android中的同步机制" class="headerlink" title="Android中的同步机制"></a>Android中的同步机制</h3><p>下面我们来看看Android中的同步机制，目前Android封装的同步类包括：</p>
<p><strong>1.Mutex</strong><br>头文件是frameworks/native/include/utils/Mutex.h</p>
<p>Android中的Mutex只是对pthread提供的API的简单再封装，所以函数声明和实现体都放在同一个头文件中，这样做也方便了调用者的操作。<br>另外，Mutex中还包含一个AutoLock的嵌套类,它是利用变量生命周期特点而设计的一个辅助类。</p>
<p><strong>2.Condition</strong><br>头文件是frameworks/native/include/utils/Condition.h<br>Condition是“条件变量”在Android系统中的实现类，它是依赖Mutex来完成的。</p>
<p><strong>3.Barrier</strong><br>头文件是frameworks/native/services/surfacefinger/Barrier.h<br>Barrier是同时基于Mutex和Condition实现的一个模型。</p>
<h4 id="为什么需要Condition"><a href="#为什么需要Condition" class="headerlink" title="为什么需要Condition"></a>为什么需要Condition</h4><p>Condition的字面意思是“条件”。<br>换句话说，它的核心思想是判断“条件是否已经满足”，满足的话马上返回，继续执行未完成的动作;否则就进入休眠等待，直到条件满足时有人唤醒它。</p>
<p>可能有读者会问，这种情况用Mutex能实现吗?<br>理论上讲，的确是可以的。举一个例子，假设两个线程A和B共享一个全局变量vari，且它们的行为如下。</p>
<p>ThreadA:不断去修改vari,每次改变后的值未知。<br>ThreadB:当vari为0时，它需要做某些动作。</p>
<p>显而易见，A和B都想访问vari这个共享资源，属于Mutex的问题领域。<br>但需要商榷的细节是:线程A的“企图”仅仅是获得vari的访问权:而线程B则“醉翁之意不在酒”，其真正等待的条件是“vari等于0”。<br>那么如果用Mutex去完成的话，线程B就只能通过不断地读取vari来判断条件是否满足，有点类似于下面的伪代码:<br><figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span><span class="comment">(1)</span> <span class="comment">//死循环，直到条件满足时退出</span></span><br><span class="line">	acquire_ mutex lock<span class="comment">(vari)</span> ; <span class="comment">//获取锁</span></span><br><span class="line">	<span class="keyword">if</span><span class="comment">(0 == vari)</span> <span class="comment">//条件满足</span></span><br><span class="line">		release_ mutex_ lock<span class="comment">(vari)</span> ;<span class="comment">//释放锁</span></span><br><span class="line">		break;</span><br><span class="line">	&#125;</span><br><span class="line">	else&#123;</span><br><span class="line">		release mutex_ lock<span class="comment">(vari)</span> ;<span class="comment">//释放锁</span></span><br><span class="line">		sleep<span class="comment">()</span>;<span class="comment">//休眠一段时间</span></span><br><span class="line">	&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>对于线程B而言，什么时候达到条件是未知的，这点和其他只是使用vari的线程(比如线程A)有很大不同，因而采用轮询的方式显示极大地浪费了CPU时间。<br>这种情况下由Condition实现较好</p>
<h3 id="操作系统内存管理基础"><a href="#操作系统内存管理基础" class="headerlink" title="操作系统内存管理基础"></a>操作系统内存管理基础</h3><p>不论什么类型的操作系统，内存管理都是绝对的重点和难点。</p>
<p>简单来说，内存管理( Memory Management)旨在为系统中的所有Task提供稳定可靠的内存分配、释放与保护机制。</p>
<p>可能有人会问，我们学习Android系统还需要了解Linux Kernel 的内存管理机制吗?<br>答案是肯定的。不论是Android中的音频系统、GUI系统，还是Binder的实现机理等，都与内存管理是息息相关的。甚至可以说，任何操作系统的运行都只是在“玩内存游戏”。</p>
<p>当然，没有内核基础的读者也不要因此而觉得“前途漫漫无归路”，事实上“内存游戏”再精彩，其底层原理都基本不变。因此，需要重点理解以下几个核心:</p>
<p>1.虚拟内存;<br>2.内存分配与回收;<br>3.内存保护。</p>
<h4 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h4><p>计算机出现的早期物理内存普遍很小，不过因为当时程序的体积也不大，所以不会有什么问题。然而随着软件的发展，动辄以GB为单位的程序比比皆是。<br>在这种情况下，如何保证这些软件能在大多数机器上运行呢?</p>
<p>一种最直接的方式就是加大物理内存，使得机器能一次性读入任何程序。 这样的“理想是很丰满的”，但“现实却很骨感”。且不论硬件的升级意味着成本的增加，即便把内存加大到16G以上，问题还是没有得到根本的解决一程序体积仍然可能超过它。换句话说，这样的设备是不可<br>靠的，因为我们不清楚它什么时候会遭遇宕机。</p>
<p>虚拟内存的出现为大体积程序的运行提供了可能。它的基本思想是。<br>1.将外存储器的部分空间作为内存的扩展，如从硬盘划分出4GB大小。<br>2.当内存资源不足时，系统将按照-定算法自动挑选优先级低的数据块，并把它们存储到硬盘中。<br>3.后续如果需要用到硬盘中的这些数据块，系统将产生“缺页”指令，然后把它们交换回内存中。<br>4.这些操作 都是由操作系统内核自动完成的，对上层应用“完全透明”。</p>
<p>理解虚拟内存机制，首先要学习3种不同的地址空间。<br>1.逻辑地址<br>2.线性地址<br>3.物理地址</p>
<h5 id="逻辑地址"><a href="#逻辑地址" class="headerlink" title="逻辑地址"></a>逻辑地址</h5><p>它也称为相对地址，是程序编译后所产生的地址。其格式如下所示：<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog7/p10.png" alt></p>
<p>对于开启段页式内存管理的机器而言，逻辑地址需要经过两次变换才能得到最终的物理地址，如下图所示：<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog7/p11.png" alt></p>
<h5 id="线性地址"><a href="#线性地址" class="headerlink" title="线性地址"></a>线性地址</h5><p>线性地址是逻辑地址经过分段机制转换后形成的.逻辑地址到线性地址的转换如图所示：<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog7/p12.png" alt></p>
<h5 id="物理地址"><a href="#物理地址" class="headerlink" title="物理地址"></a>物理地址</h5><p>物理地址空间很好理解，它是指机器真实的物理内存所能表示的地址空间范围。比如对于只有64KB内存的系统来说，其物理地址范围是0x0000~0xFFFF。任何操作系统，最终都需要通过真实的物理地址来访问内存。</p>
<p>当系统开启了分页机制后，线性地址也需要经过一次转换才是物理地址。如下图所示：<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog7/p13.png" alt><br>在这个例子中，有两个概念</p>
<p>在这个例子中，有两个概念需要先说明一下。</p>
<ul>
<li><p>页<br>与分段机制不同的是，分页机制的操作对象是固定大小的内存块，称为“页”。一般情况下，页的大小为4KB。</p>
</li>
<li><p>页框<br>与页的概念相对应，页框是对物理内存的最小操作单位。显然，页和页框的大小必须完全一致，即4KB。</p>
</li>
</ul>
<p>如图所示，线性地址中的1、3、4、6页分别对应物理内存中的1、2、3、4页框。<br>这就意味着，如果一个线性地址刚好落在页3的范围中(线性地址是由页基址和偏移地址组成的，即线性地址=页基址+页内偏移量)，那么它对应的物理内存地址在页框2中( 即物理地址=页框2基址+页内偏移量)。</p>
<p>当前与物理内存没有映射关系的页(比如2、5、7页)，说明它们并不在内存中，因此访问时会产生一个缺页中断。此时操作系统会自动介入处理，利用一定的算法将当前不常用的页调出内存，从而为“缺失页”腾出位置，然后将“缺失页”从外存储器重新取回，最后返回中断点继续<br>操作。由于这些操作对访问者都是透明的，它们并不会感觉到“缺页”事件，从而保证了上层程序的稳定运行。</p>
<h4 id="内存保护"><a href="#内存保护" class="headerlink" title="内存保护"></a>内存保护</h4><p>最初的操作系统中，并没有严格意义的内存保护机制。对于内存的访问约束完全基于程序编写人员的自觉性一这 种做法显然是不可靠的。一方面，没有任何软件程序是十全十美的，它们或多或少都存在Bug，如内存越界:另一方面，那些“不怀好意”的程序可以很容易地攻击和破<br>坏系统中的数据。</p>
<p>人们逐渐认识到内存保护的必要性，并将其列入内存管理的重点。当然，保护方法也越来越多，越来越全面。<br>如上面所提到的分段和页式管理。因为每个进程的逻辑地址和物理地址都不是直接对应的，任何进程都没有办法访问到它管辖范围外的内存空间，即便刻意产生的内存越界与非法访问，操作系统也会马上阻止并强行关闭程序，从而有力地保障应用程序和操作系统的安全和稳定。</p>
<h4 id="内存分配与回收"><a href="#内存分配与回收" class="headerlink" title="内存分配与回收"></a>内存分配与回收</h4><p>对应用程序而言，内存的分配和回收是它们最关心的。换句话说，这是程序开发者与操作系统内存管理模块间的直接交互点。</p>
<p>既然是操作系统的重要组成部分，内存管理模块也同样遵循操作系统的定义，即为“上层建筑”控制和使用硬件(内存储器)提供有效的接口方法。Linux Kernel所面对的核心问题包括但不限于:</p>
<p><strong>1.保证硬件无关性</strong><br>每个硬件平台的物理内存型号、大小甚至架构(比如不同的体系结构)等都可能是不一样的。<br>这种差异绝不能体现在应用程序上，操作系统应尽可能实现向上的“透明”。</p>
<p><strong>2.动态分配内存和回收</strong><br>需要考虑的问题很多，如如何为内存划分不同的使用区域;分配的粒度问题，即分配的最小<br>单位;如何管理和区别已经使用和未使用的内存;如何回收和再利用等。</p>
<p><strong>内存碎片</strong><br>和磁盘管理一样，内存也一样会有碎片的问题。</p>
<p>举个例子，假设初始状态有6块未使用的内存单元。<br>随着程序不断地申请使用，前面5块已经成功分配。此时若某程序释放了第2块单元，那么最后将会有两块不连续的未使用内存单元存在—碎片形成。</p>
<p>另外，内核既要保证内存分配的合理性，也要考虑整体机制的高效性。内存的分配和回收是非常频繁的，如果没有办法实现高效管理，将会极大地影响系统的稳定性。</p>
<h4 id="进程间通信–mmap"><a href="#进程间通信–mmap" class="headerlink" title="进程间通信–mmap"></a>进程间通信–mmap</h4><p>mmap函数，它是兼容POSIX协议的一个系统调用。Linux Kernel和Android系统中都频繁使用到了这个函数。<br>比如上层应用在使用Binder 驱动前，就必须通过mmap()来为其正常工作提供环境。</p>
<p>正如其名所示(Memory Map)，mmap 可以将某个设备或者文件映射到应用进程的内存空间中，<br>这样访问这块内存就相当于对设备/文件进行读写，而不需要再通过read()，write()了 。</p>
<p>由此可见，理论上mmap也可以用于进程间通信，即通过映射同一块物理内存来共享内存。这种方式因为减少了数据复制的次数，在一定程度上能提高进程间通信的效率。</p>
<h3 id="Android中的Low-Memory-Killer"><a href="#Android中的Low-Memory-Killer" class="headerlink" title="Android中的Low Memory Killer"></a>Android中的Low Memory Killer</h3><p>嵌入式设备的一个普遍特点是内存容量相对有限。当运行的程序超过一定数量，或者涉及复杂的计算时，很可能出现内存不足，进而导致系统卡顿的现象。<br>Android 系统也不例外，它同样面临着设备物理内存短缺的困境。<br>另外，细心的开发者应该已经注意到了，对于已经启动过一次的Android程序，再一次启动所花的时间明显减少了。<br>原因就在于Android系统并不马上清理那些已经“淡出视野”的程序(比如调用Activity.finish退出UI界面)。<br>换句话说，它们在一定的时间里仍然驻留在内存中(虽然用户已经感觉不到它们的存在)。</p>
<p>这样做的好处是明显的，即下一次启动不需要再为程序重新创建-一个进程;<br>坏处也同样存在，那就是加大了内存0OM (Out of Memory)的概率。</p>
<p>那么，应该如何掌握平衡点呢?<br>熟悉Linux的开发人员应该知道，底层内核有自己的内存监控机制，即OOMKiller。一旦发现现系统的可用内存达到临界值，这个0OM的管理者就会自动跳出来“收拾残局”。<br>根据策略的不同，OOM的处理手段略有差异。不过它的核心思想始终是:<br>按照优先级顺序，从低到高逐步杀掉进程，回收内存。<br>优先级的设定策略一方面要考虑对系统的损害程度(例如系统的核心进程,优先级通常较高)<br>另一方面也希望尽可能多地释放无用内存。根据经验，一个合理的策略至少要综合以下几个因素</p>
<p>1.进程消耗的内存;<br>2.进程占用的 CPU时间:<br>3.oom adj (OOM权重)。</p>
<p>我们先来了解下Linux Kernel中的OOM Killer。内核所管理的进程都有一一个衡量其oom权重的值。<br>根据这一权重值以及上面所提及的若干其他因素，系统会实时给每个进程评分，以决定0OM时应该杀死哪些进程。<br>比如oom_ score分数越低的进程，被杀死的概率越小，或者说被杀死的时间越晚。</p>
<p>而Android系统则为此开发了一个专门的驱动，名为Low Memory Killer(LMK)<br>LMK为进程回收设定了层级，当内存不足时，先杀死级别较低的进程</p>
<h3 id="Android进程和线程"><a href="#Android进程和线程" class="headerlink" title="Android进程和线程"></a>Android进程和线程</h3><p>进程(Process)是程序的一一个运行实例，以区别于“程序”这一静态的概念;<br>而线程(Thread)则是CPU调度的基本单位。</p>
<p>当前大部分的操作系统都支持多任务运行，这一特性让用户感到计算机好像可以同时处理很多事情。<br>显然在只有一个CPU核心的情况下，这种“同时”是一种假象。<br>它是操作系统采用分时的方法，为正在运行的多个任务分配合理的、单独的CPU时间片来实现的。</p>
<p>举一个例子，假设当前系统中有5个任务，如果采用“平均分配”法且时间片为10ms的话，那么各个任务每隔40ms就能被执行一一次。<br>只要机器速度够快，用户的感觉就是所有任务都在同步运行。那么，Android中的程序和进程具体是什么概念呢?</p>
<p>我们知道，一个应用程序的主入口一般都是main函数，这基本上成了程序开发的-一种规范<br>它是“一切事物的起源”。 而main()函数的工作也是千篇一律的。 总结如下:</p>
<p>1.初始化<br>比如Windows环境下通常要创建窗口、向系统申请资源等。<br>2.进入死循环<br>并在循环中处理各种事件，直到进程退出。这种模型是“以事件为驱动”的软件系统的必然结果，因此几乎存在于任何操作系统和编程语言中。</p>
<h4 id="多进程实现"><a href="#多进程实现" class="headerlink" title="多进程实现"></a>多进程实现</h4><p>1.针对个别组件<br>可以在AndroidManifest.xml文件中的<activity>、<service>、 <receiver> 和<provider> (四大组件都支持，可以根据需要来添加)标签中加入android:process 属性来表明这一组件想要运行在哪个进程空间中。</provider></receiver></service></activity></p>
<p>2.针对整个程序包<br>可以直接在<application>标签中加入android:process属性来指明想要依存的进程环境。</application></p>
<p>3.结论<br>下面再来做个小结。<br>1）四大组件并不是程序(进程)的全部，而只是它的“零件”。<br>2）应用程序启动后，将创建ActivityThread主线程。<br>3）同一个包中的组件将运行在相同的进程空间中。<br>4）不同包中的组件可以通过一定的方式运行在-一个进程空间中。<br>5）一个Activity 应用启动后至少会有3个线程:即一个主线程和两个Binder线程。</p>
<h3 id="Handler-MessageQueue，Runable与Looper"><a href="#Handler-MessageQueue，Runable与Looper" class="headerlink" title="Handler,MessageQueue，Runable与Looper"></a>Handler,MessageQueue，Runable与Looper</h3><p>1.Handler就像搬运工<br>2.MessageQueue就像传送带<br>3.Looper就像发动机</p>
<p>Runnable利用Handler向MessageQueue中插入消息<br>然后Looper从MessageQueue中取出来，由于Looper创建在主线程，就完成了线程切换.<br>当前线程的Looper存储在ThreadLocal中</p>
<h3 id="Thread类"><a href="#Thread类" class="headerlink" title="Thread类"></a>Thread类</h3><p>Thread实现了Runnable，也就是说线程是可执行代码<br>线程有如下几种状态<br><figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">enum</span> <span class="title">State</span> &#123;</span></span><br><span class="line">	NEW，. / <span class="regexp">/线程已经创建，但还没有start</span></span><br><span class="line"><span class="regexp">	RUNNABLE，/</span><span class="regexp">/处于可运行状态，一切就绪</span></span><br><span class="line"><span class="regexp">	BLOCKED，/</span><span class="regexp">/处于阻塞状态， 比如等待某个锁的释放</span></span><br><span class="line"><span class="regexp">	WAITING，/</span><span class="regexp">/处于 等待状态</span></span><br><span class="line"><span class="regexp">	TIMED WAITING，/</span><span class="regexp">/ 等待特定的时间</span></span><br><span class="line"><span class="regexp">	TERMINATED /</span><span class="regexp">/终止运行</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p>
<h4 id="Thread休眠与唤醒"><a href="#Thread休眠与唤醒" class="headerlink" title="Thread休眠与唤醒"></a>Thread休眠与唤醒</h4><p><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog7/p14.png" alt><br>调用者只有成为Object的monitor后，才能调用它的wait方法。<br>而成为一个对象的monitor需要执行这个object的synchronized方法</p>
<h4 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt"></a>interrupt</h4><p>如果说wait是一种“自愿”的行为，那么interrupt就是“被迫”的了。调用-一个线程的interrupt的目的和这个单词的字面意思一样，就是“中断”它的执行过程。此时有以下3种可能性。<br>1.如果Thread正被blocked在某个object的wait. 上，或者join()， sleep(方法中， 那么会被唤醒，中断状态会被清除并接收到InterruptedException。<br>2.如果 Thread被blocked在InterruptibleChannel的I/O操作中，那么中断状态会被置位，并接收到ClosedByInterruptException，此时channel 会被关闭。<br>3.如果Thread被blocked 在Selector中， 那么中断状态会被置位并且马上返回，不会收到任何exception。</p>
<p>在Core Java中有这样一句话：”没有任何语言方面的需求要求一个被中断的程序应该终止。中断一个线程只是为了引起该线程的注意，被中断线程可以决定如何应对中断 “。<br>但是当线程被阻塞的时候，比如被Object.wait, Thread.join和Thread.sleep三种方法之一阻塞时。调用它的interrput()方法。可想而知，没有占用CPU运行的线程是不可能给自己的中断状态置位的。这就会产生一个InterruptedException异常。</p>
<h4 id="join"><a href="#join" class="headerlink" title="join"></a>join</h4><p>它希望达到的目的就是只有当tl线程执行完成时，我们才接着执行后面的t2.start()。这样就保证了两个线程的顺序执行。<br>而带有时间参数的join()则多了一个限制，即假如在规定时间内t1没有执行完成，那么我们也会继续执行后面的语句，以防止“无限等待”拖垮整个程序。</p>
<h4 id="Sleep"><a href="#Sleep" class="headerlink" title="Sleep"></a>Sleep</h4><p>释放cpu不释放锁</p>
<p>下面看下Thread的状态迁移图<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog7/p15.png" alt></p>
<h3 id="Android应用程序的典型启动流程"><a href="#Android应用程序的典型启动流程" class="headerlink" title="Android应用程序的典型启动流程"></a>Android应用程序的典型启动流程</h3><p>1.Launcher同样也是一个Activity，他启动一个App同样是从startActivity开始的，比如Launcher通知AMS启动我们清单文件中配置的启动Activity<br>2.AMS记录要启动的Activity信息，并通知Launcher进入onPause状态<br>3.Launcher进入onPause状态，并通知AMS自已已经pause了，可以启动Activity了<br>4.AMS判断APP从未启动过，所以利用zygot fort一个新的进程，并且在新进程中创建ActivityThread对象，并执行其main方法<br>5.APP主线程启动完毕后通知AMS，并传入ApplicationThread以便通信<br>6.AMS通过ApplicationThread通知App绑定Application并启动MainActivity<br>7.APP启动MainActivity，然后就到了startActivity的流程</p>
<h3 id="startActivity流程"><a href="#startActivity流程" class="headerlink" title="startActivity流程"></a>startActivity流程</h3><p>Activity的启动过程，我们可以从Context的startActivity说起，其实现是ContextImpl的startActivity，<br>然后内部会通过Instrumentation来尝试启动Activity，这是一个跨进程过程，它会调用ams的startActivity方法，当ams校验完activity的合法性后，<br>会通过ApplicationThread回调到我们的进程，这也是一次跨进程过程，而applicationThread就是一个binder，回调逻辑是在binder线程池中完成的.<br>所以需要通过Handler H将其切换到ui线程，第一个消息是LAUNCH_ACTIVITY，它对应handleLaunchActivity，在这个方法里完成了Activity的创建和启动.<br>接着，在activity的onResume中，activity的内容将开始渲染到window上，然后开始绘制直到我们看见。</p>
<h3 id="Android程序的内存管理与优化"><a href="#Android程序的内存管理与优化" class="headerlink" title="Android程序的内存管理与优化"></a>Android程序的内存管理与优化</h3><h4 id="Android系统对内存使用的限制"><a href="#Android系统对内存使用的限制" class="headerlink" title="Android系统对内存使用的限制"></a>Android系统对内存使用的限制</h4><p>Android是-一个支持多任务运行的系统，这意味着每个程序所占用的内存越小，理论上可以同时运行的进程数量就越多。<br>随着硬件设备的不断升级换代，Android虚拟机系统允许单个进程所能使用的Heap Size 的上限也在呈现上升趋势。<br>具体来说，这个值是由特定的系统属性“dalvik.vm.heapsize”决定的。譬如Android 5.0版本中的堆大小是: 48M.</p>
<p>一旦进程申请的heap空间超过系统的阈值，就会引发OutOfMemory (OOM)的错误。不过发生这种情况通常只能说明个体情况的“违规”,而不是设备真地已经没有任何可用的内存空间了。</p>
<p>值得一提的是，Android 系统允许开发人员在AndroidManifest.xml 的<application>中将android:largeHeap赋值为true，以便获得更大的HeapSize。<br>LargeHeapSize的具体值可以通过getLargeMemoryClass()来取得。<br>不过，这个方法只限于-一些确实需要大内存空间的程序(如图像处理类程序)，切忌在出现0OM时为了偷懶而直接使用它，这样所带来的最终后果通常是得不偿失的。</application></p>
]]></content>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>ASM插桩学习</title>
    <url>/blog/2020/10/asm-transoform-learn.html</url>
    <content><![CDATA[<h3 id="ASM介绍"><a href="#ASM介绍" class="headerlink" title="ASM介绍"></a>ASM介绍</h3><p>ASM是一个字节码操作库，它可以直接修改已经存在的class文件或者生成class文件。ASM提供了一些便捷的功能来操作字节码内容。</p>
<p>与其它字节码操作框架（比如：AspectJ等）相比，ASM更偏向于底层，它是直接操作字节码的，在设计上相对更小、更快，所以在性能上更好，而且几乎可以任意修改字节码。</p>
<p>同时ASM在编译期处理字节码,对性能没什么影响</p>
<h3 id="为什么要有ASM"><a href="#为什么要有ASM" class="headerlink" title="为什么要有ASM"></a>为什么要有ASM</h3><p>我们都知道任何的字节码操作库最终都是要修改.class文件的，在Android平台上通常是.class转.dex阶段。<br>但是字节码文件格式很复杂，如果我们直接修改字节码文件会很困难，而且操作起来极度不便。</p>
<p>于是ASM出现了，它对字节码指令再做一层封装，对外提供了一系列ASM API</p>
<h3 id="几个问题"><a href="#几个问题" class="headerlink" title="几个问题"></a>几个问题</h3><p>通过上面的讲解,我们知道ASM的原理即是，获取所有class文件并拦截，修改class文件后替换原文件。<br>感觉跟动态代理比较像。<br>于是，我们需要思考几个问题</p>
<blockquote>
<p>1、如何获取所有编译后的class文件，如何拦截，并替换他们？<br>2、如何修改某个class文件？<br>3、修改完成之后，如何替换原有的class,达到hook的目的？</p>
</blockquote>
<p>下面我们来一起解决这几个问题</p>
<p>Q1:在Android开发中，字节码插桩的时机是在apk打包过程的class转dex阶段；而Gradle已经给我们提供了一个工具在这个阶段做一些事情，比如修改class内容，它就是Transform API。通过Transform就可以获取到所有的.class文件,包括jar包中的，然后你可以根据自己的需求过滤出需要的.class文件。<br>这一步非常关键，需要你掌握Gradle插件和Transform的知识，如果你还不太熟悉它们，可以参考：<br><a href="https://www.jianshu.com/p/f902b51e242b" target="_blank" rel="noopener">Android 自定义Gradle插件的3种方式</a><br><a href="https://www.jianshu.com/p/cf90c557b866" target="_blank" rel="noopener">Android Gradle Transform 详解</a></p>
<p>Q2:在上一步的Transform API中可以拿到需要处理的class文件，但是并不能知道class的具体内容和格式，所以需要借助一个工具来解析class文件结构，这个工具就是ASM，它不仅能解析class，还提供了大量的API来修改class内容，几乎所有的CRUD操作都可以完成。</p>
<p>Q3:在修改完class之后，只需要按照原来文件的路径，通过FileOutputStream文件流的形式去覆盖原文件即可。</p>
<h3 id="ASM核心API"><a href="#ASM核心API" class="headerlink" title="ASM核心API"></a>ASM核心API</h3><p>ASM Core API提供了3个类来操作字节码，分别是：</p>
<p>1.ClassReader:对具体的class文件进行读取与解析；</p>
<p>2.ClassWriter:将修改后的class文件通过文件流的方式覆盖掉原来的class文件，从而实现class修改；</p>
<p>3.ClassVisitor:可以访问class文件的各个部分，比如方法、变量、注解等，这也是修改原代码的地方。</p>
<h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><h4 id="1-使用buildSrc模式来定义插件"><a href="#1-使用buildSrc模式来定义插件" class="headerlink" title="1.使用buildSrc模式来定义插件"></a>1.使用buildSrc模式来定义插件</h4><p>具体的使用buildSrc模式定义插件的代码可见<br><a href="https://www.jianshu.com/p/f902b51e242b" target="_blank" rel="noopener">Android 自定义Gradle插件的3种方式</a></p>
<h4 id="2-实现自定义Transform"><a href="#2-实现自定义Transform" class="headerlink" title="2.实现自定义Transform"></a>2.实现自定义Transform</h4><p>主要目的是遍历class文件，查找目标class,便于后面的修改.<br>源码可见：<a href="https://github.com/shenzhen2017/AsmTimeUtil/blob/main/buildSrc/src/main/groovy/com/zj/plugin/MyTransform.groovy" target="_blank" rel="noopener">https://github.com/shenzhen2017/AsmTimeUtil/blob/main/buildSrc/src/main/groovy/com/zj/plugin/MyTransform.groovy</a><br><strong>代码详解</strong><br>1、通过DirectoryInput遍历所有的文件，如果有子文件夹，也会找到其包含的class文件，然后只处理其中的Activity文件（我这里是通过文件名来过滤的，可能不是很严谨，不过不影响大局，后面会说更好的方式）。</p>
<p>2、在找到目标Activity文件之后，就可以做字节码操作相关的事情了。先来说一下大体的流程：</p>
<p>2.1、ClassReader：对class文件进行读取与解析；<br>2.2、ClassWriter：对class文件写入；<br>2.3、ClassVisitor：可以访问class文件的各个部分，在ClassReader解析到某一个结构就会通知到ClassVisitor的相应方法，比如解析到方法会回调ClassVisitor#visitMethod,其它属性、注解等也有对应的方法；<br>2.4、 classReader.accept：依次调用 ClassVisitor的各个方法<br>2.5、 classWriter.toByteArray()：将最终修改的字节码以 byte 数组形式返回。<br>2.6、FileOutputStream：通过文件流写入方式覆盖掉原先的内容，实现class文件的改写。</p>
<h4 id="3-实现ClassVisitor"><a href="#3-实现ClassVisitor" class="headerlink" title="3.实现ClassVisitor"></a>3.实现ClassVisitor</h4><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LifecycleClassVisitor</span> <span class="title">extends</span> <span class="title">ClassVisitor</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> className;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LifecycleClassVisitor</span><span class="params">(ClassVisitor cv)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 参数1：ASM API版本，源码规定只能为4，5，6</span></span><br><span class="line"><span class="comment">         * 参数2：ClassVisitor不能为 null</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        super(Opcodes.ASM6, cv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(<span class="keyword">int</span> version, <span class="keyword">int</span> access, <span class="keyword">String</span> name, <span class="keyword">String</span> signature, <span class="keyword">String</span> superName, <span class="keyword">String</span>[] interfaces)</span> </span>&#123;</span><br><span class="line">        super.visit(version, access, name, signature, superName, interfaces);</span><br><span class="line">        <span class="keyword">this</span>.className = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="function"><span class="keyword">public</span> MethodVisitor <span class="title">visitMethod</span><span class="params">(<span class="keyword">int</span> access, <span class="keyword">String</span> name, <span class="keyword">String</span> desc, <span class="keyword">String</span> signature, <span class="keyword">String</span>[] exceptions)</span> </span>&#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"ClassVisitor visitMethod name-------"</span> + name);</span><br><span class="line">        MethodVisitor mv = cv.visitMethod(access, name, desc, signature, exceptions);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (name.startsWith(<span class="string">"on"</span>)) &#123;</span><br><span class="line">            <span class="comment">//处理onXX()方法</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> LifecycleMethodVisitor(mv, className, name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mv;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitEnd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        super.visitEnd();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个类很好理解，就是访问类的时候会调用它，在解析到class的各部分的时候会调用visitXX()方法，而且这些方法的调用是有顺序的</p>
<p>在这里，我只想在Activity生命周期的方法里插入一句代码，所以我只关注visitMethod()方法即可这里通过方法名找到对应的方法，然后就可以完成代码的插入了。这个方法返回了一个MethodVisitor对象，如果你要修改方法的内容就会用到它，</p>
<h4 id="4-实现MethodVisitor"><a href="#4-实现MethodVisitor" class="headerlink" title="4.实现MethodVisitor"></a>4.实现MethodVisitor</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LifecycleMethodVisitor</span> <span class="keyword">extends</span> <span class="title">MethodVisitor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String className;</span><br><span class="line">    <span class="keyword">private</span> String methodName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LifecycleMethodVisitor</span><span class="params">(MethodVisitor methodVisitor, String className, String methodName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(Opcodes.ASM6, methodVisitor);</span><br><span class="line">        <span class="keyword">this</span>.className = className;</span><br><span class="line">        <span class="keyword">this</span>.methodName = methodName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法执行前插入</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.visitCode();</span><br><span class="line">        System.out.println(<span class="string">"MethodVisitor visitCode------"</span>);</span><br><span class="line"></span><br><span class="line">        mv.visitLdcInsn(<span class="string">"TAG"</span>);</span><br><span class="line">        mv.visitLdcInsn(className + <span class="string">"-------&gt;"</span> + methodName);</span><br><span class="line">        mv.visitMethodInsn(Opcodes.INVOKESTATIC, <span class="string">"android/util/Log"</span>, <span class="string">"e"</span>, <span class="string">"(Ljava/lang/String;Ljava/lang/String;)I"</span>, <span class="keyword">false</span>);</span><br><span class="line">        mv.visitInsn(Opcodes.POP);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法执行后插入</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitInsn</span><span class="params">(<span class="keyword">int</span> opcode)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        if (opcode==Opcodes.RETURN)&#123;</span></span><br><span class="line"><span class="comment">//            mv.visitLdcInsn("TAG");</span></span><br><span class="line"><span class="comment">//            mv.visitLdcInsn(className + "-------&gt;" + methodName);</span></span><br><span class="line"><span class="comment">//            mv.visitMethodInsn(Opcodes.INVOKESTATIC, "android/util/Log", "e", "(Ljava/lang/String;Ljava/lang/String;)I", false);</span></span><br><span class="line"><span class="comment">//            mv.visitInsn(Opcodes.POP);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="keyword">super</span>.visitInsn(opcode);</span><br><span class="line">        System.out.println(<span class="string">"MethodVisitor visitInsn------"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitEnd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.visitEnd();</span><br><span class="line">        System.out.println(<span class="string">"MethodVisitor visitEnd------"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是真正修改字节码内容的地方，这个类也有一系列visitXX()方法，并且是按顺序执行的，这里着重讲2个方法</p>
<p><strong>visitCode</strong><br>表示开始访问方法，表示在方法执行前插入<br>这段代码实际上大概如下所示：<br><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Log</span>.<span class="built_in">e</span>(<span class="string">"TAG"</span>, <span class="string">"MainActivity-------&gt;onCreate()"</span>);</span><br></pre></td></tr></table></figure></p>
<p>ASm框架为了写这一行代码，需要写这么多行代码，对于应用开发者来说是很麻烦的<br>我们可以借助ASM Bytecode Outline插件来完成，在插件市场安装后，右键show Bytecode outline即可将java代码转换成ASM代码<br>然后将相应ASM代码拷贝出来即可。</p>
<p><strong>visitInsn</strong><br>访问零操作指令，比如访问return指令.</p>
<p>如果想在方法最后织入代码，写在visitEnd方法内是无效的，因为回调它的时候方法已经访问结束了。但是有一个迂回的解决办法，方法执行结束前都会有一个return指令，即使你的方法返回值为void，那编译成字节码时会默认补上一个return指令。</p>
<p>所以可以 在visitInsn中实现在方法结束时插桩。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>1.ASM框架入门不难，但也并不简单，对基础要求较高，至少需要你掌握APK打包流程，自定义Gradle插件，Transform API以及AOP思想。<br>2.ASM使用起来比较复杂，写一条java指令需要很多行代码才能实现，这是因为他是直接操作字节码指令的。<br>3.ASM足够强大，由于是直接操作字节码，效率更高，同时因为工作在编译期完成，不会影响性能。</p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://www.jianshu.com/p/d5333660e312?utm_campaign=haruki" target="_blank" rel="noopener">Android ASM快速入门</a><br><a href="https://www.jianshu.com/p/16ed4d233fd1" target="_blank" rel="noopener">【Android】函数插桩（Gradle + ASM）</a><br><a href="https://www.jianshu.com/p/b33da498d6ba" target="_blank" rel="noopener">Android 中使用ASM，对Activity生命周期打点统计</a><br><a href="https://juejin.im/post/6844904118700474375" target="_blank" rel="noopener">深入探索编译插桩技术（四、ASM 探秘）</a><br><a href="https://juejin.im/entry/6844903466188406792" target="_blank" rel="noopener">ASM 实战统计方法耗时</a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>ARTS打卡1</title>
    <url>/blog/2020/10/arts-way-one.html</url>
    <content><![CDATA[<h3 id="什么是ARTS"><a href="#什么是ARTS" class="headerlink" title="什么是ARTS"></a>什么是ARTS</h3><p>在开始ARTS打卡之前，先介绍一下什么是ARTS<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog8/p1.png" alt></p>
<p>ARTS 源于极客时间《左耳听风》专栏组织的一个学习打卡活动，四个字母对应着四个行动准则：<br>Algorithm：每周至少做一个 leetcode 的算法题<br>Review: 阅读并点评一篇英文技术文章<br>Tip：学习至少一个技术技巧<br>Share：[撰写并]分享一篇有观点和思考的技术文章</p>
<p>图片来源: <a href="https://mp.weixin.qq.com/s/WMlApIA-v8zpB9l-VlMlyw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/WMlApIA-v8zpB9l-VlMlyw</a></p>
<h3 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h3><p><a href="https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/" target="_blank" rel="noopener">剑指 Offer 21. 调整数组顺序使奇数位于偶数前面</a></p>
<p>解析<br>通过定义双指针的方式来实现<br>1.定义头指针 left ，尾指针 right<br>2.left 一直往右移，直到它指向的值为偶数<br>3.right 一直往左移， 直到它指向的值为奇数<br>4.交换 nums[left] 和 nums[right] .<br>重复上述操作，直到 left==right .</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">fun exchange(nums: <span class="type">IntArray</span>): <span class="type">IntArray</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> <span class="keyword">left</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> <span class="keyword">right</span> = nums.size - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">left</span> &lt; <span class="keyword">right</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[<span class="keyword">left</span>]%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">left</span>++</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[<span class="keyword">right</span>]%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">right</span>--</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">left</span> &lt; <span class="keyword">right</span>) &#123;</span><br><span class="line">                val temp = nums[<span class="keyword">left</span>]</span><br><span class="line">                nums[<span class="keyword">left</span>] = nums[<span class="keyword">right</span>]</span><br><span class="line">                nums[<span class="keyword">right</span>] = temp</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h3><p><a href="https://docs.gradle.org/current/userguide/composite_builds.html" target="_blank" rel="noopener">Composite builds</a><br>本文主要讲述了gradle的composite build<br>composite build可以实现<br>1.允许我们可以组合通常独立开发的构建，例如在应用程序使用的库中尝试bug修复时,可以方便实现aar与源码的切换<br>2.允许我们将大型多项目构建分解为更小、更孤立的模块，这些模块可以根据需要独立或一起工作</p>
<h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><p><strong>git merge —no-off 与 git merge的区别</strong></p>
<p>git merge –no-ff 可以保存你之前的分支历史。能够更好的查看 merge历史，以及branch 状态。</p>
<p>git merge 则不会显示 feature，只保留单条分支记录。</p>
<h3 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h3><p>《深入理解Android内核设计思想》读书笔记,第四与第五章<br><a href="https://shenzhen2017.github.io/blog/2020/10/android-kernal-read.html">https://shenzhen2017.github.io/blog/2020/10/android-kernal-read.html</a></p>
]]></content>
      <tags>
        <tag>ARTS</tag>
      </tags>
  </entry>
  <entry>
    <title>Viewmodel完全解析</title>
    <url>/blog/2020/10/viewmodel-sum-up.html</url>
    <content><![CDATA[<p>随着Jetpack的发布，为我们开发提供了不少便利，ViewModel就是其中之一。<br>ViewModel 类旨在以注重生命周期的方式存储和管理界面相关的数据。ViewModel 类让数据可在发生屏幕旋转等配置更改后继续留存。</p>
<h3 id="ViewModel使用的四种方式"><a href="#ViewModel使用的四种方式" class="headerlink" title="ViewModel使用的四种方式"></a>ViewModel使用的四种方式</h3><p>下面介绍下ViewModel的四种使用方式</p>
<ul>
<li>ViewModel 中的 Saved State —— 后台进程重启时，ViewModel 的数据恢复；</li>
<li>在 NavGraph 中使用 ViewModel —— ViewModel 与导航 (Navigation) 组件库的集成；</li>
<li>ViewModel 配合数据绑定 (data-binding) —— 通过使用 ViewModel 和 LiveData 简化数据绑定；</li>
<li>viewModelScope —— Kotlin 协程与 ViewModel 的集成。</li>
</ul>
<p>下面介绍下我常用的ViewModel数据恢复与ViewModel与协程结合两种，更多的可见：<br><a href="https://zhuanlan.zhihu.com/p/143346337" target="_blank" rel="noopener">知识点 | ViewModel 四种集成方式</a></p>
<h4 id="ViewModel-的-Saved-State-——-后台进程重启时，ViewModel-的数据恢复"><a href="#ViewModel-的-Saved-State-——-后台进程重启时，ViewModel-的数据恢复" class="headerlink" title="ViewModel 的 Saved State —— 后台进程重启时，ViewModel 的数据恢复"></a>ViewModel 的 Saved State —— 后台进程重启时，ViewModel 的数据恢复</h4><p>我们都知道，在屏幕旋转时，ViewModel可以保存数据。<br>但是当应用在后台进程被系统杀死，当重新打开页面时，ViewModel的数据并不会恢复.<br>这种情况就需要与SavedStateHandle结合，在后台进程回收时保存数据.</p>
<p>下面我们来看下如何使用SavedStateHandle</p>
<h5 id="第一步-添加依赖"><a href="#第一步-添加依赖" class="headerlink" title="第一步: 添加依赖"></a>第一步: 添加依赖</h5><p>SaveStateHandle 目前在一个独立的模块中，您需要在依赖中添加:<br><figure class="highlight flix"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lifecycle_version</span> </span>= <span class="string">"2.2.0"</span></span><br><span class="line">implementation <span class="string">"androidx.lifecycle:lifecycle-viewmodel-savedstate:$lifecycle_version</span></span><br></pre></td></tr></table></figure></p>
<h5 id="第二步-修改调用-ViewModelProvider-的方式"><a href="#第二步-修改调用-ViewModelProvider-的方式" class="headerlink" title="第二步: 修改调用 ViewModelProvider 的方式"></a>第二步: 修改调用 ViewModelProvider 的方式</h5><p>接下来，您需要创建一个持有 SaveStateHandle 的 ViewModel。在 Activity 或 Fragment 的 onCreate 方法中，将 ViewModelProvider 的调用修改为:<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//下面的 Kotlin 扩展需要依赖以下或更新新版本的 ktx 库：</span></span><br><span class="line"><span class="comment">//androidx.fragment:fragment-ktx:1.0.0（最新版本 1.2.4） 或</span></span><br><span class="line"><span class="comment">//androidx.activity:activity-ktx:1.0.0 （最新版本 1.1.0）</span></span><br><span class="line"><span class="keyword">val</span> viewModel <span class="keyword">by</span> viewModels &#123; SavedStateViewModelFactory(application, <span class="keyword">this</span>) &#125;</span><br><span class="line"><span class="comment">// 或者不使用 ktx</span></span><br><span class="line"><span class="keyword">val</span> viewModel = ViewModelProvider(<span class="keyword">this</span>, SavedStateViewModelFactory(application, <span class="keyword">this</span>))</span><br><span class="line">            .<span class="keyword">get</span>(MyViewModel::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br></pre></td></tr></table></figure></p>
<p>创建 ViewModel 的类是 ViewModel 工厂 (ViewModel factory)，而创建包含 SaveStateHandle 的 View Model 的工厂类是 SavedStateViewModelFactory。通过此工厂创建的 ViewModel 将持有一个基于传入 Activity 或 Fragment 的 SaveStateHandle。</p>
<h5 id="第三步-使用-SaveStateHandle"><a href="#第三步-使用-SaveStateHandle" class="headerlink" title="第三步: 使用 SaveStateHandle"></a>第三步: 使用 SaveStateHandle</h5><p>当前面的步骤准备完成时，您就可以在 ViewModel 中使用 SavedStateHandle 了。下面是一个保存用户 ID 的示例：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyViewModel</span></span>(state :SavedStateHandle) :ViewModel() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将Key声明为常量</span></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> USER_KEY = <span class="string">"userId"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> savedStateHandle = state</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">saveCurrentUser</span><span class="params">(userId: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 存储 userId 对应的数据</span></span><br><span class="line">        savedStateHandle.<span class="keyword">set</span>(USER_KEY, userId)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getCurrentUser</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="comment">// 从 saveStateHandle 中取出当前 userId</span></span><br><span class="line">        <span class="keyword">return</span> savedStateHandle.<span class="keyword">get</span>(USER_KEY)?: <span class="string">""</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果您想要在 ViewModel 中使用 LiveData，可以调用SavedStateHandle.getLiveData()，示例如下:</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">// getLiveData 方法会取得一个与 key 相关联的 MutableLiveData </span></span><br><span class="line"><span class="comment">// 当与 key 相对应的 value 改变时 MutableLiveData 也会更新。</span></span><br><span class="line"><span class="keyword">private</span> val _userId : MutableLiveData&lt;<span class="keyword">String</span>&gt; = savedStateHandle.getLiveData(USER_KEY)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只暴露一个不可变 LiveData 的情况</span></span><br><span class="line">val userId : LiveData&lt;<span class="keyword">String</span>&gt; = _userId</span><br></pre></td></tr></table></figure>
<h4 id="ViewMode-与-Kotlin-协程-viewModelScope"><a href="#ViewMode-与-Kotlin-协程-viewModelScope" class="headerlink" title="ViewMode 与 Kotlin 协程: viewModelScope"></a>ViewMode 与 Kotlin 协程: viewModelScope</h4><p>通常情况下，我们使用回调 (Callback) 处理异步调用，这种方式在逻辑比较复杂时，会导致回调层层嵌套，代码也变得难以理解。Kotlin 协程 (Coroutines)同样适用于处理异步调用，它让逻辑变得简单的同时，也确保了操作不会阻塞主线程</p>
<p>一段简单的协程代码:<br><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 下面是示例代码，真实情景下不要使用 GlobalScope </span></span><br><span class="line"><span class="selector-tag">GlobalScope</span><span class="selector-class">.launch</span> &#123;</span><br><span class="line">    <span class="selector-tag">longRunningFunction</span>()</span><br><span class="line">    <span class="selector-tag">anotherLongRunningFunction</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这段示例代码只启动了一个协程，但我们在真实的使用环境下很容易创建出许多协程，这就难免会导致有些协程的状态无法被跟踪。如果这些协程中刚好有您想要停止的任务时，就会导致任务泄漏(work leak)。</p>
<p>为了防止任务泄漏，您需要将协程加入到一个CoroutineScope中。CoroutineScope 可以持续跟踪协程的执行，它可以被取消。当 CoroutineScope 被取消时，它所跟踪的所有协程都会被取消。上面的代码中，我使用了GlobalScope，正如我们不推荐随意使用全局变量一样，这种方式通常不推荐使用。所以，如果想要使用协程，您要么限定一个作用域 (scope)，要么获得一个作用域的访问权限。而在 ViewModel 中，我们可以使用 viewModelScope 来管理协程的作用域。</p>
<h5 id="viewModelScope"><a href="#viewModelScope" class="headerlink" title="viewModelScope"></a>viewModelScope</h5><p>当 ViewModel 被销毁时，通常都会有一些与其相关的操作也应当被停止。</p>
<p>例如，假设您正在准备将一个位图 (bitmap) 显示到屏幕上。这种操作就符合我们前面提到的一些特征: 既不能在执行时阻塞主线程，又要求在用户退出相关界面时停止执行。使用协程进行此类操作时，就应当使用viewModelScope。</p>
<p>viewModelScope 是一个 ViewModel 的 Kotlin 扩展属性。正如前面所说，它能在 ViewModel 销毁时 (onCleared()方法调用时) 退出。这样一来，只要您使用了 ViewModel，您就可以使用 viewModelScope 在 ViewModel 中启动各种协程，而不用担心任务泄漏<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyViewModel</span></span>() : ViewModel() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">initialize</span><span class="params">()</span></span> &#123;</span><br><span class="line">        viewModelScope.launch &#123;</span><br><span class="line">            processBitmap()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">processBitmap</span><span class="params">()</span></span> = withContext(Dispatchers.Default) &#123;</span><br><span class="line">        <span class="comment">// 在这里做耗时操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="ViewModel为什么旋转时可以保存数据？"><a href="#ViewModel为什么旋转时可以保存数据？" class="headerlink" title="ViewModel为什么旋转时可以保存数据？"></a>ViewModel为什么旋转时可以保存数据？</h3><p>我们都知道 ViewModel 不会因为 Activity 的旋转发生改变而销毁，ViewModel 作用域如下所示：<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog8/p2.webp" alt><br>观察上图，我相信小伙伴们肯定有如下疑惑：<br>当 Activity 因旋转发生改变时，系统会重新创建一个新的 Activity 。那老的 Activity 中的 ViewModel 是如何传递给新的 Activity 的呢？</p>
<p>我们首先了解下数据恢复的几种常见方式</p>
<h4 id="使用-onSaveInstanceState-与-onRestoreInstanceState"><a href="#使用-onSaveInstanceState-与-onRestoreInstanceState" class="headerlink" title="使用 onSaveInstanceState 与 onRestoreInstanceState"></a>使用 onSaveInstanceState 与 onRestoreInstanceState</h4><p>当您的 Activity 开始停止时，系统会调用 onSaveInstanceState() 方法，以便您的 Activity 可以将状态信息保存到实例状态 Bundle 中。</p>
<p>重建先前被销毁的 Activity 后，您可以从系统传递给 Activity 的 Bundle 中恢复保存的实例状态。onCreate() 和 onRestoreInstanceState() 回调方法均会收到包含实例状态信息的相同 Bundle。</p>
<h4 id="使用-Fragment-的-setRetainInstance"><a href="#使用-Fragment-的-setRetainInstance" class="headerlink" title="使用 Fragment 的 setRetainInstance"></a>使用 Fragment 的 setRetainInstance</h4><p>当配置发生改变时，Fragment 会随着宿主 Activity 销毁与重建，当我们调用 Fragment 中的 setRetainInstance(true) 方法时，系统允许 Fragment 绕开销毁-重建的过程。使用该方法，将会发送信号给系统，让 Activity 重建时，保留 Fragment 的实例。需要注意的是：</p>
<ul>
<li>使用该方法后，不会调用 Fragment 的 onDestory() 方法，但仍然会调用 onDetach() 方法</li>
<li>使用该方法后，不会调用 Fragment 的 onCreate(Bundle) 方法。因为 Fragment 没有被重建。</li>
<li>使用该方法后，Fragment 的 onAttach(Activity) 与 onActivityCreated(Bundle) 方法仍然会被调用。</li>
</ul>
<h4 id="使用-onRetainNonConfigurationInstance-与-getLastNonConfigurationInstance"><a href="#使用-onRetainNonConfigurationInstance-与-getLastNonConfigurationInstance" class="headerlink" title="使用 onRetainNonConfigurationInstance 与 getLastNonConfigurationInstance"></a>使用 onRetainNonConfigurationInstance 与 getLastNonConfigurationInstance</h4><p>在 Activity 中提供了 onRetainNonConfigurationInstance 方法，用于处理配置发生改变时数据的保存。随后在重新创建的 Activity 中调用 getLastNonConfigurationInstance 获取上次保存的数据。我们不能直接重写上述方法，如果想在 Activity 中自定义想要恢复的数据，需要我们调用上述两个方法的内部方法：</p>
<ul>
<li>onRetainCustomNonConfigurationInstance()</li>
<li>getLastCustomNonConfigurationInstance()</li>
</ul>
<p>注意：onRetainNonConfigurationInstance 方法系统调用时机介于 onStop - onDestory 之间，getLastNonConfigurationInstance 方法可在 onCreate 与 onStart 方法中调用。</p>
<h4 id="几种数据恢复方式的总结"><a href="#几种数据恢复方式的总结" class="headerlink" title="几种数据恢复方式的总结"></a>几种数据恢复方式的总结</h4><p>通过了解数据恢复的几种方式，我们能得到如下对比图：<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog8/p3.webp" alt></p>
<h4 id="ViewModel-的恢复"><a href="#ViewModel-的恢复" class="headerlink" title="ViewModel 的恢复"></a>ViewModel 的恢复</h4><p>ViewModel 在官方设计之初就倾向于在配置改变时进行数据的恢复。考虑到数据恢复时的效率，官方最终采用了 onRetainNonConfigurationInstance 的方式来恢复 ViewModel 。</p>
<p>知道了 ViewModel 的恢复方式，那现在一起来解决我们之前的疑惑。当 Activity 因配置发生改变时，系统会重新创建一个新的 Activity 。那老的 Activity 中的 ViewModel 是如何传递给新的 Activity ？</p>
<p>在 Androidx 中的 Activity 的最新代码中，官方重写了 onRetainNonConfigurationInstance 方法，在该方法中保存了 ViewModelStore (ViweModelStore 中存储了 ViewModel )，进而也保存了 ViewModel，具体代码如下所示：<br><figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">public final Object onRetainNonConfigurationInstance() &#123;</span><br><span class="line">    Object <span class="attr">custom</span> = onRetainCustomNonConfigurationInstance();</span><br><span class="line"></span><br><span class="line">    ViewModelStore <span class="attr">viewModelStore</span> = mViewModelStore;</span><br><span class="line">    <span class="keyword">if</span> (<span class="attr">viewModelStore</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">        NonConfigurationInstances <span class="attr">nc</span> =</span><br><span class="line">                (NonConfigurationInstances) getLastNonConfigurationInstance();</span><br><span class="line">        <span class="keyword">if</span> (nc != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="attr">viewModelStore</span> = nc.viewModelStore;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="attr">viewModelStore</span> == <span class="literal">null</span> &amp;&amp; <span class="attr">custom</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">        return <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //将ViewModel存储在 NonConfigurationInstances 对象中</span><br><span class="line">    NonConfigurationInstances <span class="attr">nci</span> = new NonConfigurationInstances();</span><br><span class="line">    nci.<span class="attr">custom</span> = custom;</span><br><span class="line">    nci.<span class="attr">viewModelStore</span> = viewModelStore;</span><br><span class="line">    return nci;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>于是我们知道，在屏幕旋转后，当新的 Activity 重新创建，并调用 ViewModelProviders.of(this).get(xxxModel.class) 时，又会在 getViewModelStore() 方法中获取老 Activity 保存的 ViewModelStore。</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ViewModelStore getViewModelStore() &#123;</span><br><span class="line">    <span class="keyword">if</span> (getApplication() == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalStateException</span>(<span class="string">"Your activity is not yet attached to the "</span></span><br><span class="line">                + <span class="string">"Application instance. You can't request ViewModel before onCreate call."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mViewModelStore == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//👇获取保存的NonConfigurationInstances，</span></span><br><span class="line">        NonConfigurationInstances nc =</span><br><span class="line">                (NonConfigurationInstances) getLastNonConfigurationInstance();</span><br><span class="line">        <span class="keyword">if</span> (nc != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//👇从该对象中获取ViewModelStore</span></span><br><span class="line">            mViewModelStore = nc.viewModelStore;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mViewModelStore == <span class="literal">null</span>) &#123;</span><br><span class="line">            mViewModelStore = <span class="keyword">new</span> <span class="type">ViewModelStore</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mViewModelStore;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而ViewModel实际是存储在ViewModelStore中的,ViewModelStore还原后，那么也就拿到了 ViewModel。具体代码如下所示：<br>从ViewModelStroe中获取ViewModel的相关代码<br><figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line"><span class="comment">@NonNull</span></span><br><span class="line"><span class="comment">    @</span>MainThread</span><br><span class="line">    public &lt;T extends ViewModel&gt; T <span class="built_in">get</span>(<span class="comment">@NonNull String key, @</span>NonNull Class&lt;T&gt; modelClass) &#123;</span><br><span class="line">        ViewModel viewModel = mViewModelStore.get(<span class="built_in">key</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (modelClass.isInstance(viewModel)) &#123;</span><br><span class="line">            <span class="comment">//noinspection unchecked</span></span><br><span class="line">            <span class="keyword">return</span> (T) viewModel;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//noinspection StatementWithEmptyBody</span></span><br><span class="line">            <span class="keyword">if</span> (viewModel != <span class="built_in">null</span>) &#123;</span><br><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> log a warning.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mFactory instanceof KeyedFactory) &#123;</span><br><span class="line">            viewModel = ((KeyedFactory) (mFactory)).<span class="keyword">create</span>(<span class="built_in">key</span>, modelClass);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            viewModel = (mFactory).<span class="keyword">create</span>(modelClass);</span><br><span class="line">        &#125;</span><br><span class="line">        mViewModelStore.put(<span class="built_in">key</span>, viewModel);</span><br><span class="line">        <span class="comment">//noinspection unchecked</span></span><br><span class="line">        <span class="keyword">return</span> (T) viewModel;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>这就是为什么屏幕旋转后，ViewModel可以保存数据的原因</p>
<h3 id="为什么Fragment中的数据屏幕旋转后可以保存？"><a href="#为什么Fragment中的数据屏幕旋转后可以保存？" class="headerlink" title="为什么Fragment中的数据屏幕旋转后可以保存？"></a>为什么Fragment中的数据屏幕旋转后可以保存？</h3><p>如果我们在Fragment中调用如下代码：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> model: MyViewModel = ViewModelProviders.of(<span class="keyword">this</span>).<span class="keyword">get</span>(MyViewModel::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br></pre></td></tr></table></figure></p>
<p>追踪他们的调用，可以发现获取ViewModel是通过mNonConfig存储的<br><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@NonNull</span></span><br><span class="line">   ViewModelStore getViewModelStore(<span class="variable">@NonNull</span> Fragment f) &#123;</span><br><span class="line">       <span class="selector-tag">return</span> <span class="selector-tag">mNonConfig</span><span class="selector-class">.getViewModelStore</span>(f);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>那么mNonConfig又是什么时候创建的呢？又存储在哪里？</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">void attachController(@NonNull FragmentHostCallback<span class="php"><span class="meta">&lt;?</span>&gt; host,</span></span><br><span class="line"><span class="php">           @NonNull FragmentContainer container, @Nullable <span class="keyword">final</span> Fragment <span class="keyword">parent</span>) &#123;</span></span><br><span class="line"><span class="php">       <span class="comment">//省略更多...</span></span></span><br><span class="line"><span class="php">       <span class="keyword">if</span> (<span class="keyword">parent</span> != <span class="keyword">null</span>) &#123;</span></span><br><span class="line"><span class="php">           mNonConfig = <span class="keyword">parent</span>.mFragmentManager.getChildNonConfig(<span class="keyword">parent</span>);</span></span><br><span class="line"><span class="php">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (host <span class="keyword">instanceof</span> ViewModelStoreOwner) &#123;</span></span><br><span class="line"><span class="php">           <span class="comment">//👇走这里</span></span></span><br><span class="line"><span class="php">           ViewModelStore viewModelStore = ((ViewModelStoreOwner) host).getViewModelStore();</span></span><br><span class="line"><span class="php">           mNonConfig = FragmentManagerViewModel.getInstance(viewModelStore);</span></span><br><span class="line"><span class="php">       &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="php">           mNonConfig = <span class="keyword">new</span> FragmentManagerViewModel(<span class="keyword">false</span>);</span></span><br><span class="line"><span class="php">       &#125;</span></span><br><span class="line"><span class="php">   &#125;</span></span><br></pre></td></tr></table></figure>
<p>在将Fragment添加到FragmentManager中时会调用到这<br>因为传入的 parent = null，且 Activity 默认实现了 ViewModelStoreOwner 接口，所以会获取 Activity 中的 ViewModelStore，接着调用 FragmentManagerViewModel 的 getInstance() 方法:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> FragmentManagerViewModel <span class="title">getInstance</span><span class="params">(ViewModelStore viewModelStore)</span> </span>&#123;</span><br><span class="line">    ViewModelProvider viewModelProvider = <span class="keyword">new</span> ViewModelProvider(viewModelStore,</span><br><span class="line">            FACTORY);</span><br><span class="line">    <span class="keyword">return</span> viewModelProvider.get(FragmentManagerViewModel<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在该方法中，会创建 FragmentManagerViewModel，并将其添加到 Activity 中的 ViewModelStore 中。</p>
<p>整体流程如下所示:<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog8/p4.webp" alt></p>
<p><strong>ViewModel 在 Fragment 中不会因配置改变而销毁的原理</strong><br>根据上面的分析，ViewModel 在 Fragment 中不会因配置改变而销毁的原因其实是因为其声明的 ViewModel 是存储在 FragmentManagerViewModel 中的，而 FragmentManagerViewModel 是存储在宿主 Activity 中的 ViewModelStore 中，又因 Activity 中 ViewModelStore不会因配置改变而销毁，故 Fragment 中 ViewModel 也不会因配置改变而销毁。</p>
<h3 id="ViewModel-能在-Fragment-中共享的原理"><a href="#ViewModel-能在-Fragment-中共享的原理" class="headerlink" title="ViewModel 能在 Fragment 中共享的原理"></a>ViewModel 能在 Fragment 中共享的原理</h3><p>ViewModel 的另一大特性就是能在 Fragment 中共享数据。</p>
<p>假如我们想 Fragment D 获取 Fragment A 中的数据，那么我们只有在 Activity 中的 ViewModelStore 下添加 ViewModel。只有这样，我们才能在不同 Fragment 中获取相同的数据。这也是为什么在 Fragment 中使用共享的 ViewModel 时，我们要在调用ViewModelProvider.of() 创建 ViewModel 时需要传入 getActivity() 的原因。</p>
<p>具体例子如下：<br><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">SharedViewModel</span> <span class="keyword">extends</span> <span class="title">ViewModel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">MutableLiveData</span>&lt;<span class="type">Item</span>&gt; selected = <span class="keyword">new</span> <span class="type">MutableLiveData</span>&lt;<span class="type">Item</span>&gt;();</span><br><span class="line"></span><br><span class="line">    public void select(<span class="type">Item</span> item) &#123;</span><br><span class="line">        selected.setValue(item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="type">LiveData</span>&lt;<span class="type">Item</span>&gt; getSelected() &#123;</span><br><span class="line">        <span class="keyword">return</span> selected;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">FragmentA</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">SharedViewModel</span> model;</span><br><span class="line">    public void onCreate(<span class="type">Bundle</span> savedInstanceState) &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        <span class="comment">//👇传入的是宿主Activity</span></span><br><span class="line">        model = <span class="type">ViewModelProviders</span>.of(getActivity()).get(<span class="type">SharedViewModel</span><span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        itemSelector.setOnClickListener(item -&gt; &#123;</span><br><span class="line">            model.select(item);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">FragmentD</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line">    public void onCreate(<span class="type">Bundle</span> savedInstanceState) &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">         <span class="comment">//👇传入的是宿主Activity</span></span><br><span class="line">        <span class="type">SharedViewModel</span> model = <span class="type">ViewModelProviders</span>.of(getActivity()).get(<span class="type">SharedViewModel</span><span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        model.getSelected().observe(<span class="keyword">this</span>, &#123; item -&gt;</span><br><span class="line">           <span class="comment">// Update the UI.</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://zhuanlan.zhihu.com/p/143346337" target="_blank" rel="noopener">知识点 | ViewModel 四种集成方式</a><br><a href="https://www.jianshu.com/p/39ef3e0a5829" target="_blank" rel="noopener">ViewModel 这些知识点你都知道吗?</a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>ARTS打卡2</title>
    <url>/blog/2020/10/arts-way-two.html</url>
    <content><![CDATA[<h3 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h3><p><strong>统计字典序元音字符串的数目</strong><br>给你一个整数 n，请返回长度为 n 、仅由元音 (a, e, i, o, u) 组成且按 字典序排列 的字符串数量。<br>字符串 s 按 字典序排列 需要满足：对于所有有效的 i，s[i] 在字母表中的位置总是与 s[i+1] 相同或在 s[i+1] 之前</p>
<p>通过动态规划实现<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">countVowelStrings</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> dp = Array(n + <span class="number">1</span>) &#123;</span><br><span class="line">            IntArray(<span class="number">5</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.fill(dp,<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">2</span>..n) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = sum(i - <span class="number">1</span>, <span class="number">0</span>, dp)</span><br><span class="line">            dp[i][<span class="number">1</span>] = sum(i - <span class="number">1</span>, <span class="number">1</span>, dp)</span><br><span class="line">            dp[i][<span class="number">2</span>] = sum(i - <span class="number">1</span>, <span class="number">2</span>, dp)</span><br><span class="line">            dp[i][<span class="number">3</span>] = sum(i - <span class="number">1</span>, <span class="number">3</span>, dp)</span><br><span class="line">            dp[i][<span class="number">4</span>] = sum(i - <span class="number">1</span>, <span class="number">4</span>, dp)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n].sum()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">sum</span><span class="params">(i: <span class="type">Int</span>, start: <span class="type">Int</span>, arr: <span class="type">Array</span>&lt;<span class="type">IntArray</span>&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> start until <span class="number">5</span>) &#123;</span><br><span class="line">            result += arr[i][j]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h3><p><a href="https://medium.com/androiddevelopers/viewmodels-with-saved-state-jetpack-navigation-data-binding-and-coroutines-df476b78144e" target="_blank" rel="noopener">ViewModels with Saved State, Jetpack Navigation, Data Binding and Coroutines</a><br>本文主要讲述了viewModel的四种使用方式<br>1.ViewModel 中的 Saved State —— 后台进程重启时，ViewModel 的数据恢复；<br>2.在 NavGraph 中使用 ViewModel —— ViewModel 与导航 (Navigation) 组件库的集成；<br>3.ViewModel 配合数据绑定 (data-binding) —— 通过使用 ViewModel 和 LiveData 简化数据绑定；<br>4.viewModelScope —— Kotlin 协程与 ViewModel 的集成。</p>
<h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><p><strong>ConstraintLayout如何动态设置margin?</strong><br>记录下布局依赖变更，clone复制原先布局，一定要写，<br>margin只能设置top,down<br>applyTo应用布局<br><figure class="highlight gams"><table><tr><td class="code"><pre><span class="line">ConstraintSet <span class="keyword">set</span> = new <span class="comment">ConstraintSet()</span>;</span><br><span class="line">           <span class="keyword">set</span>.clone(clDetail);</span><br><span class="line">           <span class="keyword">set</span>.connect(divider.getId(), ConstraintSet.TOP, recyclerView.getId(), ConstraintSet.BOTTOM);</span><br><span class="line">           <span class="keyword">set</span>.setMargin(divider.getId(), ConstraintSet.TOP, DensityUtils.dip2px(getContext(), 3));</span><br><span class="line">           <span class="keyword">set</span>.applyTo(clDetail);</span><br></pre></td></tr></table></figure></p>
<p>其他使用方法<br>clear ：清除所有依赖<br>connect 传入父布局，所有子布局必须有ID<br>constrainHeight:设置控件高度<br><figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (newConfig.orientation == Configuration.ORIENTATION_PORTRAIT) &#123;</span><br><span class="line">        <span class="keyword">set</span>.clear(mViewDataBind.flVideo.getId());</span><br><span class="line">        <span class="keyword">set</span>.constrainHeight(mViewDataBind.flVideo.getId(),ConvertUtils.dp2px(250));</span><br><span class="line">        <span class="keyword">set</span>.connect(mViewDataBind.flVideo.getId(), ConstraintSet.TOP, mViewDataBind.titleBar.getId(), ConstraintSet.BOTTOM);</span><br><span class="line">        <span class="keyword">set</span>.connect(mViewDataBind.flVideo.getId(), ConstraintSet.RIGHT, mViewDataBind.titleBar.getId(), ConstraintSet.RIGHT);</span><br><span class="line">        <span class="keyword">set</span>.connect(mViewDataBind.flVideo.getId(), ConstraintSet.LEFT, ConstraintSet.PARENT_ID, ConstraintSet.LEFT);</span><br><span class="line">        <span class="keyword">set</span>.applyTo(mViewDataBind.clParent);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newConfig.orientation == Configuration.ORIENTATION_LANDSCAPE) &#123;</span><br><span class="line">        <span class="keyword">set</span>.constrainHeight(mViewDataBind.flVideo.getId(),0);</span><br><span class="line">        <span class="keyword">set</span>.connect(mViewDataBind.flVideo.getId(), ConstraintSet.TOP, ConstraintSet.PARENT_ID, ConstraintSet.TOP);</span><br><span class="line">        <span class="keyword">set</span>.connect(mViewDataBind.flVideo.getId(), ConstraintSet.BOTTOM, ConstraintSet.PARENT_ID, ConstraintSet.BOTTOM);</span><br><span class="line">        <span class="keyword">set</span>.applyTo(mViewDataBind.clParent);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h3><p><a href="https://shenzhen2017.github.io/blog/2020/10/viewmodel-sum-up.html">Viewmodel完全解析</a><br>本文主要讲述了以下内容<br>1.ViewModel的四种使用场景<br>2.ViewModel旋转屏幕保存数据的原理<br>3.ViewModel Fragment间传递数据的原理</p>
]]></content>
      <tags>
        <tag>ARTS</tag>
      </tags>
  </entry>
  <entry>
    <title>怎么从官方文档学习</title>
    <url>/blog/2020/11/learn-by-document.html</url>
    <content><![CDATA[<p>有很多Android开发者，或者是因为语言，或许因为科学上网等原因，不太习惯逛Android官网<br>其实Android官网中有许多资源，包括kotlin,协程,jetpack，android各种最佳实践和项目例子等。<br>下面做一些总结，希望对大家有用。</p>
<h2 id="kotlin相关学习资源"><a href="#kotlin相关学习资源" class="headerlink" title="kotlin相关学习资源"></a>kotlin相关学习资源</h2><p>1.<a href="https://developer.android.google.cn/kotlin/first" target="_blank" rel="noopener">https://developer.android.google.cn/kotlin/first</a><br>2.<a href="https://developers.google.cn/codelabs/advanced-android-kotlin-training-welcome#0" target="_blank" rel="noopener">https://developers.google.cn/codelabs/advanced-android-kotlin-training-welcome</a></p>
<h3 id="kotlin协程"><a href="#kotlin协程" class="headerlink" title="kotlin协程"></a>kotlin协程</h3><p><a href="https://developer.android.google.cn/kotlin/coroutines" target="_blank" rel="noopener">https://developer.android.google.cn/kotlin/coroutines</a></p>
<h2 id="jetPack相关文档"><a href="#jetPack相关文档" class="headerlink" title="jetPack相关文档"></a>jetPack相关文档</h2><p><a href="https://developer.android.google.cn/jetpack" target="_blank" rel="noopener">https://developer.android.google.cn/jetpack</a></p>
<h2 id="Android架构组件"><a href="#Android架构组件" class="headerlink" title="Android架构组件"></a>Android架构组件</h2><p><a href="https://developer.android.google.cn/docs" target="_blank" rel="noopener">https://developer.android.google.cn/docs</a></p>
<h2 id="UI组件"><a href="#UI组件" class="headerlink" title="UI组件"></a>UI组件</h2><p>1.android 各种widgets的使用实例<br><a href="https://github.com/android/views-widgets-samples.git" target="_blank" rel="noopener">https://github.com/android/views-widgets-samples.git</a></p>
<p>2.motion-layout code lab<br><a href="https://developers.google.cn/codelabs/motion-layout/#0" target="_blank" rel="noopener">https://developers.google.cn/codelabs/motion-layout/</a><br><a href="https://codelabs.developers.google.com/codelabs/kotlin-android-training-linear-layout/index.html?index=..%2F..android-kotlin-fundamentals#0" target="_blank" rel="noopener">https://codelabs.developers.google.com/codelabs/kotlin-android-training-linear-layout/index.html?index=..%2F..android-kotlin-fundamentals#0</a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>ARTS打卡3</title>
    <url>/blog/2020/11/arts-way-three.html</url>
    <content><![CDATA[<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><blockquote>
<p><a href="https://leetcode-cn.com/contest/weekly-contest-214/problems/get-maximum-in-generated-array/" target="_blank" rel="noopener">获取生成数组中的最大值</a><br>给你一个整数 n 。按照规则生成一个长度为 n + 1 的数组 nums</p>
</blockquote>
<p>代码实现如下：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getMaximumGenerated</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> result = IntArray(n + <span class="number">1</span>)</span><br><span class="line">        result[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        result[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">var</span> max = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>..n / <span class="number">2</span>) &#123;</span><br><span class="line">            result[<span class="number">2</span> * i] = result[i]</span><br><span class="line">            max = maxOf(result[<span class="number">2</span> * i], max)</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">2</span> * i + <span class="number">1</span> &lt;= n) &#123;</span><br><span class="line">                result[<span class="number">2</span> * i + <span class="number">1</span>] = result[i] + result[i + <span class="number">1</span>]</span><br><span class="line">                max = maxOf(result[<span class="number">2</span> * i + <span class="number">1</span>], max)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p><a href="https://medium.com/androiddevelopers/merge-adapters-sequentially-with-mergeadapter-294d2942127a" target="_blank" rel="noopener">Merge adapters sequentially with MergeAdapter</a><br>本文主要讲述了MergeAdapter的使用<br>利用MergeAdapter可以方便的组合多个adapter<br>MergeAdapter 允许我们按顺序显示多个 adapter 的内容。 例如，假设我们有以下 3 个adapter：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> firstAdapter: FirstAdapter = …</span><br><span class="line"><span class="keyword">val</span> secondAdapter: SecondAdapter = …</span><br><span class="line"><span class="keyword">val</span> thirdAdapter: ThirdAdapter = …</span><br><span class="line"><span class="keyword">val</span> mergeAdapter = MergeAdapter(firstAdapter, secondAdapter, </span><br><span class="line">     thirdAdapter)</span><br><span class="line">recyclerView.adapter = mergeAdapter</span><br></pre></td></tr></table></figure></p>
<p>recyclerView 将顺序显示每个 adapter 中的 item<br>使用不同的 adapter 可以使您更好地区分列表的每个顺序部分。 例如，如果要显示标题，则无需将与标题显示相关的逻辑放在处理列表显示的同一 adapter 中，而是可以将其封装在其自己的 adapter 中</p>
<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><p>临时合并代码的操作<br>例如当代码正在review时，你需要合并代码，操作步骤如下：<br>原分支为feature/test,需要合并develop<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span><span class="selector-class">.git</span> checkout -<span class="selector-tag">b</span> temp</span><br><span class="line"><span class="number">2</span><span class="selector-class">.git</span> branch -D feature/test</span><br><span class="line"><span class="number">3</span><span class="selector-class">.git</span> checkout feature/test</span><br><span class="line"><span class="number">4</span><span class="selector-class">.git</span> merge origin/develop --no-ff</span><br><span class="line"><span class="number">5</span><span class="selector-class">.git</span> cherry-pick temp</span><br><span class="line"><span class="number">6</span><span class="selector-class">.git</span> push origin feature/test</span><br><span class="line"><span class="number">7</span><span class="selector-class">.git</span> branch -D temp</span><br></pre></td></tr></table></figure></p>
<h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p>本周主要完成分享LiveData相关总结文章,详情可见：<br><a href="https://shenzhen2017.github.io/blog/2020/11/live-data-sum.html">【带着问题学】关于LiveData你应该知道的知识点</a></p>
]]></content>
      <tags>
        <tag>ARTS</tag>
      </tags>
  </entry>
  <entry>
    <title>【带着问题学】关于LiveData你应该知道的知识点</title>
    <url>/blog/2020/11/live-data-sum.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>带着问题学习可以让我们在学习的过程中更加有目的性与条理。<br>例如在读源码的过程中，我们如果从头开始读，往往千头万绪，抓不住要领。<br>而如果在开始读之前先带着几个问题，则可以让我们在读源码的过程中有一个主线。<br>最后也可以通过判断自己的问题是否得到解决了，来判断自己是否真的读懂了，不然面对成千上万行的代码，很容易有白读了的感觉。</p>
<p>下面列出先列出几个问题<br>1.LiveData为什么可以自动取消订阅，如何避免内存泄漏？<br>2.LiveData设置相同的值，会不会回调？<br>3.LiveData有什么坑？如何实现LiveDataBus？</p>
<p>本文主要回答了以上3个问题，读者在读完后可以看看相关问题有没有得到解答~</p>
<h2 id="LiveData如何避免内存泄漏"><a href="#LiveData如何避免内存泄漏" class="headerlink" title="LiveData如何避免内存泄漏?"></a>LiveData如何避免内存泄漏?</h2><p>首先说说为什么会发生内存泄漏<br>当一个长生命周期的对象引用了一个短生命周期的对象，就会产生内存泄漏。<br>比如当我们使用Rxjava来发起一个网络请求的时候，而在Activity关闭的时候没有取消订阅，就会发生内存泄漏.<br>所以需要用户使用CompositeDisposable，来在onDestroy时取消订阅<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> d: Disposable? = <span class="literal">null</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> ds: CompositeDisposable</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">(v: <span class="type">View</span>)</span></span> &#123;</span><br><span class="line">       <span class="keyword">when</span> (v.id) &#123;</span><br><span class="line">           R.id.btn_start_count -&gt; &#123;</span><br><span class="line">               d = Observable.interval(<span class="number">1</span>, TimeUnit.SECONDS)</span><br><span class="line">                       .subscribeOn(Schedulers.io())</span><br><span class="line">                       .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">                       .subscribe &#123;</span><br><span class="line">                           tv_count.text = it.toString()</span><br><span class="line">                           loge(TAG, <span class="string">"count:<span class="variable">$it</span>"</span>)</span><br><span class="line">                       &#125;</span><br><span class="line">               ds.add(d!!)</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span> &#123;</span><br><span class="line">       <span class="keyword">super</span>.onDestroy()</span><br><span class="line">       ds.dispose()</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>如上所示：通过compositeDisable可以避免Rxjava发生内存泄漏。<br>但是这种方法依赖于用户手动操作，容易忘记与出现问题。</p>
<p>但使用LiveData却不用担心这个问题,LiveData订阅后，在页面销毁后可以自动取消订阅<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MutableLiveDataFragment</span> : <span class="type">Fragment</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> changeObserver = Observer&lt;String&gt; &#123; value -&gt;</span><br><span class="line">        value?.let &#123; txt_fragment.text = it &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onAttach</span><span class="params">(context: <span class="type">Context</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onAttach(context)</span><br><span class="line">        getLiveDataA().observe(<span class="keyword">this</span>, changeObserver)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// .. some other Fragment specific code ..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="为什么LiveData可以自动取消订阅？"><a href="#为什么LiveData可以自动取消订阅？" class="headerlink" title="为什么LiveData可以自动取消订阅？"></a>为什么LiveData可以自动取消订阅？</h3><p>如果一个Observer的生命周期处于STARTED或RESUMED状态，那么LiveData将认为这个Observer处于活跃状态.LiveData仅通知活跃的Observer去更新UI。<br>非活跃状态的Observer，即使订阅了LiveData，也不会收到更新的通知。</p>
<p>结合一个实现了LifecycleOwner接口的对象，你能注册一个Observer。这种结合关系使得当具有生命周期的对象的状态变为DESTROYED时，Observer将被取消订阅。这对于活和片段尤其有用，因为它们可以安全地订阅LiveData对象，而不必担心内存泄漏 - 当活和片段生命周期为DESTROYED时，它们立即会被取消订阅。</p>
<h4 id="1-首先看看订阅时发生了什么"><a href="#1-首先看看订阅时发生了什么" class="headerlink" title="1.首先看看订阅时发生了什么"></a>1.首先看看订阅时发生了什么</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MainThread</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">observe</span><span class="params">(@NonNull LifecycleOwner owner, @NonNull Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class="line">        assertMainThread(<span class="string">"observe"</span>);</span><br><span class="line">        <span class="keyword">if</span> (owner.getLifecycle().getCurrentState() == DESTROYED) &#123;</span><br><span class="line">            <span class="comment">// ignore</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LifecycleBoundObserver wrapper = <span class="keyword">new</span> LifecycleBoundObserver(owner, observer);</span><br><span class="line">        ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper);</span><br><span class="line">        <span class="keyword">if</span> (existing != <span class="keyword">null</span> &amp;&amp; !existing.isAttachedTo(owner)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Cannot add the same observer"</span></span><br><span class="line">                    + <span class="string">" with different lifecycles"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (existing != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        owner.getLifecycle().addObserver(wrapper);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>观察者被存放到了mObservers之中，其中存放的是LifecycleBoundObserver类型</p>
<h4 id="接下来看看LifecycleBoundObserver类"><a href="#接下来看看LifecycleBoundObserver类" class="headerlink" title="接下来看看LifecycleBoundObserver类"></a>接下来看看LifecycleBoundObserver类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LifecycleBoundObserver</span> <span class="keyword">extends</span> <span class="title">ObserverWrapper</span> <span class="keyword">implements</span> <span class="title">GenericLifecycleObserver</span> </span>&#123;</span><br><span class="line">        <span class="meta">@NonNull</span></span><br><span class="line">        <span class="keyword">final</span> LifecycleOwner mOwner;</span><br><span class="line"></span><br><span class="line">        LifecycleBoundObserver(<span class="meta">@NonNull</span> LifecycleOwner owner, Observer&lt;? <span class="keyword">super</span> T&gt; observer) &#123;</span><br><span class="line">            <span class="keyword">super</span>(observer);</span><br><span class="line">            mOwner = owner;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">shouldBeActive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> mOwner.getLifecycle().getCurrentState().isAtLeast(STARTED);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStateChanged</span><span class="params">(LifecycleOwner source, Lifecycle.Event event)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (mOwner.getLifecycle().getCurrentState() == DESTROYED) &#123;</span><br><span class="line">                removeObserver(mObserver);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            activeStateChanged(shouldBeActive());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">isAttachedTo</span><span class="params">(LifecycleOwner owner)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> mOwner == owner;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">detachObserver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            mOwner.getLifecycle().removeObserver(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>当Lifecycles的State发生变化会回调onStateChanged方法，当State为DESTROYED是，则移除观察者Observer。里面调用的是LiveData的removeObserver方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MainThread</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(@NonNull <span class="keyword">final</span> Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class="line">        assertMainThread(<span class="string">"removeObserver"</span>);</span><br><span class="line">        ObserverWrapper removed = mObservers.remove(observer);</span><br><span class="line">        <span class="keyword">if</span> (removed == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        removed.detachObserver();</span><br><span class="line">        removed.activeStateChanged(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>当页面销毁时，在mObservers中remove了observer，就这样完成了订阅的自动取消。</p>
<h2 id="livedata传相同的值会不会执行onchanged回调"><a href="#livedata传相同的值会不会执行onchanged回调" class="headerlink" title="livedata传相同的值会不会执行onchanged回调?"></a>livedata传相同的值会不会执行onchanged回调?</h2><p>当我们给liveData设置value时，Observer就会更新。但如果我们两次设置一样的value，Observer是否会更新？</p>
<p>首先看看setValue方法<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MainThread</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        assertMainThread(<span class="string">"setValue"</span>);</span><br><span class="line">        mVersion++;</span><br><span class="line">        mData = value;</span><br><span class="line">        dispatchingValue(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>其中最重要的是mVersion参数<br>接下来看dispatchingValue方法<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatchingValue</span><span class="params">(@Nullable ObserverWrapper initiator)</span> </span>&#123;</span><br><span class="line">        ....</span><br><span class="line">        considerNotify(initiator);</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">considerNotify</span><span class="params">(ObserverWrapper observer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!observer.mActive) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Check latest state b4 dispatch. Maybe it changed state but we didn't get the event yet.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// we still first check observer.active to keep it as the entrance for events. So even if</span></span><br><span class="line">        <span class="comment">// the observer moved to an active state, if we've not received that event, we better not</span></span><br><span class="line">        <span class="comment">// notify for a more predictable notification order.</span></span><br><span class="line">        <span class="keyword">if</span> (!observer.shouldBeActive()) &#123;</span><br><span class="line">            observer.activeStateChanged(<span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (observer.mLastVersion &gt;= mVersion) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        observer.mLastVersion = mVersion;</span><br><span class="line">        observer.mObserver.onChanged((T) mData);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>到这里一目了然，只要mVersion是大于等于之前的值，就会回调onChanged方法，也就是说，不管值是否相同，只看version的值，也就是基本只有int到达最大值的时候才会导致bug，2的31次方-1，估计只有无聊的人才会写改这么多次值的代码了。</p>
<h2 id="LiveDataBus实现"><a href="#LiveDataBus实现" class="headerlink" title="LiveDataBus实现"></a>LiveDataBus实现</h2><h3 id="为什么要使用LiveData来实现通信总线？"><a href="#为什么要使用LiveData来实现通信总线？" class="headerlink" title="为什么要使用LiveData来实现通信总线？"></a>为什么要使用LiveData来实现通信总线？</h3><h4 id="使用LiveData的理由"><a href="#使用LiveData的理由" class="headerlink" title="使用LiveData的理由"></a>使用LiveData的理由</h4><ul>
<li>LiveData具有的这种可观察性和生命周期感知的能力，使其非常适合作为Android通信总线的基础构件。</li>
<li>使用者不用显示调用反注册方法。<br>由于LiveData具有生命周期感知能力，所以LiveDataBus只需要调用注册回调方法，而不需要显示的调用反注册方法。这样带来的好处不仅可以编写更少的代码，而且可以完全杜绝其他通信总线类框架（如EventBus、RxBus）忘记调用反注册所带来的内存泄漏的风险。</li>
</ul>
<h4 id="为什么要用LiveDataBus替代EventBus和RxBus"><a href="#为什么要用LiveDataBus替代EventBus和RxBus" class="headerlink" title="为什么要用LiveDataBus替代EventBus和RxBus"></a>为什么要用LiveDataBus替代EventBus和RxBus</h4><ul>
<li>LiveDataBus的实现及其简单 相对EventBus复杂的实现，LiveDataBus只需要一个类就可以实现。</li>
<li>LiveDataBus可以减小APK包的大小 由于LiveDataBus只依赖Android官方Android Architecture Components组件的LiveData，没有其他依赖，本身实现只有一个类。作为比较，EventBus JAR包大小为57kb，RxBus依赖RxJava和RxAndroid，其中RxJava2包大小2.2MB，RxJava1包大小1.1MB，RxAndroid包大小9kb。使用LiveDataBus可以大大减小APK包的大小。</li>
<li>LiveDataBus依赖方支持更好 LiveDataBus只依赖Android官方Android Architecture Components组件的LiveData，相比RxBus依赖的RxJava和RxAndroid，依赖方支持更好。</li>
<li>LiveDataBus具有生命周期感知 LiveDataBus具有生命周期感知，在Android系统中使用调用者不需要调用反注册，相比EventBus和RxBus使用更为方便，并且没有内存泄漏风险。</li>
</ul>
<h3 id="LiveData实现事件总线的坑"><a href="#LiveData实现事件总线的坑" class="headerlink" title="LiveData实现事件总线的坑"></a>LiveData实现事件总线的坑</h3><p>由于LiveData的粘性特性，用LiveData实现LiveDataBus，订阅者会收到订阅之前发布的消息。对于一个消息总线来说，这是不可接受的。无论EventBus或者RxBus，订阅方都不会收到订阅之前发出的消息。对于一个消息总线，LiveDataBus必须要解决这个问题。</p>
<h4 id="粘性消息的原因"><a href="#粘性消息的原因" class="headerlink" title="粘性消息的原因"></a>粘性消息的原因</h4><p>当LifeCircleOwner的状态发生变化的时候，会调用LiveData.ObserverWrapper的activeStateChanged函数，如果这个时候ObserverWrapper的状态是active，就会调用LiveData的dispatchingValue。<br>前面分析过，最后会调用到considerNotify方法<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">considerNotify</span><span class="params">(ObserverWrapper observer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!observer.mActive) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Check latest state b4 dispatch. Maybe it changed state but we didn't get the event yet.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// we still first check observer.active to keep it as the entrance for events. So even if</span></span><br><span class="line">        <span class="comment">// the observer moved to an active state, if we've not received that event, we better not</span></span><br><span class="line">        <span class="comment">// notify for a more predictable notification order.</span></span><br><span class="line">        <span class="keyword">if</span> (!observer.shouldBeActive()) &#123;</span><br><span class="line">            observer.activeStateChanged(<span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (observer.mLastVersion &gt;= mVersion) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        observer.mLastVersion = mVersion;</span><br><span class="line">        observer.mObserver.onChanged((T) mData);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>在LiveData的considerNotify方法中，如果ObserverWrapper的mLastVersion小于LiveData的mVersion，就会去回调mObserver的onChanged方法。而每个新的订阅者，其version都是-1，LiveData一旦设置过其version是大于-1的（每次LiveData设置值都会使其version加1），这样就会导致LiveDataBus每注册一个新的订阅者，这个订阅者立刻会收到一个回调，即使这个设置的动作发生在订阅之前。</p>
<h4 id="问题原因总结"><a href="#问题原因总结" class="headerlink" title="问题原因总结"></a>问题原因总结</h4><p>对于这个问题，总结一下发生的核心原因。对于LiveData，其初始的version是-1，当我们调用了其setValue或者postValue，其vesion会+1；对于每一个观察者的封装ObserverWrapper，其初始version也为-1，也就是说，每一个新注册的观察者，其version为-1；当LiveData设置这个ObserverWrapper的时候，如果LiveData的version大于ObserverWrapper的version，LiveData就会强制把当前value推送给Observer。</p>
<h4 id="如何解决这个问题"><a href="#如何解决这个问题" class="headerlink" title="如何解决这个问题"></a>如何解决这个问题</h4><p>明白了问题产生的原因之后，我们来看看怎么才能解决这个问题。很显然，根据之前的分析，只需要在注册一个新的订阅者的时候把Wrapper的version设置成跟LiveData的version一致即可。</p>
<p>那么怎么实现呢，看看LiveData的observe方法，他会在observe时创建一个LifecycleBoundObserver，LifecycleBoundObserver是ObserverWrapper的派生类。然后会把这个LifecycleBoundObserver放入一个私有Map容器mObservers中。无论ObserverWrapper还是LifecycleBoundObserver都是私有的或者包可见的，所以无法通过继承的方式更改LifecycleBoundObserver的version。</p>
<p>那么能不能从Map容器mObservers中取到LifecycleBoundObserver，然后再更改version呢？答案是肯定的，通过查看SafeIterableMap的源码我们发现有一个protected的get方法。因此，在调用observe的时候，我们可以通过反射拿到LifecycleBoundObserver，再把LifecycleBoundObserver的version设置成和LiveData一致即可。</p>
<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>具体实现可见于美团分享的文章，链接在文末</p>
<h3 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h3><p>使用美团的这种方式，依赖于反射，在时间上会慢一些，同时性能上有一些损失。<br>我还看到网络上有一种基于LiveData,不利用反射实现消息总线的方案，比起美团方案各有利弊，有兴趣的同学可以了解下。<br><a href="https://github.com/KunMinX/UnPeek-LiveData" target="_blank" rel="noopener">MVVM最佳实践之UnPeek-LiveData</a></p>
<h2 id="LiveData丢失数据的坑"><a href="#LiveData丢失数据的坑" class="headerlink" title="LiveData丢失数据的坑"></a>LiveData丢失数据的坑</h2><h3 id="postValue-数据丢失的问题"><a href="#postValue-数据丢失的问题" class="headerlink" title="postValue 数据丢失的问题"></a>postValue 数据丢失的问题</h3><p>postValue 只是把传进来的数据先存到 mPendingData，然后往主线程抛一个 Runnable，在这个 Runnable 里面再调用 setValue 来把存起来的值真正设置上去，并回调观察者们。而如果在这个 Runnable 执行前多次 postValue，其实只是改变暂存的值 mPendingData，并不会再次抛另一个 Runnable。这就会出现后设置的值把前面的值覆盖掉的问题，会导致事件丢失。<br><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">protected</span> <span class="function"><span class="keyword">void</span> <span class="title">postValue</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> postTask;</span><br><span class="line">    <span class="keyword">synchronized</span> (mDataLock) &#123;</span><br><span class="line">        postTask = mPendingData == NOT_SET;</span><br><span class="line">        <span class="comment">// 这里先把数据暂存起来，后来的数据会覆盖前面的</span></span><br><span class="line">        mPendingData = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里保证只抛一个 mPostValueRunnable，#-.-</span></span><br><span class="line">    <span class="keyword">if</span> (!postTask) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ArchTaskExecutor.getInstance().postToMainThread(mPostValueRunnable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="setValue-不回调观察者"><a href="#setValue-不回调观察者" class="headerlink" title="setValue 不回调观察者"></a>setValue 不回调观察者</h3><p>LiveData 的生命周期感知能力就体现在这里，它不会回调处于「非激活状态」（即 onStart 之后到 onPause 之前）的观察者，因为这时更新 View 没有意义，而且比较危险，它会等到观察者激活之后再把新的值回调给他。<br>但是如果我传了多个数据（假设都是用 setValue 保证不会被覆盖），那些处于非激活状态的观察者是毫不知情的，他们在激活的时候只会收到最后一个数据。这对于事件传递来说，就表现为事件丢失，中间传的任何数据都无法收到，那也就失去了事件传递的意义。</p>
<h3 id="打造一个不会丢事件的-LiveData"><a href="#打造一个不会丢事件的-LiveData" class="headerlink" title="打造一个不会丢事件的 LiveData"></a>打造一个不会丢事件的 LiveData</h3><h4 id="postValue-的问题"><a href="#postValue-的问题" class="headerlink" title="postValue 的问题"></a>postValue 的问题</h4><p>对于 postValue 的问题，既然它最后也是调用的 setValue，丢数据是因为只抛了一次 Runable，那我们就自己每次都往主线程抛一个 Runable 就能解决这个问题</p>
<h4 id="非激活状态的问题"><a href="#非激活状态的问题" class="headerlink" title="非激活状态的问题"></a>非激活状态的问题</h4><p>对于非激活状态，可以用observeForever来观察，但是observeForever不会帮我们自动取消订阅。<br>我们需要在不使用时手动调用 public void removeObserver(@NonNull final Observer&lt;? super T&gt; observer) 移除观察者，否则可能会内存泄漏。</p>
<h4 id="造一个生命周期感知的还不丢事件的观察者"><a href="#造一个生命周期感知的还不丢事件的观察者" class="headerlink" title="造一个生命周期感知的还不丢事件的观察者"></a>造一个生命周期感知的还不丢事件的观察者</h4><p>具体实现可见：<a href="https://www.jianshu.com/p/b2646bf112ce" target="_blank" rel="noopener">把 LiveData 用于事件传递那些坑</a></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://tech.meituan.com/2018/07/26/android-livedatabus.html" target="_blank" rel="noopener">Android消息总线的演进之路：用LiveDataBus替代RxBus、EventBus</a><br><a href="https://github.com/KunMinX/UnPeek-LiveData" target="_blank" rel="noopener">UnPeek-LiveData</a><br><a href="https://www.jianshu.com/p/b2646bf112ce" target="_blank" rel="noopener">把 LiveData 用于事件传递那些坑</a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>ARTS打卡4</title>
    <url>/blog/2020/11/arts-way-four.html</url>
    <content><![CDATA[<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><blockquote>
<p><a href="https://leetcode-cn.com/problems/check-array-formation-through-concatenation/" target="_blank" rel="noopener">1640. 能否连接形成数组</a><br>给你一个整数数组 arr ，数组中的每个整数 互不相同 。另有一个由整数数组构成的数组 pieces，其中的整数也 互不相同 。请你以 任意顺序 连接 pieces 中的数组以形成 arr 。但是，不允许 对每个数组 pieces[i] 中的整数重新排序。<br>如果可以连接 pieces 中的数组形成 arr ，返回 true ；否则，返回 false 。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun canFormArray(arr: IntArray, pieces: Array&lt;IntArray&gt;): Boolean &#123;</span><br><span class="line">        val map = hashMapOf&lt;Int, IntArray&gt;()</span><br><span class="line">        pieces.forEach &#123;</span><br><span class="line">            map[it[0]] = it</span><br><span class="line">        &#125;</span><br><span class="line">        var i = 0</span><br><span class="line">        while (i &lt; arr.size) &#123;</span><br><span class="line">            if (map.contains(arr[i]).not()) &#123;</span><br><span class="line">                return false</span><br><span class="line">            &#125;</span><br><span class="line">            val array = map[arr[i]]!!</span><br><span class="line">            var j = 0</span><br><span class="line">            while (j &lt; array.size) &#123;</span><br><span class="line">                if (arr[i] != array[j]) &#123;</span><br><span class="line">                    return false</span><br><span class="line">                &#125;</span><br><span class="line">                i++</span><br><span class="line">                j++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p><a href="https://android-developers.googleblog.com/2020/10/android-studio-41.html" target="_blank" rel="noopener">What’s New in android studio 4.1</a><br>本文主要讲述了Android studio 4.1的新特性<br>1.新数据库检查器<br>2.直接在Android Studio中运行Android模拟器<br>3.使用TensorFlow Lite模型<br>4.使用TensorFlow Lite模型<br>5.本机内存探查器<br>6.系统跟踪用户界面：更轻松的选择新的分析选项以及更多的帧渲染数据<br>7.Dagger navigation support<br>8.自定义视图预览<br>9.Apply Changes</p>
<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><p>获取APK包名的方法<br><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">adb <span class="keyword">shell</span></span><br><span class="line"><span class="bash">logcat | grep START<span class="comment">#需要先打开apk后，再敲入命令</span></span></span><br></pre></td></tr></table></figure></p>
<p>详情可见：<a href="https://www.jianshu.com/p/f6e8a03db025" target="_blank" rel="noopener">获取APK包名的几种方法</a></p>
<h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p>本周主要总结了工作中常用到的一些工具,详情可见：<br><a href="https://shenzhen2017.github.io/blog/2020/11/common-usage-tools.html">常用工具总结</a></p>
]]></content>
      <tags>
        <tag>ARTS</tag>
      </tags>
  </entry>
  <entry>
    <title>常用工具总结</title>
    <url>/blog/2020/11/common-usage-tools.html</url>
    <content><![CDATA[<p>1.markdown排版工具<br><a href="https://www.mdnice.com/" target="_blank" rel="noopener">https://www.mdnice.com/</a></p>
<p>2.封面图设计工具<br><a href="https://www.chuangkit.com/" target="_blank" rel="noopener">https://www.chuangkit.com/</a></p>
<p>3.UML图工具<br><a href="https://www.draw.io/" target="_blank" rel="noopener">https://www.draw.io/</a></p>
<p>4.mac屏幕保护时钟工具<br><a href="https://fliqlo.com/#/screensaver" target="_blank" rel="noopener">https://fliqlo.com/#/screensaver</a></p>
]]></content>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>Gradle多模块复用技巧</title>
    <url>/blog/2020/11/gradle-tips-learn.html</url>
    <content><![CDATA[<p>随着项目中的模块越来越多，模块中的依赖，版本号等都需要统一控制，下面介绍几种Gradle代码，多模块复用的技巧</p>
<h2 id="ext方式"><a href="#ext方式" class="headerlink" title="ext方式"></a>ext方式</h2><p>Android 开发中统一不同 module 的依赖版本十分重要，传统的方式是使用 ext 的方式<br>如下所示，首先是创建config.gradle,然后在根build.gradle和app模块下的build.gradle下使用</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="comment">// config.gradle</span></span><br><span class="line">ext &#123;</span><br><span class="line">    android = [</span><br><span class="line">            compileSdkVersion: <span class="number">26</span>,</span><br><span class="line">            buildToolsVersion: <span class="string">"25.0.0"</span>,</span><br><span class="line">            minSdkVersion    : <span class="number">14</span>,</span><br><span class="line">            targetSdkVersion : <span class="number">22</span>,</span><br><span class="line">            versionCode      : <span class="number">17</span>,</span><br><span class="line">            versionName      : <span class="string">"1.7"</span>,</span><br><span class="line">            applicationId    : <span class="string">"com.king.headline"</span>,</span><br><span class="line">            applicationId2222: <span class="string">"com.king.headline"</span>,</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">dependencies</span> = [</span><br><span class="line">            appcompatv7: <span class="string">"com.android.support:design:22.2.0"</span>,</span><br><span class="line">            loadtoast: <span class="string">"net.steamcrafted:load-toast:1.0.6"</span>,</span><br><span class="line">            constraintlayout: <span class="string">"com.android.support.constraint:constraint-layout:1.0.2"</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>于根目录下的build.gradle于引用当前gradle<br><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="comment">// root builf.gradle</span></span><br><span class="line">apply <span class="keyword">from</span>: <span class="string">"config.gradle"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">buildscript</span> &#123;</span><br><span class="line">    ext.kotlin_version = <span class="string">"1.4.10"</span></span><br><span class="line">    <span class="keyword">repositories</span> &#123;</span><br><span class="line">        google()</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">dependencies</span> &#123;</span><br><span class="line">        <span class="keyword">classpath</span> <span class="string">"com.android.tools.build:gradle:4.0.1"</span></span><br><span class="line">        <span class="keyword">classpath</span> <span class="string">"org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在app模块下的build.gradle中使用</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="comment">// app build.gradle</span></span><br><span class="line">apply plugin: <span class="string">'com.android.application'</span></span><br><span class="line"><span class="keyword">def</span> cfg = rootProject.ext.android</span><br><span class="line"><span class="keyword">def</span> dpc = rootProject.ext.<span class="keyword">dependencies</span></span><br><span class="line">android &#123;</span><br><span class="line">    compileSdkVersion cfg.compileSdkVersion</span><br><span class="line">    buildToolsVersion cfg.buildToolsVersion</span><br><span class="line"></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        applicationId <span class="string">"com.king.headline"</span></span><br><span class="line">        minSdkVersion <span class="number">14</span></span><br><span class="line">        targetSdkVersion <span class="number">22</span></span><br><span class="line">        versionCode <span class="number">17</span></span><br><span class="line">        versionName <span class="string">"1.7"</span></span><br><span class="line">    &#125;</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled <span class="keyword">false</span></span><br><span class="line">            proguardFiles getDefaultProguardFile(<span class="string">'proguard-android.txt'</span>), <span class="string">'proguard-rules.pro'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="keyword">compile</span> <span class="keyword">fileTree</span>(dir: <span class="string">'libs'</span>, <span class="keyword">include</span>: [<span class="string">'*.jar'</span>])</span><br><span class="line">    <span class="keyword">compile</span> dpc.loadtoast</span><br><span class="line">    <span class="keyword">compile</span> dpc.appcompatv7</span><br><span class="line">    <span class="keyword">compile</span> dpc.constraintlayout</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="进阶使用-遍历代替一行行手写"><a href="#进阶使用-遍历代替一行行手写" class="headerlink" title="进阶使用:遍历代替一行行手写"></a>进阶使用:遍历代替一行行手写</h3><p>因为项目中的依赖太多了，还有一种写法是在在 ext{…} 中写依赖，然后在脚本中遍历添加依赖的方式<br><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">ext&#123;</span><br><span class="line">    <span class="keyword">dependencies</span> = [...]</span><br><span class="line">    annotationd_ependencies = [...]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">dependencies</span>.<span class="keyword">each</span> &#123; k, v -&gt; implementation v &#125;</span><br><span class="line">annotationd_ependencies.<span class="keyword">each</span> &#123; k, v -&gt; kapt v &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="自定义-plugin-includeBuild"><a href="#自定义-plugin-includeBuild" class="headerlink" title="自定义 plugin + includeBuild"></a>自定义 plugin + includeBuild</h2><h3 id="1-我们新建一个-module，命名为-version"><a href="#1-我们新建一个-module，命名为-version" class="headerlink" title="1.我们新建一个 module，命名为 version"></a>1.我们新建一个 module，命名为 version</h3><h3 id="2-添加DependencyVersionPlugin"><a href="#2-添加DependencyVersionPlugin" class="headerlink" title="2.添加DependencyVersionPlugin"></a>2.添加DependencyVersionPlugin</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DependencyVersionPlugin</span> : <span class="type">Plugin</span>&lt;<span class="type">Project</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">apply</span><span class="params">(project: <span class="type">Project</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 version 的 build.gradle 文件加入<br><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">gradlePlugin</span> &#123;</span><br><span class="line">    <span class="section">plugins</span> &#123;</span><br><span class="line">        <span class="section">version</span> &#123;</span><br><span class="line">            <span class="attribute">id</span> = <span class="string">'com.test.version'</span></span><br><span class="line">            implementationClass = <span class="string">'com.test.version.DependencyVersionPlugin'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3-在-settings-gradle-加入-includeBuild-“version”-（重点）"><a href="#3-在-settings-gradle-加入-includeBuild-“version”-（重点）" class="headerlink" title="3.在 settings.gradle 加入 includeBuild(“version”) （重点）"></a>3.在 settings.gradle 加入 includeBuild(“version”) （重点）</h3><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">includeBuild</span><span class="params">(<span class="string">"version"</span>)</span></span></span><br><span class="line"></span><br><span class="line">rootProject.name=<span class="string">'VersionControlDemo'</span></span><br><span class="line">include <span class="string">':app'</span></span><br><span class="line">include <span class="string">':lib'</span></span><br></pre></td></tr></table></figure>
<h3 id="4-接下来在需要引用的-module-中引入该插件"><a href="#4-接下来在需要引用的-module-中引入该插件" class="headerlink" title="4.接下来在需要引用的 module 中引入该插件"></a>4.接下来在需要引用的 module 中引入该插件</h3><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">plugins</span> &#123;</span><br><span class="line">    <span class="attribute">id</span> <span class="string">"com.flywith24.version"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后就可以使用了</p>
<h3 id="定义依赖库版本"><a href="#定义依赖库版本" class="headerlink" title="定义依赖库版本"></a>定义依赖库版本</h3><p>示例如下所示：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">object</span> Testing &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">val</span> jUnit = <span class="string">"junit:junit:4.12"</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">val</span> androidJunit = <span class="string">"androidx.test.ext:junit:1.1.1"</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">val</span> espresso = <span class="string">"androidx.test.espresso:espresso-core:3.2.0"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="然后在build-gradle中使用"><a href="#然后在build-gradle中使用" class="headerlink" title="然后在build.gradle中使用"></a>然后在build.gradle中使用</h3><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">implementation(AndroidX.coreKtx)</span><br><span class="line">implementation(AndroidX.appcompat)</span><br><span class="line">implementation(AndroidX.constraintlayout)</span><br></pre></td></tr></table></figure>
<h2 id="使用组合构建切换远程依赖-本地module"><a href="#使用组合构建切换远程依赖-本地module" class="headerlink" title="使用组合构建切换远程依赖/本地module"></a>使用组合构建切换远程依赖/本地module</h2><p>在settings.gralde中添加<br><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">if</span> (Boolean.valueOf(useLocal)) &#123;</span><br><span class="line">    <span class="selector-tag">includeBuild</span>(<span class="string">'../Flywith24-Permission'</span>) &#123;</span><br><span class="line">        <span class="selector-tag">dependencySubstitution</span> &#123;</span><br><span class="line">            <span class="selector-tag">substitute</span> <span class="selector-tag">module</span>(<span class="string">'com.github.Flywith24:Flywith24-Permission'</span>) <span class="selector-tag">with</span> <span class="selector-tag">project</span>(<span class="string">':library'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果使用本地代码，将useLocal设置为true即可.</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/jinfulin/article/details/80421927" target="_blank" rel="noopener">gradle配置优化及dependencies中各种依赖方式说明</a><br><a href="https://juejin.im/post/6844904169833234439" target="_blank" rel="noopener">【奇技淫巧】除了 buildSrc 还能这样统一配置依赖版本？巧用 includeBuild</a><br><a href="https://juejin.im/post/6870082590397693965" target="_blank" rel="noopener">【奇技淫巧】子 module 的 build.gradle 中没有一行代码？多项目构建技巧</a><br><a href="https://juejin.im/post/6890549273105006600" target="_blank" rel="noopener">Gradle 爬坑指南 – Gradle 核心模型、Hook 函数、ext 扩展属性、Project API</a><br><a href="https://github.com/hi-dhl/ComposingBuilds-vs-buildSrc" target="_blank" rel="noopener">Composing builds vs buildSrc区别</a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Java与Kotlin泛型详解</title>
    <url>/blog/2020/11/kotlin-java-generic.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>带着问题学习可以让我们在学习的过程中更加有目的性与条理。<br>例如在读源码的过程中，我们如果从头开始读，往往千头万绪，抓不住要领。<br>而如果在开始读之前先带着几个问题，则可以让我们在读源码的过程中有一个主线。<br>最后也可以通过判断自己的问题是否得到解决了，来判断自己是否真的读懂了，不然面对成千上万行的代码，很容易有白读了的感觉。</p>
<p>阅读本文前，下面先列出几个问题<br>1.为什么我们需要泛型？<br>2.如何定义泛型类？如何定义泛型方法?<br>3.怎么限定类型变量？<br>4.泛型有什么局限性？<br>5.泛型类型的继承规则是怎样的？<br>6.什么是泛型的通配符？什么是PECS原则？<br>7.虚拟机如何实现泛型？什么是泛型擦除？<br>8.kotlin中的泛型与Java泛型有什么区别？</p>
<h2 id="为什么我们需要泛型？"><a href="#为什么我们需要泛型？" class="headerlink" title="为什么我们需要泛型？"></a>为什么我们需要泛型？</h2><p>首先举两个例子</p>
<h3 id="1-求和函数"><a href="#1-求和函数" class="headerlink" title="1.求和函数"></a>1.求和函数</h3><p>实际开发中，经常有数值类型求和的需求，例如实现int类型的加法, 有时候还需要实现long类型的求和<br>如果还需要double类型的求和，又需要重新在重载一个输入是double类型的add方法。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addInt</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">addFloat</span><span class="params">(<span class="keyword">float</span> x,<span class="keyword">float</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种情况就会写很多重复代码</p>
<h3 id="2-List中添加元素"><a href="#2-List中添加元素" class="headerlink" title="2.List中添加元素"></a>2.List中添加元素</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">list.add(<span class="string">"mark"</span>);</span><br><span class="line">list.add(<span class="string">"OK"</span>);</span><br><span class="line">list.add(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">        String name = list.get(i); <span class="comment">// 1</span></span><br><span class="line">        System.out.println(<span class="string">"name:"</span> + name);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>定义了一个List类型的集合，先向其中加入了两个字符串类型的值，随后加入一个Integer类型的值。这是完全允许的，因为此时list默认的类型为Object类型</p>
<p>在之后的循环中，由于忘记了之前在list中也加入了Integer类型的值或其他编码原因,容易引发类型转换错误.<br>因为编译阶段正常,因此，导致此类错误编码过程中不易发现。</p>
<p>在如上的编码过程中，我们发现主要存在两个问题：<br>1.当我们将一个对象放入集合中，集合不会记住此对象的类型，当再次从集合中取出此对象时，改对象的编译类型变成了Object类型，但其运行时类型任然为其本身类型。<br>2.因此，从List取出集合元素时需要人为的强制类型转化到具体的目标类型，且很容易出现“java.lang.ClassCastException”异常。</p>
<p>所以泛型的好处就是：<br>1.适用于多种数据类型执行相同的代码<br>2.泛型中的类型在使用时指定，不需要强制类型转换</p>
<h2 id="如何定义泛型类与泛型方法？"><a href="#如何定义泛型类与泛型方法？" class="headerlink" title="如何定义泛型类与泛型方法？"></a>如何定义泛型类与泛型方法？</h2><p>泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？<br>顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。<br>泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。<br>也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。</p>
<h3 id="泛型类与泛型接口的定义"><a href="#泛型类与泛型接口的定义" class="headerlink" title="泛型类与泛型接口的定义"></a>泛型类与泛型接口的定义</h3><p>引入一个类型变量T（其他大写字母都可以，不过常用的就是T，E，K，V等等），并且用&lt;&gt;括起来，并放在类名的后面。泛型类是允许有多个类型变量的。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Genertor</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImplGenertor</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Genertor</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="泛型方法的定义"><a href="#泛型方法的定义" class="headerlink" title="泛型方法的定义"></a>泛型方法的定义</h3><p>泛型方法，是在调用方法的时候指明泛型的具体类型 ，泛型方法可以在任何地方和任何场景中使用，包括普通类和泛型类。<br>注意泛型类中定义的普通方法和泛型方法的区别。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>.<span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">genericMethod</span><span class="params">(T...a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[a.length/<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>.<span class="function"><span class="keyword">public</span> T <span class="title">genericMethod</span><span class="params">(T...a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[a.length/<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>如上所示，第2种虽然在方法中使用了泛型，却不是一个泛型方法。<br>这只是类中的一个普通的成员方法，只不过他的返回值是泛型类中已经声明了的泛型。</p>
<h2 id="怎么限定类型变量？"><a href="#怎么限定类型变量？" class="headerlink" title="怎么限定类型变量？"></a>怎么限定类型变量？</h2><p>有时候，我们需要对类型变量加以约束，比如计算两个变量的最小，最大值。<br>请问，如果确保传入的两个变量一定有compareTo方法？那么解决这个问题的方案就是将T限制为实现了接口Comparable的类<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&gt; <span class="function">T <span class="title">min</span><span class="params">(T a,T b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.comapareTo(b)&gt;<span class="number">0</span>) <span class="keyword">return</span> a; <span class="keyword">else</span> <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>同时extends左右都允许有多个，如 T,V extends Comparable &amp; Serializable<br>这种类的限定既可以用在泛型方法上也可以用在泛型类上。</p>
<h2 id="泛型有什么局限性？"><a href="#泛型有什么局限性？" class="headerlink" title="泛型有什么局限性？"></a>泛型有什么局限性？</h2><p>因为Java中的泛型是利用泛型擦除实现的，目前还有以下局限性<br>1.不能用基本类型实例化类型参数<br>2.运行时类型查询只适用于原始类型<br>3.泛型类的静态上下文中类型变量失效<br>4.不能创建参数化类型的数组<br>5.不能实例化类型变量<br>6.不能捕获泛型类的实例</p>
<p>不能在静态域或方法中引用类型变量。因为泛型是要在对象创建的时候才知道是什么类型的，而对象创建的代码执行先后顺序是static的部分，然后才是构造函数等等。所以在对象初始化之前static的部分已经执行了，如果你在静态部分引用的泛型，那么毫无疑问虚拟机根本不知道是什么东西，因为这个时候类还没有初始化。</p>
<h2 id="泛型类型的继承规则是怎样的？"><a href="#泛型类型的继承规则是怎样的？" class="headerlink" title="泛型类型的继承规则是怎样的？"></a>泛型类型的继承规则是怎样的？</h2><p>现在我们有一个类和子类<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Emplyee</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">Emplyee</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>有一个泛型类<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt;</span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>请问Pair<employee>和Pair<worker>是继承关系吗？<br>答案：不是，他们之间没有什么关系<br>但是泛型类可以继承或者扩展其他泛型类，比如List和ArrayList</worker></employee></p>
<h2 id="通配符与PECS"><a href="#通配符与PECS" class="headerlink" title="通配符与PECS"></a>通配符与PECS</h2><p>正是因为前面所述的，Pair<employee>和Pair<worker>没有任何关系,而我们有时候需要用到类之前的继承关系<br>为解决这个问题，于是提出了一个通配符类型 ?<br>有两种使用方式：<br>？ extends X  表示类型的上界，类型参数是X的子类<br>？ super X  表示类型的下界，类型参数是X的超类<br>这两种 方式从名字上来看，特别是super，很有迷惑性，下面我们来仔细辨析这两种方法。</worker></employee></p>
<h3 id="？-extends-X"><a href="#？-extends-X" class="headerlink" title="？ extends X"></a>？ extends X</h3><p>表示传递给方法的参数，必须是X的子类（包括X本身）<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print2</span><span class="params">(GenericType&lt;? extends Fruit&gt; p)</span></span>&#123;</span><br><span class="line">	System.out.println(p.getData().getColor());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">use2</span><span class="params">()</span></span>&#123;</span><br><span class="line">	GenericType&lt;Fruit&gt; a = <span class="keyword">new</span> GenericType&lt;&gt;();</span><br><span class="line">	print2(a);</span><br><span class="line">	GenericType&lt;Orange&gt; b = <span class="keyword">new</span> GenericType&lt;&gt;();</span><br><span class="line">	print2(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是对泛型类GenericType来说，如果其中提供了get和set类型参数变量的方法的话，set方法是不允许被调用的，会出现编译错误<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">GenericType&lt;? extends Fruit&gt; c =  <span class="keyword">new</span> GenericType&lt;&gt;();</span><br><span class="line"></span><br><span class="line">Apple apple =  <span class="keyword">new</span> Apple();</span><br><span class="line">Fruit fruit = <span class="keyword">new</span> Fruit();</span><br><span class="line">        <span class="comment">//set会报错</span></span><br><span class="line">        <span class="comment">//c.setData(apple);</span></span><br><span class="line">        <span class="comment">//c.setData(fruit);</span></span><br><span class="line">        <span class="comment">//get是可以的</span></span><br><span class="line">Fruit x = c.getData();</span><br></pre></td></tr></table></figure></p>
<p>get方法则没问题，会返回一个Fruit类型的值。<br>为何？<br>道理很简单，？extends X  表示类型的上界，类型参数是X的子类，那么可以肯定的说，get方法返回的一定是个X（不管是X或者X的子类）编译器是可以确定知道的。但是set方法只知道传入的是个X，至于具体是X的那个子类，不知道。</p>
<p>总结：主要用于安全地访问数据，可以访问X及其子类型，并且不能写入非null的数据。</p>
<h3 id="？-super-X"><a href="#？-super-X" class="headerlink" title="？ super X"></a>？ super X</h3><p>表示传递给方法的参数，必须是X的超类（包括X本身）<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printSuper</span><span class="params">(GenericType&lt;? <span class="keyword">super</span> Apple&gt; p)</span></span>&#123;</span><br><span class="line">	System.out.println(p.getData());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">useSuper</span><span class="params">()</span></span>&#123;</span><br><span class="line">	GenericType&lt;Fruit&gt; fruitGenericType = <span class="keyword">new</span> GenericType&lt;&gt;();</span><br><span class="line">	GenericType&lt;Apple&gt; appleGenericType = <span class="keyword">new</span> GenericType&lt;&gt;();</span><br><span class="line">	GenericType&lt;HongFuShi&gt; hongFuShiGenericType = <span class="keyword">new</span> GenericType&lt;&gt;();</span><br><span class="line">	GenericType&lt;Orange&gt; orangeGenericType = <span class="keyword">new</span> GenericType&lt;&gt;();</span><br><span class="line">	printSuper(fruitGenericType);</span><br><span class="line">	printSuper(appleGenericType);</span><br><span class="line">	printSuper(hongFuShiGenericType);</span><br><span class="line">	printSuper(orangeGenericType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是对泛型类GenericType来说，如果其中提供了get和set类型参数变量的方法的话，set方法可以被调用的，且能传入的参数只能是X或者X的子类<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//表示GenericType的类型参数的下界是Apple</span></span><br><span class="line">GenericType&lt;? <span class="keyword">super</span> Apple&gt; x = <span class="keyword">new</span> GenericType&lt;&gt;();</span><br><span class="line">x.setData(<span class="keyword">new</span> Apple());</span><br><span class="line">x.setData(<span class="keyword">new</span> HongFuShi());</span><br><span class="line">        <span class="comment">//x.setData(new Fruit());</span></span><br><span class="line">Object data = x.getData();</span><br></pre></td></tr></table></figure></p>
<p>get方法只会返回一个Object类型的值。<br>为何？<br>？super X  表示类型的下界，类型参数是X的超类（包括X本身），那么可以肯定的说，get方法返回的一定是个X的超类，那么到底是哪个超类？不知道，但是可以肯定的说，Object一定是它的超类，所以get方法返回Object。编译器是可以确定知道的。对于set方法来说，编译器不知道它需要的确切类型，但是X和X的子类可以安全的转型为X。</p>
<p>总结：主要用于安全地写入数据，可以写入X及其子类型</p>
<h3 id="无限定的通配符"><a href="#无限定的通配符" class="headerlink" title="无限定的通配符 ?"></a>无限定的通配符 ?</h3><p>表示对类型没有什么限制，可以把？看成所有类型的父类，如Pair&lt; ?&gt;；<br>比如：<br>ArrayList<t> al=new ArrayList<t>(); 指定集合元素只能是T类型<br>ArrayList&lt;?&gt; al=new ArrayList&lt;?&gt;();集合元素可以是任意类型，这种没有意义，一般是方法中，只是为了说明用法。<br>在使用上：<br>？ getFirst() ： 返回值只能赋给 Object，；<br>void setFirst(?) ： setFirst 方法不能被调用， 甚至不能用 Object 调用；</t></t></p>
<h3 id="PECS原则"><a href="#PECS原则" class="headerlink" title="PECS原则"></a>PECS原则</h3><p>上面讲解的extend与super的使用，其实可以用PECS原则来总结<br>PECS指“Producer Extends，Consumer Super”。换句话说，如果参数化类型表示一个生产者，就使用&lt;? extends T&gt;；如果它表示一个消费者，就使用&lt;? super T&gt;</p>
<p>总结 ? extends 和 the ? super 通配符的特征，我们可以得出以下结论：</p>
<ul>
<li>如果你想从一个数据类型里获取数据，使用 ? extends 通配符</li>
<li>如果你想把对象写入一个数据结构里，使用 ? super 通配符</li>
<li>如果你既想存，又想取，那就别用通配符。</li>
</ul>
<h2 id="虚拟机是如何实现泛型的？什么是泛型擦除？"><a href="#虚拟机是如何实现泛型的？什么是泛型擦除？" class="headerlink" title="虚拟机是如何实现泛型的？什么是泛型擦除？"></a>虚拟机是如何实现泛型的？什么是泛型擦除？</h2><p>泛型思想早在C++语言的模板（Template）中就开始生根发芽，在Java语言处于还没有出现泛型的版本时，只能通过Object是所有类型的父类和类型强制转换两个特点的配合来实现类型泛化。，由于Java语言里面所有的类型都继承于java.lang.Object，所以Object转型成任何对象都是有可能的。但是也因为有无限的可能性，就只有程序员和运行期的虚拟机才知道这个Object到底是个什么类型的对象。在编译期间，编译器无法检查这个Object的强制转型是否成功，如果仅仅依赖程序员去保障这项操作的正确性，许多ClassCastException的风险就会转嫁到程序运行期之中。</p>
<p>泛型技术在C#和Java之中的使用方式看似相同，但实现上却有着根本性的分歧，C#里面泛型无论在程序源码中、编译后的IL中（Intermediate Language，中间语言，这时候泛型是一个占位符），或是运行期的CLR中，都是切实存在的，List＜int＞与List＜String＞就是两个不同的类型，它们在系统运行期生成，有自己的虚方法表和类型数据，这种实现称为类型膨胀，基于这种方法实现的泛型称为真实泛型。</p>
<p>Java语言中的泛型则不一样，它只在程序源码中存在，在编译后的字节码文件中，就已经替换为原来的原生类型（Raw Type，也称为裸类型）了，并且在相应的地方插入了强制转型代码，因此，对于运行期的Java语言来说，ArrayList＜int＞与ArrayList＜String＞就是同一个类，所以泛型技术实际上是Java语言的一颗语法糖，Java语言中的泛型实现方法称为<strong>类型擦除</strong>，基于这种方法实现的泛型称为伪泛型。</p>
<p>将一段Java代码编译成Class文件，然后再用字节码反编译工具进行反编译后，将会发现泛型都不见了，程序又变回了Java泛型出现之前的写法，泛型类型都变回了原生类型<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">method</span><span class="params">(List&lt;String&gt; stringList)</span></span>&#123;</span><br><span class="line">	System.out.println(<span class="string">"List"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="string">"OK"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">method</span><span class="params">(List&lt;Integer&gt; stringList)</span></span>&#123;</span><br><span class="line">	System.out.println(<span class="string">"List"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面这段代码是不能被编译的，因为参数List＜Integer＞和List＜String＞编译之后都被擦除了，变成了一样的原生类型List＜E＞，擦除动作导致这两种方法的特征签名变得一模一样。</p>
<h3 id="为什么泛型擦除后get不需要类型转换？"><a href="#为什么泛型擦除后get不需要类型转换？" class="headerlink" title="为什么泛型擦除后get不需要类型转换？"></a>为什么泛型擦除后get不需要类型转换？</h3><p>因为类型擦除的问题，所以所有的泛型类型变量最后都会被替换为原始类型。这样就引起了一个问题，既然都被替换为原始类型，那么为什么我们在获取的时候，不需要进行强制类型转换呢？看下ArrayList和get方法：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">	RangeCheck(index);</span><br><span class="line">	<span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>看以看到，在return之前，会根据泛型变量进行强转。<br>写了个简单的测试代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ArrayList&lt;Date&gt; list=<span class="keyword">new</span> ArrayList&lt;Date&gt;();</span><br><span class="line">		list.add(<span class="keyword">new</span> Date());</span><br><span class="line">		Date myDate=list.get(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后反编了下字节码，如下<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">Code:</span><br><span class="line">0: new #16 // class java/util/ArrayList</span><br><span class="line"><span class="number">3</span>: dup</span><br><span class="line">4: invokespecial #18 // Method java/util/ArrayList."&lt;init</span><br><span class="line">:()V</span><br><span class="line"><span class="number">7</span>: astore_1</span><br><span class="line"><span class="number">8</span>: aload_1</span><br><span class="line">9: new #19 // class java/util/Date</span><br><span class="line"><span class="number">12</span>: dup</span><br><span class="line">13: invokespecial #21 // Method java/util/Date."&lt;init&gt;":()</span><br><span class="line"> </span><br><span class="line">16: invokevirtual #22 // Method java/util/ArrayList.add:(L</span><br><span class="line">va/lang/Object;)Z</span><br><span class="line"><span class="number">19</span>: pop</span><br><span class="line"><span class="number">20</span>: aload_1</span><br><span class="line"><span class="number">21</span>: iconst_0</span><br><span class="line">22: invokevirtual #26 // Method java/util/ArrayList.get:(I</span><br><span class="line">java/lang/Object;</span><br><span class="line">25: checkcast #19 // class java/util/Date</span><br><span class="line"><span class="number">28</span>: astore_2</span><br><span class="line"><span class="number">29</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure></p>
<p>看第22 ，它调用的是ArrayList.get()方法，方法返回值是Object，说明类型擦除了。然后第25，它做了一个checkcast操作，即检查类型#19， 在在上面找#19引用的类型，他是<br>9: new #19 // class java/util/Date<br>是一个Date类型，即做Date类型的强转。<br>所以不是在get方法里强转的，是在你调用的地方强转的</p>
<h2 id="kotlin泛型"><a href="#kotlin泛型" class="headerlink" title="kotlin泛型"></a>kotlin泛型</h2><p>kotlin泛型中引入了in和out</p>
<h3 id="Out-协变"><a href="#Out-协变" class="headerlink" title="Out (协变)"></a>Out (协变)</h3><p>如果你的类是将泛型作为内部方法的返回，那么可以用 out：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Production</span>&lt;<span class="type">out T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">produce</span><span class="params">()</span></span>: T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以称其为 production class/interface，因为其主要是产生（produce）指定泛型对象。因此，可以这样来记：produce = output = out。<br>相当于Java中的? extends T</p>
<h3 id="In-逆变"><a href="#In-逆变" class="headerlink" title="In(逆变)"></a>In(逆变)</h3><p>如果你的类是将泛型对象作为函数的参数，那么可以用 in：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Consumer</span>&lt;<span class="type">in T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">consume</span><span class="params">(item: <span class="type">T</span>)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以称其为 consumer class/interface，因为其主要是消费指定泛型对象。因此，可以这样来记：consume = input = in。<br>相当于Java中的? super T</p>
<h3 id="Invariant-不变"><a href="#Invariant-不变" class="headerlink" title="Invariant(不变)"></a>Invariant(不变)</h3><p>如果既将泛型作为函数参数，又将泛型作为函数的输出，那就既不用 in 或 out。<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ProductionConsumer</span>&lt;<span class="type">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">produce</span><span class="params">()</span></span>: T</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">consume</span><span class="params">(item: <span class="type">T</span>)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>“父类泛型对象可以赋值给子类泛型对象，用 in；<br>子类泛型对象可以赋值给父类泛型对象，用 out。”</p>
</blockquote>
<p>关于In out使用的例子，可见：<a href="https://zhuanlan.zhihu.com/p/32583310" target="_blank" rel="noopener">Kotlin 泛型中的 in 和 out</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.cnblogs.com/dldrjyy13102/p/8297045.html" target="_blank" rel="noopener">PECS法则与extends和super关键字</a><br><a href="https://blog.csdn.net/LonelyRoamer/article/details/7868820" target="_blank" rel="noopener">什么是泛型擦除</a><br><a href="https://blog.csdn.net/wanliguodu/article/details/80260224" target="_blank" rel="noopener">由Kotlin 中关键字out和in和Java中的泛型的比较学习</a><br><a href="https://zhuanlan.zhihu.com/p/32583310" target="_blank" rel="noopener">Kotlin 泛型中的 in 和 out</a></p>
]]></content>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>ARTS打卡5</title>
    <url>/blog/2020/11/arts-way-five.html</url>
    <content><![CDATA[<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><blockquote>
<p><a href="https://leetcode-cn.com/contest/weekly-contest-216/problems/check-if-two-string-arrays-are-equivalent/" target="_blank" rel="noopener">5605. 检查两个字符串数组是否相等</a><br>给你两个字符串数组 word1 和 word2 。如果两个数组表示的字符串相同，返回 true ；否则，返回 false 。<br>数组表示的字符串 是由数组中的所有元素 按顺序 连接形成的字符串。<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">arrayStringsAreEqual</span><span class="params">(word1: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;, word2: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> stringBuilder1 = StringBuilder()</span><br><span class="line">        <span class="keyword">val</span> stringBuilder2 = StringBuilder()</span><br><span class="line">        word1.forEach &#123; </span><br><span class="line">            stringBuilder1.append(it)</span><br><span class="line">        &#125;</span><br><span class="line">        word2.forEach &#123; </span><br><span class="line">            stringBuilder2.append(it)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stringBuilder1.toString()==stringBuilder2.toString()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p><a href="https://android-developers.googleblog.com/2019/05/android-studio-35-beta.html" target="_blank" rel="noopener">Android Studio 3.5 Beta</a><br><a href="https://medium.com/androiddevelopers/improving-build-speed-in-android-studio-3e1425274837" target="_blank" rel="noopener">Improving build speed in Android Studio</a><br><a href="https://juejin.cn/post/6844903875401498631" target="_blank" rel="noopener">[译] 改善 Android Studio 的构建速度</a></p>
<p>本文主要讲述了Android Studio在提高编译速度方面的努力<br>1.首次定义了编译速度的衡量标准<br>2.为什么在android studio努力提高编译速度后，大部分项目的编译时间还增长了？<br>3.如何修复内部流程并持续改进性能<br>4.改善性能工具，让用户更便于使用<br>5.为了提高编译速度，你可以做什么</p>
<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><p>TabLayout底部指示条自定义为圆角</p>
<h3 id="1-自定义drawable"><a href="#1-自定义drawable" class="headerlink" title="1.自定义drawable"></a>1.自定义drawable</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">shape</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">corners</span> <span class="attr">android:radius</span>=<span class="string">"2dp"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">size</span> <span class="attr">android:height</span>=<span class="string">"2dp"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">solid</span> <span class="attr">android:color</span>=<span class="string">"@color/red"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">shape</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-tab添加indicator"><a href="#2-tab添加indicator" class="headerlink" title="2.tab添加indicator"></a>2.tab添加indicator</h3><figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">com</span>.google.android.material.tabs.TabLayout</span><br><span class="line"><span class="symbol">android:</span>id=<span class="string">"@+id/tab_layout"</span></span><br><span class="line"><span class="symbol">android:</span>layout_width=<span class="string">"match_parent"</span></span><br><span class="line"><span class="symbol">android:</span>layout_height=<span class="string">"45dp"</span></span><br><span class="line"><span class="symbol">app:</span>tabIndicator=<span class="string">"@drawable/shape_tab_corner_indicator"</span></span><br><span class="line"><span class="symbol">app:</span>tabIndicatorColor=<span class="string">"@color/red"</span></span><br><span class="line"><span class="symbol">app:</span>tabIndicatorFullWidth=<span class="string">"false"</span></span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>
<h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p>本周主要总结了Android自定义View相关问题，详情可见：<br><a href="https://shenzhen2017.github.io/blog/2020/11/android-view-arcitechture.html">Android自定义View问题总结</a></p>
]]></content>
      <tags>
        <tag>ARTS</tag>
      </tags>
  </entry>
  <entry>
    <title>Android自定义View问题总结</title>
    <url>/blog/2020/11/android-view-arcitechture.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>带着问题学习可以让我们在学习的过程中更加有目的性与条理。<br>例如在读源码的过程中，我们如果从头开始读，往往千头万绪，抓不住要领。<br>而如果在开始读之前先带着几个问题，则可以让我们在读源码的过程中有一个主线。<br>最后也可以通过判断自己的问题是否得到解决了，来判断自己是否真的读懂了，不然面对成千上万行的代码，很容易有白读了的感觉。<br>阅读本文前，下面先列出几个问题</p>
<p>1.View什么时候发生绘制？<br>2.setContentView之后发生了什么？<br>3.View怎么测量大小？MeasureSpec的作用是什么？如何产生？<br>4.MeasureSpec中UNSPECIFIED的用途<br>5.如何自定义FlowLayout<br>6.一道滴滴面试题</p>
<h2 id="View什么时候发生绘制"><a href="#View什么时候发生绘制" class="headerlink" title="View什么时候发生绘制"></a>View什么时候发生绘制</h2><p>在Android应用中，View的第一次绘制是伴随这个Activity启动开始的。当Activity生命周期执行到onCreate时，我们都知道这时候会调用setContentView方法。View的绘制就是从这里开始。</p>
<p>除此之外，当View树中的视图发生变化时，会开始View的绘制；或者主动调用View的绘制方法，比如invalidate方法。这个都会发起View的绘制。</p>
<h2 id="setContentView之后发生了什么？"><a href="#setContentView之后发生了什么？" class="headerlink" title="setContentView之后发生了什么？"></a>setContentView之后发生了什么？</h2><p>通过在Activity中调用setContentView方法开始View的加载。这个过程是通过Window对象加载的。我们可以再PhoneWindow中找到这个方法。在这个方法中可以看到一个installDecor的方法。这个方法的作用就是初始化顶级View，也就是DecorView（这里不再介绍DecorView的创建过程，想了解的同学可以自行阅读代码）。之后View的工作流程就是从DecorView开始的，这个后面再讲。</p>
<p>setContentView只是先将顶级View初始化，还没有开始View的绘制。接着往下看，ActivityThread继续执行Activity的生命周期。在ActivityThread执行到handleResumeActivity方法时，这里调用了Activity的生命周期函数onResume。接着在通过WindowManager添加了DecorView，然后才开始了View的工作流程。这里也解释了为什么在Activity在执行完onResume的时候用户才可以跟App交互。</p>
<p>最后创建了ViewRootImpl的实例，ViewRootImpl的作用就是沟通View和WindowManager，实现两者所需要的协议，它管理着View的工作流程。<br>ViewRootImpl中的performTraversals方法中可以看到执行了3个方法。分别是performMeasure、performLayout、performDraw，从名称上也可以想到，着3个方法执行了View的measure、layout、draw方法</p>
<p>关于setConteView后发生什么的详情解析可见：<a href="https://juejin.cn/post/6890152854649225230" target="_blank" rel="noopener">Android视图体系—View的工作流程</a></p>
<h2 id="View怎么测量大小？"><a href="#View怎么测量大小？" class="headerlink" title="View怎么测量大小？"></a>View怎么测量大小？</h2><p>View通过measure来确定大小<br>measure的作用就是决定View到底有多大。在整个View树种是由View和ViewGroup组成。而measure也分为着两种绘制方式。View的measure只测试自身大小。ViewGroup除了测量自身大小，还负责测量子View的大小。</p>
<h3 id="MeasureSpec的作用"><a href="#MeasureSpec的作用" class="headerlink" title="MeasureSpec的作用"></a>MeasureSpec的作用</h3><p>MeasureSpec封装了View的规格尺寸参数，包括View的宽高以及测量模式。<br>它的高2位代表测量模式（通过mode &amp; MODE_MASK计算），低30位代表尺寸。其中测量模式总共有3中。</p>
<ul>
<li>UNSPECIFIED：未指定模式不对子View的尺寸进行限制。</li>
<li>AT_MOST：最大模式对应于wrap_content属性，父容器已经确定子View的大小，并且子View不能大于这个值。</li>
<li>EXACTLY：精确模式对应于match_parent属性和具体的数值，子View可以达到父容器指定大小的值。</li>
</ul>
<p>对于每一个View，都会有一个MeasureSpec属性来保存View的尺寸规格信息。在View测量的时候，通过makeMeasureSpec来保存宽高信息，通过getMode获取测量模式，通过getSize获取宽或高。</p>
<h3 id="MeasureSpec是如何产生的"><a href="#MeasureSpec是如何产生的" class="headerlink" title="MeasureSpec是如何产生的"></a>MeasureSpec是如何产生的</h3><p>MeasureSpec相当于View测量过程中的一个规格，在View开始测量前需要先生成MeasureSpec来指导View以何种方式测量。<br>MeasureSpec生成是由父布局决定的，同时对于顶级ViewDecorView来说是由LayoutParams决定的。<br>在上面分析View工作流程开始的时候，在ViewRootImpl中开始工作流程前，有一个方法measureHierarchy()，这个方法就是生成DecorView的方式。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">measureHierarchy</span><span class="params">(<span class="keyword">final</span> View host, <span class="keyword">final</span> WindowManager.LayoutParams lp,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> Resources res, <span class="keyword">final</span> <span class="keyword">int</span> desiredWindowWidth, <span class="keyword">final</span> <span class="keyword">int</span> desiredWindowHeight)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (baseSize != <span class="number">0</span> &amp;&amp; desiredWindowWidth &gt; baseSize) &#123;</span><br><span class="line">        childWidthMeasureSpec = getRootMeasureSpec(baseSize, lp.width);</span><br><span class="line">        childHeightMeasureSpec = getRootMeasureSpec(desiredWindowHeight, lp.height);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在代码中可以看到通过getRootMeasureSpec()方法获取了DecorView的MeasureSpec。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getRootMeasureSpec</span><span class="params">(<span class="keyword">int</span> windowSize, <span class="keyword">int</span> rootDimension)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> measureSpec;</span><br><span class="line">    <span class="keyword">switch</span> (rootDimension) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> ViewGroup.LayoutParams.MATCH_PARENT:</span><br><span class="line">        <span class="comment">// Window can't resize. Force root view to be windowSize.</span></span><br><span class="line">        measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ViewGroup.LayoutParams.WRAP_CONTENT:</span><br><span class="line">        <span class="comment">// Window can resize. Set max size for root view.</span></span><br><span class="line">        measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// Window wants to be an exact size. Force root view to be that size.</span></span><br><span class="line">        measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> measureSpec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>getRootMeasureSpec()也不复杂，在方法中可以看出如果是LayoutParams.MATCH_PARENT，那么DecorView的大小就是Window的大小；如果是LayoutParams.WRAP_CONTENT，那么DecorView的大小不确定。<br>对于普通的View，MeasureSpec来自于父布局（ViewGroup）生成。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChildWithMargins</span><span class="params">(View child,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> parentWidthMeasureSpec, <span class="keyword">int</span> widthUsed,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> parentHeightMeasureSpec, <span class="keyword">int</span> heightUsed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</span><br><span class="line">            mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin</span><br><span class="line">                    + widthUsed, lp.width);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</span><br><span class="line">            mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin</span><br><span class="line">                    + heightUsed, lp.height);</span><br><span class="line"></span><br><span class="line">    child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这里可以看到生成子View的MeasureSpec时与父布局的MeasureSpec以及padding相关，同时也与View本身的margin有关。</p>
<h3 id="MeasureSpec中UNSPECIFIED的用途"><a href="#MeasureSpec中UNSPECIFIED的用途" class="headerlink" title="MeasureSpec中UNSPECIFIED的用途"></a>MeasureSpec中UNSPECIFIED的用途</h3><p>UNSPECIFIED主要在一线父View不限制子View宽高的情况下使用，比如ScrollView<br>1.UNSPECIFIED会在ScrollView的measure方法里传给子View<br>2.子View收到UNSPECIFIED，会根据自己的实际内容大小来决定高度<br>3.UNSPECIFIED与AT_MOST的区别就是，它没有最大size限定这也说明UNSPECIFIED在ScrollView里很实用，因为ScrllView不需要限定子View的大小，它可以滚动嘛<br>详情可见：<a href="https://blog.csdn.net/u012947056/article/details/81292621" target="_blank" rel="noopener">measure之UNSPECIFIED的用途</a></p>
<h2 id="如何自定义FlowLayout"><a href="#如何自定义FlowLayout" class="headerlink" title="如何自定义FlowLayout"></a>如何自定义FlowLayout</h2><p>实现自定义View主要需要解决以下3个问题<br>1.自定义控件的大小，也就是宽和高分别设置多少；<br>2.如果是 ViewGroup，如何合理安排其内部子 View 的摆放位置。<br>3.如何根据相应的属性将 UI 元素绘制到界面；    </p>
<p>以上 3 个问题依次在如下 3 个方法中得到解决：<br>onMeasure,onLayout,onDraw</p>
<h3 id="FlowLayout的onMeasure方法"><a href="#FlowLayout的onMeasure方法" class="headerlink" title="FlowLayout的onMeasure方法"></a>FlowLayout的onMeasure方法</h3><p>因为自定义的控件是一个容器，onMeasure 方法会更加复杂一些。因为 ViewGroup 在测量自己的宽高之前，需要先确定其内部子 View 的所占大小，然后才能确定自己的大小。<br>如下所示：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测量控件的宽和高</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">     <span class="comment">//获得宽高的测量模式和测量值</span></span><br><span class="line">     <span class="keyword">int</span> widthMode = MeasureSpec.getMode(widthMeasureSpec);</span><br><span class="line">     <span class="keyword">int</span> widthSize = MeasureSpec.getSize(widthMeasureSpec);</span><br><span class="line">     <span class="keyword">int</span> heightSize = MeasureSpec.getSize(heightMeasureSpec);</span><br><span class="line">     <span class="keyword">int</span> heightMode = MeasureSpec.getMode(heightMeasureSpec);</span><br><span class="line"></span><br><span class="line">     <span class="comment">//获得容器中子View的个数</span></span><br><span class="line">     <span class="keyword">int</span> childCount = getChildCount();</span><br><span class="line">     <span class="comment">//记录每一行View的总宽度</span></span><br><span class="line">     <span class="keyword">int</span> totalLineWidth = <span class="number">0</span>;</span><br><span class="line">     <span class="comment">//记录每一行最高View的高度</span></span><br><span class="line">     <span class="keyword">int</span> perLineMaxHeight = <span class="number">0</span>;</span><br><span class="line">     <span class="comment">//记录当前ViewGroup的总高度</span></span><br><span class="line">     <span class="keyword">int</span> totalHeight = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childCount; i++) &#123;</span><br><span class="line">         View childView = getChildAt(i);</span><br><span class="line">         <span class="comment">//对子View进行测量</span></span><br><span class="line">         measureChild(childView, widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">         MarginLayoutParams lp = (MarginLayoutParams) childView.getLayoutParams();</span><br><span class="line">         <span class="comment">//获得子View的测量宽度</span></span><br><span class="line">         <span class="keyword">int</span> childWidth = childView.getMeasuredWidth() + lp.leftMargin + lp.rightMargin;</span><br><span class="line">         <span class="comment">//获得子View的测量高度</span></span><br><span class="line">         <span class="keyword">int</span> childHeight = childView.getMeasuredHeight() + lp.topMargin + lp.bottomMargin;</span><br><span class="line">         <span class="keyword">if</span> (totalLineWidth + childWidth &gt; widthSize) &#123;</span><br><span class="line">             <span class="comment">//统计总高度</span></span><br><span class="line">             totalHeight += perLineMaxHeight;</span><br><span class="line">             <span class="comment">//开启新的一行</span></span><br><span class="line">             totalLineWidth = childWidth;</span><br><span class="line">             perLineMaxHeight = childHeight;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="comment">//记录每一行的总宽度</span></span><br><span class="line">             totalLineWidth += childWidth;</span><br><span class="line">             <span class="comment">//比较每一行最高的View</span></span><br><span class="line">             perLineMaxHeight = Math.max(perLineMaxHeight, childHeight);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//当该View已是最后一个View时，将该行最大高度添加到totalHeight中</span></span><br><span class="line">         <span class="keyword">if</span> (i == childCount - <span class="number">1</span>) &#123;</span><br><span class="line">             totalHeight += perLineMaxHeight;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//如果高度的测量模式是EXACTLY，则高度用测量值，否则用计算出来的总高度（这时高度的设置为wrap_content）</span></span><br><span class="line">     heightSize = heightMode == MeasureSpec.EXACTLY ? heightSize : totalHeight;</span><br><span class="line">     setMeasuredDimension(widthSize, heightSize);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>上述 onMeasure 方法的主要目的有 2 个：<br>1.调用 measureChild 方法递归测量子 View；<br>2.通过叠加每一行的高度，计算出最终 FlowLayout 的最终高度 totalHeight。  </p>
<h3 id="FlowLayout的onLayout方法"><a href="#FlowLayout的onLayout方法" class="headerlink" title="FlowLayout的onLayout方法"></a>FlowLayout的onLayout方法</h3><p>上面的 FlowLayout 中的 onMeasure 方法只是计算出 ViewGroup 的最终显示宽高，但是并没有规定某一个子 View 应该显示在何处位置。要定义 ViewGroup 内部子 View 的显示规则，则需要复写并实现 onLayout 方法。<br>onLayout是一个抽象方法，也就是说每一个自定义 ViewGroup 都必须主动实现如何排布子 View，具体就是遍历每一个子 View，调用 child.(l, t, r, b) 方法来为每个子 View 设置具体的布局位置。四个参数分别代表左上右下的坐标位置，一个简易的 FlowLayout 实现如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    mAllViews.clear();</span><br><span class="line">    mPerLineMaxHeight.clear();</span><br><span class="line">    <span class="comment">//存放每一行的子View</span></span><br><span class="line">    List&lt;View&gt; lineViews = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//记录每一行已存放View的总宽度</span></span><br><span class="line">    <span class="keyword">int</span> totalLineWidth = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//记录每一行最高View的高度</span></span><br><span class="line">    <span class="keyword">int</span> lineMaxHeight = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/****遍历所有View，将View添加到List&lt;List&lt;View&gt;&gt;集合中**********/</span></span><br><span class="line">    <span class="comment">//获得子View的总个数</span></span><br><span class="line">    <span class="keyword">int</span> childCount = getChildCount();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childCount; i++) &#123;</span><br><span class="line">        View childView = getChildAt(i);</span><br><span class="line">        MarginLayoutParams lp = (MarginLayoutParams) childView.getLayoutParams();</span><br><span class="line">        <span class="keyword">int</span> childWidth = childView.getMeasuredWidth() + lp.leftMargin + lp.rightMargin;</span><br><span class="line">        <span class="keyword">int</span> childHeight = childView.getMeasuredHeight() + lp.topMargin + lp.bottomMargin;</span><br><span class="line">        <span class="keyword">if</span> (totalLineWidth + childWidth &gt; getWidth()) &#123;</span><br><span class="line">            mAllViews.add(lineViews);</span><br><span class="line">            mPerLineMaxHeight.add(lineMaxHeight);</span><br><span class="line">            <span class="comment">//开启新的一行</span></span><br><span class="line">            totalLineWidth = <span class="number">0</span>;</span><br><span class="line">            lineMaxHeight = <span class="number">0</span>;</span><br><span class="line">            lineViews = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        totalLineWidth += childWidth;</span><br><span class="line">        lineViews.add(childView);</span><br><span class="line">        lineMaxHeight = Math.max(lineMaxHeight, childHeight);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//单独处理最后一行</span></span><br><span class="line">    mAllViews.add(lineViews);</span><br><span class="line">    mPerLineMaxHeight.add(lineMaxHeight);</span><br><span class="line">    <span class="comment">/************遍历集合中的所有View并显示出来************/</span></span><br><span class="line">    <span class="comment">//表示一个View和父容器左边的距离</span></span><br><span class="line">    <span class="keyword">int</span> mLeft = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//表示View和父容器顶部的距离</span></span><br><span class="line">    <span class="keyword">int</span> mTop = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mAllViews.size(); i++) &#123;</span><br><span class="line">        <span class="comment">//获得每一行的所有View</span></span><br><span class="line">        lineViews = mAllViews.get(i);</span><br><span class="line">        lineMaxHeight = mPerLineMaxHeight.get(i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; lineViews.size(); j++) &#123;</span><br><span class="line">            View childView = lineViews.get(j);</span><br><span class="line">            MarginLayoutParams lp = (MarginLayoutParams) childView.getLayoutParams();</span><br><span class="line">            <span class="keyword">int</span> leftChild = mLeft + lp.leftMargin;</span><br><span class="line">            <span class="keyword">int</span> topChild = mTop + lp.topMargin;</span><br><span class="line">            <span class="keyword">int</span> rightChild = leftChild + childView.getMeasuredWidth()；</span><br><span class="line">            <span class="keyword">int</span> bottomChild = topChild + childView.getMeasuredHeight();</span><br><span class="line">            <span class="comment">//四个参数分别表示View的左上角和右下角</span></span><br><span class="line">            childView.layout(leftChild, topChild, rightChild, bottomChild);</span><br><span class="line">            mLeft += lp.leftMargin + childView.getMeasuredWidth() + lp.rightMargin;</span><br><span class="line">        &#125;</span><br><span class="line">        mLeft = <span class="number">0</span>;</span><br><span class="line">        mTop += lineMaxHeight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>完整代码可见：<a href="https://github.com/McoyJiang/LagouAndroidShare/tree/master/course15_%E8%87%AA%E5%AE%9A%E4%B9%89View/LagouCustomizedView" target="_blank" rel="noopener">自定义FlowLayout代码</a></p>
<h2 id="一道滴滴面试题"><a href="#一道滴滴面试题" class="headerlink" title="一道滴滴面试题"></a>一道滴滴面试题</h2><p>之前在面试滴滴时碰到了这样一首题目，这个问题如果你如果理解了，相信你已经充分掌握了自定义View的measure过程<br>Activity内根布局LinearLayout，背景颜色为红色,宽高为wrap_content<br>内部包含View背影颜色为蓝色,宽高也为wrap_content<br>求界面颜色<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:background</span>=<span class="string">"@color/red"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">View</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">"@color/blue"</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p><strong>答案是蓝色</strong><br>在下当时想当然的认为，既然都是wrap_content，界面颜色应该是白色。但是正确答案是蓝色<br>下面就来分析下具体原因  </p>
<h3 id="LinearLayout的onMeasure"><a href="#LinearLayout的onMeasure" class="headerlink" title="LinearLayout的onMeasure()"></a>LinearLayout的onMeasure()</h3><p>onMeasure()中比较简单，但是这里我们需要明确一下，这个方法的参数是什么含义：</p>
<p>MeasureSpec就不用多说了，记录当前View的尺寸和测量模式<br>另外明确一点，这里的MeasureSpec是父View的<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> widthMeasureSpec horizontal space requirements as imposed by the parent.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> heightMeasureSpec vertical space requirements as imposed by the parent.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mOrientation == VERTICAL) &#123;</span><br><span class="line">        measureVertical(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        measureHorizontal(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里咱们就选measureVertical()追进去，方法里的边界条件非常的多，但其中对于子View的测量过程比较的简单，遍历所有的子View，挨个调用measureChildBeforeLayout()方法，而这个方法最终会走到ViewGroup中的measureChildWithMargins()：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChildWithMargins</span><span class="params">(View child,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> parentWidthMeasureSpec, <span class="keyword">int</span> widthUsed,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> parentHeightMeasureSpec, <span class="keyword">int</span> heightUsed)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这个方法主要就是做了一件事情：通过子View的LayoutParams和父View的MeasureSpec来决定子View的MeasureSpec</span></span><br><span class="line">    <span class="keyword">final</span> MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</span><br><span class="line">            mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin</span><br><span class="line">                    + widthUsed, lp.width);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</span><br><span class="line">            mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin</span><br><span class="line">                    + heightUsed, lp.height);</span><br><span class="line"></span><br><span class="line">    child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="生成子View的MeasureSpec"><a href="#生成子View的MeasureSpec" class="headerlink" title="生成子View的MeasureSpec"></a>生成子View的MeasureSpec</h3><p>这部分逻辑主要在getChildMeasureSpec()方法中，我们直接追进去就好了：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getChildMeasureSpec</span><span class="params">(<span class="keyword">int</span> spec, <span class="keyword">int</span> padding, <span class="keyword">int</span> childDimension)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略部分初始化代码</span></span><br><span class="line">    <span class="keyword">switch</span> (specMode) &#123; </span><br><span class="line">        <span class="keyword">case</span> MeasureSpec.EXACTLY: </span><br><span class="line">            <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123; </span><br><span class="line">                resultSize = childDimension;</span><br><span class="line">                resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">                resultSize = size;</span><br><span class="line">                resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">                resultSize = size;</span><br><span class="line">                resultMode = MeasureSpec.AT_MOST;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MeasureSpec.AT_MOST: </span><br><span class="line">            <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                resultSize = childDimension;</span><br><span class="line">                resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">                resultSize = size;</span><br><span class="line">                resultMode = MeasureSpec.AT_MOST;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">                resultSize = size;</span><br><span class="line">                resultMode = MeasureSpec.AT_MOST;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MeasureSpec.UNSPECIFIED: </span><br><span class="line">            <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                resultSize = childDimension;</span><br><span class="line">                resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">                resultSize = View.sUseZeroUnspecifiedMeasureSpec ? <span class="number">0</span> : size;</span><br><span class="line">                resultMode = MeasureSpec.UNSPECIFIED;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">                resultSize = View.sUseZeroUnspecifiedMeasureSpec ? <span class="number">0</span> : size;</span><br><span class="line">                resultMode = MeasureSpec.UNSPECIFIED;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> MeasureSpec.makeMeasureSpec(resultSize, resultMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这部分代码，就是Google定的规则，也没什么好说的。总结起来就是《Android开发艺术探索》中的那张图：<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog7/p2.png" alt><br>看了这个，咱们就可以思考一下咱们开篇遇到的问题：父View（LinearLayout）是wrap_content，子View是wrap_parent，那么子View的MeasureSpec是什么样子？</p>
<p>有了上边的分析，我们很容易得出答案：parentSize + AT_MOST。因此咱们就知道这种场景下，子View的wrap_parent意味自己的宽高就是父View的宽高。那么此时父View的宽高是多少呢？</p>
<p>由于这里的父View已经是根View了，那么它的外边便是DecorView，而DecorView的MeasureSpec相对简单些，直接基于Window的宽高和自身的LayoutParams进行计算。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getRootMeasureSpec</span><span class="params">(<span class="keyword">int</span> windowSize, <span class="keyword">int</span> rootDimension)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> measureSpec;</span><br><span class="line">    <span class="keyword">switch</span> (rootDimension) &#123;</span><br><span class="line">        <span class="keyword">case</span> ViewGroup.LayoutParams.MATCH_PARENT:</span><br><span class="line">            measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ViewGroup.LayoutParams.WRAP_CONTENT:</span><br><span class="line">            measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> measureSpec;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">    setContentView(view, <span class="keyword">new</span> ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因此这种场景下，DecorView的MeasureSpec是屏幕宽高 + EXACTLY，那么父View（LinearLayout）的宽高就很明确了：parentSize + AT_MOST。</p>
<p>1.子View（TextView）的MeasureSpec是parentSize + AT_MOST<br>2.父View（LinearLayout）的MeasureSpec是parentSize + AT_MOST<br>3.DecorView的MeasureSpec是屏幕的size + EXACTLY   </p>
<h3 id="执行子View的measure-方法"><a href="#执行子View的measure-方法" class="headerlink" title="执行子View的measure()方法"></a>执行子View的measure()方法</h3><p>接下来咱们去看一看子View的measure()方法，<br>上述的部分我们已经知道measureChildWithMargins()方法中会基于父View的MeasureSpec和子View的LayoutParams计算子View的MeasureSpec,<br>然后调用子View的measure()：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">	setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),</span><br><span class="line">		getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getDefaultSize</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> measureSpec)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> result = size;</span><br><span class="line">	<span class="keyword">int</span> specMode = MeasureSpec.getMode(measureSpec);</span><br><span class="line">	<span class="keyword">int</span> specSize = MeasureSpec.getSize(measureSpec);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (specMode) &#123;</span><br><span class="line">		<span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</span><br><span class="line">		result = size;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> MeasureSpec.AT_MOST:</span><br><span class="line">		<span class="keyword">case</span> MeasureSpec.EXACTLY:</span><br><span class="line">		result = specSize;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码中可以看出，View的宽度即为父View传过来的宽高，即屏幕宽高。<br>因此最终效果为全屏显示蓝色。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://juejin.cn/post/6890152854649225230" target="_blank" rel="noopener">Android视图体系—View的工作流程</a><br><a href="https://blog.csdn.net/u012947056/article/details/81292621" target="_blank" rel="noopener">measure之UNSPECIFIED的用途</a><br><a href="https://juejin.cn/post/6893699917458604046" target="_blank" rel="noopener">深入理解自定义ViewGroup的布局测量过程</a><br><a href="https://juejin.cn/post/6877731252871364615" target="_blank" rel="noopener">来解释一下这个简单布局为什么是这个效果吧！</a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>协程初步</title>
    <url>/blog/2020/11/kotlin-coroutine-start.html</url>
    <content><![CDATA[<h2 id="协程的基本概念"><a href="#协程的基本概念" class="headerlink" title="协程的基本概念"></a>协程的基本概念</h2><ul>
<li>协程是可以由程序自行控制挂起，恢复的程序</li>
<li>协程可以用来实现多任务的协作执行</li>
<li>协程可以用来解决异步在任务控制流中的灵活转移</li>
</ul>
<h3 id="协程的作用"><a href="#协程的作用" class="headerlink" title="协程的作用"></a>协程的作用</h3><ul>
<li>协程可以让异步代码同步化</li>
<li>协程可以降低异步代码的程序复杂度</li>
<li>同步代码比异步代码更灵活，更容易实现复杂业务</li>
</ul>
<h3 id="线程VS协程"><a href="#线程VS协程" class="headerlink" title="线程VS协程"></a>线程VS协程</h3><p>线程是抢占式的，协程是协作式的<br>线程是根据时间片轮转，由操作系统调度<br>协程则是程序之间相互协作<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog8/p1.jpg" alt></p>
<h4 id="Kotlin协程只是个“线程框架”"><a href="#Kotlin协程只是个“线程框架”" class="headerlink" title="Kotlin协程只是个“线程框架”?"></a>Kotlin协程只是个“线程框架”?</h4><ul>
<li>运行在线程上的框架不一定就是“线程框架”，例如所有框架</li>
<li>支持线程切换的框架也不一定就是”线程框架” ,例如OkHttp</li>
</ul>
<h3 id="协程的主要内容"><a href="#协程的主要内容" class="headerlink" title="协程的主要内容"></a>协程的主要内容</h3><p>如下图所示：<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog8/p2.png" alt></p>
<h3 id="协程的分类"><a href="#协程的分类" class="headerlink" title="协程的分类"></a>协程的分类</h3><h4 id="按调用栈"><a href="#按调用栈" class="headerlink" title="按调用栈"></a>按调用栈</h4><p>1.有栈协程:每个协程会分配单独的调用栈,类似线程的调用栈<br>2.无栈协程:不会分配单独的调用栈,挂起点状态通过闭包或对象保存</p>
<h4 id="按调用关系"><a href="#按调用关系" class="headerlink" title="按调用关系"></a>按调用关系</h4><p>1.对称协程:调度权可以转移给任意协程,协程之间是对等关系<br>2.非对称协程:调度权只能转移给调用自己的协程,协程存在父子关系</p>
<h2 id="kotlin协程的基本要素"><a href="#kotlin协程的基本要素" class="headerlink" title="kotlin协程的基本要素"></a>kotlin协程的基本要素</h2><h3 id="挂起函数"><a href="#挂起函数" class="headerlink" title="挂起函数"></a>挂起函数</h3><ul>
<li>挂起函数:以suspend修饰的函数</li>
<li>挂起函数只能在其他挂起函数或协程中调用</li>
<li>挂起函数调用时包含了协程“挂起”的语义</li>
<li>挂起函数返回时则包含了协程“恢复”的语义</li>
</ul>
<h3 id="挂起函数怎么做到挂起和恢复？"><a href="#挂起函数怎么做到挂起和恢复？" class="headerlink" title="挂起函数怎么做到挂起和恢复？"></a>挂起函数怎么做到挂起和恢复？</h3><p>当我们写下面这样一个方法的时候<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Temp</span> </span>&#123;</span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后将他编译，获得其java字节码<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Temp</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title">test</span><span class="params">(@NotNull Continuation $completion)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> Unit.INSTANCE;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，挂起函数中默认有一个不可见的参数Continuation<br>挂起函数的挂起与恢复即利用这个Continuation参数来实现的<br>成功时回调Continuation.resume,失败时回调Continuation.resumeWithException</p>
<p>下面看一个将回调转写成挂起函数的例子，利用suspendCoroutine实现将retrofit的回调转化成挂起函数<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getUserSuspend</span><span class="params">(name: <span class="type">String</span>)</span></span> = suspendCoroutine&lt;User&gt;&#123;continuation -&gt;</span><br><span class="line">        githubApi.getUserCallback(name).enqueue( <span class="keyword">object</span> : Callback&lt;User&gt;&#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFailure</span><span class="params">(call: <span class="type">Call</span>&lt;<span class="type">User</span>&gt;, t: <span class="type">Throwable</span>)</span></span> =</span><br><span class="line">            continuation.resumeWithException<span class="string">'t)</span></span><br><span class="line"><span class="string">        override fun onResponse(call: Call&lt;User&gt;, response: Response&lt;User&gt;) =</span></span><br><span class="line"><span class="string">            response.takeIf(it.isSuccessfu /)?.body()?.let (continuation:resume)</span></span><br><span class="line"><span class="string">        &#125;)</span></span><br><span class="line"><span class="string">    &#125;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="协程上下文"><a href="#协程上下文" class="headerlink" title="协程上下文"></a>协程上下文</h3><p>协程上下文是一个数据集合</p>
<ul>
<li>协程执行过程中需要携带数据</li>
<li>索弓|是CoroutineContext.Key</li>
<li>元素是CoroutineContext. Element</li>
</ul>
<h4 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h4><ul>
<li>拦截器ContinuationInterceptor是一类协程上下文元素</li>
<li>可以对协程上下文所在协程的Continuation进行拦截</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">interceptContinuation</span><span class="params">(continuation: <span class="type">Continuation</span>&lt;<span class="type">T</span>&gt;)</span></span>: Continuation&lt;T&gt;</span><br></pre></td></tr></table></figure>
<p>利用拦截器可以实现线程切换</p>
<h2 id="手写Python生成器"><a href="#手写Python生成器" class="headerlink" title="手写Python生成器"></a>手写Python生成器</h2><p>python语法中也存在协程，我们先介绍一下python中协程的简单用法<br>要理解协程，首先需要知道生成器是什么。生成器其实就是不断产出值的函数，只不过在函数中需要使用yield这一个关键词将值产出。下面来看一个例子：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen</span><span class="params">()</span>:</span></span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">yield</span> n</span><br><span class="line">        n += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">g = gen()</span><br><span class="line">print(g)  <span class="comment"># &lt;generator object gen at 0x00000246E165A7C8&gt;</span></span><br><span class="line">print(next(g))  <span class="comment"># 输出结果为0</span></span><br><span class="line">print(next(g))  <span class="comment"># 输出结果为1</span></span><br></pre></td></tr></table></figure></p>
<p>我们调用gen()函数并不会直接执行该函数，而是会得到一个生成器对象。对这个生成器对象调用next()函数，这个生成器对象会开始执行到第一个yield处，于是产出一个值0，注意：这时候gen()就暂停在yield处，直到第二次调用next()函数。</p>
<p>到这里我们可以发现，生成器函数是可以暂停的函数，它在调用方的驱使下（调用方使用next()函数），每次执行到yield处将yield后方的值产出给调用方后就暂停自己的执行，直到调用方下一次驱动它执行。</p>
<p>接下来看看我们怎么使用kotlin实现同样的效果</p>
<h3 id="1-先看看最终要实现的调用代码"><a href="#1-先看看最终要实现的调用代码" class="headerlink" title="1.先看看最终要实现的调用代码"></a>1.先看看最终要实现的调用代码</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> nums = generator &#123; start: <span class="built_in">Int</span> -&gt;</span><br><span class="line">            <span class="comment">//限制yield的调用范围，只能在lambda中使用</span></span><br><span class="line">            <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span>..<span class="number">5</span>) &#123;</span><br><span class="line">                yield(start + i)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> seqs = nums(<span class="number">10</span>)</span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> seqs)&#123;</span><br><span class="line">            println(j)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>上面就是我们最终要实现的效果<br>可以看出，我们需要实现的有<br>1.generator方法<br>2.generator方法获得的结果需要支持Iterator接口<br>3.yield方法<br>4.yield需要限制在一定的范围之内</p>
<h3 id="2-Generator接口与实现"><a href="#2-Generator接口与实现" class="headerlink" title="2.Generator接口与实现"></a>2.Generator接口与实现</h3><h4 id="定义Generator接口"><a href="#定义Generator接口" class="headerlink" title="定义Generator接口"></a>定义Generator接口</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Generator</span>&lt;<span class="type">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">iterator</span><span class="params">()</span></span>: Iterator&lt;T&gt;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="定义Generator实现"><a href="#定义Generator实现" class="headerlink" title="定义Generator实现"></a>定义Generator实现</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GeneratorImpl</span>&lt;<span class="type">T</span>&gt;</span>(</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> block: <span class="keyword">suspend</span> GeneratorScope&lt;T&gt;.(T) -&gt; <span class="built_in">Unit</span>,</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> parameter: T</span><br><span class="line">    ) : Generator&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">iterator</span><span class="params">()</span></span>: Iterator&lt;T&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> GeneratorIterator(block, parameter)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="定义GeneratorScope"><a href="#定义GeneratorScope" class="headerlink" title="定义GeneratorScope"></a>定义GeneratorScope</h4><p>为了限定yield方法的使用范围，需要定义GeneratorScope<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">GeneratorScope</span>&lt;<span class="type">T</span>&gt; <span class="keyword">internal</span> <span class="keyword">constructor</span></span>() &#123;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">val</span> parameter: T</span><br><span class="line">        <span class="keyword">abstract</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">yield</span><span class="params">(value: <span class="type">T</span>)</span></span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="写出generator方法"><a href="#写出generator方法" class="headerlink" title="写出generator方法"></a>写出generator方法</h4><p>定义了上面这些内容，我们就可以写出generator方法了<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">generator</span><span class="params">(block: <span class="type">suspend</span> <span class="type">GeneratorScope</span>&lt;<span class="type">T</span>&gt;.(<span class="type">T</span>) -&gt; <span class="type">Unit</span>)</span></span>: (T) -&gt; Generator&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            GeneratorImpl(block, it)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的语句用到了带接收者的lambda表达式<br>lambda 作为形参函数声明时，可以携带接收者，如下图：<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog8/p5.webp" alt><br>带接收者的 lambda 丰富了函数声明的信息，当传递该 lambda值时，将携带该接收者,比如：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明接收者</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">kotlinDSL</span><span class="params">(block:<span class="type">StringBuilder</span>.()-&gt;<span class="type">Unit</span>)</span></span>&#123;</span><br><span class="line">  block(StringBuilder(<span class="string">"Kotlin"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用高阶函数</span></span><br><span class="line">kotlinDSL &#123;</span><br><span class="line">  <span class="comment">// 这个 lambda 的接收者类型为StringBuilder</span></span><br><span class="line">  append(<span class="string">" DSL"</span>)</span><br><span class="line">  println(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; 输出 Kotlin DSL</span><br></pre></td></tr></table></figure></p>
<h3 id="3-GeneratorIterator的具体实现"><a href="#3-GeneratorIterator的具体实现" class="headerlink" title="3.GeneratorIterator的具体实现"></a>3.GeneratorIterator的具体实现</h3><h4 id="定义生成器状态"><a href="#定义生成器状态" class="headerlink" title="定义生成器状态"></a>定义生成器状态</h4><p>首先我们需要定义生成器的状态，方便后续判断生成器是否准备好，并根据相应条件做好状态转换<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">NotReady</span></span>(<span class="keyword">val</span> continuation: Continuation&lt;<span class="built_in">Unit</span>&gt;) : State()</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Ready</span>&lt;<span class="type">T</span>&gt;</span>(<span class="keyword">val</span> continuation: Continuation&lt;<span class="built_in">Unit</span>&gt;, <span class="keyword">val</span> nextValue: T) : State()</span><br><span class="line">        <span class="keyword">object</span> Done : State()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>如上所示，定义了3种状态<br>1.NotReady,未准备好，初始状态，挂起状态<br>2.Ready,已准备好，准备返回<br>3.Done,生成器内已经没有了数据</p>
<p>上面的语句使用了sealed密封类<br>1.密封(Sealed)类是一个限制类层次结构的类。<br>2.可以在类名之前使用sealed关键字将类声明为密封类。<br>3.它用于表示受限制的类层次结构。<br>4.当对象具有来自有限集的类型之一，但不能具有任何其他类型时，使用密封类。<br>5.密封类的构造函数在默认情况下是私有的，它也不能允许声明为非私有。   </p>
<p>密封类的主要优点在于与when一起使用时<br>由于密封类的子类将自身类型作为一种情况。 因此，密封类中的when表达式涵盖所有情况，从而避免使用else子句。</p>
<h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GeneratorIterator</span>&lt;<span class="type">T</span>&gt;</span>(</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> block: <span class="keyword">suspend</span> GeneratorScope&lt;T&gt;.(T) -&gt; <span class="built_in">Unit</span>,</span><br><span class="line">        <span class="keyword">override</span> <span class="keyword">val</span> parameter: T</span><br><span class="line">    ) : Iterator&lt;T&gt;, Continuation&lt;Any?&gt;, GeneratorScope&lt;T&gt;() &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="keyword">val</span> context: CoroutineContext = EmptyCoroutineContext</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">var</span> state: State</span><br><span class="line"></span><br><span class="line">        <span class="keyword">init</span> &#123;</span><br><span class="line">            <span class="keyword">val</span> coroutineBlock: <span class="keyword">suspend</span> GeneratorScope&lt;T&gt;.() -&gt; <span class="built_in">Unit</span> = &#123;</span><br><span class="line">                block(parameter)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">val</span> start = coroutineBlock.createCoroutine(<span class="keyword">this</span>, <span class="keyword">this</span>)</span><br><span class="line">            state = State.NotReady(start)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">hasNext</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">            resume()</span><br><span class="line">            <span class="keyword">return</span> state != State.Done</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">next</span><span class="params">()</span></span>: T &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">when</span> (<span class="keyword">val</span> currentState = state) &#123;</span><br><span class="line">                <span class="keyword">is</span> State.NotReady -&gt; &#123;</span><br><span class="line">                    <span class="keyword">return</span> next()</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">is</span> State.Ready&lt;*&gt; -&gt; &#123;</span><br><span class="line">                    state = State.NotReady(currentState.continuation)</span><br><span class="line">                    (currentState <span class="keyword">as</span> State.Ready&lt;T&gt;).nextValue</span><br><span class="line">                &#125;</span><br><span class="line">                State.Done -&gt; <span class="keyword">throw</span> IndexOutOfBoundsException(<span class="string">"No Value Left"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">Any</span>?&gt;)</span></span> &#123;</span><br><span class="line">            state = State.Done</span><br><span class="line">            result.getOrThrow()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">yield</span><span class="params">(value: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">return</span> suspendCoroutine &#123;</span><br><span class="line">                state = <span class="keyword">when</span> (state) &#123;</span><br><span class="line">                    <span class="keyword">is</span> State.NotReady -&gt; State.Ready(it, value)</span><br><span class="line">                    <span class="keyword">is</span> State.Ready&lt;*&gt; -&gt; <span class="keyword">throw</span> IllegalStateException(<span class="string">"Cannot yield a value while ready"</span>)</span><br><span class="line">                    State.Done -&gt; <span class="keyword">throw</span> IllegalStateException(<span class="string">"Cannot yield a value while Done"</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">resume</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">when</span> (<span class="keyword">val</span> currentState = state) &#123;</span><br><span class="line">                <span class="keyword">is</span> State.NotReady -&gt; currentState.continuation.resume(<span class="built_in">Unit</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>主要的遍历，挂起与恢复逻辑便定义在GeneratorIterator中<br>1.调用coroutineBlock.createCoroutine创建协程<br>2.调用continuation.resume启动<br>3.调用传入的block,即yield,挂起函数，并更新状态<br>4.在next方法中返回值，并更新状态<br>5.然后再在hasNext方法中恢复协程，遍历到下一个<br>6.最后在完成时调用resumeWith，状态设置为Done</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.jianshu.com/p/7c851145ee4c" target="_blank" rel="noopener">Python协程</a><br><a href="https://www.jianshu.com/p/f5f0d38e3e44" target="_blank" rel="noopener">带接收者的 lambda表达式</a><br><a href="https://blog.csdn.net/alfredkao/article/details/107592173" target="_blank" rel="noopener">Kotlin Sealed类</a></p>
]]></content>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>android文档之性能优化总结</title>
    <url>/blog/2020/12/android-doc-performace.html</url>
    <content><![CDATA[<blockquote>
<p>原文地址:<a href="https://developer.android.google.cn/topic/performance" target="_blank" rel="noopener">https://developer.android.google.cn/topic/performance</a></p>
</blockquote>
<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>用户对应用具有如下的期望：<br>1.耗电少。<br>2.启动快。<br>3.对用户互动响应迅速。</p>
<h2 id="Android-Vitals"><a href="#Android-Vitals" class="headerlink" title="Android Vitals"></a>Android Vitals</h2><h3 id="ANR"><a href="#ANR" class="headerlink" title="ANR"></a>ANR</h3><p>如果 Android 应用的界面线程处于阻塞状态的时间过长，会触发“应用无响应”(ANR) 错误<br>出现以下任何情况时，系统都会针对您的应用触发 ANR：</p>
<ul>
<li>当您的 Activity 位于前台时，您的应用在 5 秒钟内未响应输入事件或 BroadcastReceiver（如按键或屏幕轻触事件）。</li>
<li>虽然前台没有 Activity，但您的 BroadcastReceiver 用了相当长的时间仍未执行完毕。</li>
</ul>
<p>如果您的应用遇到 ANR 错误，您可以按照本文中的指导来诊断并解决问题。</p>
<h4 id="诊断-ANR"><a href="#诊断-ANR" class="headerlink" title="诊断 ANR"></a>诊断 ANR</h4><p>诊断 ANR 时需要考虑以下几种常见模式：</p>
<p>1.应用在主线程上非常缓慢地执行涉及 I/O 的操作。<br>2.应用在主线程上进行长时间的计算。<br>3.主线程在对另一个进程进行同步 binder 调用，而后者需要很长时间才能返回。<br>4.主线程处于阻塞状态，为发生在另一个线程上的长操作等待同步的块。<br>5.主线程在进程中或通过 binder 调用与另一个线程之间发生死锁。主线程不只是在等待长操作执行完毕，而且处于死锁状态</p>
<p>以下方法可帮助您找出是以上哪种原因造成了 ANR</p>
<h5 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h5><p>使用 StrictMode 有助于您在开发应用时发现主线程上的意外 I/O 操作。您可以在应用级别或 Activity 级别使用 StrictMode。</p>
<h5 id="启用后台-ANR-对话框"><a href="#启用后台-ANR-对话框" class="headerlink" title="启用后台 ANR 对话框"></a>启用后台 ANR 对话框</h5><p>只有在设备的开发者选项中启用了显示所有 ANR 时，Android 才会针对花费过长时间处理广播消息的应用显示 ANR 对话框。因此，系统并不会始终向用户显示后台 ANR 对话框，但应用仍可能会遇到性能问题。</p>
<h5 id="TraceView"><a href="#TraceView" class="headerlink" title="TraceView"></a>TraceView</h5><p>您可以使用 TraceView 在查看用例时获取正在运行的应用的跟踪信息，并找出主线程繁忙的位置。如需了解如何使用 TraceView，请参阅使用 TraceView 和 dmtracedump 分析性能。</p>
<h5 id="拉取跟踪信息文件"><a href="#拉取跟踪信息文件" class="headerlink" title="拉取跟踪信息文件"></a>拉取跟踪信息文件</h5><p>Android 会在遇到 ANR 时存储跟踪信息。在较低的操作系统版本中，设备上只有一个 /data/anr/traces.txt 文件。在较新的操作系统版本中，有多个 /data/anr/anr_* 文件。您可以使用 Android 调试桥 (ADB) 作为根，从设备或模拟器中获取 ANR 跟踪信息：</p>
<h4 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h4><h5 id="主线程上执行速度缓慢的代码"><a href="#主线程上执行速度缓慢的代码" class="headerlink" title="主线程上执行速度缓慢的代码"></a>主线程上执行速度缓慢的代码</h5><p>在您的代码中找出应用的主线程忙碌时间超过 5 秒的位置。在您的应用中查找可疑用例并尝试重现 ANR。</p>
<p>然后通过TraceView来找出</p>
<h5 id="主线程上的-IO"><a href="#主线程上的-IO" class="headerlink" title="主线程上的 IO"></a>主线程上的 IO</h5><p>在主线程上执行 IO 操作是导致主线程上操作速度缓慢的常见原因，主线程上操作速度缓慢会导致 ANR。建议将所有 IO 操作移至工作线程，如上一部分所示。</p>
<p>IO 操作示例包括网络和存储操作。如需了解详情，请参阅执行网络操作和保存数据。</p>
<h5 id="锁争用"><a href="#锁争用" class="headerlink" title="锁争用"></a>锁争用</h5><p>在某些情况下，导致 ANR 的工作并不是直接在应用的主线程上执行。如果某工作线程持有对某项资源的锁，而该资源是主线程完成其工作所必需的，这种情况下就可能会发生 ANR。</p>
<h3 id="崩溃"><a href="#崩溃" class="headerlink" title="崩溃"></a>崩溃</h3><p>未处理的异常或信号导致的意外退出，会使 Android 应用崩溃。使用 Java 编写的应用会在抛出未处理的异常（由 Throwable 类表示）时崩溃。使用原生代码语言编写的应用，会在执行过程中遇到未处理的信号（如 SIGSEGV）时崩溃。</p>
<p>当应用崩溃时，Android 会终止应用的进程并显示一个对话框，告知用户应用已停止</p>
<p>应用并不是只有在前台运行时才会崩溃。任何应用组件，甚至是广播接收器或内容提供程序这类在后台运行的组件，都有可能导致应用崩溃。这些崩溃常常让用户感到困惑，因为他们并没有在使用应用。</p>
<h4 id="诊断崩溃"><a href="#诊断崩溃" class="headerlink" title="诊断崩溃"></a>诊断崩溃</h4><p>解决崩溃问题可能很困难。但是，如果您能确定崩溃的根本原因，就有很可能能够找到解决方法。</p>
<h5 id="读取堆栈轨迹"><a href="#读取堆栈轨迹" class="headerlink" title="读取堆栈轨迹"></a>读取堆栈轨迹</h5><p>解决崩溃的第一步是确定它发生的位置。如果您使用的是 Play 管理中心或 logcat 工具的输出，则可使用报告详细信息中提供的堆栈轨迹。如果您没有堆栈轨迹可用，则应通过手动测试应用或联系受影响的用户在本地再现崩溃，并且要在使用 logcat 的情况下再现。</p>
<h5 id="有关再现崩溃的提示"><a href="#有关再现崩溃的提示" class="headerlink" title="有关再现崩溃的提示"></a>有关再现崩溃的提示</h5><p>再现问题可能无法简单地通过启动模拟器或将设备连接到计算机来实现。开发环境往往具有更多的资源，比如带宽、内存和存储。通过异常类型确定哪项资源不足，或找到 Android 版本、设备类型或应用版本之间的关联。</p>
<h5 id="内存错误"><a href="#内存错误" class="headerlink" title="内存错误"></a>内存错误</h5><p>如果发生了 OutOfMemoryError 异常，您可以首先创建一个内存容量较低的模拟器。图 2 显示了 AVD 管理器设置，您可以通过这些设置控制设备的内存容量。</p>
<h2 id="渲染速度缓慢"><a href="#渲染速度缓慢" class="headerlink" title="渲染速度缓慢"></a>渲染速度缓慢</h2><p>界面呈现是指从应用生成帧并将其显示在屏幕上的动作。要确保用户能够流畅地与您的应用互动，您的应用呈现每帧的时间不应超过 16ms，以达到每秒 60 帧的呈现速度（为什么是60fps？）。如果您的应用存在界面呈现缓慢的问题，系统会不得不跳过一些帧，这会导致用户感觉您的应用不流畅。我们将这种情况称为卡顿。</p>
<h3 id="识别卡顿"><a href="#识别卡顿" class="headerlink" title="识别卡顿"></a>识别卡顿</h3><p>1.目视检查<br>2.Systrace<br>3.自定义性能监控</p>
<h3 id="常见的卡顿来源"><a href="#常见的卡顿来源" class="headerlink" title="常见的卡顿来源"></a>常见的卡顿来源</h3><h4 id="可滚动列表"><a href="#可滚动列表" class="headerlink" title="可滚动列表"></a>可滚动列表</h4><p>ListView 和 RecyclerView （尤其是后者）常用于最易出现卡顿的复杂滚动列表。它们都包含 Systrace 标记，因此您可以使用 Systrace 来判断它们是不是导致应用出现卡顿的因素。请务必传递命令行参数 -a <your-package-name>，以便让 RecyclerView 中的跟踪部分（以及您添加的所有跟踪标记）显示出来。请遵循系统跟踪信息输出中生成的提醒提供的指导（如果有）。在 Systrace 中，您可以点击 RecyclerView 跟踪部分，以查看关于 RecyclerView 正在执行的工作的说明。</your-package-name></p>
<h5 id="RecyclerView：notifyDataSetChanged"><a href="#RecyclerView：notifyDataSetChanged" class="headerlink" title="RecyclerView：notifyDataSetChanged"></a>RecyclerView：notifyDataSetChanged</h5><p>如果您在一个帧中看到 RecyclerView 中的每一项都重新绑定（并因此重新布局和重新绘制），请确保您没有调用 notifyDataSetChanged()、setAdapter(Adapter) 或 swapAdapter(Adapter, boolean) 来进行细微更新。这些方法会向系统表明整个列表内容已更改，并会在 Systrace 中显示为 RV FullInvalidate。应改用 SortedList 或 DiffUtil，以便在内容发生更改或添加了内容时生成最少量的更新。</p>
<h5 id="RecyclerView：嵌套的-RecyclerView"><a href="#RecyclerView：嵌套的-RecyclerView" class="headerlink" title="RecyclerView：嵌套的 RecyclerView"></a>RecyclerView：嵌套的 RecyclerView</h5><p>嵌套 RecyclerView 很常见，对于由水平滚动列表组成的纵向列表（例如 Play 商店主页面上的应用网格），尤其如此。这种方法效果很好，但它也会导致大量来回移动的视图。在首次向下滚动页面时，如果您看到大量内部内容出现扩充，则可能需要检查内部（水平）RecyclerView 之间是否正在共享 RecyclerView.RecycledViewPool。默认情况下，每个 RecyclerView 都将有自己的内容池。然而，在屏幕上同时显示十几个 itemViews 的情况下，如果所有行都显示类型相似的视图，那么当不同的水平列表无法共享 itemViews 时，就会出现问题。</p>
<h5 id="RecyclerView：膨胀过多-创建过程用时过长"><a href="#RecyclerView：膨胀过多-创建过程用时过长" class="headerlink" title="RecyclerView：膨胀过多/创建过程用时过长"></a>RecyclerView：膨胀过多/创建过程用时过长</h5><p>RecyclerView 中的预取功能会在界面线程处于空闲状态时提前执行工作，因此在大多数情况下应该有助于解决膨胀造成的开销问题。如果您在帧中（而不是标记为 RV 预取的部分中）看到了扩充，请确保您是在版本较新的设备上进行测试（预取功能当前仅在 Android 5.0 API 级别 21 及更高版本上受支持），并且使用的是较新版本的支持库。</p>
<p>如果您经常在屏幕上出现新内容时看到导致卡顿的扩充问题，请确认您的视图类型数量没有超出所需要的数量。RecyclerView 内容中的视图类型越少，屏幕上出现新的内容类型时需要进行的扩充就越少。如果可能的话，可以在适当情况下合并视图类型 - 如果不同类型之间只有图标、颜色或文本片段不同，您可以在绑定时进行这项更改，从而避免膨胀（同时减少应用占用的内存）。</p>
<p>如果视图类型看起来合适，请考虑降低膨胀导致的开销。减少不必要的容器和结构视图会有所帮助 – 请考虑使用 ConstraintLayout 构建 itemViews，以便轻松减少结构视图。如果您希望真正进行优化以提升性能，内容的层次结构非常简单，并且您不需要复杂的主题和样式功能，可以考虑自己调用构造函数，但是请注意，通常不值得为此牺牲 XML 的简易性和功能。</p>
<h5 id="RecyclerView：绑定用时过长"><a href="#RecyclerView：绑定用时过长" class="headerlink" title="RecyclerView：绑定用时过长"></a>RecyclerView：绑定用时过长</h5><p>绑定（即 onBindViewHolder(VH, int)）应该非常简单，并且所有内容（最复杂的内容除外）所需的绑定时间都应远远少于 1 毫秒。它应该只从适配器的内部内容数据获取 POJO 内容，并对 ViewHolder 中的视图调用 setter。如果 RV OnBindView 用时很长，请确认在绑定代码中只执行最少量的工作。</p>
<p>如果您使用简单的 POJO 对象将数据保存在适配器中，可以使用数据绑定库完全避免在 onBindViewHolder 中写入绑定代码。</p>
<h5 id="布局性能"><a href="#布局性能" class="headerlink" title="布局性能"></a>布局性能</h5><p>如果 Systrace 表明 Choreographer#doFrame 的布局部分执行的工作过多或者执行工作的频率太高，则意味着您遇到了布局性能问题。应用的布局性能取决于视图层次结构的哪个部分包含会发生改变的布局参数或输入。</p>
<h2 id="进程和线程概览"><a href="#进程和线程概览" class="headerlink" title="进程和线程概览"></a>进程和线程概览</h2><p>当应用组件启动且该应用未运行任何其他组件时，Android 系统会使用单个执行线程为应用启动新的 Linux 进程。默认情况下，同一应用的所有组件会在相同的进程和线程（称为“主”线程）中运行。如果某个应用组件启动且该应用已存在进程（因为存在该应用的其他组件），则该组件会在此进程内启动并使用相同的执行线程。但是，您可以安排应用中的其他组件在单独的进程中运行，并为任何进程创建额外的线程。</p>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>默认情况下，同一应用的所有组件均在相同的进程中运行，且大多数应用都不应改变这一点。但是，如果您发现需要控制某个组件所属的进程，则可在清单文件中执行此操作。</p>
<p>各类组件元素（<activity>、<service>、<receiver> 和 <provider>）的清单文件条目均支持 android:process 属性，此属性可指定该组件应在哪个进程中运行。您可以设置此属性，使每个组件均在各自的进程中运行，或者使某些组件共享一个进程，而其他组件则不共享。您也可设置 android:process，以便不同应用的组件在同一进程中运行，但前提是这些应用共享相同的 Linux 用户 ID 并使用相同的证书进行签署。</provider></receiver></service></activity></p>
<p>此外，<application> 元素还支持 android:process 属性，用来设置适用于所有组件的默认值。</application></p>
<p>当内存不足，而其他更急于为用户提供服务的进程又需要内存时，Android 可能会决定在某一时刻关闭某个进程。正因如此，系统会销毁在被终止进程中运行的应用组件。当这些组件需再次运行时，系统将为其重启进程。</p>
<p>决定终止哪个进程时，Android 系统会权衡其对用户的相对重要性。例如，相较于托管可见 Activity 的进程而言，系统更有可能关闭托管屏幕上不再可见的 Activity 的进程。因此，是否终止某个进程的决定取决于该进程中所运行组件的状态。</p>
<p>如需详细了解进程生命周期及其与应用状态的关系，请参阅进程和应用生命周期。</p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>启动应用时，系统会为该应用创建一个称为“main”（主线程）的执行线程。此线程非常重要，因为其负责将事件分派给相应的界面微件，其中包括绘图事件。此外，应用与 Android 界面工具包组件（来自 android.widget 和 android.view 软件包的组件）也几乎都在该线程中进行交互。因此，主线程有时也称为界面线程。但在一些特殊情况下，应用的主线程可能并非其界面线程，相关详情请参阅线程注解。</p>
<p>系统不会为每个组件实例创建单独的线程。在同一进程中运行的所有组件均在界面线程中进行实例化，并且对每个组件的系统调用均由该线程进行分派。因此，响应系统回调的方法（例如，报告用户操作的 onKeyDown() 或生命周期回调方法）始终在进程的界面线程中运行。</p>
<h2 id="缩减应用大小"><a href="#缩减应用大小" class="headerlink" title="缩减应用大小"></a>缩减应用大小</h2><h3 id="使用-Android-Size-Analyzer"><a href="#使用-Android-Size-Analyzer" class="headerlink" title="使用 Android Size Analyzer"></a>使用 Android Size Analyzer</h3><p>您可以使用 Android Studio 中的插件市场下载 Android Size Analyzer 插件，如图 1 所示。要打开插件市场并安装该插件，请按以下步骤操作：</p>
<p>依次选择 File &gt; Settings（或在 Mac 上，依次选择 Android Studio &gt; Preferences）。<br>选择左侧面板中的 Plugins 部分。<br>点击 Marketplace 标签。<br>搜索“Android Size Analyzer”插件。<br>点击分析器插件的 Install 按钮。</p>
<h3 id="压缩-PNG-文件"><a href="#压缩-PNG-文件" class="headerlink" title="压缩 PNG 文件"></a>压缩 PNG 文件</h3><p>aapt 工具可以在编译过程中通过无损压缩来优化放置在 res/drawable/ 中的图片资源。例如，aapt 工具可以通过调色板将不需要超过 256 种颜色的真彩色 PNG 转换为 8 位 PNG。这样做会生成质量相同但内存占用量更小的图片。</p>
<h3 id="使用-WebP-文件格式"><a href="#使用-WebP-文件格式" class="headerlink" title="使用 WebP 文件格式"></a>使用 WebP 文件格式</h3><p>如果以 Android 3.2（API 级别 13）及更高版本为目标，您还可以使用 WebP 文件格式的图片（而不是使用 PNG 或 JPEG 文件）。WebP 格式提供有损压缩（如 JPEG）以及透明度（如 PNG），不过与 JPEG 或 PNG 相比，这种格式可以提供更好的压缩效果。</p>
<h3 id="使用矢量图形"><a href="#使用矢量图形" class="headerlink" title="使用矢量图形"></a>使用矢量图形</h3><p>您可以使用矢量图形创建与分辨率无关的图标和其他可伸缩媒体。使用这些图形可以极大地减少 APK 占用的空间。 矢量图片在 Android 中以 VectorDrawable 对象的形式表示。借助 VectorDrawable 对象，100 字节的文件可以生成与屏幕大小相同的清晰图片。</p>
<p>不过，系统渲染每个 VectorDrawable 对象需要花费大量时间，而较大的图片则需要更长的时间才能显示在屏幕上。因此，请考虑仅在显示小图片时使用这些矢量图形。</p>
<h2 id="内存管理概览"><a href="#内存管理概览" class="headerlink" title="内存管理概览"></a>内存管理概览</h2><p>Android 运行时 (ART) 和 Dalvik 虚拟机使用分页和内存映射来管理内存。这意味着应用修改的任何内存，无论修改的方式是分配新对象还是轻触内存映射的页面，都会一直驻留在 RAM 中，并且无法换出。要从应用中释放内存，只能释放应用保留的对象引用，使内存可供垃圾回收器回收。这种情况有一个例外：对于任何未经修改的内存映射文件（如代码），如果系统想要在其他位置使用其内存，可将其从 RAM 中换出。</p>
<h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p>ART 或 Dalvik 虚拟机之类的受管内存环境会跟踪每次内存分配。一旦确定程序不再使用某块内存，它就会将该内存重新释放到堆中，无需程序员进行任何干预。这种回收受管内存环境中的未使用内存的机制称为“垃圾回收”。垃圾回收有两个目标：在程序中查找将来无法访问的数据对象，并回收这些对象使用的资源。</p>
<p>Android 的内存堆是分代的，这意味着它会根据分配对象的预期寿命和大小跟踪不同的分配存储分区。例如，最近分配的对象属于“新生代”。当某个对象保持活动状态达足够长的时间时，可将其提升为较老代，然后是永久代。</p>
<p>堆的每一代对相应对象可占用的内存量都有其自身的专用上限。每当一代开始填满时，系统便会执行垃圾回收事件以释放内存。垃圾回收的持续时间取决于它回收的是哪一代对象以及每一代有多少个活动对象。</p>
<p>尽管垃圾回收速度非常快，但仍会影响应用的性能。通常情况下，您无法从代码中控制何时发生垃圾回收事件。系统有一套专门确定何时执行垃圾回收的标准。当条件满足时，系统会停止执行进程并开始垃圾回收。如果在动画或音乐播放等密集型处理循环过程中发生垃圾回收，则可能会增加处理时间，进而可能会导致应用中的代码执行超出建议的 16ms 阈值，无法实现高效、流畅的帧渲染。</p>
<p>此外，您的代码流执行的各种工作可能迫使垃圾回收事件发生得更频繁或导致其持续时间超过正常范围。 例如，如果您在 Alpha 混合动画的每一帧期间，在 for 循环的最内层分配多个对象，则可能会使内存堆受到大量对象的影响。在这种情况下，垃圾回收器会执行多个垃圾回收事件，并可能降低应用的性能。</p>
<h3 id="谨慎使用服务"><a href="#谨慎使用服务" class="headerlink" title="谨慎使用服务"></a>谨慎使用服务</h3><p>在不需要某项服务时让其保持运行状态，是 Android 应用可能犯下的最严重的内存管理错误之一。如果您的应用需要某项服务在后台执行工作，请不要让其保持运行状态，除非其需要运行作业。请注意在服务完成任务后使其停止运行。否则，您可能会在无意中导致内存泄漏。</p>
<p>在您启动某项服务后，系统更倾向于让此服务的进程始终保持运行状态。这种行为会导致服务进程代价十分高昂，因为一旦服务使用了某部分 RAM，那么这部分 RAM 就不再可供其他进程使用。这会减少系统可以在 LRU 缓存中保留的缓存进程数量，从而降低应用切换效率。当内存紧张，并且系统无法维护足够的进程以托管当前运行的所有服务时，这甚至可能导致系统出现抖动。</p>
<p>您通常应该避免使用持久性服务，因为它们会对可用内存提出持续性的要求。我们建议您采用 JobSchedulerJobScheduler 等替代实现方式。要详细了解如何使用 JobScheduler 调度后台进程，请参阅后台优化。</p>
<p>如果您必须使用某项服务，则限制此服务的生命周期的最佳方式是使用 IntentService，它会在处理完启动它的 intent 后立即自行结束。有关详情，请参阅在后台服务中运行。</p>
<h3 id="使用经过优化的数据容器"><a href="#使用经过优化的数据容器" class="headerlink" title="使用经过优化的数据容器"></a>使用经过优化的数据容器</h3><p>编程语言所提供的部分类并未针对移动设备做出优化。例如，常规 HashMap 实现的内存效率可能十分低下，因为每个映射都需要分别对应一个单独的条目对象。</p>
<p>Android 框架包含几个经过优化的数据容器，包括 SparseArray、SparseBooleanArray 和 LongSparseArray。 例如，SparseArray 类的效率更高，因为它们可以避免系统需要对键（有时还对值）进行自动装箱（这会为每个条目分别再创建 1-2 个对象）。</p>
<p>如果需要，您可以随时切换到原始数组以获得非常精简的数据结构。</p>
<h3 id="避免内存抖动"><a href="#避免内存抖动" class="headerlink" title="避免内存抖动"></a>避免内存抖动</h3><p>如前所述，垃圾回收事件通常不会影响应用的性能。不过，如果在短时间内发生许多垃圾回收事件，就可能会快速耗尽帧时间。系统花在垃圾回收上的时间越多，能够花在呈现或流式传输音频等其他任务上的时间就越少。</p>
<p>通常，“内存抖动”可能会导致出现大量的垃圾回收事件。实际上，内存抖动可以说明在给定时间内出现的已分配临时对象的数量。</p>
<p>例如，您可以在 for 循环中分配多个临时对象。或者，您也可以在视图的 onDraw() 函数中创建新的 Paint 或 Bitmap 对象。在这两种情况下，应用都会快速创建大量对象。这些操作可以快速消耗新生代 (young generation) 区域中的所有可用内存，从而迫使垃圾回收事件发生。</p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>ARTS打卡7</title>
    <url>/blog/2020/12/arts-way-seven.html</url>
    <content><![CDATA[<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><blockquote>
<p><a href="https://leetcode-cn.com/contest/weekly-contest-218/problems/goal-parser-interpretation/" target="_blank" rel="noopener">5617. 设计 Goal 解析器</a><br>请你设计一个可以解释字符串 command 的 Goal 解析器 。command 由 “G”、”()” 和/或 “(al)” 按某种顺序组成。Goal 解析器会将 “G” 解释为字符串 “G”、”()” 解释为字符串 “o” ，”(al)” 解释为字符串 “al” 。然后，按原顺序将经解释得到的字符串连接成一个字符串。<br>给你字符串 command ，返回 Goal 解析器 对 command 的解释结果。</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">interpret</span><span class="params">(command: <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">val</span> stack = Stack&lt;<span class="built_in">Char</span>&gt;()</span><br><span class="line">        <span class="keyword">val</span> result = StringBuilder()</span><br><span class="line">        command.forEach &#123;</span><br><span class="line">            <span class="keyword">if</span> (it == <span class="string">'G'</span>)&#123;</span><br><span class="line">                result.append(it)</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                stack.push(it)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (it == <span class="string">')'</span>)&#123;</span><br><span class="line">                <span class="keyword">val</span> item = StringBuilder()</span><br><span class="line">                <span class="keyword">while</span> (stack.isNotEmpty())&#123;</span><br><span class="line">                    item.append(stack.pop())</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (item.toString() == <span class="string">")("</span>)&#123;</span><br><span class="line">                    result.append(<span class="string">"o"</span>)</span><br><span class="line">                &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                    result.append(<span class="string">"al"</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.toString()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p><a href="https://developer.android.google.cn/topic/libraries/view-binding/migration" target="_blank" rel="noopener">https://developer.android.google.cn/topic/libraries/view-binding/migration</a><br>Android Kotlin Extensions 插件最初由 JetBrains 开发,其中Synthetic 视图 : 可以将调用 findViewById 替换为使用 kotlinx.android.synthetic 进行 UI 交互。<br>极大的方便了用户的使用<br>但 Kotlin synthetic 却存在一些弊端:</p>
<ul>
<li>污染全局命名空间</li>
<li>不能暴露可空性信息</li>
<li>仅支持 Kotlin 代码</li>
</ul>
<p>因此android官方将弃用Synthetic视图<br>弃用期随着 Kotlin 1.4.20 的发布正式开始。android-kotlin-extensions 将继续保留至少一年时间，但在 2021 年 9 月或之后的 Kotlin 版本中将被移除<br>详情可见:<a href="https://juejin.cn/post/6902226860080529421" target="_blank" rel="noopener">Kotlin Android Extensions 的未来计划</a></p>
<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><h3 id="解决TabLayout在平板上无法全屏的问题"><a href="#解决TabLayout在平板上无法全屏的问题" class="headerlink" title="解决TabLayout在平板上无法全屏的问题"></a>解决TabLayout在平板上无法全屏的问题</h3><p>​​具体的参数设置如下：</p>
<ol>
<li>宽度一定要设置成 match_parent, 即 android:layout_width=”match_parent”</li>
<li>tabGravity设置成fill, 即  app:tabGravity=”fill”</li>
<li>tabMaxWidth设置成 0dp, 即 app:tabMaxWidth=”0dp”</li>
<li>tabMode设置成fixed, 即 app:tabMode=”fixed”<br>完成以上四步就可以铺满整个屏幕宽度了</li>
</ol>
<p>实际测试发现只需要添加tabGravity即可<br>详情可见：<a href="https://blog.csdn.net/qq_29742677/article/details/84339690" target="_blank" rel="noopener">Android TabLayout宽度在平板上未铺满解决方案</a></p>
<h3 id="PopWindow的版本兼容问题"><a href="#PopWindow的版本兼容问题" class="headerlink" title="PopWindow的版本兼容问题"></a>PopWindow的版本兼容问题</h3><p>popWindow在android7.0以上及之下的表现行为不太一样<br>主流解决方法大概如下：<br>①重写showAsDropDown()，以24为界限，区别对待；<br>②调用show的时候，SDK&gt;24的时用showAtLocation（）替代showAsDropDown()；</p>
<p>详情可见：<br><a href="https://blog.csdn.net/iblade/article/details/100073141" target="_blank" rel="noopener">PopupWindow显示位置错乱，真正的终极方案。</a><br><a href="https://blog.csdn.net/alwaysGoalong/article/details/80455427" target="_blank" rel="noopener">Android 7.0中PopupWindow设置位置不生效解决方法（亲测可用）</a></p>
<h3 id="自定义drawable复用问题"><a href="#自定义drawable复用问题" class="headerlink" title="自定义drawable复用问题"></a>自定义drawable复用问题</h3><p>在我们使用一些自定义drawable时，比如圆角矩形时，常常只会是背景颜色与圆角角度不一样<br>而这样就重复需要定义一些drawable文件，而这就会带来类爆炸</p>
<p>一个解决drawable类爆炸的解决方法是使用GradientDrawable，结合kotlin扩展，可以方便的解决自定义drawable复用的问题<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> View.<span class="title">setRoundRectBg</span><span class="params">(color: <span class="type">Int</span> = Color.WHITE, cornerRadius: <span class="type">Int</span> = <span class="number">15.</span>dp)</span></span> &#123;</span><br><span class="line">    background = GradientDrawable().apply &#123;</span><br><span class="line">        setColor(color)</span><br><span class="line">        setCornerRadius(cornerRadius.toFloat())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>详情可见：<a href="https://mp.weixin.qq.com/s/yJM64wm07S3dqdvMvtaHcA" target="_blank" rel="noopener">无需自定义 View，巧妙利用 xml 属性，避免 drawable 泛滥</a></p>
<h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p><a href="https://shenzhen2017.github.io/blog/2020/12/2020-sum-up.html">【2020年终总结】程序员的三年之痒</a></p>
]]></content>
      <tags>
        <tag>ARTS</tag>
      </tags>
  </entry>
  <entry>
    <title>ARTS打卡6</title>
    <url>/blog/2020/11/arts-way-six.html</url>
    <content><![CDATA[<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><blockquote>
<p><a href="https://leetcode-cn.com/contest/weekly-contest-217/problems/richest-customer-wealth/" target="_blank" rel="noopener">5613. 最富有客户的资产总量</a><br>给你一个 m x n 的整数网格 accounts ，其中 accounts[i][j] 是第 i​​​​​​​​​​​​ 位客户在第 j 家银行托管的资产数量。返回最富有客户所拥有的 资产总量 。<br>客户的 资产总量 就是他们在各家银行托管的资产数量之和。最富有客户就是 资产总量 最大的客户。</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">maximumWealth</span><span class="params">(accounts: <span class="type">Array</span>&lt;<span class="type">IntArray</span>&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> max = <span class="number">0</span></span><br><span class="line">        accounts.forEach &#123;</span><br><span class="line">            max = maxOf(max,it.sum())</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p><a href="https://proandroiddev.com/should-we-choose-kotlins-stateflow-or-sharedflow-to-substitute-for-android-s-livedata-2d69f2bd6fa5" target="_blank" rel="noopener">Substituting Android’s LiveData: StateFlow or SharedFlow?</a><br>本文主要讲述了使用sharedFlow和stateFlow替换liveData的一些尝试</p>
<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><h3 id="kotin接口支持SAM转换"><a href="#kotin接口支持SAM转换" class="headerlink" title="kotin接口支持SAM转换"></a>kotin接口支持SAM转换</h3><p>什么是SAM转换？可能有的同学还不太了解，这里先科普一下：</p>
<p>SAM 转换，即 Single Abstract Method Conversions，就是对于只有单个非默认抽象方法接口的转换 —— 对于符合这个条件的接口（称之为 SAM Type ），在 Kotlin 中可以直接用 Lambda 来表示 —— 当然前提是 Lambda 的所表示函数类型能够跟接口的中方法相匹配。</p>
<p>在Kotlin1.4之前，Kotlin是不支持Kotlin的SAM转换的，可以支持Java SAM转换，官方给出的的解释是：是 Kotlin 本身已经有了函数类型和高阶函数，不需要在去SAM转化。 这个解释开发者并不买账，如果你用过Java Lambda和Fuction Interface。当你切换到Kotlin时，就会很懵逼。看来Kotlin是意识到了这个，或者是看到开发者的反馈，终于支持了。</p>
<p>在1.4之前，只能传递一个对象，是不支持Kotlin SAM的，而在1.4之后，可以支持Kotlin SAM,但是用法有一丢丢变化。interface需要使用fun关键字声明。使用fun关键字标记接口后，只要将此类接口作为参数，就可以将lambda作为参数传递。</p>
<p>详情可见：<a href="https://juejin.cn/post/6844904132449402887" target="_blank" rel="noopener">Kotlin1.4-M1发布，终于支持Kotlin interface SAM转换了！</a></p>
<h3 id="消除Obsever警告"><a href="#消除Obsever警告" class="headerlink" title="消除Obsever警告"></a>消除Obsever警告</h3><p>在升级到kotlin1.4之后，会有警告Live Data: Candidate resolution will be changed soon<br>解决方法：去除引用import androidx.lifecycle.observe即可<br>原因：kotlin1.4之后支持SAM转换，不再需要自定义的扩展，如下所示：<br><figure class="highlight plain"><figcaption><span>inline fun <t> LiveData<t>.observe(</t></t></span></figcaption><table><tr><td class="code"><pre><span class="line">    owner: LifecycleOwner,</span><br><span class="line">    crossinline onChanged: (T) -&gt; Unit</span><br><span class="line">): Observer&lt;T&gt; &#123;</span><br><span class="line">    val wrappedObserver = Observer&lt;T&gt; &#123; t -&gt; onChanged.invoke(t) &#125;</span><br><span class="line">    observe(owner, wrappedObserver)</span><br><span class="line">    return wrappedObserver</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>详情可见：<a href="https://stackoverflow.com/questions/64045082/live-data-candidate-resolution-will-be-changed-soon" target="_blank" rel="noopener">https://stackoverflow.com/questions/64045082/live-data-candidate-resolution-will-be-changed-soon</a></p>
<h3 id="kotlin委托属性"><a href="#kotlin委托属性" class="headerlink" title="kotlin委托属性"></a>kotlin委托属性</h3><p>从 Kotlin 1.4 开始，一个属性可以把它的 getter 与 setter 委托给另一个属性。这种委托对于顶层和类的属性（成员和扩展）都可用。该委托属性可以为：<br>1.顶层属性<br>2.同一个类的成员或扩展属性<br>3.另一个类的成员或扩展属性</p>
<p>为将一个属性委托给另一个属性，应在委托名称中使用恰当的 :: 限定符，例如，this::delegate 或 MyClass::delegate<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span>(<span class="keyword">var</span> memberInt: <span class="built_in">Int</span>, <span class="keyword">val</span> anotherClassInstance: ClassWithDelegate) &#123;</span><br><span class="line">    <span class="keyword">var</span> delegatedToMember: <span class="built_in">Int</span> <span class="keyword">by</span> <span class="keyword">this</span>::memberInt</span><br><span class="line">    <span class="keyword">var</span> delegatedToTopLevel: <span class="built_in">Int</span> <span class="keyword">by</span> ::topLevelInt</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">val</span> delegatedToAnotherClass: <span class="built_in">Int</span> <span class="keyword">by</span> anotherClassInstance::anotherClassInt</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> MyClass.extDelegated: <span class="built_in">Int</span> <span class="keyword">by</span> ::topLevelInt</span><br></pre></td></tr></table></figure></p>
<p>这是很有用的，例如，当想要以一种向后兼容的方式重命名一个属性的时候：引入一个新的属性、 使用 @Deprecated 注解来注解旧的属性、并委托其实现。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> newName: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">   <span class="meta">@Deprecated(<span class="meta-string">"Use 'newName' instead"</span>, ReplaceWith(<span class="meta-string">"newName"</span>)</span>)</span><br><span class="line">   <span class="keyword">var</span> oldName: <span class="built_in">Int</span> <span class="keyword">by</span> <span class="keyword">this</span>::newName</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">val</span> myClass = MyClass()</span><br><span class="line">   <span class="comment">// 通知：'oldName: Int' is deprecated.</span></span><br><span class="line">   <span class="comment">// Use 'newName' instead</span></span><br><span class="line">   myClass.oldName = <span class="number">42</span></span><br><span class="line">   println(myClass.newName) <span class="comment">// 42</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>详情可见：<a href="https://www.kotlincn.net/docs/reference/delegated-properties.html" target="_blank" rel="noopener">kotlin委托属性</a></p>
<h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p>本周主要总结了kotlin协程的一些基本概念<br><a href="https://shenzhen2017.github.io/blog/2020/11/kotlin-coroutine-start.html">协程初步</a></p>
]]></content>
      <tags>
        <tag>ARTS</tag>
      </tags>
  </entry>
  <entry>
    <title>ARTS打卡10</title>
    <url>/blog/2020/12/arts-way-ten.html</url>
    <content><![CDATA[<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><blockquote>
<p><a href="https://leetcode-cn.com/contest/weekly-contest-221/problems/determine-if-string-halves-are-alike/" target="_blank" rel="noopener">5637. 判断字符串的两半是否相似</a><br>给你一个偶数长度的字符串 s 。将其拆分成长度相同的两半，前一半为 a ，后一半为 b 。<br>两个字符串 相似 的前提是它们都含有相同数目的元音（’a’，’e’，’i’，’o’，’u’，’A’，’E’，’I’，’O’，’U’）。注意，s 可能同时含有大写和小写字母。<br>如果 a 和 b 相似，返回 true ；否则，返回 false 。</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">halvesAreAlike</span><span class="params">(s: <span class="type">String</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> yuanYinCount(s.substring(<span class="number">0</span>,s.length/<span class="number">2</span>)) == yuanYinCount(s.substring(s.length/<span class="number">2</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">yuanYinCount</span><span class="params">(s:<span class="type">String</span>)</span></span>:<span class="built_in">Int</span>&#123;</span><br><span class="line">        <span class="keyword">val</span> list = mutableListOf&lt;<span class="built_in">Char</span>&gt;(<span class="string">'a'</span>,<span class="string">'e'</span>,<span class="string">'i'</span>,<span class="string">'o'</span>,<span class="string">'u'</span>,<span class="string">'A'</span>,<span class="string">'E'</span>,<span class="string">'I'</span>,<span class="string">'O'</span>,<span class="string">'U'</span>)</span><br><span class="line">        <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">        s.forEach &#123;</span><br><span class="line">            <span class="keyword">if</span> (list.contains(it))&#123;</span><br><span class="line">                count++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p><a href="https://medium.com/@gilgoldzweig/how-to-perfect-android-animations-using-motionlayout-286cfa0f4f13" target="_blank" rel="noopener">https://medium.com/@gilgoldzweig/how-to-perfect-android-animations-using-motionlayout-286cfa0f4f13</a><br>本文主要是讲解了一些MotionLayout的例子与实例</p>
<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><h3 id="Lottie预览"><a href="#Lottie预览" class="headerlink" title="Lottie预览"></a>Lottie预览</h3><p>lottie图是Airbnb开源的一种动画，不能直观的察看效果，如果出现问题，很难判定到底是资源问题，还是代码问题，因此需要有一个简单的方法来预览lottie图效果<br>我们可以在本机上，使用 Python 搭建一个最简单的 HTTP 服务器。在本地动画 ZIP 包文件的文件夹下，执行下面的命令。<br><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">python -m SimpleHttpServer <span class="number">8099</span></span><br></pre></td></tr></table></figure></p>
<p>该命令会在本机上搭建一个 HTTP 服务器，监听 8099 端口<br>然后再用lottie官方app打开相应地址即可预览.</p>
<p>详情可见：<a href="https://toutiao.io/posts/ml787h/preview" target="_blank" rel="noopener">https://toutiao.io/posts/ml787h/preview</a></p>
<h3 id="9图四条黑边的意义"><a href="#9图四条黑边的意义" class="headerlink" title=".9图四条黑边的意义"></a>.9图四条黑边的意义</h3><p>顶部：在水平拉伸的时候，保持其他位置不动，只在这个点的区域做无限的延伸</p>
<p>左边：在竖直拉伸的时候，保持其他位置不动，只在这个点的区域做无限的延伸</p>
<p>底部：在水平拉伸的时候，指定图片里的内容显示的区域</p>
<p>右边：在竖直拉伸的时候，指定图片里的内容显示的区域</p>
<p>详情可见:<a href="https://blog.csdn.net/sunbinkang/article/details/77331718" target="_blank" rel="noopener">https://blog.csdn.net/sunbinkang/article/details/77331718</a></p>
<h3 id="kotlin-fold与reduce使用"><a href="#kotlin-fold与reduce使用" class="headerlink" title="kotlin fold与reduce使用"></a>kotlin fold与reduce使用</h3><h4 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> index: Array&lt;<span class="built_in">Int</span>&gt; = arrayOf(<span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">10</span>, <span class="number">3</span>, <span class="number">11</span>, <span class="number">5</span>, <span class="number">12</span>)</span><br><span class="line">  <span class="keyword">val</span> index2: Array&lt;<span class="built_in">Int</span>&gt; = arrayOf(<span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * reduce函数：累加函数，第一个参数是用来叠加的返回值，第二个参数是本次循环中列表的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">        println(<span class="string">"使用 reduce  求总和"</span>) <span class="comment">//使用 reduce  求总和</span></span><br><span class="line">        println(index.reduce &#123; acc, i -&gt; acc + i &#125;)</span><br><span class="line">        println(<span class="string">"使用 reduce  求积"</span>) <span class="comment">//使用 reduce  求积</span></span><br><span class="line">        println(index2.reduce &#123; acc, i -&gt; acc * i &#125;)  <span class="comment">//acc是累加的返回值，i是当前遍历列表中的值</span></span><br><span class="line"> </span><br><span class="line">    使用 reduce  求总和</span><br><span class="line">    System.<span class="keyword">out</span>: <span class="number">86</span></span><br><span class="line">    使用 reduce  求积</span><br><span class="line">    <span class="number">60</span></span><br></pre></td></tr></table></figure>
<h4 id="fold"><a href="#fold" class="headerlink" title="fold"></a>fold</h4><p>In kotlin, “fold” is same in Javascript’s reduce. “fold” has initial value</p>
<p>“reduce” in kotlin, you don’t give initial value<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> colors = listOf(<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>, <span class="string">"black"</span>)</span><br><span class="line"></span><br><span class="line">    println(colors.reduce &#123;</span><br><span class="line">        acc, curr -&gt; <span class="string">"<span class="variable">$acc</span>, <span class="variable">$curr</span>"</span></span><br><span class="line">    &#125;) <span class="comment">// red, blue, green, black</span></span><br><span class="line"></span><br><span class="line">    println(colors.map &#123;it.length&#125;.fold(<span class="number">0</span>) &#123;</span><br><span class="line">            acc, curr -&gt; acc + curr</span><br><span class="line">    &#125;) <span class="comment">// 17</span></span><br></pre></td></tr></table></figure></p>
<h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2>]]></content>
      <tags>
        <tag>ARTS</tag>
      </tags>
  </entry>
  <entry>
    <title>【2020年终总结】程序员的三年之痒</title>
    <url>/blog/2020/12/2020-sum-up.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对程序员来说，三年是个坎。<br>三年时间，足以让一个刚出校门的年轻人成长为一个真正的打工人。<br>三年时间，可以积累一定的工作经验，拥有一定的技术成长。<br>三年时间，不算太长也不算太短，是一个跳槽的好时机，毕竟有不少工作都是要求3年以上经验。   </p>
<p>这大概就是程序员三年之痒的来源~   </p>
<h2 id="2020的收获"><a href="#2020的收获" class="headerlink" title="2020的收获"></a>2020的收获</h2><p>2020是一个神奇的一年，发生了许多大事，但回到个人身上也只是一件一件小事。<br>一件一件小事本没有什么意义，但只要注意积累，重复练习，积少成多，应该也会有一定的价值~<br>下面总结一些2020年的一些小收获   </p>
<ul>
<li>完成了第一次跳槽</li>
<li>掘金升级到了Lv2,阅读量3万+</li>
<li>拿到了掘金搪瓷杯和卫衣</li>
<li>有两篇文章被鸿洋大神转载了</li>
<li>坚持了ARTS打卡</li>
<li>坚持了每周的总结与下周规划</li>
</ul>
<h2 id="2021的展望"><a href="#2021的展望" class="headerlink" title="2021的展望"></a>2021的展望</h2><p>2021,新的一年，新的开始<br>下面列出2021的一些目标与展望        </p>
<ul>
<li>掘金升级到LV4</li>
<li>做一个100以上star的Github开源项目</li>
<li>读几本计算机原理，计算机网络，数据结构等基础领域的书</li>
<li>掌握flutter的使用与相关原理</li>
<li>最后，希望以上都能实现</li>
</ul>
<h2 id="一些面试资源"><a href="#一些面试资源" class="headerlink" title="一些面试资源"></a>一些面试资源</h2><p>今年完成了第一次跳槽，积累了一些面试相关的资源，在这里总结一下，希望对读者有用。   </p>
<h3 id="简历"><a href="#简历" class="headerlink" title="简历"></a>简历</h3><p>首先是简历，一般找一个模板，填写掌握的技能和项目经历即可。<br>github上有一个不错的模板，详情可见：<a href="https://github.com/CyC2018/Markdown-Resume" target="_blank" rel="noopener">https://github.com/CyC2018/Markdown-Resume</a><br>项目clone后，个性Resuem.md即可，然后导出为pdf文件。<br>简历建议长度为2页，太长太短都不好。<br>建议用掌握与熟练掌握取代了解与精通。    </p>
<h3 id="刷题"><a href="#刷题" class="headerlink" title="刷题"></a>刷题</h3><p>算法题可以说是现在找工作必刷的了。不过根据我面试的经验，算法题总得来说问的还是比较少，还有一些公司是基本不问算法的。<br>当然如果碰到字节，快手这种每轮都问算法的公司，如果因为算法题拿不到offer就很可惜了。<br>算法题就好像高考语文的古诗词默写一样，分不多，但丢了就很可惜了。<br>根据我的经验，大概刷了，掌握100道题就足以应付面试了。<br>当然完全掌握需要重复练习，不是刷了一遍就可以的。<br>这里推荐一下极客时间上覃超的五遍刷题法    </p>
<h4 id="五遍刷题法"><a href="#五遍刷题法" class="headerlink" title="五遍刷题法"></a>五遍刷题法</h4><p>1.第一遍，直接看解法<br>多解法，比较解法优劣，默写好的解法<br>2.第二遍，打开leetcode，直接开始写<br>多种解法比较，调优<br>3.第三遍，过一天之后，再重复做题<br>4.第四遍，过了一周，再来反复练<br>5.第五遍，面试前一周，恢复性训练      </p>
<p>极客时间上每周四覃超老师都会直播面试，比较精彩，大家可以去看看。当然也没有必要去买算法课，看一看直播，了解下刷题的思路即可。<br>通过以上方法重复练习，大概刷100题就足以应付面试，如果每天刷3道，大概准备一个月即可    </p>
<h3 id="题库"><a href="#题库" class="headerlink" title="题库"></a>题库</h3><p>刷题也要注意，不要一题一题刷，比如Leetcode的每日一题<br>建议按知识点分类，这样比较方便重复练习与知识点掌握<br>在知识点刷过一遍后，也可以按照公司分类或者LeetCode热题100刷，一般公司出算法题也是有题库的<br>下面推荐几个题库供大家使用</p>
<h4 id="按知识点分类"><a href="#按知识点分类" class="headerlink" title="按知识点分类"></a>按知识点分类</h4><p><a href="https://github.com/yuanguangxin/LeetCode" target="_blank" rel="noopener">https://github.com/yuanguangxin/LeetCode</a><br><a href="https://github.com/zhangyixing1007/leetcode" target="_blank" rel="noopener">https://github.com/zhangyixing1007/leetcode</a>     </p>
<h4 id="按公司分类"><a href="#按公司分类" class="headerlink" title="按公司分类"></a>按公司分类</h4><p><a href="https://github.com/afatcoder/LeetcodeTop" target="_blank" rel="noopener">https://github.com/afatcoder/LeetcodeTop</a>    </p>
<h4 id="热题100"><a href="#热题100" class="headerlink" title="热题100"></a>热题100</h4><p><a href="https://zhuanlan.zhihu.com/p/84230862" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/84230862</a>    </p>
<h3 id="一些高质量面经总结"><a href="#一些高质量面经总结" class="headerlink" title="一些高质量面经总结"></a>一些高质量面经总结</h3><p><a href="https://juejin.cn/post/6876968255597051917" target="_blank" rel="noopener">三年经验Android开发面经总结</a><br><a href="https://github.com/Moosphan/Android-Daily-Interview" target="_blank" rel="noopener">Android面试每日一题,内容很多，包罗万象</a><br><a href="https://carlwe.com/2019/12/07/Android%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86%E9%94%A6/" target="_blank" rel="noopener">Android面试题集锦</a><br><a href="https://juejin.cn/post/6844904155153170439" target="_blank" rel="noopener">这些年，我所经历的所有面试｜写给正在求职的 Androider</a>    </p>
<h2 id="一些学习方法"><a href="#一些学习方法" class="headerlink" title="一些学习方法"></a>一些学习方法</h2><p>如上文所说，坚持是一件很难的事。正因为如此，我们需要通过一些方法来辅助我们。<br>提高放弃的成本，增强坚持下去的成就感，提高最终坚持下去的概率。   </p>
<h3 id="ARTS打卡"><a href="#ARTS打卡" class="headerlink" title="ARTS打卡"></a>ARTS打卡</h3><p>在开始ARTS打卡之前，先介绍一下什么是ARTS<br>ARTS 源于极客时间《左耳听风》专栏组织的一个学习打卡活动，四个字母对应着四个行动准则：     </p>
<ul>
<li>Algorithm：每周至少做一个 leetcode 的算法题</li>
<li>Review: 阅读并点评一篇英文技术文章</li>
<li>Tip：学习至少一个技术技巧</li>
<li>Share：[撰写并]分享一篇有观点和思考的技术文章<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog8/p1.png" alt></li>
</ul>
<p>ARTS打卡将坚持拆解成一个一个小任务，当你不太清楚该做什么的时候，当你感觉常常不了了之的时候，可以尝试下ARTS每周打卡。<br>为了提高坚持下去的动力，可以组建一个打卡群，或者发给朋友之类的，提高坚持下去的概率。<br>下面是我每周打卡的一些内容，读者可以参考下<br><a href="https://shenzhen2017.github.io/blog/2020/12/arts-way-seven.html">ARTS打卡7</a><br><a href="https://shenzhen2017.github.io/blog/2020/11/arts-way-six.html">ARTS打卡6</a></p>
<h3 id="每周总结与下周计划"><a href="#每周总结与下周计划" class="headerlink" title="每周总结与下周计划"></a>每周总结与下周计划</h3><p>为了实现预定的目标，我们需要将任务拆分成一个个小模块，每周制定计划并统计每周的完成率。<br>这样也有利于提高我们坚持下去的概率<br>最初我是在<a href="https://juejin.cn/user/4318537403878167" target="_blank" rel="noopener">jsonchao</a>大神在群里看到的<br>jsonchao大神关于性能优化的系列文章都很优秀，有需要的读者可以关注下         </p>
<p>jsonchao每周都会在群里发自己的学习计划与完成情况，在他的影响下我也逐渐开始用起了这个学习方法<br>下面给出每周总结与下周计划的示例，用的网站是<a href="http://mubu.com/app" target="_blank" rel="noopener">http://mubu.com/app</a><br><img src="https://raw.githubusercontent.com/shenzhen2017/Goal/master/2020/9%E6%9C%887%E6%97%A5%E8%87%B39%E6%9C%8813%E6%97%A5%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92.png" alt><br><img src="https://raw.githubusercontent.com/shenzhen2017/Goal/master/2020/9%E6%9C%887%E6%97%A5%E8%87%B39%E6%9C%8813%E6%97%A5%E5%AD%A6%E4%B9%A0%E5%AE%8C%E6%88%90%E6%83%85%E5%86%B5.png" alt><br>如果读者觉得有用，也可以尝试下这种方法  </p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>定目标是简单的，但更简单的是没有完成目标。<br>相信大家都有很多类似的体验，年初定好的计划，往往不了了之。<br>达成目标并不是一件简单的事，但我相信我们可以通过坚持做一件件简单的事来达成目标。<br>毕竟，坚持是一件最不简单的事   </p>
<p>罗老师曾经说过     </p>
<blockquote>
<p>“把车停到公司楼下， 我摸了摸，给同事买的几盒炒面依然滚烫。<br>去时的大雪完全停了，我打开天窗，车顶残留的雪落了我一头，能看到很多星星，凉凉的空气好得不像话，喇叭里的音乐也从重金属变成了钢琴曲…<br>突然我就伤感起来了：你只是勤奋工作，努力做好自己，结果很多你的同行就要倒闭了…生命真残酷啊。”<br>——罗永浩</p>
</blockquote>
<p>如果我们能够勤奋工作，努力做好自己，相信年底回过头来，会发现这一年有不少收获，会发现自己已经走出了很远。<br>2021,共勉~    </p>
]]></content>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/blog/2017/03/hello-world.html</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>ARTS打卡8</title>
    <url>/blog/2020/12/arts-way-eight.html</url>
    <content><![CDATA[<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><blockquote>
<p><a href="https://leetcode-cn.com/contest/weekly-contest-219/problems/count-of-matches-in-tournament/" target="_blank" rel="noopener">5625. 比赛中的配对次数</a><br>给你一个整数 n ，表示比赛中的队伍数。比赛遵循一种独特的赛制：<br>如果当前队伍数是 偶数 ，那么每支队伍都会与另一支队伍配对。总共进行 n / 2 场比赛，且产生 n / 2 支队伍进入下一轮。<br>如果当前队伍数为 奇数 ，那么将会随机轮空并晋级一支队伍，其余的队伍配对。总共进行 (n - 1) / 2 场比赛，且产生 (n - 1) / 2 + 1 支队伍进入下一轮。<br>返回在比赛中进行的配对次数，直到决出获胜队伍为止。</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">numberOfMatches</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n==<span class="number">0</span>||n==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">if</span> (n%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">            n/<span class="number">2</span>+numberOfMatches(n/<span class="number">2</span>)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            (n-<span class="number">1</span>)/<span class="number">2</span> + numberOfMatches((n-<span class="number">1</span>)/<span class="number">2</span>+<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p><a href="https://developers.google.cn/codelabs/advanced-android-kotlin-training-property-animation#0" target="_blank" rel="noopener">https://developers.google.cn/codelabs/advanced-android-kotlin-training-property-animation#0</a><br>本文主要讲述了android属性动画，是MotionLayout动画的前置知识</p>
<h2 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h2><h3 id="Git合并多个commit的操作"><a href="#Git合并多个commit的操作" class="headerlink" title="Git合并多个commit的操作"></a>Git合并多个commit的操作</h3><p>当我们需要合并多个提交时，可以使用git rebase -i<br>详情可见：<a href="https://www.jianshu.com/p/964de879904a" target="_blank" rel="noopener">「Git」合并多个 Commit</a></p>
<h3 id="LineHeight失效问题"><a href="#LineHeight失效问题" class="headerlink" title="LineHeight失效问题"></a>LineHeight失效问题</h3><p>lineHeight的兼容性不好，在很多机型上会失效<br>建议使用lineSpacingExtra替代</p>
<h3 id="部分机型虚线绘制失效的问题"><a href="#部分机型虚线绘制失效的问题" class="headerlink" title="部分机型虚线绘制失效的问题"></a>部分机型虚线绘制失效的问题</h3><p>直接使用DashEffect会有部分机型失效的问题，可以使用以下方法绘制虚线<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">drawHDashLine</span><span class="params">(canvas: <span class="type">Canvas</span>?, startX: <span class="type">Float</span>, stopX: <span class="type">Float</span>, lineY: <span class="type">Float</span>, paintChineseMindLine: <span class="type">Paint</span>, line: <span class="type">Float</span>, empty: <span class="type">Float</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">var</span> drawPointX = startX</span><br><span class="line">            <span class="keyword">var</span> isLine = <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> (drawPointX &lt; stopX) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isLine == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">val</span> start = drawPointX</span><br><span class="line">                    drawPointX = <span class="keyword">if</span> ((drawPointX + line) &gt;= stopX) stopX <span class="keyword">else</span> drawPointX + line</span><br><span class="line">                    canvas?.drawLine(start, lineY, drawPointX, lineY, paintChineseMindLine)</span><br><span class="line">                    isLine = <span class="number">0</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    drawPointX = <span class="keyword">if</span> ((drawPointX + empty) &gt;= stopX) stopX <span class="keyword">else</span> drawPointX + empty</span><br><span class="line">                    isLine = <span class="number">1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p>本周主要是翻译：<br>【译】取代Android的LiveData:StateFlow还是SharedFlow？<br>详情可见：<a href="https://shenzhen2017.github.io/blog/2020/12/translate-substituing-liveData.html">https://shenzhen2017.github.io/blog/2020/12/translate-substituing-liveData.html</a></p>
]]></content>
      <tags>
        <tag>ARTS</tag>
      </tags>
  </entry>
  <entry>
    <title>ARTS打卡9</title>
    <url>/blog/2020/12/arts-way-nine.html</url>
    <content><![CDATA[<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><blockquote>
<p><a href="https://leetcode-cn.com/contest/weekly-contest-220/problems/reformat-phone-number/" target="_blank" rel="noopener">5629. 重新格式化电话号码</a><br>给你一个字符串形式的电话号码 number 。number 由数字、空格 ‘ ‘、和破折号 ‘-‘ 组成。<br>请你按下述方式重新格式化电话号码。<br>首先，删除 所有的空格和破折号。<br>其次，将数组从左到右 每 3 个一组 分块，直到 剩下 4 个或更少数字。剩下的数字将按下述规定再分块：<br>2 个数字：单个含 2 个数字的块。<br>3 个数字：单个含 3 个数字的块。<br>4 个数字：两个分别含 2 个数字的块。<br>最后用破折号将这些块连接起来。注意，重新格式化过程中 不应该 生成仅含 1 个数字的块，并且 最多 生成两个含 2 个数字的块。<br>返回格式化后的电话号码。</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">reformatNumber</span><span class="params">(number: <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">val</span> item = number.trim().replace(<span class="string">" "</span>,<span class="string">""</span>).replace(<span class="string">"-"</span>,<span class="string">""</span>)</span><br><span class="line">        <span class="keyword">val</span> result = StringBuilder()</span><br><span class="line">        <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; item.length)&#123;</span><br><span class="line">            <span class="keyword">if</span> (item.length-i&lt;=<span class="number">4</span>)&#123;</span><br><span class="line">                <span class="keyword">when</span> &#123;</span><br><span class="line">                    item.length-i==<span class="number">4</span> -&gt; result.append(item[i]).append(item[i+<span class="number">1</span>]).append(<span class="string">"-"</span>).append(item[i+<span class="number">2</span>]).append(item[i+<span class="number">3</span>])</span><br><span class="line">                    item.length-i == <span class="number">3</span> -&gt; result.append(item[i]).append(item[i+<span class="number">1</span>]).append(item[i+<span class="number">2</span>])</span><br><span class="line">                    <span class="keyword">else</span> -&gt; result.append(item[i]).append(item[i+<span class="number">1</span>])</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                result.append(item[i]).append(item[i+<span class="number">1</span>]).append(item[i+<span class="number">2</span>]).append(<span class="string">"-"</span>)</span><br><span class="line">                i += <span class="number">3</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.toString()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p><a href="https://thegeekpage.com/wifi-disconnecting-when-vpn-in-enabled/" target="_blank" rel="noopener">https://thegeekpage.com/wifi-disconnecting-when-vpn-in-enabled/</a><br><a href="https://thegeekpage.com/restart-pc-in-clean-boot-mode/" target="_blank" rel="noopener">https://thegeekpage.com/restart-pc-in-clean-boot-mode/</a><br>本文主要是windows10 安装vpn后，一打开vpn,wifi自动关闭<br>最后通过为windows建立干净启动解决问题</p>
<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><h3 id="ConstraintLayout给几个View添加背景"><a href="#ConstraintLayout给几个View添加背景" class="headerlink" title="ConstraintLayout给几个View添加背景"></a>ConstraintLayout给几个View添加背景</h3><p>考虑这么一个场景，如果一个页面里面有部分 view 需要加个背景，使用Layer引用这几个 view，然后给Layer设置背景就可以了。如果不用Layer，只能另外加个 ViewGroup 包住这几个 View 了，这样会增加 view 的层级，不利于性能。</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;android.support.constraint.helper.Layer</span><br><span class="line">        app:<span class="attribute">layout_constraintLeft_toLeftOf</span>=<span class="string">"parent"</span></span><br><span class="line">        app:<span class="attribute">layout_constraintTop_toTopOf</span>=<span class="string">"parent"</span></span><br><span class="line">        android:<span class="attribute">id</span>=<span class="string">"@+id/layer"</span></span><br><span class="line">        android:<span class="attribute">layout_width</span>=<span class="string">"wrap_content"</span></span><br><span class="line">        android:<span class="attribute">layout_height</span>=<span class="string">"wrap_content"</span></span><br><span class="line">        android:<span class="attribute">background</span>=<span class="string">"@drawable/frame"</span></span><br><span class="line">        android:<span class="attribute">padding</span>=<span class="string">"32dp"</span></span><br><span class="line">        app:<span class="attribute">constraint_referenced_ids</span>=<span class="string">"button4,button5,button7,button6,button3,button2"</span> /&gt;</span><br></pre></td></tr></table></figure>
<p>详情可见：<a href="https://juejin.cn/post/6844903872255754248" target="_blank" rel="noopener">ConstraintLayout 2.0 新特性详解及实战</a></p>
<h3 id="圆角View与圆角ImageView实现"><a href="#圆角View与圆角ImageView实现" class="headerlink" title="圆角View与圆角ImageView实现"></a>圆角View与圆角ImageView实现</h3><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;androidx.constraintlayout.utils.widget.ImageFilterButton</span><br><span class="line">    android:<span class="attribute">layout_width</span>=<span class="string">"wrap_content"</span></span><br><span class="line">    android:<span class="attribute">layout_height</span>=<span class="string">"wrap_content"</span></span><br><span class="line">    android:<span class="attribute">layout_marginTop</span>=<span class="string">"100dp"</span></span><br><span class="line">    android:<span class="attribute">src</span>=<span class="string">"@mipmap/ic_launcher"</span></span><br><span class="line">    app:<span class="attribute">layout_constraintLeft_toLeftOf</span>=<span class="string">"parent"</span></span><br><span class="line">    app:<span class="attribute">layout_constraintRight_toRightOf</span>=<span class="string">"parent"</span></span><br><span class="line">    app:<span class="attribute">layout_constraintTop_toTopOf</span>=<span class="string">"parent"</span></span><br><span class="line">    app:<span class="attribute">round</span>=<span class="string">"50dp"</span> /&gt;</span><br></pre></td></tr></table></figure>
<p>可以使用ImageFilterButton与ImageFilterView实现，通过round属性设置</p>
<p>详情可见：<a href="https://juejin.cn/post/6854573221312725000#heading-5" target="_blank" rel="noopener">ImageFilterView实现圆角</a></p>
<h3 id="ConstraintLayout-margin设置为负值"><a href="#ConstraintLayout-margin设置为负值" class="headerlink" title="ConstraintLayout margin设置为负值"></a>ConstraintLayout margin设置为负值</h3><p>有ConstraintLayout实践经验的朋友应该知道margin设置负值在ConstraintLayout是没有效果的<br>我们可以通过轻量级的Space来间接实现这种效果。<br>详情可见：<a href="https://juejin.cn/post/6854573221312725000#heading-9" target="_blank" rel="noopener">ConstraintLayout实现maring为负值</a></p>
<h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p><a href="https://shenzhen2017.github.io/blog/2020/12/motionlayout-recyclerview-animation.html">利用MotionLayout实现RecyclerView折叠展开动画</a><br>结合MotionLayout与RecyclerView，实现展开折叠动画</p>
]]></content>
      <tags>
        <tag>ARTS</tag>
      </tags>
  </entry>
  <entry>
    <title>【译】取代Android的LiveData:StateFlow还是SharedFlow？</title>
    <url>/blog/2020/12/translate-substituing-liveData.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>原标题: Substituting Android’s LiveData: StateFlow or SharedFlow?<br>原文地址: <a href="https://proandroiddev.com/should-we-choose-kotlins-stateflow-or-sharedflow-to-substitute-for-android-s-livedata-2d69f2bd6fa5" target="_blank" rel="noopener">Substituting Android’s LiveData: StateFlow or SharedFlow?</a><br>原文作者：Patrick Steiger</p>
</blockquote>
<p>Kotlin Coroutines最近推出了两种Flow类型，SharedFlow和StateFlow，Android社区开始考虑使用用这些新类型去替代LiveData的可能性。<br>这样做的两个主要原因是：    </p>
<ul>
<li>1.LiveData与UI紧密绑定（没有自然的方式将工作卸载到工作线程）    </li>
<li>2.LiveData与Android平台紧密绑定。    </li>
</ul>
<p>我们可以从这两个事实得出结论，就Clean Architecture而言，尽管LiveData在展示层上运行良好，但它并不能很好地集成到域层中，后者应该独立于平台（意味着一个纯粹的Kotlin / Java模块）；   而且它也不太适合数据层（存储库实现和数据源），因为我们通常应该将数据访问工作分担给工作线程。<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog9/p1.png" alt><br>但是，我们不能仅用纯Flow代替LiveData。使用纯Flow作为LiveData替代品的主要问题是：   </p>
<ul>
<li>1.Flow是无状态的（并且不能通过.value访问）。</li>
<li>2.Flow是声明性的,一个Flow Builder仅描述Flow是什么，并且仅在收集时才具体化。 并且将为每个收集器有效地实例化新的Flow，这意味着将为每个收集器冗余且重复地运行上游昂贵的数据库访问。</li>
<li>3.Flow本身对Android生命周期一无所知，并且不会在Android生命周期状态发生变化时自动暂停和恢复收集器。</li>
</ul>
<blockquote>
<p>这些不应被视为Flow固有缺陷：这些只是使其无法很好地替代LiveData，而在其他情况下却可能很实用。</p>
</blockquote>
<p>对于（3），我们已经可以使用LifecycleCoroutineScope扩展（例如launchWhenStarted）来启动协程以收集我们的flows-这些收集器将自动暂停并与组件的Lifecycle同步恢复。  </p>
<blockquote>
<p>注意：在本文中，我们将收集和观察用作同义词概念。 收集是Kotlin Flows（我们收集一个Flow）的首选术语，观察是Android LiveData（我们观察一个LiveData）的首选术语。  </p>
</blockquote>
<p>但是关于（1）访问当前状态，（2）对于N&gt; = 1个收集器仅实现一次，而对于0个收集器则消失，我们该如何实现呢？</p>
<p>现在，SharedFlow和StateFlow为这两个问题提供了解决方案。     </p>
<h2 id="一个实例"><a href="#一个实例" class="headerlink" title="一个实例"></a>一个实例</h2><p>我们举一个例子。我们的用例正在获取附近的位置。我们假设将Firebase实时数据库与GeoFire库一起使用，该库允许查询附近的位置。   </p>
<h3 id="使用LiveData端到端"><a href="#使用LiveData端到端" class="headerlink" title="使用LiveData端到端"></a>使用LiveData端到端</h3><p><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog9/p2.png" alt></p>
<p>让我们首先展示从数据源一直到视图的LiveData用法。<br>数据源负责通过GeoQuery连接到Firebase实时数据库。<br>当我们收到onGeoQueryReady或onGeoQueryError时，将使用自上一个onGeoQueryReady以来输入，退出或移动的位置的总和来更新LiveData值。<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Singleton</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NearbyUsersDataSource</span> <span class="meta">@Inject</span> <span class="keyword">constructor</span></span>() &#123;</span><br><span class="line">    <span class="comment">// Ideally, those should be constructor-injected.</span></span><br><span class="line">    <span class="keyword">val</span> geoFire = GeoFire(FirebaseDatabase.getInstance().getReference(<span class="string">"geofire"</span>))</span><br><span class="line">    <span class="keyword">val</span> geoLocation = GeoLocation(<span class="number">0.0</span>, <span class="number">0.0</span>)</span><br><span class="line">    <span class="keyword">val</span> radius = <span class="number">100.0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">val</span> geoQuery = geoFire.queryAtLocation(geoLocation, radius)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Listener for receiving GeoLocations</span></span><br><span class="line">    <span class="keyword">val</span> listener: GeoQueryEventListener = <span class="keyword">object</span> : GeoQueryEventListener &#123;</span><br><span class="line">        <span class="keyword">val</span> map = mutableMapOf&lt;Key, GeoLocation&gt;()</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onKeyEntered</span><span class="params">(key: <span class="type">String</span>, location: <span class="type">GeoLocation</span>)</span></span> &#123;</span><br><span class="line">            map[key] = location</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onKeyExited</span><span class="params">(key: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">            map.remove(key)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onKeyMoved</span><span class="params">(key: <span class="type">String</span>, location: <span class="type">GeoLocation</span>)</span></span> &#123;</span><br><span class="line">            map[key] = location</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onGeoQueryReady</span><span class="params">()</span></span> &#123;</span><br><span class="line">            _locations.value = State.Ready(map.toMap())</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onGeoQueryError</span><span class="params">(e: <span class="type">DatabaseError</span>)</span></span> &#123;</span><br><span class="line">            _locations.value = State.Error(map.toMap(), e.toException())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Listen for changes only while observed</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> _locations = <span class="keyword">object</span> : MutableLiveData&lt;State&gt;() &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActive</span><span class="params">()</span></span> &#123;</span><br><span class="line">            geoQuery.addGeoQueryEventListener(listener)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onInactive</span><span class="params">()</span></span> &#123;</span><br><span class="line">            geoQuery.removeGeoQueryEventListener(listener)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Expose read-only LiveData</span></span><br><span class="line">    <span class="keyword">val</span> locations: LiveData&lt;State&gt; <span class="keyword">by</span> <span class="keyword">this</span>::_locations</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">State</span></span>(<span class="keyword">open</span> <span class="keyword">val</span> value: Map&lt;Key, GeoLocation&gt;) &#123;</span><br><span class="line">        <span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Ready</span></span>(</span><br><span class="line">            <span class="keyword">override</span> <span class="keyword">val</span> value: Map&lt;Key, GeoLocation&gt;</span><br><span class="line">        ) : State(value)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Error</span></span>(</span><br><span class="line">            <span class="keyword">override</span> <span class="keyword">val</span> value: Map&lt;Key, GeoLocation&gt;,</span><br><span class="line">            <span class="keyword">val</span> exception: Exception</span><br><span class="line">        ) : State(value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后，我们的Repository，ViewModel和Activity应该很简单：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Singleton</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NearbyUsersRepository</span> <span class="meta">@Inject</span> <span class="keyword">constructor</span></span>(</span><br><span class="line">    nearbyUsersDataSource: NearbyUsersDataSource</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="keyword">val</span> locations <span class="keyword">get</span>() = nearbyUsersDataSource.locations</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NearbyUsersViewModel</span> <span class="meta">@ViewModelInject</span> <span class="keyword">constructor</span></span>(</span><br><span class="line">    nearbyUsersRepository: NearbyUsersRepository</span><br><span class="line">) : ViewModel() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> locations <span class="keyword">get</span>() = nearbyUsersRepository.locations</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AndroidEntryPoint</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NearbyUsersActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> viewModel: NearbyUsersViewModel <span class="keyword">by</span> viewModels()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        viewModel.locations.observe(<span class="keyword">this</span>) &#123; state: State -&gt;</span><br><span class="line">            <span class="comment">// Update views with the data.   </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在您决定使包含存储库接口的域层（独立于平台）之前，这种尝试可能不错。 同样，一旦需要将工作分担到数据源上的工作线程上，您将发现LiveData没有简单，惯用的方法。</p>
<h3 id="在数据源和Repository上使用Flow"><a href="#在数据源和Repository上使用Flow" class="headerlink" title="在数据源和Repository上使用Flow"></a>在数据源和Repository上使用Flow</h3><p><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog9/p3.png" alt><br>让我们将数据源转换为使用Flow。 我们有一个Flow生成器callbackFlow，它将回调转换为Flow。<br>收集此Flow后，它将运行传递给Flow构建器的代码块，添加GeoQuery侦听器并到达awaitClose，在该处暂停直到Flow被关闭（即直到没有人收集或因为异常被取消为止).<br>关闭时，它将删除监听器，并且Flow将取消实现。<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Singleton</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NearbyUsersDataSource</span> <span class="meta">@Inject</span> <span class="keyword">constructor</span></span>() &#123;</span><br><span class="line">    <span class="comment">// Ideally, those should be constructor-injected.</span></span><br><span class="line">    <span class="keyword">val</span> geoFire = GeoFire(FirebaseDatabase.getInstance().getReference(<span class="string">"geofire"</span>))</span><br><span class="line">    <span class="keyword">val</span> geoLocation = GeoLocation(<span class="number">0.0</span>, <span class="number">0.0</span>)</span><br><span class="line">    <span class="keyword">val</span> radius = <span class="number">100.0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">val</span> geoQuery = geoFire.queryAtLocation(geoLocation, radius)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> GeoQuery.<span class="title">asFlow</span><span class="params">()</span></span> = callbackFlow &#123;</span><br><span class="line">        <span class="keyword">val</span> listener: GeoQueryEventListener = <span class="keyword">object</span> : GeoQueryEventListener &#123;</span><br><span class="line">            <span class="keyword">val</span> map = mutableMapOf&lt;Key, GeoLocation&gt;()</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onKeyEntered</span><span class="params">(key: <span class="type">String</span>, location: <span class="type">GeoLocation</span>)</span></span> &#123;</span><br><span class="line">                map[key] = location</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onKeyExited</span><span class="params">(key: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">                map.remove(key)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onKeyMoved</span><span class="params">(key: <span class="type">String</span>, location: <span class="type">GeoLocation</span>)</span></span> &#123;</span><br><span class="line">                map[key] = location</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onGeoQueryReady</span><span class="params">()</span></span> &#123;</span><br><span class="line">                emit(State.Ready(locations.toMap()))</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onGeoQueryError</span><span class="params">(e: <span class="type">DatabaseError</span>)</span></span> &#123;</span><br><span class="line">                emit(State.Error(map.toMap(), e.toException()))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        addGeoQueryEventListener(listener)</span><br><span class="line">        </span><br><span class="line">        awaitClose &#123; removeGeoQueryEventListener(listener) &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> locations: Flow&lt;State&gt; = geoQuery.asFlow()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">State</span></span>(<span class="keyword">open</span> <span class="keyword">val</span> value: Map&lt;Key, GeoLocation&gt;) &#123;</span><br><span class="line">        <span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Ready</span></span>(</span><br><span class="line">            <span class="keyword">override</span> <span class="keyword">val</span> value: Map&lt;Key, GeoLocation&gt;</span><br><span class="line">        ) : State(value)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Error</span></span>(</span><br><span class="line">            <span class="keyword">override</span> <span class="keyword">val</span> value: Map&lt;Key, GeoLocation&gt;,</span><br><span class="line">            <span class="keyword">val</span> exception: Exception</span><br><span class="line">        ) : State(value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们的Repository和ViewModel不做任何更改，但是我们的Activity现在接收到Flow而不是LiveData，因此它需要进行调整：我们将收集Flow而不是观察LiveData。<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AndroidEntryPoint</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NearbyUsersActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> viewModel: NearbyUsersViewModel <span class="keyword">by</span> viewModels()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        lifecycleScope.launchWhenStarted &#123;</span><br><span class="line">            viewModel.locations.collect &#123;</span><br><span class="line">                <span class="comment">// Update views with the data.   </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们使用launchWhenStarted {}来收集Flow，因此协程仅在Activity达到onStart（）生命周期状态时才自动启动，而当它达到onStop（）生命周期状态时将自动暂停。 这类似于LiveData给我们的生命周期自动处理。 </p>
<blockquote>
<p>注意：您可以选择在展示层中继续使用LiveData。 在这种情况下，您可以使用Flow <t>.asLiveData扩展函数轻松地在ViewModel中将Flow从Flow转换为LiveData。<br>这个决定将带来后果，我们将继续进行讨论，并且将证明端到端使用SharedFlow和StateFlow更加通用，并且可能更适合您的体系结构。<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog9/p4.png" alt>  </t></p>
</blockquote>
<h3 id="在View层中使用Flow有什么问题？"><a href="#在View层中使用Flow有什么问题？" class="headerlink" title="在View层中使用Flow有什么问题？"></a>在View层中使用Flow有什么问题？</h3><p>这种方法的第一个问题是生命周期的处理，LiveData会自动为我们处理。 在上面的示例中，我们通过使用launchWhenStarted {}实现了类似的行为。    </p>
<p>但是还有另一个问题：由于Flow是声明性的，并且仅在收集时运行（实例化），因此，如果我们有多个收集器，则将为每个收集器运行一个新的Flow，彼此完全独立。<br>根据完成的操作（例如数据库或网络操作），这可能会非常无效。<br>如果我们期望操作只进行一次以确保正确性，则甚至可能导致错误的状态。<br>在我们的实际示例中，我们将为每个收集器添加一个新的GeoQuery监听器-可能不是关键问题，但肯定会浪费内存和CPU周期。   </p>
<blockquote>
<p>注意：如果通过在ViewModel中使用Flow <t> .asLiveData（）将存储库流转换为LiveData，则LiveData将成为Flow的唯一收集器，无论展示层中有多少观察者，都将只有一个Flow 集。<br>但是，为了使该架构正常工作，您需要确保自己的所有其他组件都可以从ViewModel访问LiveData，而绝不能直接从存储库访问Flow。<br>这可能是一个挑战，具体取决于应用程序的分离程度：所有需要存储库的组件现在都将依赖Activity实例来获取ViewModel实例，以及这些组件的范围 需要相应地加以限制。</t></p>
</blockquote>
<p>无论我们在View层中有多少个收集器，我们都只需要一个GeoQuery监听器。 我们可以通过共享所有收集器之间的流来实现此目的。     </p>
<h3 id="SharedFlow"><a href="#SharedFlow" class="headerlink" title="SharedFlow"></a>SharedFlow</h3><p>SharedFlow是一种流，它允许在多个收集器之间共享自己，因此对于所有同时收集器，只有一个流有效地运行（实现）。<br>如果定义访问数据库的SharedFlow并且由多个收集器收集，则数据库访问将仅运行一次，并且所得到的数据将共享给所有收集器。    </p>
<p>StateFlow也可以用于实现相同的行为：它是具有.value（其当前状态）和特定SharedFlow配置（约束）的专用SharedFlow。 稍后我们将讨论这些限制。<br>我们有一个运算符，用于将任何Flow转换为SharedFlow<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Flow<span class="type">&lt;T&gt;</span>.<span class="title">shareIn</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    scope: <span class="type">CoroutineScope</span>, </span></span></span><br><span class="line"><span class="function"><span class="params">    started: <span class="type">SharingStarted</span>, </span></span></span><br><span class="line"><span class="function"><span class="params">    replay: <span class="type">Int</span> = <span class="number">0</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>: SharedFlow&lt;T&gt; (source)</span><br></pre></td></tr></table></figure></p>
<p>让我们将其应用于我们的数据源。     </p>
<p>scope是完成实现该流程的所有计算的地方。<br>由于我们的数据源是@Singleton，因此我们可以使用应用程序进程的LifecycleScope，它是一个LifecycleCoroutineScope，它是在进程创建时创建的，仅在进程销毁时才销毁。    </p>
<p>对于started参数，我们可以使用SharingStarted.WhileSubscribed（），这使Flow仅在订阅者数量从0变为1时才开始共享（实现），并在订阅者数量从1变为0时停止共享。     与我们之前通过在onActive（）回调中添加GeoQuery侦听器并在onInactive（）回调中删除侦听器实现的LiveData行为类似。      我们还可以将其配置为立即启动（立即实现，而不再取消实现）或懒启动（在首次收集时实现，而从未取消实现），但是我们希望它在下游不再收集时停止上游数据库的收集。    </p>
<blockquote>
<p>关于术语的注意事项：正如我们将术语“观察者”用于LiveData，将“收集器”用于Flow一样，我们将术语“订阅”用于SharedFlow。</p>
</blockquote>
<p>对于replay参数,我们可以设置为1，新订阅者将在订阅时立即获得最后发出的值。<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Singleton</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NearbyUsersDataSource</span> <span class="meta">@Inject</span> <span class="keyword">constructor</span></span>() &#123;</span><br><span class="line">    <span class="comment">// Ideally, those should be constructor-injected.</span></span><br><span class="line">    <span class="keyword">val</span> geoFire = GeoFire(FirebaseDatabase.getInstance().getReference(<span class="string">"geofire"</span>))</span><br><span class="line">    <span class="keyword">val</span> geoLocation = GeoLocation(<span class="number">0.0</span>, <span class="number">0.0</span>)</span><br><span class="line">    <span class="keyword">val</span> radius = <span class="number">100.0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">val</span> geoQuery = geoFire.queryAtLocation(geoLocation, radius)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> GeoQuery.<span class="title">asFlow</span><span class="params">()</span></span> = callbackFlow &#123;</span><br><span class="line">        <span class="keyword">val</span> listener: GeoQueryEventListener = <span class="keyword">object</span> : GeoQueryEventListener &#123;</span><br><span class="line">            <span class="keyword">val</span> map = mutableMapOf&lt;Key, GeoLocation&gt;()</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onKeyEntered</span><span class="params">(key: <span class="type">String</span>, location: <span class="type">GeoLocation</span>)</span></span> &#123;</span><br><span class="line">                map[key] = location</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onKeyExited</span><span class="params">(key: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">                map.remove(key)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onKeyMoved</span><span class="params">(key: <span class="type">String</span>, location: <span class="type">GeoLocation</span>)</span></span> &#123;</span><br><span class="line">                map[key] = location</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onGeoQueryReady</span><span class="params">()</span></span> &#123;</span><br><span class="line">                emit(State.Ready(map.toMap())</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onGeoQueryError</span><span class="params">(e: <span class="type">DatabaseError</span>)</span></span> &#123;</span><br><span class="line">                emit(State.Error(map.toMap(), e.toException())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        addGeoQueryEventListener(listener)</span><br><span class="line">        </span><br><span class="line">        awaitClose &#123; removeGeoQueryEventListener(listener) &#125;</span><br><span class="line">    &#125;.shareIn(</span><br><span class="line">         ProcessLifecycleOwner.<span class="keyword">get</span>().lifecycleScope,</span><br><span class="line">         SharingStarted.WhileSubscribed(),</span><br><span class="line">         <span class="number">1</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> locations: Flow&lt;State&gt; = geoQuery.asFlow()</span><br><span class="line">                     </span><br><span class="line">    <span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">State</span></span>(<span class="keyword">open</span> <span class="keyword">val</span> value: Map&lt;Key, GeoLocation&gt;) &#123;</span><br><span class="line">        <span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Ready</span></span>(</span><br><span class="line">            <span class="keyword">override</span> <span class="keyword">val</span> value: Map&lt;Key, GeoLocation&gt;</span><br><span class="line">        ) : State(value)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Error</span></span>(</span><br><span class="line">            <span class="keyword">override</span> <span class="keyword">val</span> value: Map&lt;Key, GeoLocation&gt;,</span><br><span class="line">            <span class="keyword">val</span> exception: Exception</span><br><span class="line">        ) : State(value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>将SharedFlow本身视为Flow收集器可能会有所帮助，它会将上游的冷流变为热流，并在下游的许多收集器之间共享收集的值。 在冷的上游水流和多个下游收集器之间的中间位置有一个人。  </p>
<p>现在，我们可能会以为Activity不需要调整。<br>错误！ 有一个陷阱：在使用launchWhenStarted {}启动的协程中收集流时，协程将在onStop（）上暂停，并在onStart（）上恢复，但仍将订阅该流。<br>对于MutableSharedFlow <t>，这意味着MutableSharedFlow <t> .subscriptionCount对于暂停的协程不会更改。 为了利用SharingStarted.WhileSubscribed（）的功能，我们实际上需要在onStop（）上退订，然后在onStart（）上再次订阅。 这意味着取消收集协程并重新创建它。</t></t></p>
<p>让我们为此目的创建一个类：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PublishedApi</span></span><br><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserverImpl</span>&lt;<span class="type">T</span>&gt; </span>(</span><br><span class="line">    lifecycleOwner: LifecycleOwner,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> flow: Flow&lt;T&gt;,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> collector: <span class="keyword">suspend</span> (T) -&gt; <span class="built_in">Unit</span></span><br><span class="line">) : DefaultLifecycleObserver &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> job: Job? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStart</span><span class="params">(owner: <span class="type">LifecycleOwner</span>)</span></span> &#123;</span><br><span class="line">        job = owner.lifecycleScope.launch &#123;</span><br><span class="line">            flow.collect &#123;</span><br><span class="line">                collector(it)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStop</span><span class="params">(owner: <span class="type">LifecycleOwner</span>)</span></span> &#123;</span><br><span class="line">        job?.cancel()</span><br><span class="line">        job = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        lifecycleOwner.lifecycle.addObserver(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T&gt;</span> Flow<span class="type">&lt;T&gt;</span>.<span class="title">observe</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    lifecycleOwner: <span class="type">LifecycleOwner</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">noinline</span> collector: <span class="type">suspend</span> (<span class="type">T</span>) -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> &#123;</span><br><span class="line">    ObserverImpl(lifecycleOwner, <span class="keyword">this</span>, collector)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T&gt;</span> Flow<span class="type">&lt;T&gt;</span>.<span class="title">observeIn</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    lifecycleOwner: <span class="type">LifecycleOwner</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> &#123;</span><br><span class="line">    ObserverImpl(lifecycleOwner, <span class="keyword">this</span>, &#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在，我们可以调整Activity以使用刚刚创建的.observeIn（LifecycleOwner）扩展功能：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AndroidEntryPoint</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NearbyUsersActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> viewModel: NearbyUsersViewModel <span class="keyword">by</span> viewModels()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        viewModel</span><br><span class="line">            .locations</span><br><span class="line">            .onEach &#123; <span class="comment">/* new locations received */</span> &#125;</span><br><span class="line">            .observeIn(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当LifecycleOwner的生命周期达到CREATED状态（恰好在onStop（）调用之前）时，使用observeIn（LifecycleOwner）创建的收集器协程将被销毁，并且一旦达到STARTED状态（在onStart（）调用之后）将被重新创建。</p>
<blockquote>
<p>注意：为什么是CREATED状态？ 不应该是STOPED状态吗？ 乍一看听起来有点违反直觉，但确实很合理。 Lifecycle.State仅具有以下状态：CREATED, DESTROYED, INITIALIZED, RESUMED, STARTED。<br>没有STOPPED和PAUSED状态。 当生命周期达到onPause（）时，它不会返回新状态，而是返回到STARTED状态。 当到达onStop（）时，它返回到CREATED状态。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog9/p5.png" alt><br>现在，我们有了一个数据源，该数据源一次实现，但将其数据共享给所有订阅者。<br>一旦没有订阅者，它的上游收集将停止，并在第一个订阅者重新出现时重新启动。<br>它不依赖于Android平台，也不与主线程绑定（仅通过应用.flowOn（）运算符即可在其他线程中进行流转换：<br>flowOn（Dispatchers.IO）或.flowOn（Dispatchers.Default） ）。</p>
<h3 id="但是，如果我最终需要访问Flow的当前状态而不收集它怎么办？"><a href="#但是，如果我最终需要访问Flow的当前状态而不收集它怎么办？" class="headerlink" title="但是，如果我最终需要访问Flow的当前状态而不收集它怎么办？"></a>但是，如果我最终需要访问Flow的当前状态而不收集它怎么办？</h3><p>如果确实需要像使用LiveData一样使用.value访问Flow的状态，则我们可以使用StateFlow，它是一种专用的受限SharedFlow。    </p>
<p>ShareFlow使用shareIn来实现<br>StateFlow使用stateIn实现</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Flow<span class="type">&lt;T&gt;</span>.<span class="title">stateIn</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    scope: <span class="type">CoroutineScope</span>, </span></span></span><br><span class="line"><span class="function"><span class="params">    started: <span class="type">SharingStarted</span>, </span></span></span><br><span class="line"><span class="function"><span class="params">    initialValue: <span class="type">T</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>: StateFlow&lt;T&gt; (source)</span><br></pre></td></tr></table></figure>
<p>从方法参数可以看出，sharedIn（）和stateIn（）之间有两个基本区别：</p>
<p>1.stateIn（）不支持replay自定义。 StateFlow是具有固定replay=1的SharedFlow。 这意味着新订阅者将在订阅后立即获得当前状态。<br>2.stateIn（）需要一个初始值。 这意味着如果您当时没有初始值，则需要使StateFlow <t>类型T为可为空，或使用密封类来表示空的初始值。    </t></p>
<h3 id="选择哪个，StateFlow或SharedFlow？"><a href="#选择哪个，StateFlow或SharedFlow？" class="headerlink" title="选择哪个，StateFlow或SharedFlow？"></a>选择哪个，StateFlow或SharedFlow？</h3><p>回答此问题的简单方法是尝试回答其他一些问题：   </p>
<p><strong>“我真的需要在任何给定时间使用myFlow.value访问Flow的当前状态吗？”</strong><br>如果此问题的答案为“否”，则可以考虑使用SharedFlow。 </p>
<p><strong>“我需要支持发出和收集重复值吗？”</strong><br>如果对这个问题的回答是“是”，则需要SharedFlow。  </p>
<p><strong>“对于新订户，我是否需要重播超过最新值的内容？”</strong><br>如果对这个问题的回答是“是”，则需要SharedFlow。    </p>
<p>正如我们所看到的，对于所有内容，StateFlow并不是自动的正确答案。  </p>
<p>1.它忽略（合并）重复的值，并且这是不可配置的。 有时您不需要忽略重复的值，例如：连接尝试将尝试的结果存储在流中，并且每次失败后都需要重试。   </p>
<p>2.另外，它需要一个初始值。 由于SharedFlow没有.value，因此不需要使用初始值实例化-收集器将暂停直到第一个值出现，并且没有人会尝试在任何值到达之前访问.value。 如果您没有StateFlow的初始值，则必须将StateFlow类型设为可为null的T？ 并使用null作为初始值（或使用密封类来表示空的初始值）。</p>
<p>3.另外，您可能需要调整重播值。 SharedFlow可以为新订户重播最后n个值。 StateFlow的固定重播值为1-它仅共享当前状态值</p>
<p>两者都支持SharingStarted（立刻，懒加载或WhileSubscribed（））配置。我通常使用SharingStarted.WhileSubscribed（）<br>并在Activity onStart（）/ onStop（）时，销毁/重新创建所有收集器，<br>因此，当用户不积极使用该应用程序时，数据源上游收集将停止    </p>
<p>StateFlow施加在SharedFlow上的约束可能不是最适合您，您可能需要调整行为并选择使用SharedFlow。就个人而言，我很少需要访问myFlow.value，并且享受SharedFlow的灵活性，因此我通常选择SharedFlow。  </p>
<h3 id="一个使用SharedFlow的实例"><a href="#一个使用SharedFlow的实例" class="headerlink" title="一个使用SharedFlow的实例"></a>一个使用SharedFlow的实例</h3><p>考虑以下围绕Google Billing Client库的包装。我们有一个MutableSharedFlow billingClientStatus，用于存储当前到计费服务的连接状态。<br>我们将其初始值设置为SERVICE_DISCONNECTED。我们收集billingClientStatus，当它不正常时，我们尝试将startConnection（）连接到计费服务。<br>如果连接尝试失败，我们将发出SERVICE_DISCONNECTED。</p>
<p>在该示例中，如果billingClientStatus是MutableStateFlow而不是MutableSharedFlow，则当其值已经为SERVICE_DISCONNECTED且我们尝试将其设置为相同（连接重试失败）时，它将忽略更新，因此，它将不会尝试重新连接再次。   </p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Singleton</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Biller</span> <span class="meta">@Inject</span> <span class="keyword">constructor</span></span>(</span><br><span class="line">    <span class="meta">@ApplicationContext</span> <span class="keyword">private</span> <span class="keyword">val</span> context: Context,</span><br><span class="line">) : PurchasesUpdatedListener, BillingClientStateListener &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> billingClient: BillingClient =</span><br><span class="line">        BillingClient.newBuilder(context)</span><br><span class="line">            .setListener(<span class="keyword">this</span>)</span><br><span class="line">            .enablePendingPurchases()</span><br><span class="line">            .build()</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> billingClientStatus = MutableSharedFlow&lt;<span class="built_in">Int</span>&gt;(</span><br><span class="line">        replay = <span class="number">1</span>,</span><br><span class="line">        onBufferOverflow = BufferOverflow.DROP_OLDEST</span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBillingSetupFinished</span><span class="params">(result: <span class="type">BillingResult</span>)</span></span> &#123;</span><br><span class="line">        billingClientStatus.tryEmit(result.responseCode)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBillingServiceDisconnected</span><span class="params">()</span></span> &#123;</span><br><span class="line">        billingClientStatus.tryEmit(BillingClient.BillingResponseCode.SERVICE_DISCONNECTED)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Suspend until billingClientStatus == BillingClient.BillingResponseCode.OK</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">requireBillingClientSetup</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> =</span><br><span class="line">        withTimeoutOrNull(TIMEOUT_MILLIS) &#123;</span><br><span class="line">            billingClientStatus.first &#123; it == BillingClient.BillingResponseCode.OK &#125;</span><br><span class="line">            <span class="literal">true</span></span><br><span class="line">        &#125; ?: <span class="literal">false</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        billingClientStatus.tryEmit(BillingClient.BillingResponseCode.SERVICE_DISCONNECTED)</span><br><span class="line">        billingClientStatus.observe(ProcessLifecycleOwner.<span class="keyword">get</span>()) &#123;</span><br><span class="line">            <span class="keyword">when</span> (it) &#123;</span><br><span class="line">                BillingClient.BillingResponseCode.OK -&gt; with (billingClient) &#123;</span><br><span class="line">                    updateSkuPrices()</span><br><span class="line">                    handlePurchases()</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">                    delay(RETRY_MILLIS)</span><br><span class="line">                    billingClient.startConnection(<span class="keyword">this</span><span class="symbol">@Biller</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> TIMEOUT_MILLIS = <span class="number">2000L</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> RETRY_MILLIS = <span class="number">3000L</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这种情况下，我们需要使用SharedFlow，它支持发出连续的重复值。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要是关于SharedFlow与StateFlow的一些介绍及使用他们代替LiveData的一些尝试<br>这是在下翻译的第一篇文章，还有很多不足之处，请各位读者结合原文观看，如果有什么总量，欢迎提出指正。    </p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>利用MotionLayout实现RecyclerView折叠展开动画</title>
    <url>/blog/2020/12/motionlayout-recyclerview-animation.html</url>
    <content><![CDATA[<p>RecyclerView的展开与折叠是一种常见的动画<br>主要有两种方式可以实现<br><strong>1.通过添加与移除元素</strong><br>notifyInsert,notifyRemoved，这种方式涉及到元素的加减，动画效果不太流畅<br><strong>2.通过给RecyclerView的item添加动画</strong><br>这种情况需要考虑一个item添加动画时，对其他的item的影响。而利用MotionLayout可以方便的实现这一点。    </p>
<p><strong>先来看看效果</strong><br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog9/p1.gif" alt><br>1.支持流畅的展开折叠<br>2.支持多类型item<br>3.支持只能同时展开一个    </p>
<p>下面来看下具体实现  </p>
<h2 id="1-引入MotionLayout库"><a href="#1-引入MotionLayout库" class="headerlink" title="1.引入MotionLayout库"></a>1.引入MotionLayout库</h2><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">dependencies</span> &#123; <span class="attribute">implementation</span> <span class="string">'com.android.support.constraint:constraint-layout:2.0.0-beta2'</span> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-在布局文件中使用"><a href="#2-在布局文件中使用" class="headerlink" title="2.在布局文件中使用"></a>2.在布局文件中使用</h2><p>MotionLayout 想要使用 MotionLayout，只需要在布局文件中作如下声明即可：<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">&lt;androidx<span class="selector-class">.constraintlayout</span><span class="selector-class">.motion</span><span class="selector-class">.widget</span><span class="selector-class">.MotionLayout</span> xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    xmlns:app=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span><br><span class="line">    xmlns:tools=<span class="string">"http://schemas.android.com/tools"</span></span><br><span class="line">    android:id=<span class="string">"@+id/motionContainer"</span></span><br><span class="line">    android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">    android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">    android:<span class="attribute">background</span>=<span class="string">"@color/white"</span></span><br><span class="line">    app:layoutDescription=<span class="string">"@xml/motion_list_rv_item_scene"</span>&gt;</span><br><span class="line">.....</span><br><span class="line">&lt;/android<span class="selector-class">.support</span><span class="selector-class">.constraint</span><span class="selector-class">.motion</span>.MotionLayout&gt;</span><br></pre></td></tr></table></figure></p>
<p>由于 MotionLayout 作为 ConstraintLayout 的子类，那么就自然而然地可以像 ConstraintLayout 那样使用去“约束”子视图了，不过这可就有点“大材小用了”，MotionLayout 的用处可远不止这些。我们先来看看 MotionLayout 的构成：<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog9/p1.webp" alt></p>
<p>由上图可知，MotionLayout 可分为 <view> 和 <helper> 两个部分。<view> 部分可简单理解为一个 ConstraintLayout，至于 <helper> 其实就是我们的“动画层”了。MotionLayout 为我们提供了 layoutDescription 属性，我们需要为它传入一个 MotionScene 包裹的 XML 文件，想要实现动画交互，就必须通过这个“媒介”来连接。</helper></view></helper></view></p>
<h2 id="MotionScene"><a href="#MotionScene" class="headerlink" title="MotionScene"></a>MotionScene</h2><p>什么是 MotionScene？结合上图 MotionScene 主要由三部分组成：StateSet、ConstraintSet 和 Transition<br>实现RecyclerView展开折叠效果，主要用到了 ConstarintSet 和 Transition     </p>
<h3 id="首先来看看布局文件"><a href="#首先来看看布局文件" class="headerlink" title="首先来看看布局文件"></a>首先来看看布局文件</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.motion.widget.MotionLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/motionContainer"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:background</span>=<span class="string">"@color/white"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layoutDescription</span>=<span class="string">"@xml/motion_list_rv_item_scene"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/box_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:orientation</span>=<span class="string">"vertical"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"86dp"</span>&gt;</span></span><br><span class="line">            ....</span><br><span class="line">            <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">View</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"100dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:background</span>=<span class="string">"@color/blue_magic"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">View</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/view2"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"1dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_below</span>=<span class="string">"@id/box_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">"#eaeaef"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.motion.widget.MotionLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>布局文件很简单，只不过你可能会注意到，我们对 LinearLayout并没有添加任何约束，原因在于：我们会在 MotionScene 中声明 ConstraintSet，里面将包含该 LinearLayout 的“运动”起始点和终点的约束信息。</p>
<p>当然你也可以在布局文件中对其加以约束，但 MotionScene 中对于控件约束的优先级会高于布局文件中的设定。这里我们通过 layoutDescription 来为 MotionLayout 设置它的 MotionScene 为 motion_list_rv_item_scene，接下来就让我们一睹 MotionScene 的芳容：</p>
<h3 id="动画文件"><a href="#动画文件" class="headerlink" title="动画文件"></a>动画文件</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">MotionScene</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ConstraintSet</span> <span class="attr">android:id</span>=<span class="string">"@+id/start"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Constraint</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@id/box_content"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"0dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"86dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">"parent"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ConstraintSet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ConstraintSet</span> <span class="attr">android:id</span>=<span class="string">"@+id/end"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Constraint</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@id/box_content"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"0dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"186dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">"parent"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ConstraintSet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Transition</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:constraintSetEnd</span>=<span class="string">"@id/end"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:constraintSetStart</span>=<span class="string">"@+id/start"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:duration</span>=<span class="string">"500"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:motionInterpolator</span>=<span class="string">"easeInOut"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Transition</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">MotionScene</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>首先，可以发现我们定义了两个 <constraintset>   分别描述了RecyclerView中的item的动画起始位置以及结束位置的约束信息（仅包含少量必要信息，如：width、height、margin以及位置属性等）。<br>显而易见，itemView起始高度为86dp，结束高度186dp.    </constraintset></p>
<p><strong>那么问题来了，如何让它动起来呢？</strong><br>这就要依靠我们的 <transition> 元素了。     </transition></p>
<p>事实上，我们都知道，动画都是有开始位置和结束位置的，而 MotionLayout 正是利用这一客观事实，将首尾位置和动画过程分离，两个点位置和距离虽然是固定的，但是它们之间的 Path 是无限的，可以是“一马平川”，也可以是”蜿蜒曲折”的。</p>
<p>我们只需要为 Transition 设置起始位置和结束位置的 ConstraintSet 并设置动画时间即可，剩下的都交给 MotionLayout 自动去帮我们完成。</p>
<p>当然你也可以通过 onClick 点击事件来触发动画，绑定目标控件的 id 以及通过 clickAction 属性来设置点击事件的类型。</p>
<h3 id="OnClick有多种类型"><a href="#OnClick有多种类型" class="headerlink" title="OnClick有多种类型"></a>OnClick有多种类型</h3><ul>
<li>1.toggle，如果布局当前处于开始状态，请将动画效果切换为结束状态；否则，请将动画效果切换为开始状态。</li>
<li>2.transitionToStart,为从当前布局到 <transition> 元素的 motion::constraintSetStart 属性指定的布局添加动画效果。</transition></li>
<li>3.transitionToEnd,为从当前布局到 <transition> 元素的 motion:constraintSetEnd 属性指定的布局添加动画效果。</transition></li>
</ul>
<h2 id="只能同时展开一个item实现"><a href="#只能同时展开一个item实现" class="headerlink" title="只能同时展开一个item实现"></a>只能同时展开一个item实现</h2><p>因为我们需要在展开一个item时，折叠其他item,因此不在xml中指定点击事件，去adapter中指定<br>实现展开一个时折叠其他item 我们可以通过MotionLayout的progress判断当前是在start状态还是end状态。   </p>
<p>下面的代码主要有几点需要注意的<br>1.如果是start状态则展开，否则则折叠<br>2.利用payload局部刷新达到折叠其他itemView的效果。<br>3.在RecyclerView滚动时会复用，所以需要在onBindViewHolder时初始化item的状态，即progress，不然会发生错位现象</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBindViewHolder</span><span class="params">(holder: <span class="type">RecyclerView</span>.<span class="type">ViewHolder</span>, position: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (holder <span class="keyword">is</span> MotionViewHolder) &#123;</span><br><span class="line">            <span class="keyword">val</span> motionBox = holder.itemView.findViewById&lt;MotionLayout&gt;(R.id.motionContainer)</span><br><span class="line">            <span class="keyword">if</span> (expandList[position])&#123;</span><br><span class="line">                motionBox.progress = <span class="number">1.0f</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                motionBox.progress = <span class="number">0f</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            holder.itemView.setOnClickListener &#123;</span><br><span class="line">                expandList.fill(<span class="literal">false</span>)</span><br><span class="line">                <span class="keyword">if</span> (motionBox.progress == <span class="number">1.0f</span>) &#123;</span><br><span class="line">                    motionBox.transitionToStart()</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (motionBox.progress == <span class="number">0.0f</span>) &#123;</span><br><span class="line">                    motionBox.transitionToEnd()</span><br><span class="line">                    expandList[position] = <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until itemCount) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i != position) &#123;</span><br><span class="line">                        notifyItemChanged(i, <span class="string">"collapse"</span>)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBindViewHolder</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        holder: <span class="type">RecyclerView</span>.<span class="type">ViewHolder</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        position: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        payloads: <span class="type">MutableList</span>&lt;<span class="type">Any</span>&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (payloads.isNullOrEmpty()) &#123;</span><br><span class="line">            <span class="keyword">super</span>.onBindViewHolder(holder, position, payloads)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (holder <span class="keyword">is</span> MotionViewHolder) &#123;</span><br><span class="line">                <span class="keyword">val</span> motionBox = holder.itemView.findViewById&lt;MotionLayout&gt;(R.id.motionContainer)</span><br><span class="line">                motionBox.transitionToStart()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过以上步骤，即利用MotionLayout比较简单的实现了RecyclerView的item展开折叠效果<br>1.支持流畅的展开折叠<br>2.支持多类型item<br>3.支持只能同时展开一个    </p>
<p>MotionLayout还有很多更强大的功能，比如与AppBarLayout联动，与Lottie联动，实现复杂动画等。<br>读者如有兴趣可阅读下方的参考链接，及本文的所有代码</p>
<h3 id="本文的所有相关代码"><a href="#本文的所有相关代码" class="headerlink" title="本文的所有相关代码"></a>本文的所有相关代码</h3><p><a href="https://github.com/shenzhen2017/MotionLayoutRecyclerView" target="_blank" rel="noopener">MotionLayoutRecyclerView实现</a></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://juejin.cn/post/6844903918598635534" target="_blank" rel="noopener">MotionLayout：打开动画新世界大门 (part I)</a><br><a href="https://juejin.cn/post/6854573206653812743" target="_blank" rel="noopener">Android MotionLayout动画：续写ConstraintLayout新篇章</a>     </p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
</search>
